// ==UserScript==
// @name               nHentai Helper
// @name:zh-CN         nHentai 助手
// @name:zh-TW         nHentai 助手
// @namespace          https://github.com/Tsuk1ko
// @version            3.12.0
// @author             Jindai Kirin
// @description        Download nHentai manga as compression file easily, and add some useful features. Also support some mirror sites.
// @description:zh-CN  为 nHentai 增加压缩打包下载方式以及一些辅助功能，同时还支持一些镜像站
// @description:zh-TW  爲 nHentai 增加壓縮打包下載方式以及一些輔助功能，同時還支援一些鏡像站
// @license            GPL-3.0
// @icon               https://icon.horse/icon/nhentai.net
// @homepageURL        https://github.com/Tsuk1ko/nhentai-helper
// @supportURL         https://github.com/Tsuk1ko/nhentai-helper/issues
// @include            /^https:\/\/([^/]*\.)?(nya|dog|cat|bug|qq|fox|ee|yy)hentai[0-9]*\./
// @match              https://nhentai.net/*
// @match              https://nhentai.xxx/*
// @match              https://nhentai.to/*
// @match              https://nhentai.website/*
// @connect            nhentai.net
// @connect            i.nhentai.net
// @connect            i2.nhentai.net
// @connect            i3.nhentai.net
// @connect            i5.nhentai.net
// @connect            i7.nhentai.net
// @connect            *
// @grant              GM_addStyle
// @grant              GM_getValue
// @grant              GM_openInTab
// @grant              GM_registerMenuCommand
// @grant              GM_setValue
// @grant              GM_xmlhttpRequest
// @grant              unsafeWindow
// @run-at             document-end
// @noframes
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const o=document.createElement("style");o.textContent=e,document.head.append(o)})(` @charset "UTF-8";.nhentai-helper-btn:disabled{cursor:wait}.gallery>.nhentai-helper-btn{position:absolute;top:0;min-width:42px;opacity:.8}.gallery:hover>.nhentai-helper-btn{opacity:1}.gallery .download-zip-btn{left:0}.gallery .ignore-btn{display:none;right:0}.gallery:hover .ignore-btn{display:block}#page-container{position:relative}@media screen and (max-width: 768px){#page-container{padding-top:40px}}#online-view-mode-btn{position:absolute;right:0;top:0;margin:0}.btn-noty-green{background-color:#66bb6a!important}.btn-noty-blue{background-color:#42a5f5!important}.btn-noty:hover{filter:brightness(1.15)}.noty_buttons{padding-top:0!important}.pages-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;display:inline-block;border-radius:3px;padding:0 .1em 0 1em;font-size:1em;width:100%;height:40px;border:0;vertical-align:top;margin-top:5px}.gallery.downloaded .caption{color:#999}.noty_close_button{display:none}.noty_layout_mixin,#noty_layout__top,#noty_layout__topLeft,#noty_layout__topCenter,#noty_layout__topRight,#noty_layout__bottom,#noty_layout__bottomLeft,#noty_layout__bottomCenter,#noty_layout__bottomRight,#noty_layout__center,#noty_layout__centerLeft,#noty_layout__centerRight{position:fixed;margin:0;padding:0;z-index:9999999;-webkit-transform:translateZ(0) scale(1,1);transform:translateZ(0) scale(1);-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-font-smoothing:subpixel-antialiased;filter:blur(0);-webkit-filter:blur(0);max-width:90%}#noty_layout__top{top:0;left:5%;width:90%}#noty_layout__topLeft{top:20px;left:20px;width:325px}#noty_layout__topCenter{top:5%;left:50%;width:325px;-webkit-transform:translate(-webkit-calc(-50% - .5px)) translateZ(0) scale(1,1);transform:translate(calc(-50% - .5px)) translateZ(0) scale(1)}#noty_layout__topRight{top:20px;right:20px;width:325px}#noty_layout__bottom{bottom:0;left:5%;width:90%}#noty_layout__bottomLeft{bottom:20px;left:20px;width:325px}#noty_layout__bottomCenter{bottom:5%;left:50%;width:325px;-webkit-transform:translate(-webkit-calc(-50% - .5px)) translateZ(0) scale(1,1);transform:translate(calc(-50% - .5px)) translateZ(0) scale(1)}#noty_layout__bottomRight{bottom:20px;right:20px;width:325px}#noty_layout__center{top:50%;left:50%;width:325px;-webkit-transform:translate(-webkit-calc(-50% - .5px),-webkit-calc(-50% - .5px)) translateZ(0) scale(1,1);transform:translate(calc(-50% - .5px),calc(-50% - .5px)) translateZ(0) scale(1)}#noty_layout__centerLeft{top:50%;left:20px;width:325px;-webkit-transform:translate(0,-webkit-calc(-50% - .5px)) translateZ(0) scale(1,1);transform:translateY(calc(-50% - .5px)) translateZ(0) scale(1)}#noty_layout__centerRight{top:50%;right:20px;width:325px;-webkit-transform:translate(0,-webkit-calc(-50% - .5px)) translateZ(0) scale(1,1);transform:translateY(calc(-50% - .5px)) translateZ(0) scale(1)}.noty_progressbar{display:none}.noty_has_timeout.noty_has_progressbar .noty_progressbar{display:block;position:absolute;left:0;bottom:0;height:3px;width:100%;background-color:#646464;opacity:.2;filter:alpha(opacity=10)}.noty_bar{-webkit-backface-visibility:hidden;-webkit-transform:translate(0,0) translateZ(0) scale(1,1);-ms-transform:translate(0,0) scale(1,1);transform:translate(0) scale(1);-webkit-font-smoothing:subpixel-antialiased;overflow:hidden}.noty_effects_open{opacity:0;-webkit-transform:translate(50%);-ms-transform:translate(50%);transform:translate(50%);-webkit-animation:noty_anim_in .5s cubic-bezier(.68,-.55,.265,1.55);animation:noty_anim_in .5s cubic-bezier(.68,-.55,.265,1.55);-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.noty_effects_close{-webkit-animation:noty_anim_out .5s cubic-bezier(.68,-.55,.265,1.55);animation:noty_anim_out .5s cubic-bezier(.68,-.55,.265,1.55);-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.noty_fix_effects_height{-webkit-animation:noty_anim_height 75ms ease-out;animation:noty_anim_height 75ms ease-out}.noty_close_with_click{cursor:pointer}.noty_close_button{position:absolute;top:2px;right:2px;font-weight:700;width:20px;height:20px;text-align:center;line-height:20px;background-color:#0000000d;border-radius:2px;cursor:pointer;-webkit-transition:all .2s ease-out;transition:all .2s ease-out}.noty_close_button:hover{background-color:#0000001a}.noty_modal{position:fixed;width:100%;height:100%;background-color:#000;z-index:10000;opacity:.3;left:0;top:0}.noty_modal.noty_modal_open{opacity:0;-webkit-animation:noty_modal_in .3s ease-out;animation:noty_modal_in .3s ease-out}.noty_modal.noty_modal_close{-webkit-animation:noty_modal_out .3s ease-out;animation:noty_modal_out .3s ease-out;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@-webkit-keyframes noty_modal_in{to{opacity:.3}}@keyframes noty_modal_in{to{opacity:.3}}@-webkit-keyframes noty_modal_out{to{opacity:0}}@keyframes noty_modal_out{to{opacity:0}}@-webkit-keyframes noty_anim_in{to{-webkit-transform:translate(0);transform:translate(0);opacity:1}}@keyframes noty_anim_in{to{-webkit-transform:translate(0);transform:translate(0);opacity:1}}@-webkit-keyframes noty_anim_out{to{-webkit-transform:translate(50%);transform:translate(50%);opacity:0}}@keyframes noty_anim_out{to{-webkit-transform:translate(50%);transform:translate(50%);opacity:0}}@-webkit-keyframes noty_anim_height{to{height:0}}@keyframes noty_anim_height{to{height:0}}.noty_theme__relax.noty_bar{margin:4px 0;overflow:hidden;border-radius:2px;position:relative}.noty_theme__relax.noty_bar .noty_body{padding:10px}.noty_theme__relax.noty_bar .noty_buttons{border-top:1px solid #e7e7e7;padding:5px 10px}.noty_theme__relax.noty_type__alert,.noty_theme__relax.noty_type__notification{background-color:#fff;border:1px solid #dedede;color:#444}.noty_theme__relax.noty_type__warning{background-color:#ffeaa8;border:1px solid #FFC237;color:#826200}.noty_theme__relax.noty_type__warning .noty_buttons{border-color:#dfaa30}.noty_theme__relax.noty_type__error{background-color:#ff8181;border:1px solid #e25353;color:#fff}.noty_theme__relax.noty_type__error .noty_buttons{border-color:#8b0000}.noty_theme__relax.noty_type__info,.noty_theme__relax.noty_type__information{background-color:#78c5e7;border:1px solid #3badd6;color:#fff}.noty_theme__relax.noty_type__info .noty_buttons,.noty_theme__relax.noty_type__information .noty_buttons{border-color:#0b90c4}.noty_theme__relax.noty_type__success{background-color:#bcf5bc;border:1px solid #7cdd77;color:#006400}.noty_theme__relax.noty_type__success .noty_buttons{border-color:#50c24e}.noty_theme__metroui.noty_bar{margin:4px 0;overflow:hidden;position:relative;box-shadow:#0000004c 0 0 5px}.noty_theme__metroui.noty_bar .noty_progressbar{position:absolute;left:0;bottom:0;height:3px;width:100%;background-color:#000;opacity:.2;filter:alpha(opacity=20)}.noty_theme__metroui.noty_bar .noty_body{padding:1.25em;font-size:14px}.noty_theme__metroui.noty_bar .noty_buttons{padding:0 10px .5em}.noty_theme__metroui.noty_type__alert,.noty_theme__metroui.noty_type__notification{background-color:#fff;color:#1d1d1d}.noty_theme__metroui.noty_type__warning{background-color:#fa6800;color:#fff}.noty_theme__metroui.noty_type__error{background-color:#ce352c;color:#fff}.noty_theme__metroui.noty_type__info,.noty_theme__metroui.noty_type__information{background-color:#1ba1e2;color:#fff}.noty_theme__metroui.noty_type__success{background-color:#60a917;color:#fff}.noty_theme__mint.noty_bar{margin:4px 0;overflow:hidden;border-radius:2px;position:relative}.noty_theme__mint.noty_bar .noty_body{padding:10px;font-size:14px}.noty_theme__mint.noty_bar .noty_buttons{padding:10px}.noty_theme__mint.noty_type__alert,.noty_theme__mint.noty_type__notification{background-color:#fff;border-bottom:1px solid #D1D1D1;color:#2f2f2f}.noty_theme__mint.noty_type__warning{background-color:#ffae42;border-bottom:1px solid #E89F3C;color:#fff}.noty_theme__mint.noty_type__error{background-color:#de636f;border-bottom:1px solid #CA5A65;color:#fff}.noty_theme__mint.noty_type__info,.noty_theme__mint.noty_type__information{background-color:#7f7eff;border-bottom:1px solid #7473E8;color:#fff}.noty_theme__mint.noty_type__success{background-color:#afc765;border-bottom:1px solid #A0B55C;color:#fff}.noty_theme__sunset.noty_bar{margin:4px 0;overflow:hidden;border-radius:2px;position:relative}.noty_theme__sunset.noty_bar .noty_body{padding:10px;font-size:14px;text-shadow:1px 1px 1px rgba(0,0,0,.1)}.noty_theme__sunset.noty_bar .noty_buttons{padding:10px}.noty_theme__sunset.noty_type__alert,.noty_theme__sunset.noty_type__notification{background-color:#073b4c;color:#fff}.noty_theme__sunset.noty_type__alert .noty_progressbar,.noty_theme__sunset.noty_type__notification .noty_progressbar{background-color:#fff}.noty_theme__sunset.noty_type__warning{background-color:#ffd166;color:#fff}.noty_theme__sunset.noty_type__error{background-color:#ef476f;color:#fff}.noty_theme__sunset.noty_type__error .noty_progressbar{opacity:.4}.noty_theme__sunset.noty_type__info,.noty_theme__sunset.noty_type__information{background-color:#118ab2;color:#fff}.noty_theme__sunset.noty_type__info .noty_progressbar,.noty_theme__sunset.noty_type__information .noty_progressbar{opacity:.6}.noty_theme__sunset.noty_type__success{background-color:#06d6a0;color:#fff}.noty_theme__bootstrap-v3.noty_bar{margin:4px 0;overflow:hidden;position:relative;border:1px solid transparent;border-radius:4px}.noty_theme__bootstrap-v3.noty_bar .noty_body{padding:15px}.noty_theme__bootstrap-v3.noty_bar .noty_buttons{padding:10px}.noty_theme__bootstrap-v3.noty_bar .noty_close_button{font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;filter:alpha(opacity=20);opacity:.2;background:transparent}.noty_theme__bootstrap-v3.noty_bar .noty_close_button:hover{background:transparent;text-decoration:none;cursor:pointer;filter:alpha(opacity=50);opacity:.5}.noty_theme__bootstrap-v3.noty_type__alert,.noty_theme__bootstrap-v3.noty_type__notification{background-color:#fff;color:inherit}.noty_theme__bootstrap-v3.noty_type__warning{background-color:#fcf8e3;color:#8a6d3b;border-color:#faebcc}.noty_theme__bootstrap-v3.noty_type__error{background-color:#f2dede;color:#a94442;border-color:#ebccd1}.noty_theme__bootstrap-v3.noty_type__info,.noty_theme__bootstrap-v3.noty_type__information{background-color:#d9edf7;color:#31708f;border-color:#bce8f1}.noty_theme__bootstrap-v3.noty_type__success{background-color:#dff0d8;color:#3c763d;border-color:#d6e9c6}.noty_theme__bootstrap-v4.noty_bar{margin:4px 0;overflow:hidden;position:relative;border:1px solid transparent;border-radius:.25rem}.noty_theme__bootstrap-v4.noty_bar .noty_body{padding:.75rem 1.25rem}.noty_theme__bootstrap-v4.noty_bar .noty_buttons{padding:10px}.noty_theme__bootstrap-v4.noty_bar .noty_close_button{font-size:1.5rem;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;filter:alpha(opacity=20);opacity:.5;background:transparent}.noty_theme__bootstrap-v4.noty_bar .noty_close_button:hover{background:transparent;text-decoration:none;cursor:pointer;filter:alpha(opacity=50);opacity:.75}.noty_theme__bootstrap-v4.noty_type__alert,.noty_theme__bootstrap-v4.noty_type__notification{background-color:#fff;color:inherit}.noty_theme__bootstrap-v4.noty_type__warning{background-color:#fcf8e3;color:#8a6d3b;border-color:#faebcc}.noty_theme__bootstrap-v4.noty_type__error{background-color:#f2dede;color:#a94442;border-color:#ebccd1}.noty_theme__bootstrap-v4.noty_type__info,.noty_theme__bootstrap-v4.noty_type__information{background-color:#d9edf7;color:#31708f;border-color:#bce8f1}.noty_theme__bootstrap-v4.noty_type__success{background-color:#dff0d8;color:#3c763d;border-color:#d6e9c6}.noty_theme__semanticui.noty_bar{margin:4px 0;overflow:hidden;position:relative;border:1px solid transparent;font-size:1em;border-radius:.28571429rem;box-shadow:0 0 0 1px #22242638 inset,0 0 0 0 transparent}.noty_theme__semanticui.noty_bar .noty_body{padding:1em 1.5em;line-height:1.4285em}.noty_theme__semanticui.noty_bar .noty_buttons{padding:10px}.noty_theme__semanticui.noty_type__alert,.noty_theme__semanticui.noty_type__notification{background-color:#f8f8f9;color:#000000de}.noty_theme__semanticui.noty_type__warning{background-color:#fffaf3;color:#573a08;box-shadow:0 0 0 1px #c9ba9b inset,0 0 0 0 transparent}.noty_theme__semanticui.noty_type__error{background-color:#fff6f6;color:#9f3a38;box-shadow:0 0 0 1px #e0b4b4 inset,0 0 0 0 transparent}.noty_theme__semanticui.noty_type__info,.noty_theme__semanticui.noty_type__information{background-color:#f8ffff;color:#276f86;box-shadow:0 0 0 1px #a9d5de inset,0 0 0 0 transparent}.noty_theme__semanticui.noty_type__success{background-color:#fcfff5;color:#2c662d;box-shadow:0 0 0 1px #a3c293 inset,0 0 0 0 transparent}.noty_theme__nest.noty_bar{margin:0 0 15px;overflow:hidden;border-radius:2px;position:relative;box-shadow:#00000019 5px 4px 10px}.noty_theme__nest.noty_bar .noty_body{padding:10px;font-size:14px;text-shadow:1px 1px 1px rgba(0,0,0,.1)}.noty_theme__nest.noty_bar .noty_buttons{padding:10px}.noty_layout .noty_theme__nest.noty_bar{z-index:5}.noty_layout .noty_theme__nest.noty_bar:nth-child(2){position:absolute;top:0;margin-top:4px;margin-right:-4px;margin-left:4px;z-index:4;width:100%}.noty_layout .noty_theme__nest.noty_bar:nth-child(3){position:absolute;top:0;margin-top:8px;margin-right:-8px;margin-left:8px;z-index:3;width:100%}.noty_layout .noty_theme__nest.noty_bar:nth-child(4){position:absolute;top:0;margin-top:12px;margin-right:-12px;margin-left:12px;z-index:2;width:100%}.noty_layout .noty_theme__nest.noty_bar:nth-child(5){position:absolute;top:0;margin-top:16px;margin-right:-16px;margin-left:16px;z-index:1;width:100%}.noty_layout .noty_theme__nest.noty_bar:nth-child(n+6){position:absolute;top:0;margin-top:20px;margin-right:-20px;margin-left:20px;z-index:-1;width:100%}#noty_layout__bottomLeft .noty_theme__nest.noty_bar:nth-child(2),#noty_layout__topLeft .noty_theme__nest.noty_bar:nth-child(2){margin-top:4px;margin-left:-4px;margin-right:4px}#noty_layout__bottomLeft .noty_theme__nest.noty_bar:nth-child(3),#noty_layout__topLeft .noty_theme__nest.noty_bar:nth-child(3){margin-top:8px;margin-left:-8px;margin-right:8px}#noty_layout__bottomLeft .noty_theme__nest.noty_bar:nth-child(4),#noty_layout__topLeft .noty_theme__nest.noty_bar:nth-child(4){margin-top:12px;margin-left:-12px;margin-right:12px}#noty_layout__bottomLeft .noty_theme__nest.noty_bar:nth-child(5),#noty_layout__topLeft .noty_theme__nest.noty_bar:nth-child(5){margin-top:16px;margin-left:-16px;margin-right:16px}#noty_layout__bottomLeft .noty_theme__nest.noty_bar:nth-child(n+6),#noty_layout__topLeft .noty_theme__nest.noty_bar:nth-child(n+6){margin-top:20px;margin-left:-20px;margin-right:20px}.noty_theme__nest.noty_type__alert,.noty_theme__nest.noty_type__notification{background-color:#073b4c;color:#fff}.noty_theme__nest.noty_type__alert .noty_progressbar,.noty_theme__nest.noty_type__notification .noty_progressbar{background-color:#fff}.noty_theme__nest.noty_type__warning{background-color:#ffd166;color:#fff}.noty_theme__nest.noty_type__error{background-color:#ef476f;color:#fff}.noty_theme__nest.noty_type__error .noty_progressbar{opacity:.4}.noty_theme__nest.noty_type__info,.noty_theme__nest.noty_type__information{background-color:#118ab2;color:#fff}.noty_theme__nest.noty_type__info .noty_progressbar,.noty_theme__nest.noty_type__information .noty_progressbar{opacity:.6}.noty_theme__nest.noty_type__success{background-color:#06d6a0;color:#fff}.noty_theme__light.noty_bar{margin:4px 0;overflow:hidden;border-radius:2px;position:relative}.noty_theme__light.noty_bar .noty_body{padding:10px}.noty_theme__light.noty_bar .noty_buttons{border-top:1px solid #e7e7e7;padding:5px 10px}.noty_theme__light.noty_type__alert,.noty_theme__light.noty_type__notification{background-color:#fff;border:1px solid #dedede;color:#444}.noty_theme__light.noty_type__warning{background-color:#ffeaa8;border:1px solid #FFC237;color:#826200}.noty_theme__light.noty_type__warning .noty_buttons{border-color:#dfaa30}.noty_theme__light.noty_type__error{background-color:#ed7000;border:1px solid #e25353;color:#fff}.noty_theme__light.noty_type__error .noty_buttons{border-color:#8b0000}.noty_theme__light.noty_type__info,.noty_theme__light.noty_type__information{background-color:#78c5e7;border:1px solid #3badd6;color:#fff}.noty_theme__light.noty_type__info .noty_buttons,.noty_theme__light.noty_type__information .noty_buttons{border-color:#0b90c4}.noty_theme__light.noty_type__success{background-color:#57c880;border:1px solid #7cdd77;color:#006400}.noty_theme__light.noty_type__success .noty_buttons{border-color:#50c24e}.download-item[data-v-83b954f2]{position:relative;white-space:nowrap;padding:2px;overflow:visible}.download-item--can-cancel[data-v-83b954f2]:hover{width:calc(100% - 30px)}.download-item__cancel[data-v-83b954f2]{cursor:pointer;position:absolute;top:0;right:-30px;color:#f44336;font-size:20px;line-height:30px;width:30px}.download-item__title[data-v-83b954f2]{overflow:hidden;text-overflow:ellipsis;text-align:left}.download-item__progress[data-v-83b954f2]{background-color:#0000ff80;line-height:10px}.download-item--error .download-item__progress[data-v-83b954f2]{background-color:#ff000080}.download-item--compressing .download-item__progress[data-v-83b954f2]{background-color:#00ff0080}.download-item__progress-text[data-v-83b954f2]{transform:scale(.8)}#download-panel[data-v-f37e74c3]{overflow-x:hidden;position:fixed;top:20vh;right:0;width:calc(50vw - 620px);max-width:300px;min-width:150px;max-height:60vh;background-color:#000000b3;z-index:100;font-size:12px;overflow-y:scroll}#download-panel[data-v-f37e74c3]::-webkit-scrollbar{width:6px;background-color:#000000b3}#download-panel[data-v-f37e74c3]::-webkit-scrollbar-thumb{background-color:#fff9}:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645,.045,.355,1);--el-transition-function-fast-bezier:cubic-bezier(.23,1,.32,1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0,0,0,.04),0px 8px 20px rgba(0,0,0,.08);--el-box-shadow-light:0px 0px 12px rgba(0,0,0,.12);--el-box-shadow-lighter:0px 0px 6px rgba(0,0,0,.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0,0,0,.08),0px 12px 32px rgba(0,0,0,.12),0px 8px 16px -8px rgba(0,0,0,.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0,0,0,.8);--el-overlay-color-light:rgba(0,0,0,.7);--el-overlay-color-lighter:rgba(0,0,0,.5);--el-mask-color:rgba(255,255,255,.9);--el-mask-color-extra-light:rgba(255,255,255,.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.el-icon{--color:inherit;align-items:center;display:inline-flex;height:1em;justify-content:center;line-height:1em;position:relative;width:1em;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{to{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{background:var(--el-popup-modal-bg-color);height:100%;left:0;opacity:var(--el-popup-modal-opacity);position:fixed;top:0;width:100%}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:16px;--el-dialog-border-radius:var(--el-border-radius-small);background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;margin:var(--el-dialog-margin-top,15vh) auto 50px;overflow-wrap:break-word;padding:var(--el-dialog-padding-primary);position:relative;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:none!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;height:100%;margin-bottom:0;overflow:auto}.el-dialog__wrapper{bottom:0;left:0;margin:0;overflow:auto;position:fixed;right:0;top:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding-bottom:var(--el-dialog-padding-primary)}.el-dialog__header.show-close{padding-right:calc(var(--el-dialog-padding-primary) + var(--el-message-close-size, 16px))}.el-dialog__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:48px;outline:none;padding:0;position:absolute;right:0;top:0;width:48px}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{color:var(--el-text-color-primary);font-size:var(--el-dialog-title-font-size);line-height:var(--el-dialog-font-line-height)}.el-dialog__body{color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{box-sizing:border-box;padding-top:var(--el-dialog-padding-primary);text-align:right}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{bottom:0;left:0;overflow:auto;position:fixed;right:0;top:0}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@-webkit-keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@-webkit-keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{background-color:var(--el-overlay-color-lighter);bottom:0;height:100%;left:0;overflow:auto;position:fixed;right:0;top:0;z-index:2000}.el-overlay .el-overlay-root{height:0}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--label-left .el-form-item__label{justify-content:flex-start}.el-form--label-top .el-form-item{display:block}.el-form--label-top .el-form-item .el-form-item__label{display:block;height:auto;line-height:22px;margin-bottom:8px;text-align:left}.el-form--inline .el-form-item{display:inline-flex;margin-right:32px;vertical-align:middle}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form--large.el-form--label-top .el-form-item .el-form-item__label{line-height:22px;margin-bottom:12px}.el-form--default.el-form--label-top .el-form-item .el-form-item__label{line-height:22px;margin-bottom:8px}.el-form--small.el-form--label-top .el-form-item .el-form-item__label{line-height:20px;margin-bottom:4px}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item__label-wrap{display:flex}.el-form-item__label{align-items:flex-start;box-sizing:border-box;color:var(--el-text-color-regular);display:inline-flex;flex:0 0 auto;font-size:var(--el-form-label-font-size);height:32px;justify-content:flex-end;line-height:32px;padding:0 12px 0 0}.el-form-item__content{align-items:center;display:flex;flex:1;flex-wrap:wrap;font-size:var(--font-size);line-height:32px;min-width:0;position:relative}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;left:0;line-height:1;padding-top:2px;position:absolute;top:100%}.el-form-item__error--inline{display:inline-block;left:auto;margin-left:10px;position:relative;top:auto}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{color:var(--el-color-danger);content:"*";margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{color:var(--el-color-danger);content:"*";margin-left:4px}.el-form-item.is-error .el-input__wrapper,.el-form-item.is-error .el-input__wrapper.is-focus,.el-form-item.is-error .el-input__wrapper:focus,.el-form-item.is-error .el-input__wrapper:hover,.el-form-item.is-error .el-select__wrapper,.el-form-item.is-error .el-select__wrapper.is-focus,.el-form-item.is-error .el-select__wrapper:focus,.el-form-item.is-error .el-select__wrapper:hover,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner.is-focus,.el-form-item.is-error .el-textarea__inner:focus,.el-form-item.is-error .el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:inset 0 0 0 1px transparent}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transform-origin:center top;transition:var(--el-transition-md-fade)}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transform-origin:center bottom;transition:var(--el-transition-md-fade)}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transform-origin:top left;transition:var(--el-transition-md-fade)}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-collapse{--el-collapse-border-color:var(--el-border-color-lighter);--el-collapse-header-height:48px;--el-collapse-header-bg-color:var(--el-fill-color-blank);--el-collapse-header-text-color:var(--el-text-color-primary);--el-collapse-header-font-size:13px;--el-collapse-content-bg-color:var(--el-fill-color-blank);--el-collapse-content-font-size:13px;--el-collapse-content-text-color:var(--el-text-color-primary);border-bottom:1px solid var(--el-collapse-border-color);border-top:1px solid var(--el-collapse-border-color)}.el-collapse-item.is-disabled .el-collapse-item__header{color:var(--el-text-color-disabled);cursor:not-allowed}.el-collapse-item__header{align-items:center;background-color:var(--el-collapse-header-bg-color);border:none;border-bottom:1px solid var(--el-collapse-border-color);color:var(--el-collapse-header-text-color);cursor:pointer;display:flex;font-size:var(--el-collapse-header-font-size);font-weight:500;height:var(--el-collapse-header-height);line-height:var(--el-collapse-header-height);outline:none;padding:0;transition:border-bottom-color var(--el-transition-duration);width:100%}.el-collapse-item__arrow{font-weight:300;margin:0 8px 0 auto;transition:transform var(--el-transition-duration)}.el-collapse-item__arrow.is-active{transform:rotate(90deg)}.el-collapse-item__header.focusing:focus:not(:hover){color:var(--el-color-primary)}.el-collapse-item__header.is-active{border-bottom-color:transparent}.el-collapse-item__wrap{background-color:var(--el-collapse-content-bg-color);border-bottom:1px solid var(--el-collapse-border-color);box-sizing:border-box;overflow:hidden;will-change:height}.el-collapse-item__content{color:var(--el-collapse-content-text-color);font-size:var(--el-collapse-content-font-size);line-height:1.7692307692;padding-bottom:25px}.el-collapse-item:last-child{margin-bottom:-1px}.el-table{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-bg-color);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0,0,0,.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0,0,0,.15);--el-table-index:var(--el-index-normal);background-color:var(--el-table-bg-color);box-sizing:border-box;color:var(--el-table-text-color);font-size:14px;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;max-width:100%;overflow:hidden;position:relative;width:100%}.el-table__inner-wrapper{display:flex;flex-direction:column;height:100%;position:relative}.el-table__inner-wrapper:before{bottom:0;height:1px;left:0;width:100%}.el-table tbody:focus-visible{outline:none}.el-table.has-footer.el-table--fluid-height tr:last-child td.el-table__cell,.el-table.has-footer.el-table--scrollable-y tr:last-child td.el-table__cell{border-bottom-color:transparent}.el-table__empty-block{align-items:center;display:flex;justify-content:center;left:0;min-height:60px;position:-webkit-sticky;position:sticky;text-align:center;width:100%}.el-table__empty-text{color:var(--el-text-color-secondary);line-height:60px;width:50%}.el-table__expand-column .cell{padding:0;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table__expand-icon{color:var(--el-text-color-regular);cursor:pointer;font-size:12px;height:20px;position:relative;transition:transform var(--el-transition-duration-fast) ease-in-out}.el-table__expand-icon--expanded{transform:rotate(90deg)}.el-table__expand-icon>.el-icon{font-size:12px}.el-table__expanded-cell{background-color:var(--el-table-expanded-cell-bg-color)}.el-table__expanded-cell[class*=cell]{padding:20px 50px}.el-table__expanded-cell:hover{background-color:transparent!important}.el-table__placeholder{display:inline-block;width:20px}.el-table__append-wrapper{overflow:hidden}.el-table--fit{border-bottom:0;border-right:0}.el-table--fit .el-table__cell.gutter{border-right-width:1px}.el-table thead{color:var(--el-table-header-text-color)}.el-table thead th{font-weight:600}.el-table thead.is-group th.el-table__cell{background:var(--el-fill-color-light)}.el-table .el-table__cell{box-sizing:border-box;min-width:0;padding:8px 0;position:relative;text-align:left;text-overflow:ellipsis;vertical-align:middle;z-index:var(--el-table-index)}.el-table .el-table__cell.is-center{text-align:center}.el-table .el-table__cell.is-right{text-align:right}.el-table .el-table__cell.gutter{border-bottom-width:0;border-right-width:0;padding:0;width:15px}.el-table .el-table__cell.is-hidden>*{visibility:hidden}.el-table .cell{box-sizing:border-box;line-height:23px;overflow:hidden;overflow-wrap:break-word;padding:0 12px;text-overflow:ellipsis;white-space:normal}.el-table .cell.el-tooltip{min-width:50px;white-space:nowrap}.el-table--large{font-size:var(--el-font-size-base)}.el-table--large .el-table__cell{padding:12px 0}.el-table--large .cell{padding:0 16px}.el-table--default{font-size:14px}.el-table--default .el-table__cell{padding:8px 0}.el-table--default .cell{padding:0 12px}.el-table--small{font-size:12px}.el-table--small .el-table__cell{padding:4px 0}.el-table--small .cell{padding:0 8px}.el-table tr{background-color:var(--el-table-tr-bg-color)}.el-table tr input[type=checkbox]{margin:0}.el-table td.el-table__cell,.el-table th.el-table__cell.is-leaf{border-bottom:var(--el-table-border)}.el-table th.el-table__cell.is-sortable{cursor:pointer}.el-table th.el-table__cell{background-color:var(--el-table-header-bg-color);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table th.el-table__cell>.cell.highlight{color:var(--el-color-primary)}.el-table th.el-table__cell.required>div:before{background:#ff4d51;border-radius:50%;content:"";display:inline-block;height:8px;margin-right:5px;vertical-align:middle;width:8px}.el-table td.el-table__cell div{box-sizing:border-box}.el-table td.el-table__cell.gutter{width:0}.el-table--border .el-table__inner-wrapper:after,.el-table--border:after,.el-table--border:before,.el-table__inner-wrapper:before{background-color:var(--el-table-border-color);content:"";position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table--border .el-table__inner-wrapper:after{height:1px;left:0;top:0;width:100%;z-index:calc(var(--el-table-index) + 2)}.el-table--border:before{height:100%;left:0;top:-1px;width:1px}.el-table--border:after{height:100%;right:0;top:-1px;width:1px}.el-table--border .el-table__inner-wrapper{border-bottom:none;border-right:none}.el-table--border .el-table__footer-wrapper{flex-shrink:0;position:relative}.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table--border th.el-table__cell.gutter:last-of-type{border-bottom:var(--el-table-border);border-bottom-width:1px}.el-table--border th.el-table__cell{border-bottom:var(--el-table-border)}.el-table--hidden{visibility:hidden}.el-table__body-wrapper,.el-table__footer-wrapper,.el-table__header-wrapper{width:100%}.el-table__body-wrapper tr td.el-table-fixed-column--left,.el-table__body-wrapper tr td.el-table-fixed-column--right,.el-table__body-wrapper tr th.el-table-fixed-column--left,.el-table__body-wrapper tr th.el-table-fixed-column--right,.el-table__footer-wrapper tr td.el-table-fixed-column--left,.el-table__footer-wrapper tr td.el-table-fixed-column--right,.el-table__footer-wrapper tr th.el-table-fixed-column--left,.el-table__footer-wrapper tr th.el-table-fixed-column--right,.el-table__header-wrapper tr td.el-table-fixed-column--left,.el-table__header-wrapper tr td.el-table-fixed-column--right,.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background:inherit;position:-webkit-sticky!important;position:sticky!important;z-index:calc(var(--el-table-index) + 1)}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{bottom:-1px;box-shadow:none;content:"";overflow-x:hidden;overflow-y:hidden;pointer-events:none;position:absolute;top:0;touch-action:none;width:10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before{left:-10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{box-shadow:none;right:-10px}.el-table__body-wrapper tr td.el-table__fixed-right-patch,.el-table__body-wrapper tr th.el-table__fixed-right-patch,.el-table__footer-wrapper tr td.el-table__fixed-right-patch,.el-table__footer-wrapper tr th.el-table__fixed-right-patch,.el-table__header-wrapper tr td.el-table__fixed-right-patch,.el-table__header-wrapper tr th.el-table__fixed-right-patch{background:#fff;position:-webkit-sticky!important;position:sticky!important;right:0;z-index:calc(var(--el-table-index) + 1)}.el-table__header-wrapper{flex-shrink:0}.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body,.el-table__footer,.el-table__header{border-collapse:separate;table-layout:fixed}.el-table__header-wrapper{overflow:hidden}.el-table__header-wrapper tbody td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__footer-wrapper{flex-shrink:0;overflow:hidden}.el-table__footer-wrapper tfoot td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__body-wrapper .el-table-column--selection>.cell,.el-table__header-wrapper .el-table-column--selection>.cell{align-items:center;display:inline-flex;height:23px}.el-table__body-wrapper .el-table-column--selection .el-checkbox,.el-table__header-wrapper .el-table-column--selection .el-checkbox{height:unset}.el-table.is-scrolling-left .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-left.el-table--border .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:var(--el-table-border)}.el-table.is-scrolling-left th.el-table-fixed-column--left{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-right th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-middle .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-none .el-table-fixed-column--left.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--left.is-last-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-last-column:before{box-shadow:none}.el-table.is-scrolling-none th.el-table-fixed-column--left,.el-table.is-scrolling-none th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body-wrapper{flex:1;overflow:hidden;position:relative}.el-table__body-wrapper .el-scrollbar__bar{z-index:calc(var(--el-table-index) + 2)}.el-table .caret-wrapper{align-items:center;cursor:pointer;display:inline-flex;flex-direction:column;height:14px;overflow:initial;position:relative;vertical-align:middle;width:24px}.el-table .sort-caret{border:5px solid transparent;height:0;left:7px;position:absolute;width:0}.el-table .sort-caret.ascending{border-bottom-color:var(--el-text-color-placeholder);top:-5px}.el-table .sort-caret.descending{border-top-color:var(--el-text-color-placeholder);bottom:-3px}.el-table .ascending .sort-caret.ascending{border-bottom-color:var(--el-color-primary)}.el-table .descending .sort-caret.descending{border-top-color:var(--el-color-primary)}.el-table .hidden-columns{position:absolute;visibility:hidden;z-index:-1}.el-table--striped .el-table__body tr.el-table__row--striped td.el-table__cell{background:var(--el-fill-color-lighter)}.el-table--striped .el-table__body tr.el-table__row--striped.current-row td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__body tr.hover-row.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped>td.el-table__cell,.el-table__body tr.hover-row>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr>td.hover-cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr.current-row>td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table.el-table--scrollable-y .el-table__body-header{position:-webkit-sticky;position:sticky;top:0;z-index:calc(var(--el-table-index) + 2)}.el-table.el-table--scrollable-y .el-table__body-footer{bottom:0;position:-webkit-sticky;position:sticky;z-index:calc(var(--el-table-index) + 2)}.el-table__column-resize-proxy{border-left:var(--el-table-border);bottom:0;left:200px;position:absolute;top:0;width:0;z-index:calc(var(--el-table-index) + 9)}.el-table__column-filter-trigger{cursor:pointer;display:inline-block}.el-table__column-filter-trigger i{color:var(--el-color-info);font-size:14px;vertical-align:middle}.el-table__border-left-patch{height:100%;top:0;width:1px}.el-table__border-bottom-patch,.el-table__border-left-patch{background-color:var(--el-table-border-color);left:0;position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table__border-bottom-patch{height:1px}.el-table__border-right-patch{background-color:var(--el-table-border-color);height:100%;position:absolute;top:0;width:1px;z-index:calc(var(--el-table-index) + 2)}.el-table--enable-row-transition .el-table__body td.el-table__cell{transition:background-color .25s ease}.el-table--enable-row-hover .el-table__body tr:hover>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table [class*=el-table__row--level] .el-table__expand-icon{display:inline-block;height:12px;line-height:12px;margin-right:8px;text-align:center;width:12px}.el-table .el-table.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table:not(.el-table--border) .el-table__cell{border-right:none}.el-table:not(.el-table--border)>.el-table__inner-wrapper:after{content:none}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary);align-items:center;color:var(--el-checkbox-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-checkbox-font-weight);height:var(--el-checkbox-height,32px);margin-right:30px;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{border:var(--el-border);border-radius:var(--el-border-radius-base);box-sizing:border-box;padding:0 15px 0 9px}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{border-radius:var(--el-border-radius-base);padding:0 19px 0 11px}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{border-radius:calc(var(--el-border-radius-base) - 1px);padding:0 11px 0 7px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{border-radius:var(--el-checkbox-border-radius);outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px}.el-checkbox__input{cursor:pointer;display:inline-flex;outline:none;position:relative;white-space:nowrap}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-icon-color);cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-checked-icon-color);transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-checked-icon-color);content:"";display:block;height:2px;left:0;position:absolute;right:0;top:5px;transform:scale(.5)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{background-color:var(--el-checkbox-bg-color);border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;display:inline-block;height:var(--el-checkbox-input-height);position:relative;transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46);width:var(--el-checkbox-input-width);z-index:var(--el-index-normal)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{border:1px solid transparent;border-left:0;border-top:0;box-sizing:content-box;content:"";height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);transform-origin:center;transition:transform .15s ease-in .05s;width:3px}.el-checkbox__original{height:0;margin:0;opacity:0;outline:none;position:absolute;width:0;z-index:-1}.el-checkbox__label{display:inline-block;font-size:var(--el-checkbox-font-size);line-height:1;padding-left:8px}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox:last-of-type{margin-right:0}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius,4px);border-radius:var(--el-popper-border-radius);font-size:12px;line-height:20px;min-width:10px;overflow-wrap:break-word;padding:5px 11px;position:absolute;visibility:visible;z-index:2000}.el-popper.is-dark{background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary);color:var(--el-bg-color)}.el-popper.is-dark .el-popper__arrow:before{background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow:before{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{height:10px;position:absolute;width:10px;z-index:-1}.el-popper__arrow:before{background:var(--el-text-color-primary);box-sizing:border-box;content:" ";height:10px;position:absolute;transform:rotate(45deg);width:10px;z-index:-1}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent!important;border-top-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary);height:100%;overflow:hidden;position:relative}.el-scrollbar__wrap{height:100%;overflow:auto}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));border-radius:inherit;cursor:pointer;display:block;height:0;opacity:var(--el-scrollbar-opacity,.3);position:relative;transition:var(--el-transition-duration) background-color;width:0}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{border-radius:4px;bottom:2px;position:absolute;right:2px;z-index:1}.el-scrollbar__bar.is-vertical{top:2px;width:6px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-table-column--selection .cell{padding-left:14px;padding-right:14px}.el-table-filter{background-color:#fff;border:1px solid var(--el-border-color-lighter);border-radius:2px;box-shadow:var(--el-box-shadow-light);box-sizing:border-box}.el-table-filter__list{list-style:none;margin:0;min-width:100px;padding:5px 0}.el-table-filter__list-item{cursor:pointer;font-size:var(--el-font-size-base);line-height:36px;padding:0 10px}.el-table-filter__list-item:hover{background-color:var(--el-color-primary-light-9);color:var(--el-color-primary)}.el-table-filter__list-item.is-active{background-color:var(--el-color-primary);color:#fff}.el-table-filter__content{min-width:100px}.el-table-filter__bottom{border-top:1px solid var(--el-border-color-lighter);padding:8px}.el-table-filter__bottom button{background:transparent;border:none;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-small);padding:0 3px}.el-table-filter__bottom button:hover{color:var(--el-color-primary)}.el-table-filter__bottom button:focus{outline:none}.el-table-filter__bottom button.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-table-filter__wrap{max-height:280px}.el-table-filter__checkbox-group{padding:10px}.el-table-filter__checkbox-group label.el-checkbox{align-items:center;display:flex;height:unset;margin-bottom:12px;margin-left:5px;margin-right:5px}.el-table-filter__checkbox-group .el-checkbox:last-child{margin-bottom:0}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px;--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);align-items:center;background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);border-radius:var(--el-tag-border-radius);border-style:solid;border-width:1px;box-sizing:border-box;color:var(--el-tag-text-color);display:inline-flex;font-size:var(--el-tag-font-size);height:24px;justify-content:center;line-height:1;padding:0 9px;vertical-align:middle;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color);flex-shrink:0}.el-tag .el-tag__close:hover{background-color:var(--el-tag-hover-color);color:var(--el-color-white)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info,.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{height:32px;padding:0 11px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{height:20px;padding:0 7px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-divider{position:relative}.el-divider--horizontal{border-top:1px var(--el-border-color) var(--el-border-style);display:block;height:1px;margin:24px 0;width:100%}.el-divider--vertical{border-left:1px var(--el-border-color) var(--el-border-style);display:inline-block;height:1em;margin:0 8px;position:relative;vertical-align:middle;width:1px}.el-divider__text{background-color:var(--el-bg-color);color:var(--el-text-color-primary);font-size:14px;font-weight:500;padding:0 20px;position:absolute}.el-divider__text.is-left{left:20px;transform:translateY(-50%)}.el-divider__text.is-center{left:50%;transform:translate(-50%) translateY(-50%)}.el-divider__text.is-right{right:20px;transform:translateY(-50%)}.el-checkbox-group{font-size:0;line-height:0}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;font-size:var(--el-font-size-base);position:relative;vertical-align:bottom;width:100%}.el-textarea__inner{-webkit-appearance:none;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));display:block;font-family:inherit;font-size:inherit;line-height:1.5;padding:5px 11px;position:relative;resize:vertical;transition:var(--el-transition-box-shadow);width:100%}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset;outline:none}.el-textarea .el-input__count{background:var(--el-fill-color-blank);bottom:5px;color:var(--el-color-info);font-size:12px;line-height:14px;position:absolute;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;--el-input-height:var(--el-component-size);box-sizing:border-box;display:inline-flex;font-size:var(--el-font-size-base);line-height:var(--el-input-height);position:relative;vertical-align:middle;width:var(--el-input-width)}.el-input::-webkit-scrollbar{width:6px;z-index:11}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{background:var(--el-text-color-disabled);border-radius:5px;width:6px}.el-input::-webkit-scrollbar-corner,.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);cursor:pointer;font-size:14px}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{align-items:center;color:var(--el-color-info);display:inline-flex;font-size:12px;height:100%}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);display:inline-block;line-height:normal;padding-left:8px}.el-input__wrapper{align-items:center;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;cursor:text;display:inline-flex;flex-grow:1;justify-content:center;padding:1px 11px;transform:translateZ(0);transition:var(--el-transition-box-shadow)}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);-webkit-appearance:none;background:none;border:none;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));flex-grow:1;font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);outline:none;padding:0;width:100%}.el-input__inner:focus{outline:none}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__prefix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__suffix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{align-items:center;display:flex;height:inherit;justify-content:center;line-height:inherit;margin-left:8px;transition:all var(--el-transition-duration)}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color, ) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{align-items:stretch;display:inline-flex;width:100%}.el-input-group__append,.el-input-group__prepend{align-items:center;background-color:var(--el-fill-color-light);border-radius:var(--el-input-border-radius);color:var(--el-color-info);display:inline-flex;justify-content:center;min-height:100%;padding:0 20px;position:relative;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:none}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{background-color:transparent;border-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-bottom-right-radius:0;border-right:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-bottom-left-radius:0;border-left:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-bottom-left-radius:0;border-top-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-bottom-right-radius:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-bottom-right-radius:0;border-top-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-bottom-left-radius:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-hidden{display:none!important}.el-input-number{display:inline-flex;line-height:30px;position:relative;width:150px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;line-height:1;text-align:center}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-input-number__decrease,.el-input-number__increase{align-items:center;background:var(--el-fill-color-light);bottom:1px;color:var(--el-text-color-regular);cursor:pointer;display:flex;font-size:13px;height:auto;justify-content:center;position:absolute;top:1px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:32px;z-index:1}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{border-left:var(--el-border);border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;right:1px}.el-input-number__decrease{border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border);left:1px}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{line-height:38px;width:180px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{font-size:14px;width:40px}.el-input-number--large .el-input--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{line-height:22px;width:120px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{font-size:12px;width:24px}.el-input-number--small .el-input--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{border-bottom:var(--el-border);border-radius:0 var(--el-border-radius-base) 0 0;bottom:auto;left:auto}.el-input-number.is-controls-right .el-input-number__decrease{border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0;border-right:none;left:auto;right:1px;top:auto}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-switch{--el-switch-on-color:var(--el-color-primary);--el-switch-off-color:var(--el-border-color);align-items:center;display:inline-flex;font-size:14px;height:32px;line-height:20px;position:relative;vertical-align:middle}.el-switch.is-disabled .el-switch__core,.el-switch.is-disabled .el-switch__label{cursor:not-allowed}.el-switch__label{color:var(--el-text-color-primary);cursor:pointer;display:inline-block;font-size:14px;font-weight:500;height:20px;transition:var(--el-transition-duration-fast);vertical-align:middle}.el-switch__label.is-active{color:var(--el-color-primary)}.el-switch__label--left{margin-right:10px}.el-switch__label--right{margin-left:10px}.el-switch__label *{display:inline-block;font-size:14px;line-height:1}.el-switch__label .el-icon{height:inherit}.el-switch__label .el-icon svg{vertical-align:middle}.el-switch__input{height:0;margin:0;opacity:0;position:absolute;width:0}.el-switch__input:focus-visible~.el-switch__core{outline:2px solid var(--el-switch-on-color);outline-offset:1px}.el-switch__core{align-items:center;background:var(--el-switch-off-color);border:1px solid var(--el-switch-border-color,var(--el-switch-off-color));border-radius:10px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:20px;min-width:40px;outline:none;position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration)}.el-switch__core .el-switch__inner{align-items:center;display:flex;height:16px;justify-content:center;overflow:hidden;padding:0 4px 0 18px;transition:all var(--el-transition-duration);width:100%}.el-switch__core .el-switch__inner .is-icon,.el-switch__core .el-switch__inner .is-text{color:var(--el-color-white);font-size:12px;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.el-switch__core .el-switch__action{align-items:center;background-color:var(--el-color-white);border-radius:var(--el-border-radius-circle);color:var(--el-switch-off-color);display:flex;height:16px;justify-content:center;left:1px;position:absolute;transition:all var(--el-transition-duration);width:16px}.el-switch.is-checked .el-switch__core{background-color:var(--el-switch-on-color);border-color:var(--el-switch-border-color,var(--el-switch-on-color))}.el-switch.is-checked .el-switch__core .el-switch__action{color:var(--el-switch-on-color);left:calc(100% - 17px)}.el-switch.is-checked .el-switch__core .el-switch__inner{padding:0 18px 0 4px}.el-switch.is-disabled{opacity:.6}.el-switch--wide .el-switch__label.el-switch__label--left span{left:10px}.el-switch--wide .el-switch__label.el-switch__label--right span{right:10px}.el-switch .label-fade-enter-from,.el-switch .label-fade-leave-active{opacity:0}.el-switch--large{font-size:14px;height:40px;line-height:24px}.el-switch--large .el-switch__label{font-size:14px;height:24px}.el-switch--large .el-switch__label *{font-size:14px}.el-switch--large .el-switch__core{border-radius:12px;height:24px;min-width:50px}.el-switch--large .el-switch__core .el-switch__inner{height:20px;padding:0 6px 0 22px}.el-switch--large .el-switch__core .el-switch__action{height:20px;width:20px}.el-switch--large.is-checked .el-switch__core .el-switch__action{left:calc(100% - 21px)}.el-switch--large.is-checked .el-switch__core .el-switch__inner{padding:0 22px 0 6px}.el-switch--small{font-size:12px;height:24px;line-height:16px}.el-switch--small .el-switch__label{font-size:12px;height:16px}.el-switch--small .el-switch__label *{font-size:12px}.el-switch--small .el-switch__core{border-radius:8px;height:16px;min-width:30px}.el-switch--small .el-switch__core .el-switch__inner{height:12px;padding:0 2px 0 14px}.el-switch--small .el-switch__core .el-switch__action{height:12px;width:12px}.el-switch--small.is-checked .el-switch__core .el-switch__action{left:calc(100% - 13px)}.el-switch--small.is-checked .el-switch__core .el-switch__inner{padding:0 14px 0 2px}.el-slider{--el-slider-main-bg-color:var(--el-color-primary);--el-slider-runway-bg-color:var(--el-border-color-light);--el-slider-stop-bg-color:var(--el-color-white);--el-slider-disabled-color:var(--el-text-color-placeholder);--el-slider-border-radius:3px;--el-slider-height:6px;--el-slider-button-size:20px;--el-slider-button-wrapper-size:36px;--el-slider-button-wrapper-offset:-15px;align-items:center;display:flex;height:32px;width:100%}.el-slider__runway{background-color:var(--el-slider-runway-bg-color);border-radius:var(--el-slider-border-radius);cursor:pointer;flex:1;height:var(--el-slider-height);position:relative}.el-slider__runway.show-input{margin-right:30px;width:auto}.el-slider__runway.is-disabled{cursor:default}.el-slider__runway.is-disabled .el-slider__bar{background-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button{border-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button-wrapper.hover,.el-slider__runway.is-disabled .el-slider__button-wrapper:hover,.el-slider__runway.is-disabled .el-slider__button-wrapper.dragging{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button.dragging,.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{transform:scale(1)}.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover,.el-slider__runway.is-disabled .el-slider__button.dragging{cursor:not-allowed}.el-slider__input{flex-shrink:0;width:130px}.el-slider__bar{background-color:var(--el-slider-main-bg-color);border-bottom-left-radius:var(--el-slider-border-radius);border-top-left-radius:var(--el-slider-border-radius);height:var(--el-slider-height);position:absolute}.el-slider__button-wrapper{background-color:transparent;height:var(--el-slider-button-wrapper-size);line-height:normal;outline:none;position:absolute;text-align:center;top:var(--el-slider-button-wrapper-offset);transform:translate(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:var(--el-slider-button-wrapper-size);z-index:1}.el-slider__button-wrapper:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-slider__button-wrapper.hover,.el-slider__button-wrapper:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button-wrapper.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__button{background-color:var(--el-color-white);border:2px solid var(--el-slider-main-bg-color);border-radius:50%;box-sizing:border-box;display:inline-block;height:var(--el-slider-button-size);transition:var(--el-transition-duration-fast);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;width:var(--el-slider-button-size)}.el-slider__button.dragging,.el-slider__button.hover,.el-slider__button:hover{transform:scale(1.2)}.el-slider__button.hover,.el-slider__button:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__stop{background-color:var(--el-slider-stop-bg-color);border-radius:var(--el-border-radius-circle);height:var(--el-slider-height);position:absolute;transform:translate(-50%);width:var(--el-slider-height)}.el-slider__marks{height:100%;left:12px;top:0;width:18px}.el-slider__marks-text{color:var(--el-color-info);font-size:14px;margin-top:15px;position:absolute;transform:translate(-50%);white-space:pre}.el-slider.is-vertical{display:inline-flex;flex:0;height:100%;position:relative;width:auto}.el-slider.is-vertical .el-slider__runway{height:100%;margin:0 16px;width:var(--el-slider-height)}.el-slider.is-vertical .el-slider__bar{border-radius:0 0 3px 3px;height:auto;width:var(--el-slider-height)}.el-slider.is-vertical .el-slider__button-wrapper{left:var(--el-slider-button-wrapper-offset);top:auto;transform:translateY(50%)}.el-slider.is-vertical .el-slider__stop{transform:translateY(50%)}.el-slider.is-vertical .el-slider__marks-text{left:15px;margin-top:0;transform:translateY(50%)}.el-slider--large{height:40px}.el-slider--small{height:24px}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{background-color:var(--el-color-primary);background-position:50%;background-repeat:no-repeat;border-right:none;border-top:none;content:"";height:12px;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;position:absolute;right:20px;top:50%;transform:translateY(-50%);width:12px}.el-select-dropdown{border-radius:var(--el-border-radius-base);box-sizing:border-box;z-index:calc(var(--el-index-top) + 1)}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__empty,.el-select-dropdown__loading{color:var(--el-text-color-secondary);font-size:var(--el-select-font-size);margin:0;padding:10px 0;text-align:center}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{box-sizing:border-box;list-style:none;margin:0;padding:6px 0}.el-select-dropdown__list.el-vl__window{margin:6px 0;padding:0}.el-select-dropdown__header{border-bottom:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__footer{border-top:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__item{box-sizing:border-box;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-base);height:34px;line-height:34px;overflow:hidden;padding:0 32px 0 20px;position:relative;text-overflow:ellipsis;white-space:nowrap}.el-select-dropdown__item.is-hovering{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.is-selected{color:var(--el-color-primary);font-weight:700}.el-select-dropdown__item.is-disabled{background-color:unset;color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{background-color:var(--el-color-primary);background-position:50%;background-repeat:no-repeat;border-right:none;border-top:none;content:"";height:12px;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;position:absolute;right:20px;top:50%;transform:translateY(-50%);width:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-disabled:after{background-color:var(--el-text-color-placeholder)}.el-select-group{margin:0;padding:0}.el-select-group__wrap{list-style:none;margin:0;padding:0;position:relative}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type):after{background:var(--el-border-color-light);bottom:12px;content:"";display:block;height:1px;left:20px;position:absolute;right:20px}.el-select-group__split-dash{background:var(--el-border-color-light);height:1px;left:20px;position:absolute;right:20px}.el-select-group__title{color:var(--el-color-info);font-size:12px;line-height:30px;padding-left:20px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-color:var(--el-disabled-text-color);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px;--el-select-width:100%;display:inline-block;position:relative;vertical-align:middle;width:var(--el-select-width)}.el-select__wrapper{align-items:center;background-color:var(--el-fill-color-blank);border-radius:var(--el-border-radius-base);box-shadow:0 0 0 1px var(--el-border-color) inset;box-sizing:border-box;cursor:pointer;display:flex;font-size:14px;gap:6px;line-height:24px;min-height:32px;padding:4px 12px;position:relative;text-align:left;transition:var(--el-transition-duration)}.el-select__wrapper:hover{box-shadow:0 0 0 1px var(--el-text-color) inset}.el-select__wrapper.is-filterable{cursor:text}.el-select__wrapper.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-select__wrapper.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-select__wrapper.is-disabled{background-color:var(--el-fill-color-light);box-shadow:0 0 0 1px var(--el-select-disabled-border) inset;color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select__wrapper.is-disabled:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-select__wrapper.is-disabled .el-select__selected-item{color:var(--el-select-disabled-color)}.el-select__wrapper.is-disabled .el-select__caret,.el-select__wrapper.is-disabled .el-tag{cursor:not-allowed}.el-select__prefix,.el-select__suffix{align-items:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:flex;flex-shrink:0;gap:6px}.el-select__caret{color:var(--el-select-input-color);cursor:pointer;font-size:var(--el-select-input-font-size);transform:rotate(0);transition:var(--el-transition-duration)}.el-select__caret.is-reverse{transform:rotate(180deg)}.el-select__selection{align-items:center;display:flex;flex:1;flex-wrap:wrap;gap:6px;min-width:0;position:relative}.el-select__selection.is-near{margin-left:-8px}.el-select__selection .el-tag{border-color:transparent;cursor:pointer}.el-select__selection .el-tag .el-tag__content{min-width:0}.el-select__selected-item{display:flex;flex-wrap:wrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select__tags-text{line-height:normal}.el-select__placeholder,.el-select__tags-text{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select__placeholder{color:var(--el-input-text-color,var(--el-text-color-regular));position:absolute;top:50%;transform:translateY(-50%);width:100%}.el-select__placeholder.is-transparent{color:var(--el-text-color-placeholder);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select__input-wrapper{max-width:100%}.el-select__input-wrapper.is-hidden{opacity:0;position:absolute}.el-select__input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-select-multiple-input-color);font-family:inherit;font-size:inherit;height:24px;max-width:100%;outline:none;padding:0}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input-calculator{left:0;max-width:100%;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:pre}.el-select--large .el-select__wrapper{font-size:14px;gap:6px;line-height:24px;min-height:40px;padding:8px 16px}.el-select--large .el-select__selection{gap:6px}.el-select--large .el-select__selection.is-near{margin-left:-8px}.el-select--large .el-select__prefix,.el-select--large .el-select__suffix{gap:6px}.el-select--large .el-select__input{height:24px}.el-select--small .el-select__wrapper{font-size:12px;gap:4px;line-height:20px;min-height:24px;padding:2px 8px}.el-select--small .el-select__selection{gap:4px}.el-select--small .el-select__selection.is-near{margin-left:-6px}.el-select--small .el-select__prefix,.el-select--small .el-select__suffix{gap:4px}.el-select--small .el-select__input{height:20px}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255,255,255,.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary);align-items:center;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);border-radius:var(--el-border-radius-base);box-sizing:border-box;color:var(--el-button-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-button-font-weight);height:32px;justify-content:center;line-height:1;outline:none;padding:8px 15px;text-align:center;transition:.1s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-button:hover{background-color:var(--el-button-hover-bg-color);border-color:var(--el-button-hover-border-color);color:var(--el-button-hover-text-color);outline:none}.el-button:active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button>span{align-items:center;display:inline-flex}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button.is-disabled,.el-button.is-disabled:hover{background-color:var(--el-button-disabled-bg-color);background-image:none;border-color:var(--el-button-disabled-border-color);color:var(--el-button-disabled-text-color);cursor:not-allowed}.el-button.is-loading{pointer-events:none;position:relative}.el-button.is-loading:before{background-color:var(--el-mask-color-extra-light);border-radius:inherit;bottom:-1px;content:"";left:-1px;pointer-events:none;position:absolute;right:-1px;top:-1px;z-index:1}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px;width:32px}.el-button.is-text{background-color:transparent;border:0 solid transparent;color:var(--el-button-text-color)}.el-button.is-text.is-disabled{background-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{background:transparent;border-color:transparent;color:var(--el-button-text-color);height:auto;padding:2px}.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-link:not(.is-disabled):hover{background-color:transparent;border-color:transparent}.el-button.is-link:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-button-active-color)}.el-button--text{background:transparent;border-color:transparent;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button--text:not(.is-disabled):hover{background-color:transparent;border-color:transparent;color:var(--el-color-primary-light-3)}.el-button--text:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-color-primary-dark-2)}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8);color:var(--el-color-primary-light-5)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8);color:var(--el-color-success-light-5)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8);color:var(--el-color-warning-light-5)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8);color:var(--el-color-danger-light-5)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8);color:var(--el-color-info-light-5)}.el-button--large{--el-button-size:40px;border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base);height:var(--el-button-size);padding:12px 19px}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{padding:12px;width:var(--el-button-size)}.el-button--small{--el-button-size:24px;border-radius:calc(var(--el-border-radius-base) - 1px);font-size:12px;height:var(--el-button-size);padding:5px 11px}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{padding:5px;width:var(--el-button-size)}.el-popconfirm__main{align-items:center;display:flex}.el-popconfirm__icon{margin-right:5px}.el-popconfirm__action{margin-top:8px;text-align:right}.el-popover{--el-popover-bg-color:var(--el-bg-color-overlay);--el-popover-font-size:var(--el-font-size-base);--el-popover-border-color:var(--el-border-color-lighter);--el-popover-padding:12px;--el-popover-padding-large:18px 20px;--el-popover-title-font-size:16px;--el-popover-title-text-color:var(--el-text-color-primary);--el-popover-border-radius:4px}.el-popover.el-popper{background:var(--el-popover-bg-color);border:1px solid var(--el-popover-border-color);border-radius:var(--el-popover-border-radius);box-shadow:var(--el-box-shadow-light);box-sizing:border-box;color:var(--el-text-color-regular);font-size:var(--el-popover-font-size);line-height:1.4;min-width:150px;overflow-wrap:break-word;padding:var(--el-popover-padding);z-index:var(--el-index-popper)}.el-popover.el-popper--plain{padding:var(--el-popover-padding-large)}.el-popover__title{color:var(--el-popover-title-text-color);font-size:var(--el-popover-title-font-size);line-height:1;margin-bottom:12px}.el-popover__reference:focus:hover,.el-popover__reference:focus:not(.focusing){outline-width:0}.el-popover.el-popper.is-dark{--el-popover-bg-color:var(--el-text-color-primary);--el-popover-border-color:var(--el-text-color-primary);--el-popover-title-text-color:var(--el-bg-color);color:var(--el-bg-color)}.el-popover.el-popper:focus,.el-popover.el-popper:focus:active{outline-width:0}.nhentai-helper-setting-help-buttons[data-v-3b39b5cd]{float:left;position:absolute}.inline-item[data-v-3b39b5cd]{display:inline-block}.inline-item[data-v-3b39b5cd]:not(:last-of-type){margin-right:8px}.inline-item__name[data-v-3b39b5cd]{margin-right:4px;-webkit-user-select:none;user-select:none}#nhentai-helper-setting-dialog .asterisk-example:before{content:"*";color:var(--el-color-danger);margin-right:4px}#nhentai-helper-setting-dialog label{font-weight:unset}#nhentai-helper-setting-dialog input:not([type=file]):not([type=checkbox]){background:inherit;color:var(--el-input-text-color, var(--el-text-color-regular))}#nhentai-helper-setting-dialog .el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color)}#nhentai-helper-setting-dialog .el-slider__stop{border:solid 1px var(--el-slider-runway-bg-color)}#nhentai-helper-setting-dialog .el-form-item:last-of-type{margin-bottom:0}#nhentai-helper-setting-dialog .el-form-item.refresh-required>.el-form-item__label-wrap>.el-form-item__label:after{content:"*";color:var(--el-color-danger);margin-left:4px}#nhentai-helper-setting-dialog .el-divider__text{color:var(--el-text-color-secondary);-webkit-user-select:none;user-select:none}#nhentai-helper-setting-dialog .m-l-16{margin-left:16px}#nhentai-helper-setting-dialog .m-b-32{margin-bottom:32px}#nhentai-helper-setting-dialog .no-sl,#nhentai-helper-setting-dialog .el-form-item__label{-webkit-user-select:none;user-select:none}#nhentai-helper-setting-dialog .el-table .el-input__prefix,#nhentai-helper-setting-dialog .el-table .el-input__suffix{line-height:30px}#nhentai-helper-setting-dialog .el-table__empty-block{display:none}.el-select-dropdown{-webkit-user-select:none;user-select:none}.language-filter[data-v-999a1213]{padding-left:10px}.filter-select[data-v-999a1213]{width:140px;margin-right:-140px}.filter-select[data-v-999a1213] .el-input__inner{color:var(--el-input-text-color, var(--el-text-color-regular))!important;background:0 0!important}@media screen and (max-width: 644px){.language-filter[data-v-999a1213]{padding:10px 0}.filter-select[data-v-999a1213]{margin-right:0}} `);

(function () {
  'use strict';

  var __defProp2 = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var require_main_001 = __commonJS({
    "main-DiH548_i.js"(exports, module) {
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_openInTab = /* @__PURE__ */ (() => typeof GM_openInTab != "undefined" ? GM_openInTab : void 0)();
      var _GM_registerMenuCommand = /* @__PURE__ */ (() => typeof GM_registerMenuCommand != "undefined" ? GM_registerMenuCommand : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      var _unsafeWindow = /* @__PURE__ */ (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)();
      var _monkeyWindow = /* @__PURE__ */ (() => window)();
      const WORKER_THREAD_NUM = Math.max(navigator.hardwareConcurrency - 1, 1);
      const { pathname, host } = location;
      const IS_PAGE_MANGA_DETAIL = /^\/g\/[0-9]+\/?(\?.*)?$/.test(pathname);
      const IS_PAGE_ONLINE_VIEW = /^\/g\/[0-9]+(\/list)?\/[0-9]+\/?(\?.*)?$/.test(pathname);
      const IS_PAGE_MANGA_LIST = !IS_PAGE_MANGA_DETAIL && !IS_PAGE_ONLINE_VIEW && document.getElementsByClassName("gallery").length > 0;
      const IS_NHENTAI = host === "nhentai.net";
      const IS_NHENTAI_TO = host === "nhentai.to" || host === "nhentai.website";
      const MEDIA_URL_TEMPLATE_KEY = `media_url_template_${host}`;
      const isNodeOrElement = typeof Node === "function" ? (val) => val instanceof Node : (val) => val && typeof val === "object" && typeof val.nodeType === "number" && typeof val.nodeName === "string";
      if (IS_NHENTAI) {
        if (_GM_getValue("prevent_console_clear", false) || localStorage.getItem("NHENTAI_HELPER_DEBUG")) {
          const c2 = _unsafeWindow.console;
          c2._clear = c2.clear;
          c2.clear = () => {
          };
          c2._log = c2.log;
          c2.log = (...args) => {
            if (args.length === 1 && isNodeOrElement(args[0]))
              return;
            c2._log(...args);
          };
        }
      }
      const logger = {
        log: (...args) => {
          console.log("[nhentai-helper]", ...args);
        },
        warn: (...args) => {
          console.warn("[nhentai-helper]", ...args);
        },
        error: (...args) => {
          console.error("[nhentai-helper]", ...args);
        }
      };
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs(x2) {
        return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
      }
      var jquery = { exports: {} };
      /*!
       * jQuery JavaScript Library v3.7.1
       * https://jquery.com/
       *
       * Copyright OpenJS Foundation and other contributors
       * Released under the MIT license
       * https://jquery.org/license
       *
       * Date: 2023-08-28T13:37Z
       */
      (function(module2) {
        (function(global2, factory) {
          {
            module2.exports = global2.document ? factory(global2, true) : function(w2) {
              if (!w2.document) {
                throw new Error("jQuery requires a window with a document");
              }
              return factory(w2);
            };
          }
        })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
          var arr = [];
          var getProto2 = Object.getPrototypeOf;
          var slice = arr.slice;
          var flat = arr.flat ? function(array) {
            return arr.flat.call(array);
          } : function(array) {
            return arr.concat.apply([], array);
          };
          var push = arr.push;
          var indexOf = arr.indexOf;
          var class2type = {};
          var toString2 = class2type.toString;
          var hasOwn2 = class2type.hasOwnProperty;
          var fnToString = hasOwn2.toString;
          var ObjectFunctionString = fnToString.call(Object);
          var support = {};
          var isFunction2 = function isFunction3(obj) {
            return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
          };
          var isWindow = function isWindow2(obj) {
            return obj != null && obj === obj.window;
          };
          var document2 = window2.document;
          var preservedScriptAttributes = {
            type: true,
            src: true,
            nonce: true,
            noModule: true
          };
          function DOMEval(code2, node, doc2) {
            doc2 = doc2 || document2;
            var i, val, script = doc2.createElement("script");
            script.text = code2;
            if (node) {
              for (i in preservedScriptAttributes) {
                val = node[i] || node.getAttribute && node.getAttribute(i);
                if (val) {
                  script.setAttribute(i, val);
                }
              }
            }
            doc2.head.appendChild(script).parentNode.removeChild(script);
          }
          function toType(obj) {
            if (obj == null) {
              return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString2.call(obj)] || "object" : typeof obj;
          }
          var version2 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery2 = function(selector, context) {
            return new jQuery2.fn.init(selector, context);
          };
          jQuery2.fn = jQuery2.prototype = {
            // The current version of jQuery being used
            jquery: version2,
            constructor: jQuery2,
            // The default length of a jQuery object is 0
            length: 0,
            toArray: function() {
              return slice.call(this);
            },
            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function(num) {
              if (num == null) {
                return slice.call(this);
              }
              return num < 0 ? this[num + this.length] : this[num];
            },
            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function(elems) {
              var ret = jQuery2.merge(this.constructor(), elems);
              ret.prevObject = this;
              return ret;
            },
            // Execute a callback for every element in the matched set.
            each: function(callback) {
              return jQuery2.each(this, callback);
            },
            map: function(callback) {
              return this.pushStack(jQuery2.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
              }));
            },
            slice: function() {
              return this.pushStack(slice.apply(this, arguments));
            },
            first: function() {
              return this.eq(0);
            },
            last: function() {
              return this.eq(-1);
            },
            even: function() {
              return this.pushStack(jQuery2.grep(this, function(_elem, i) {
                return (i + 1) % 2;
              }));
            },
            odd: function() {
              return this.pushStack(jQuery2.grep(this, function(_elem, i) {
                return i % 2;
              }));
            },
            eq: function(i) {
              var len = this.length, j = +i + (i < 0 ? len : 0);
              return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
            },
            end: function() {
              return this.prevObject || this.constructor();
            },
            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push,
            sort: arr.sort,
            splice: arr.splice
          };
          jQuery2.extend = jQuery2.fn.extend = function() {
            var options, name, src, copy, copyIsArray, clone2, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
            if (typeof target === "boolean") {
              deep = target;
              target = arguments[i] || {};
              i++;
            }
            if (typeof target !== "object" && !isFunction2(target)) {
              target = {};
            }
            if (i === length) {
              target = this;
              i--;
            }
            for (; i < length; i++) {
              if ((options = arguments[i]) != null) {
                for (name in options) {
                  copy = options[name];
                  if (name === "__proto__" || target === copy) {
                    continue;
                  }
                  if (deep && copy && (jQuery2.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                    src = target[name];
                    if (copyIsArray && !Array.isArray(src)) {
                      clone2 = [];
                    } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                      clone2 = {};
                    } else {
                      clone2 = src;
                    }
                    copyIsArray = false;
                    target[name] = jQuery2.extend(deep, clone2, copy);
                  } else if (copy !== void 0) {
                    target[name] = copy;
                  }
                }
              }
            }
            return target;
          };
          jQuery2.extend({
            // Unique for each copy of jQuery on the page
            expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
            // Assume jQuery is ready without the ready module
            isReady: true,
            error: function(msg) {
              throw new Error(msg);
            },
            noop: function() {
            },
            isPlainObject: function(obj) {
              var proto, Ctor;
              if (!obj || toString2.call(obj) !== "[object Object]") {
                return false;
              }
              proto = getProto2(obj);
              if (!proto) {
                return true;
              }
              Ctor = hasOwn2.call(proto, "constructor") && proto.constructor;
              return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
            },
            isEmptyObject: function(obj) {
              var name;
              for (name in obj) {
                return false;
              }
              return true;
            },
            // Evaluates a script in a provided context; falls back to the global one
            // if not specified.
            globalEval: function(code2, options, doc2) {
              DOMEval(code2, { nonce: options && options.nonce }, doc2);
            },
            each: function(obj, callback) {
              var length, i = 0;
              if (isArrayLike2(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                  if (callback.call(obj[i], i, obj[i]) === false) {
                    break;
                  }
                }
              } else {
                for (i in obj) {
                  if (callback.call(obj[i], i, obj[i]) === false) {
                    break;
                  }
                }
              }
              return obj;
            },
            // Retrieve the text value of an array of DOM nodes
            text: function(elem) {
              var node, ret = "", i = 0, nodeType = elem.nodeType;
              if (!nodeType) {
                while (node = elem[i++]) {
                  ret += jQuery2.text(node);
                }
              }
              if (nodeType === 1 || nodeType === 11) {
                return elem.textContent;
              }
              if (nodeType === 9) {
                return elem.documentElement.textContent;
              }
              if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
              }
              return ret;
            },
            // results is for internal usage only
            makeArray: function(arr2, results) {
              var ret = results || [];
              if (arr2 != null) {
                if (isArrayLike2(Object(arr2))) {
                  jQuery2.merge(
                    ret,
                    typeof arr2 === "string" ? [arr2] : arr2
                  );
                } else {
                  push.call(ret, arr2);
                }
              }
              return ret;
            },
            inArray: function(elem, arr2, i) {
              return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
            },
            isXMLDoc: function(elem) {
              var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
              return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
            },
            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            merge: function(first, second) {
              var len = +second.length, j = 0, i = first.length;
              for (; j < len; j++) {
                first[i++] = second[j];
              }
              first.length = i;
              return first;
            },
            grep: function(elems, callback, invert2) {
              var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert2;
              for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                  matches.push(elems[i]);
                }
              }
              return matches;
            },
            // arg is for internal usage only
            map: function(elems, callback, arg) {
              var length, value, i = 0, ret = [];
              if (isArrayLike2(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                  value = callback(elems[i], i, arg);
                  if (value != null) {
                    ret.push(value);
                  }
                }
              } else {
                for (i in elems) {
                  value = callback(elems[i], i, arg);
                  if (value != null) {
                    ret.push(value);
                  }
                }
              }
              return flat(ret);
            },
            // A global GUID counter for objects
            guid: 1,
            // jQuery.support is not used in Core but other projects attach their
            // properties to it so it needs to exist.
            support
          });
          if (typeof Symbol === "function") {
            jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
          }
          jQuery2.each(
            "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
            function(_i, name) {
              class2type["[object " + name + "]"] = name.toLowerCase();
            }
          );
          function isArrayLike2(obj) {
            var length = !!obj && "length" in obj && obj.length, type = toType(obj);
            if (isFunction2(obj) || isWindow(obj)) {
              return false;
            }
            return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
          }
          function nodeName(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
          }
          var pop = arr.pop;
          var sort = arr.sort;
          var splice2 = arr.splice;
          var whitespace2 = "[\\x20\\t\\r\\n\\f]";
          var rtrimCSS = new RegExp(
            "^" + whitespace2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace2 + "+$",
            "g"
          );
          jQuery2.contains = function(a2, b2) {
            var bup = b2 && b2.parentNode;
            return a2 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
            // IE doesn't have `contains` on SVG.
            (a2.contains ? a2.contains(bup) : a2.compareDocumentPosition && a2.compareDocumentPosition(bup) & 16));
          };
          var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
          function fcssescape(ch, asCodePoint) {
            if (asCodePoint) {
              if (ch === "\0") {
                return "�";
              }
              return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
            }
            return "\\" + ch;
          }
          jQuery2.escapeSelector = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
          };
          var preferredDoc = document2, pushNative = push;
          (function() {
            var i, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery2.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a2, b2) {
              if (a2 === b2) {
                hasDuplicate = true;
              }
              return 0;
            }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace2 + "*(" + identifier + ")(?:" + whitespace2 + // Operator (capture 2)
            "*([*^$|!~]?=)" + whitespace2 + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
            `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace2 + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace2 + "+", "g"), rcomma = new RegExp("^" + whitespace2 + "*," + whitespace2 + "*"), rleadingCombinator = new RegExp("^" + whitespace2 + "*([>+~]|" + whitespace2 + ")" + whitespace2 + "*"), rdescend = new RegExp(whitespace2 + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
              ID: new RegExp("^#(" + identifier + ")"),
              CLASS: new RegExp("^\\.(" + identifier + ")"),
              TAG: new RegExp("^(" + identifier + "|[*])"),
              ATTR: new RegExp("^" + attributes),
              PSEUDO: new RegExp("^" + pseudos),
              CHILD: new RegExp(
                "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace2 + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace2 + "*(?:([+-]|)" + whitespace2 + "*(\\d+)|))" + whitespace2 + "*\\)|)",
                "i"
              ),
              bool: new RegExp("^(?:" + booleans + ")$", "i"),
              // For use in libraries implementing .is()
              // We use this for POS matching in `select`
              needsContext: new RegExp("^" + whitespace2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace2 + "*((?:-\\d)?\\d*)" + whitespace2 + "*\\)|)(?=[^-]|$)", "i")
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
              var high = "0x" + escape2.slice(1) - 65536;
              if (nonHex) {
                return nonHex;
              }
              return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            }, unloadHandler = function() {
              setDocument();
            }, inDisabledFieldset = addCombinator(
              function(elem) {
                return elem.disabled === true && nodeName(elem, "fieldset");
              },
              { dir: "parentNode", next: "legend" }
            );
            function safeActiveElement() {
              try {
                return document3.activeElement;
              } catch (err) {
              }
            }
            try {
              push2.apply(
                arr = slice.call(preferredDoc.childNodes),
                preferredDoc.childNodes
              );
              arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
              push2 = {
                apply: function(target, els) {
                  pushNative.apply(target, slice.call(els));
                },
                call: function(target) {
                  pushNative.apply(target, slice.call(arguments, 1));
                }
              };
            }
            function find(selector, context, results, seed2) {
              var m2, i2, elem, nid, match2, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
              results = results || [];
              if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
              }
              if (!seed2) {
                setDocument(context);
                context = context || document3;
                if (documentIsHTML) {
                  if (nodeType !== 11 && (match2 = rquickExpr2.exec(selector))) {
                    if (m2 = match2[1]) {
                      if (nodeType === 9) {
                        if (elem = context.getElementById(m2)) {
                          if (elem.id === m2) {
                            push2.call(results, elem);
                            return results;
                          }
                        } else {
                          return results;
                        }
                      } else {
                        if (newContext && (elem = newContext.getElementById(m2)) && find.contains(context, elem) && elem.id === m2) {
                          push2.call(results, elem);
                          return results;
                        }
                      }
                    } else if (match2[2]) {
                      push2.apply(results, context.getElementsByTagName(selector));
                      return results;
                    } else if ((m2 = match2[3]) && context.getElementsByClassName) {
                      push2.apply(results, context.getElementsByClassName(m2));
                      return results;
                    }
                  }
                  if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    newSelector = selector;
                    newContext = context;
                    if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                      newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                      if (newContext != context || !support.scope) {
                        if (nid = context.getAttribute("id")) {
                          nid = jQuery2.escapeSelector(nid);
                        } else {
                          context.setAttribute("id", nid = expando);
                        }
                      }
                      groups = tokenize(selector);
                      i2 = groups.length;
                      while (i2--) {
                        groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                      }
                      newSelector = groups.join(",");
                    }
                    try {
                      push2.apply(
                        results,
                        newContext.querySelectorAll(newSelector)
                      );
                      return results;
                    } catch (qsaError) {
                      nonnativeSelectorCache(selector, true);
                    } finally {
                      if (nid === expando) {
                        context.removeAttribute("id");
                      }
                    }
                  }
                }
              }
              return select(selector.replace(rtrimCSS, "$1"), context, results, seed2);
            }
            function createCache() {
              var keys2 = [];
              function cache2(key, value) {
                if (keys2.push(key + " ") > Expr.cacheLength) {
                  delete cache2[keys2.shift()];
                }
                return cache2[key + " "] = value;
              }
              return cache2;
            }
            function markFunction(fn2) {
              fn2[expando] = true;
              return fn2;
            }
            function assert(fn2) {
              var el = document3.createElement("fieldset");
              try {
                return !!fn2(el);
              } catch (e) {
                return false;
              } finally {
                if (el.parentNode) {
                  el.parentNode.removeChild(el);
                }
                el = null;
              }
            }
            function createInputPseudo(type) {
              return function(elem) {
                return nodeName(elem, "input") && elem.type === type;
              };
            }
            function createButtonPseudo(type) {
              return function(elem) {
                return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
              };
            }
            function createDisabledPseudo(disabled) {
              return function(elem) {
                if ("form" in elem) {
                  if (elem.parentNode && elem.disabled === false) {
                    if ("label" in elem) {
                      if ("label" in elem.parentNode) {
                        return elem.parentNode.disabled === disabled;
                      } else {
                        return elem.disabled === disabled;
                      }
                    }
                    return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                    elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                  }
                  return elem.disabled === disabled;
                } else if ("label" in elem) {
                  return elem.disabled === disabled;
                }
                return false;
              };
            }
            function createPositionalPseudo(fn2) {
              return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed2, matches2) {
                  var j, matchIndexes = fn2([], seed2.length, argument), i2 = matchIndexes.length;
                  while (i2--) {
                    if (seed2[j = matchIndexes[i2]]) {
                      seed2[j] = !(matches2[j] = seed2[j]);
                    }
                  }
                });
              });
            }
            function testContext(context) {
              return context && typeof context.getElementsByTagName !== "undefined" && context;
            }
            function setDocument(node) {
              var subWindow, doc2 = node ? node.ownerDocument || node : preferredDoc;
              if (doc2 == document3 || doc2.nodeType !== 9 || !doc2.documentElement) {
                return document3;
              }
              document3 = doc2;
              documentElement2 = document3.documentElement;
              documentIsHTML = !jQuery2.isXMLDoc(document3);
              matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
              if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq
              preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
                subWindow.addEventListener("unload", unloadHandler);
              }
              support.getById = assert(function(el) {
                documentElement2.appendChild(el).id = jQuery2.expando;
                return !document3.getElementsByName || !document3.getElementsByName(jQuery2.expando).length;
              });
              support.disconnectedMatch = assert(function(el) {
                return matches.call(el, "*");
              });
              support.scope = assert(function() {
                return document3.querySelectorAll(":scope");
              });
              support.cssHas = assert(function() {
                try {
                  document3.querySelector(":has(*,:jqfake)");
                  return false;
                } catch (e) {
                  return true;
                }
              });
              if (support.getById) {
                Expr.filter.ID = function(id) {
                  var attrId = id.replace(runescape, funescape);
                  return function(elem) {
                    return elem.getAttribute("id") === attrId;
                  };
                };
                Expr.find.ID = function(id, context) {
                  if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                    var elem = context.getElementById(id);
                    return elem ? [elem] : [];
                  }
                };
              } else {
                Expr.filter.ID = function(id) {
                  var attrId = id.replace(runescape, funescape);
                  return function(elem) {
                    var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                    return node2 && node2.value === attrId;
                  };
                };
                Expr.find.ID = function(id, context) {
                  if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                    var node2, i2, elems, elem = context.getElementById(id);
                    if (elem) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id) {
                        return [elem];
                      }
                      elems = context.getElementsByName(id);
                      i2 = 0;
                      while (elem = elems[i2++]) {
                        node2 = elem.getAttributeNode("id");
                        if (node2 && node2.value === id) {
                          return [elem];
                        }
                      }
                    }
                    return [];
                  }
                };
              }
              Expr.find.TAG = function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                  return context.getElementsByTagName(tag);
                } else {
                  return context.querySelectorAll(tag);
                }
              };
              Expr.find.CLASS = function(className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                  return context.getElementsByClassName(className);
                }
              };
              rbuggyQSA = [];
              assert(function(el) {
                var input;
                documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
                if (!el.querySelectorAll("[selected]").length) {
                  rbuggyQSA.push("\\[" + whitespace2 + "*(?:value|" + booleans + ")");
                }
                if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                  rbuggyQSA.push("~=");
                }
                if (!el.querySelectorAll("a#" + expando + "+*").length) {
                  rbuggyQSA.push(".#.+[+~]");
                }
                if (!el.querySelectorAll(":checked").length) {
                  rbuggyQSA.push(":checked");
                }
                input = document3.createElement("input");
                input.setAttribute("type", "hidden");
                el.appendChild(input).setAttribute("name", "D");
                documentElement2.appendChild(el).disabled = true;
                if (el.querySelectorAll(":disabled").length !== 2) {
                  rbuggyQSA.push(":enabled", ":disabled");
                }
                input = document3.createElement("input");
                input.setAttribute("name", "");
                el.appendChild(input);
                if (!el.querySelectorAll("[name='']").length) {
                  rbuggyQSA.push("\\[" + whitespace2 + "*name" + whitespace2 + "*=" + whitespace2 + `*(?:''|"")`);
                }
              });
              if (!support.cssHas) {
                rbuggyQSA.push(":has");
              }
              rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
              sortOrder = function(a2, b2) {
                if (a2 === b2) {
                  hasDuplicate = true;
                  return 0;
                }
                var compare = !a2.compareDocumentPosition - !b2.compareDocumentPosition;
                if (compare) {
                  return compare;
                }
                compare = (a2.ownerDocument || a2) == (b2.ownerDocument || b2) ? a2.compareDocumentPosition(b2) : (
                  // Otherwise we know they are disconnected
                  1
                );
                if (compare & 1 || !support.sortDetached && b2.compareDocumentPosition(a2) === compare) {
                  if (a2 === document3 || a2.ownerDocument == preferredDoc && find.contains(preferredDoc, a2)) {
                    return -1;
                  }
                  if (b2 === document3 || b2.ownerDocument == preferredDoc && find.contains(preferredDoc, b2)) {
                    return 1;
                  }
                  return sortInput ? indexOf.call(sortInput, a2) - indexOf.call(sortInput, b2) : 0;
                }
                return compare & 4 ? -1 : 1;
              };
              return document3;
            }
            find.matches = function(expr, elements) {
              return find(expr, null, null, elements);
            };
            find.matchesSelector = function(elem, expr) {
              setDocument(elem);
              if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                  var ret = matches.call(elem, expr);
                  if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                  // fragment in IE 9
                  elem.document && elem.document.nodeType !== 11) {
                    return ret;
                  }
                } catch (e) {
                  nonnativeSelectorCache(expr, true);
                }
              }
              return find(expr, document3, null, [elem]).length > 0;
            };
            find.contains = function(context, elem) {
              if ((context.ownerDocument || context) != document3) {
                setDocument(context);
              }
              return jQuery2.contains(context, elem);
            };
            find.attr = function(elem, name) {
              if ((elem.ownerDocument || elem) != document3) {
                setDocument(elem);
              }
              var fn2 = Expr.attrHandle[name.toLowerCase()], val = fn2 && hasOwn2.call(Expr.attrHandle, name.toLowerCase()) ? fn2(elem, name, !documentIsHTML) : void 0;
              if (val !== void 0) {
                return val;
              }
              return elem.getAttribute(name);
            };
            find.error = function(msg) {
              throw new Error("Syntax error, unrecognized expression: " + msg);
            };
            jQuery2.uniqueSort = function(results) {
              var elem, duplicates = [], j = 0, i2 = 0;
              hasDuplicate = !support.sortStable;
              sortInput = !support.sortStable && slice.call(results, 0);
              sort.call(results, sortOrder);
              if (hasDuplicate) {
                while (elem = results[i2++]) {
                  if (elem === results[i2]) {
                    j = duplicates.push(i2);
                  }
                }
                while (j--) {
                  splice2.call(results, duplicates[j], 1);
                }
              }
              sortInput = null;
              return results;
            };
            jQuery2.fn.uniqueSort = function() {
              return this.pushStack(jQuery2.uniqueSort(slice.apply(this)));
            };
            Expr = jQuery2.expr = {
              // Can be adjusted by the user
              cacheLength: 50,
              createPseudo: markFunction,
              match: matchExpr,
              attrHandle: {},
              find: {},
              relative: {
                ">": { dir: "parentNode", first: true },
                " ": { dir: "parentNode" },
                "+": { dir: "previousSibling", first: true },
                "~": { dir: "previousSibling" }
              },
              preFilter: {
                ATTR: function(match2) {
                  match2[1] = match2[1].replace(runescape, funescape);
                  match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
                  if (match2[2] === "~=") {
                    match2[3] = " " + match2[3] + " ";
                  }
                  return match2.slice(0, 4);
                },
                CHILD: function(match2) {
                  match2[1] = match2[1].toLowerCase();
                  if (match2[1].slice(0, 3) === "nth") {
                    if (!match2[3]) {
                      find.error(match2[0]);
                    }
                    match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
                    match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
                  } else if (match2[3]) {
                    find.error(match2[0]);
                  }
                  return match2;
                },
                PSEUDO: function(match2) {
                  var excess, unquoted = !match2[6] && match2[2];
                  if (matchExpr.CHILD.test(match2[0])) {
                    return null;
                  }
                  if (match2[3]) {
                    match2[2] = match2[4] || match2[5] || "";
                  } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                  (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
                  (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                    match2[0] = match2[0].slice(0, excess);
                    match2[2] = unquoted.slice(0, excess);
                  }
                  return match2.slice(0, 3);
                }
              },
              filter: {
                TAG: function(nodeNameSelector) {
                  var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                  return nodeNameSelector === "*" ? function() {
                    return true;
                  } : function(elem) {
                    return nodeName(elem, expectedNodeName);
                  };
                },
                CLASS: function(className) {
                  var pattern = classCache[className + " "];
                  return pattern || (pattern = new RegExp("(^|" + whitespace2 + ")" + className + "(" + whitespace2 + "|$)")) && classCache(className, function(elem) {
                    return pattern.test(
                      typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                    );
                  });
                },
                ATTR: function(name, operator, check) {
                  return function(elem) {
                    var result = find.attr(elem, name);
                    if (result == null) {
                      return operator === "!=";
                    }
                    if (!operator) {
                      return true;
                    }
                    result += "";
                    if (operator === "=") {
                      return result === check;
                    }
                    if (operator === "!=") {
                      return result !== check;
                    }
                    if (operator === "^=") {
                      return check && result.indexOf(check) === 0;
                    }
                    if (operator === "*=") {
                      return check && result.indexOf(check) > -1;
                    }
                    if (operator === "$=") {
                      return check && result.slice(-check.length) === check;
                    }
                    if (operator === "~=") {
                      return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                    }
                    if (operator === "|=") {
                      return result === check || result.slice(0, check.length + 1) === check + "-";
                    }
                    return false;
                  };
                },
                CHILD: function(type, what, _argument, first, last2) {
                  var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                  return first === 1 && last2 === 0 ? (
                    // Shortcut for :nth-*(n)
                    function(elem) {
                      return !!elem.parentNode;
                    }
                  ) : function(elem, _context, xml) {
                    var cache2, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                    if (parent) {
                      if (simple) {
                        while (dir2) {
                          node = elem;
                          while (node = node[dir2]) {
                            if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                              return false;
                            }
                          }
                          start = dir2 = type === "only" && !start && "nextSibling";
                        }
                        return true;
                      }
                      start = [forward ? parent.firstChild : parent.lastChild];
                      if (forward && useCache) {
                        outerCache = parent[expando] || (parent[expando] = {});
                        cache2 = outerCache[type] || [];
                        nodeIndex = cache2[0] === dirruns && cache2[1];
                        diff = nodeIndex && cache2[2];
                        node = nodeIndex && parent.childNodes[nodeIndex];
                        while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                        (diff = nodeIndex = 0) || start.pop()) {
                          if (node.nodeType === 1 && ++diff && node === elem) {
                            outerCache[type] = [dirruns, nodeIndex, diff];
                            break;
                          }
                        }
                      } else {
                        if (useCache) {
                          outerCache = elem[expando] || (elem[expando] = {});
                          cache2 = outerCache[type] || [];
                          nodeIndex = cache2[0] === dirruns && cache2[1];
                          diff = nodeIndex;
                        }
                        if (diff === false) {
                          while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                            if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                              if (useCache) {
                                outerCache = node[expando] || (node[expando] = {});
                                outerCache[type] = [dirruns, diff];
                              }
                              if (node === elem) {
                                break;
                              }
                            }
                          }
                        }
                      }
                      diff -= last2;
                      return diff === first || diff % first === 0 && diff / first >= 0;
                    }
                  };
                },
                PSEUDO: function(pseudo, argument) {
                  var args, fn2 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo);
                  if (fn2[expando]) {
                    return fn2(argument);
                  }
                  if (fn2.length > 1) {
                    args = [pseudo, pseudo, "", argument];
                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed2, matches2) {
                      var idx, matched = fn2(seed2, argument), i2 = matched.length;
                      while (i2--) {
                        idx = indexOf.call(seed2, matched[i2]);
                        seed2[idx] = !(matches2[idx] = matched[i2]);
                      }
                    }) : function(elem) {
                      return fn2(elem, 0, args);
                    };
                  }
                  return fn2;
                }
              },
              pseudos: {
                // Potentially complex pseudos
                not: markFunction(function(selector) {
                  var input = [], results = [], matcher = compile2(selector.replace(rtrimCSS, "$1"));
                  return matcher[expando] ? markFunction(function(seed2, matches2, _context, xml) {
                    var elem, unmatched = matcher(seed2, null, xml, []), i2 = seed2.length;
                    while (i2--) {
                      if (elem = unmatched[i2]) {
                        seed2[i2] = !(matches2[i2] = elem);
                      }
                    }
                  }) : function(elem, _context, xml) {
                    input[0] = elem;
                    matcher(input, null, xml, results);
                    input[0] = null;
                    return !results.pop();
                  };
                }),
                has: markFunction(function(selector) {
                  return function(elem) {
                    return find(selector, elem).length > 0;
                  };
                }),
                contains: markFunction(function(text) {
                  text = text.replace(runescape, funescape);
                  return function(elem) {
                    return (elem.textContent || jQuery2.text(elem)).indexOf(text) > -1;
                  };
                }),
                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // https://www.w3.org/TR/selectors/#lang-pseudo
                lang: markFunction(function(lang) {
                  if (!ridentifier.test(lang || "")) {
                    find.error("unsupported lang: " + lang);
                  }
                  lang = lang.replace(runescape, funescape).toLowerCase();
                  return function(elem) {
                    var elemLang;
                    do {
                      if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                        elemLang = elemLang.toLowerCase();
                        return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                      }
                    } while ((elem = elem.parentNode) && elem.nodeType === 1);
                    return false;
                  };
                }),
                // Miscellaneous
                target: function(elem) {
                  var hash = window2.location && window2.location.hash;
                  return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                  return elem === documentElement2;
                },
                focus: function(elem) {
                  return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                // Boolean properties
                enabled: createDisabledPseudo(false),
                disabled: createDisabledPseudo(true),
                checked: function(elem) {
                  return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
                },
                selected: function(elem) {
                  if (elem.parentNode) {
                    elem.parentNode.selectedIndex;
                  }
                  return elem.selected === true;
                },
                // Contents
                empty: function(elem) {
                  for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                    if (elem.nodeType < 6) {
                      return false;
                    }
                  }
                  return true;
                },
                parent: function(elem) {
                  return !Expr.pseudos.empty(elem);
                },
                // Element/input types
                header: function(elem) {
                  return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                  return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                  return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
                },
                text: function(elem) {
                  var attr;
                  return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
                  // New HTML5 attribute values (e.g., "search") appear
                  // with elem.type === "text"
                  ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                // Position-in-collection
                first: createPositionalPseudo(function() {
                  return [0];
                }),
                last: createPositionalPseudo(function(_matchIndexes, length) {
                  return [length - 1];
                }),
                eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
                  return [argument < 0 ? argument + length : argument];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                  var i2 = 0;
                  for (; i2 < length; i2 += 2) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                  var i2 = 1;
                  for (; i2 < length; i2 += 2) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                  var i2;
                  if (argument < 0) {
                    i2 = argument + length;
                  } else if (argument > length) {
                    i2 = length;
                  } else {
                    i2 = argument;
                  }
                  for (; --i2 >= 0; ) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                  var i2 = argument < 0 ? argument + length : argument;
                  for (; ++i2 < length; ) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                })
              }
            };
            Expr.pseudos.nth = Expr.pseudos.eq;
            for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
              Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in { submit: true, reset: true }) {
              Expr.pseudos[i] = createButtonPseudo(i);
            }
            function setFilters() {
            }
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();
            function tokenize(selector, parseOnly) {
              var matched, match2, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
              if (cached) {
                return parseOnly ? 0 : cached.slice(0);
              }
              soFar = selector;
              groups = [];
              preFilters = Expr.preFilter;
              while (soFar) {
                if (!matched || (match2 = rcomma.exec(soFar))) {
                  if (match2) {
                    soFar = soFar.slice(match2[0].length) || soFar;
                  }
                  groups.push(tokens = []);
                }
                matched = false;
                if (match2 = rleadingCombinator.exec(soFar)) {
                  matched = match2.shift();
                  tokens.push({
                    value: matched,
                    // Cast descendant combinators to space
                    type: match2[0].replace(rtrimCSS, " ")
                  });
                  soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                  if ((match2 = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match2 = preFilters[type](match2)))) {
                    matched = match2.shift();
                    tokens.push({
                      value: matched,
                      type,
                      matches: match2
                    });
                    soFar = soFar.slice(matched.length);
                  }
                }
                if (!matched) {
                  break;
                }
              }
              if (parseOnly) {
                return soFar.length;
              }
              return soFar ? find.error(selector) : (
                // Cache the tokens
                tokenCache(selector, groups).slice(0)
              );
            }
            function toSelector(tokens) {
              var i2 = 0, len = tokens.length, selector = "";
              for (; i2 < len; i2++) {
                selector += tokens[i2].value;
              }
              return selector;
            }
            function addCombinator(matcher, combinator, base) {
              var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
              return combinator.first ? (
                // Check against closest ancestor/preceding element
                function(elem, context, xml) {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      return matcher(elem, context, xml);
                    }
                  }
                  return false;
                }
              ) : (
                // Check against all ancestor/preceding elements
                function(elem, context, xml) {
                  var oldCache, outerCache, newCache = [dirruns, doneName];
                  if (xml) {
                    while (elem = elem[dir2]) {
                      if (elem.nodeType === 1 || checkNonElements) {
                        if (matcher(elem, context, xml)) {
                          return true;
                        }
                      }
                    }
                  } else {
                    while (elem = elem[dir2]) {
                      if (elem.nodeType === 1 || checkNonElements) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        if (skip && nodeName(elem, skip)) {
                          elem = elem[dir2] || elem;
                        } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                          return newCache[2] = oldCache[2];
                        } else {
                          outerCache[key] = newCache;
                          if (newCache[2] = matcher(elem, context, xml)) {
                            return true;
                          }
                        }
                      }
                    }
                  }
                  return false;
                }
              );
            }
            function elementMatcher(matchers2) {
              return matchers2.length > 1 ? function(elem, context, xml) {
                var i2 = matchers2.length;
                while (i2--) {
                  if (!matchers2[i2](elem, context, xml)) {
                    return false;
                  }
                }
                return true;
              } : matchers2[0];
            }
            function multipleContexts(selector, contexts, results) {
              var i2 = 0, len = contexts.length;
              for (; i2 < len; i2++) {
                find(selector, contexts[i2], results);
              }
              return results;
            }
            function condense(unmatched, map2, filter2, context, xml) {
              var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
              for (; i2 < len; i2++) {
                if (elem = unmatched[i2]) {
                  if (!filter2 || filter2(elem, context, xml)) {
                    newUnmatched.push(elem);
                    if (mapped) {
                      map2.push(i2);
                    }
                  }
                }
              }
              return newUnmatched;
            }
            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
              if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
              }
              if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
              }
              return markFunction(function(seed2, results, context, xml) {
                var temp, i2, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed2 || multipleContexts(
                  selector || "*",
                  context.nodeType ? [context] : context,
                  []
                ), matcherIn = preFilter && (seed2 || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
                if (matcher) {
                  matcherOut = postFinder || (seed2 ? preFilter : preexisting || postFilter) ? (
                    // ...intermediate processing is necessary
                    []
                  ) : (
                    // ...otherwise use results directly
                    results
                  );
                  matcher(matcherIn, matcherOut, context, xml);
                } else {
                  matcherOut = matcherIn;
                }
                if (postFilter) {
                  temp = condense(matcherOut, postMap);
                  postFilter(temp, [], context, xml);
                  i2 = temp.length;
                  while (i2--) {
                    if (elem = temp[i2]) {
                      matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                    }
                  }
                }
                if (seed2) {
                  if (postFinder || preFilter) {
                    if (postFinder) {
                      temp = [];
                      i2 = matcherOut.length;
                      while (i2--) {
                        if (elem = matcherOut[i2]) {
                          temp.push(matcherIn[i2] = elem);
                        }
                      }
                      postFinder(null, matcherOut = [], temp, xml);
                    }
                    i2 = matcherOut.length;
                    while (i2--) {
                      if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf.call(seed2, elem) : preMap[i2]) > -1) {
                        seed2[temp] = !(results[temp] = elem);
                      }
                    }
                  }
                } else {
                  matcherOut = condense(
                    matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                  );
                  if (postFinder) {
                    postFinder(null, results, matcherOut, xml);
                  } else {
                    push2.apply(results, matcherOut);
                  }
                }
              });
            }
            function matcherFromTokens(tokens) {
              var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
              }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf.call(checkContext, elem) > -1;
              }, implicitRelative, true), matchers2 = [function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                checkContext = null;
                return ret;
              }];
              for (; i2 < len; i2++) {
                if (matcher = Expr.relative[tokens[i2].type]) {
                  matchers2 = [addCombinator(elementMatcher(matchers2), matcher)];
                } else {
                  matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
                  if (matcher[expando]) {
                    j = ++i2;
                    for (; j < len; j++) {
                      if (Expr.relative[tokens[j].type]) {
                        break;
                      }
                    }
                    return setMatcher(
                      i2 > 1 && elementMatcher(matchers2),
                      i2 > 1 && toSelector(
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                      ).replace(rtrimCSS, "$1"),
                      matcher,
                      i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                      j < len && matcherFromTokens(tokens = tokens.slice(j)),
                      j < len && toSelector(tokens)
                    );
                  }
                  matchers2.push(matcher);
                }
              }
              return elementMatcher(matchers2);
            }
            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
              var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed2, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed2 && [], setMatched = [], contextBackup = outermostContext, elems = seed2 || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                if (outermost) {
                  outermostContext = context == document3 || context || outermost;
                }
                for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
                  if (byElement && elem) {
                    j = 0;
                    if (!context && elem.ownerDocument != document3) {
                      setDocument(elem);
                      xml = !documentIsHTML;
                    }
                    while (matcher = elementMatchers[j++]) {
                      if (matcher(elem, context || document3, xml)) {
                        push2.call(results, elem);
                        break;
                      }
                    }
                    if (outermost) {
                      dirruns = dirrunsUnique;
                    }
                  }
                  if (bySet) {
                    if (elem = !matcher && elem) {
                      matchedCount--;
                    }
                    if (seed2) {
                      unmatched.push(elem);
                    }
                  }
                }
                matchedCount += i2;
                if (bySet && i2 !== matchedCount) {
                  j = 0;
                  while (matcher = setMatchers[j++]) {
                    matcher(unmatched, setMatched, context, xml);
                  }
                  if (seed2) {
                    if (matchedCount > 0) {
                      while (i2--) {
                        if (!(unmatched[i2] || setMatched[i2])) {
                          setMatched[i2] = pop.call(results);
                        }
                      }
                    }
                    setMatched = condense(setMatched);
                  }
                  push2.apply(results, setMatched);
                  if (outermost && !seed2 && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                    jQuery2.uniqueSort(results);
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                  outermostContext = contextBackup;
                }
                return unmatched;
              };
              return bySet ? markFunction(superMatcher) : superMatcher;
            }
            function compile2(selector, match2) {
              var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
              if (!cached) {
                if (!match2) {
                  match2 = tokenize(selector);
                }
                i2 = match2.length;
                while (i2--) {
                  cached = matcherFromTokens(match2[i2]);
                  if (cached[expando]) {
                    setMatchers.push(cached);
                  } else {
                    elementMatchers.push(cached);
                  }
                }
                cached = compilerCache(
                  selector,
                  matcherFromGroupMatchers(elementMatchers, setMatchers)
                );
                cached.selector = selector;
              }
              return cached;
            }
            function select(selector, context, results, seed2) {
              var i2, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match2 = !seed2 && tokenize(selector = compiled.selector || selector);
              results = results || [];
              if (match2.length === 1) {
                tokens = match2[0] = match2[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                  context = (Expr.find.ID(
                    token.matches[0].replace(runescape, funescape),
                    context
                  ) || [])[0];
                  if (!context) {
                    return results;
                  } else if (compiled) {
                    context = context.parentNode;
                  }
                  selector = selector.slice(tokens.shift().value.length);
                }
                i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
                while (i2--) {
                  token = tokens[i2];
                  if (Expr.relative[type = token.type]) {
                    break;
                  }
                  if (find2 = Expr.find[type]) {
                    if (seed2 = find2(
                      token.matches[0].replace(runescape, funescape),
                      rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                    )) {
                      tokens.splice(i2, 1);
                      selector = seed2.length && toSelector(tokens);
                      if (!selector) {
                        push2.apply(results, seed2);
                        return results;
                      }
                      break;
                    }
                  }
                }
              }
              (compiled || compile2(selector, match2))(
                seed2,
                context,
                !documentIsHTML,
                results,
                !context || rsibling.test(selector) && testContext(context.parentNode) || context
              );
              return results;
            }
            support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
            setDocument();
            support.sortDetached = assert(function(el) {
              return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
            });
            jQuery2.find = find;
            jQuery2.expr[":"] = jQuery2.expr.pseudos;
            jQuery2.unique = jQuery2.uniqueSort;
            find.compile = compile2;
            find.select = select;
            find.setDocument = setDocument;
            find.tokenize = tokenize;
            find.escape = jQuery2.escapeSelector;
            find.getText = jQuery2.text;
            find.isXML = jQuery2.isXMLDoc;
            find.selectors = jQuery2.expr;
            find.support = jQuery2.support;
            find.uniqueSort = jQuery2.uniqueSort;
          })();
          var dir = function(elem, dir2, until) {
            var matched = [], truncate = until !== void 0;
            while ((elem = elem[dir2]) && elem.nodeType !== 9) {
              if (elem.nodeType === 1) {
                if (truncate && jQuery2(elem).is(until)) {
                  break;
                }
                matched.push(elem);
              }
            }
            return matched;
          };
          var siblings = function(n, elem) {
            var matched = [];
            for (; n; n = n.nextSibling) {
              if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
              }
            }
            return matched;
          };
          var rneedsContext = jQuery2.expr.match.needsContext;
          var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
          function winnow(elements, qualifier, not) {
            if (isFunction2(qualifier)) {
              return jQuery2.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
              });
            }
            if (qualifier.nodeType) {
              return jQuery2.grep(elements, function(elem) {
                return elem === qualifier !== not;
              });
            }
            if (typeof qualifier !== "string") {
              return jQuery2.grep(elements, function(elem) {
                return indexOf.call(qualifier, elem) > -1 !== not;
              });
            }
            return jQuery2.filter(qualifier, elements, not);
          }
          jQuery2.filter = function(expr, elems, not) {
            var elem = elems[0];
            if (not) {
              expr = ":not(" + expr + ")";
            }
            if (elems.length === 1 && elem.nodeType === 1) {
              return jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
            }
            return jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
              return elem2.nodeType === 1;
            }));
          };
          jQuery2.fn.extend({
            find: function(selector) {
              var i, ret, len = this.length, self2 = this;
              if (typeof selector !== "string") {
                return this.pushStack(jQuery2(selector).filter(function() {
                  for (i = 0; i < len; i++) {
                    if (jQuery2.contains(self2[i], this)) {
                      return true;
                    }
                  }
                }));
              }
              ret = this.pushStack([]);
              for (i = 0; i < len; i++) {
                jQuery2.find(selector, self2[i], ret);
              }
              return len > 1 ? jQuery2.uniqueSort(ret) : ret;
            },
            filter: function(selector) {
              return this.pushStack(winnow(this, selector || [], false));
            },
            not: function(selector) {
              return this.pushStack(winnow(this, selector || [], true));
            },
            is: function(selector) {
              return !!winnow(
                this,
                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
                false
              ).length;
            }
          });
          var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery2.fn.init = function(selector, context, root2) {
            var match2, elem;
            if (!selector) {
              return this;
            }
            root2 = root2 || rootjQuery;
            if (typeof selector === "string") {
              if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                match2 = [null, selector, null];
              } else {
                match2 = rquickExpr.exec(selector);
              }
              if (match2 && (match2[1] || !context)) {
                if (match2[1]) {
                  context = context instanceof jQuery2 ? context[0] : context;
                  jQuery2.merge(this, jQuery2.parseHTML(
                    match2[1],
                    context && context.nodeType ? context.ownerDocument || context : document2,
                    true
                  ));
                  if (rsingleTag.test(match2[1]) && jQuery2.isPlainObject(context)) {
                    for (match2 in context) {
                      if (isFunction2(this[match2])) {
                        this[match2](context[match2]);
                      } else {
                        this.attr(match2, context[match2]);
                      }
                    }
                  }
                  return this;
                } else {
                  elem = document2.getElementById(match2[2]);
                  if (elem) {
                    this[0] = elem;
                    this.length = 1;
                  }
                  return this;
                }
              } else if (!context || context.jquery) {
                return (context || root2).find(selector);
              } else {
                return this.constructor(context).find(selector);
              }
            } else if (selector.nodeType) {
              this[0] = selector;
              this.length = 1;
              return this;
            } else if (isFunction2(selector)) {
              return root2.ready !== void 0 ? root2.ready(selector) : (
                // Execute immediately if ready is not present
                selector(jQuery2)
              );
            }
            return jQuery2.makeArray(selector, this);
          };
          init.prototype = jQuery2.fn;
          rootjQuery = jQuery2(document2);
          var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
          };
          jQuery2.fn.extend({
            has: function(target) {
              var targets = jQuery2(target, this), l2 = targets.length;
              return this.filter(function() {
                var i = 0;
                for (; i < l2; i++) {
                  if (jQuery2.contains(this, targets[i])) {
                    return true;
                  }
                }
              });
            },
            closest: function(selectors, context) {
              var cur, i = 0, l2 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
              if (!rneedsContext.test(selectors)) {
                for (; i < l2; i++) {
                  for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                      // Don't pass non-elements to jQuery#find
                      cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors)
                    ))) {
                      matched.push(cur);
                      break;
                    }
                  }
                }
              }
              return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
            },
            // Determine the position of an element within the set
            index: function(elem) {
              if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
              }
              if (typeof elem === "string") {
                return indexOf.call(jQuery2(elem), this[0]);
              }
              return indexOf.call(
                this,
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem
              );
            },
            add: function(selector, context) {
              return this.pushStack(
                jQuery2.uniqueSort(
                  jQuery2.merge(this.get(), jQuery2(selector, context))
                )
              );
            },
            addBack: function(selector) {
              return this.add(
                selector == null ? this.prevObject : this.prevObject.filter(selector)
              );
            }
          });
          function sibling(cur, dir2) {
            while ((cur = cur[dir2]) && cur.nodeType !== 1) {
            }
            return cur;
          }
          jQuery2.each({
            parent: function(elem) {
              var parent = elem.parentNode;
              return parent && parent.nodeType !== 11 ? parent : null;
            },
            parents: function(elem) {
              return dir(elem, "parentNode");
            },
            parentsUntil: function(elem, _i, until) {
              return dir(elem, "parentNode", until);
            },
            next: function(elem) {
              return sibling(elem, "nextSibling");
            },
            prev: function(elem) {
              return sibling(elem, "previousSibling");
            },
            nextAll: function(elem) {
              return dir(elem, "nextSibling");
            },
            prevAll: function(elem) {
              return dir(elem, "previousSibling");
            },
            nextUntil: function(elem, _i, until) {
              return dir(elem, "nextSibling", until);
            },
            prevUntil: function(elem, _i, until) {
              return dir(elem, "previousSibling", until);
            },
            siblings: function(elem) {
              return siblings((elem.parentNode || {}).firstChild, elem);
            },
            children: function(elem) {
              return siblings(elem.firstChild);
            },
            contents: function(elem) {
              if (elem.contentDocument != null && // Support: IE 11+
              // <object> elements with no `data` attribute has an object
              // `contentDocument` with a `null` prototype.
              getProto2(elem.contentDocument)) {
                return elem.contentDocument;
              }
              if (nodeName(elem, "template")) {
                elem = elem.content || elem;
              }
              return jQuery2.merge([], elem.childNodes);
            }
          }, function(name, fn2) {
            jQuery2.fn[name] = function(until, selector) {
              var matched = jQuery2.map(this, fn2, until);
              if (name.slice(-5) !== "Until") {
                selector = until;
              }
              if (selector && typeof selector === "string") {
                matched = jQuery2.filter(selector, matched);
              }
              if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                  jQuery2.uniqueSort(matched);
                }
                if (rparentsprev.test(name)) {
                  matched.reverse();
                }
              }
              return this.pushStack(matched);
            };
          });
          var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
          function createOptions(options) {
            var object = {};
            jQuery2.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
              object[flag] = true;
            });
            return object;
          }
          jQuery2.Callbacks = function(options) {
            options = typeof options === "string" ? createOptions(options) : jQuery2.extend({}, options);
            var firing, memory, fired, locked, list = [], queue2 = [], firingIndex = -1, fire = function() {
              locked = locked || options.once;
              fired = firing = true;
              for (; queue2.length; firingIndex = -1) {
                memory = queue2.shift();
                while (++firingIndex < list.length) {
                  if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                    firingIndex = list.length;
                    memory = false;
                  }
                }
              }
              if (!options.memory) {
                memory = false;
              }
              firing = false;
              if (locked) {
                if (memory) {
                  list = [];
                } else {
                  list = "";
                }
              }
            }, self2 = {
              // Add a callback or a collection of callbacks to the list
              add: function() {
                if (list) {
                  if (memory && !firing) {
                    firingIndex = list.length - 1;
                    queue2.push(memory);
                  }
                  (function add2(args) {
                    jQuery2.each(args, function(_2, arg) {
                      if (isFunction2(arg)) {
                        if (!options.unique || !self2.has(arg)) {
                          list.push(arg);
                        }
                      } else if (arg && arg.length && toType(arg) !== "string") {
                        add2(arg);
                      }
                    });
                  })(arguments);
                  if (memory && !firing) {
                    fire();
                  }
                }
                return this;
              },
              // Remove a callback from the list
              remove: function() {
                jQuery2.each(arguments, function(_2, arg) {
                  var index;
                  while ((index = jQuery2.inArray(arg, list, index)) > -1) {
                    list.splice(index, 1);
                    if (index <= firingIndex) {
                      firingIndex--;
                    }
                  }
                });
                return this;
              },
              // Check if a given callback is in the list.
              // If no argument is given, return whether or not list has callbacks attached.
              has: function(fn2) {
                return fn2 ? jQuery2.inArray(fn2, list) > -1 : list.length > 0;
              },
              // Remove all callbacks from the list
              empty: function() {
                if (list) {
                  list = [];
                }
                return this;
              },
              // Disable .fire and .add
              // Abort any current/pending executions
              // Clear all callbacks and values
              disable: function() {
                locked = queue2 = [];
                list = memory = "";
                return this;
              },
              disabled: function() {
                return !list;
              },
              // Disable .fire
              // Also disable .add unless we have memory (since it would have no effect)
              // Abort any pending executions
              lock: function() {
                locked = queue2 = [];
                if (!memory && !firing) {
                  list = memory = "";
                }
                return this;
              },
              locked: function() {
                return !!locked;
              },
              // Call all callbacks with the given context and arguments
              fireWith: function(context, args) {
                if (!locked) {
                  args = args || [];
                  args = [context, args.slice ? args.slice() : args];
                  queue2.push(args);
                  if (!firing) {
                    fire();
                  }
                }
                return this;
              },
              // Call all the callbacks with the given arguments
              fire: function() {
                self2.fireWith(this, arguments);
                return this;
              },
              // To know if the callbacks have already been called at least once
              fired: function() {
                return !!fired;
              }
            };
            return self2;
          };
          function Identity(v2) {
            return v2;
          }
          function Thrower(ex) {
            throw ex;
          }
          function adoptValue(value, resolve2, reject, noValue) {
            var method;
            try {
              if (value && isFunction2(method = value.promise)) {
                method.call(value).done(resolve2).fail(reject);
              } else if (value && isFunction2(method = value.then)) {
                method.call(value, resolve2, reject);
              } else {
                resolve2.apply(void 0, [value].slice(noValue));
              }
            } catch (value2) {
              reject.apply(void 0, [value2]);
            }
          }
          jQuery2.extend({
            Deferred: function(func) {
              var tuples = [
                // action, add listener, callbacks,
                // ... .then handlers, argument index, [final state]
                [
                  "notify",
                  "progress",
                  jQuery2.Callbacks("memory"),
                  jQuery2.Callbacks("memory"),
                  2
                ],
                [
                  "resolve",
                  "done",
                  jQuery2.Callbacks("once memory"),
                  jQuery2.Callbacks("once memory"),
                  0,
                  "resolved"
                ],
                [
                  "reject",
                  "fail",
                  jQuery2.Callbacks("once memory"),
                  jQuery2.Callbacks("once memory"),
                  1,
                  "rejected"
                ]
              ], state = "pending", promise = {
                state: function() {
                  return state;
                },
                always: function() {
                  deferred.done(arguments).fail(arguments);
                  return this;
                },
                "catch": function(fn2) {
                  return promise.then(null, fn2);
                },
                // Keep pipe for back-compat
                pipe: function() {
                  var fns = arguments;
                  return jQuery2.Deferred(function(newDefer) {
                    jQuery2.each(tuples, function(_i, tuple) {
                      var fn2 = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                      deferred[tuple[1]](function() {
                        var returned = fn2 && fn2.apply(this, arguments);
                        if (returned && isFunction2(returned.promise)) {
                          returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                        } else {
                          newDefer[tuple[0] + "With"](
                            this,
                            fn2 ? [returned] : arguments
                          );
                        }
                      });
                    });
                    fns = null;
                  }).promise();
                },
                then: function(onFulfilled, onRejected, onProgress) {
                  var maxDepth = 0;
                  function resolve2(depth, deferred2, handler, special) {
                    return function() {
                      var that = this, args = arguments, mightThrow = function() {
                        var returned, then;
                        if (depth < maxDepth) {
                          return;
                        }
                        returned = handler.apply(that, args);
                        if (returned === deferred2.promise()) {
                          throw new TypeError("Thenable self-resolution");
                        }
                        then = returned && // Support: Promises/A+ section 2.3.4
                        // https://promisesaplus.com/#point-64
                        // Only check objects and functions for thenability
                        (typeof returned === "object" || typeof returned === "function") && returned.then;
                        if (isFunction2(then)) {
                          if (special) {
                            then.call(
                              returned,
                              resolve2(maxDepth, deferred2, Identity, special),
                              resolve2(maxDepth, deferred2, Thrower, special)
                            );
                          } else {
                            maxDepth++;
                            then.call(
                              returned,
                              resolve2(maxDepth, deferred2, Identity, special),
                              resolve2(maxDepth, deferred2, Thrower, special),
                              resolve2(
                                maxDepth,
                                deferred2,
                                Identity,
                                deferred2.notifyWith
                              )
                            );
                          }
                        } else {
                          if (handler !== Identity) {
                            that = void 0;
                            args = [returned];
                          }
                          (special || deferred2.resolveWith)(that, args);
                        }
                      }, process2 = special ? mightThrow : function() {
                        try {
                          mightThrow();
                        } catch (e) {
                          if (jQuery2.Deferred.exceptionHook) {
                            jQuery2.Deferred.exceptionHook(
                              e,
                              process2.error
                            );
                          }
                          if (depth + 1 >= maxDepth) {
                            if (handler !== Thrower) {
                              that = void 0;
                              args = [e];
                            }
                            deferred2.rejectWith(that, args);
                          }
                        }
                      };
                      if (depth) {
                        process2();
                      } else {
                        if (jQuery2.Deferred.getErrorHook) {
                          process2.error = jQuery2.Deferred.getErrorHook();
                        } else if (jQuery2.Deferred.getStackHook) {
                          process2.error = jQuery2.Deferred.getStackHook();
                        }
                        window2.setTimeout(process2);
                      }
                    };
                  }
                  return jQuery2.Deferred(function(newDefer) {
                    tuples[0][3].add(
                      resolve2(
                        0,
                        newDefer,
                        isFunction2(onProgress) ? onProgress : Identity,
                        newDefer.notifyWith
                      )
                    );
                    tuples[1][3].add(
                      resolve2(
                        0,
                        newDefer,
                        isFunction2(onFulfilled) ? onFulfilled : Identity
                      )
                    );
                    tuples[2][3].add(
                      resolve2(
                        0,
                        newDefer,
                        isFunction2(onRejected) ? onRejected : Thrower
                      )
                    );
                  }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function(obj) {
                  return obj != null ? jQuery2.extend(obj, promise) : promise;
                }
              }, deferred = {};
              jQuery2.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                promise[tuple[1]] = list.add;
                if (stateString) {
                  list.add(
                    function() {
                      state = stateString;
                    },
                    // rejected_callbacks.disable
                    // fulfilled_callbacks.disable
                    tuples[3 - i][2].disable,
                    // rejected_handlers.disable
                    // fulfilled_handlers.disable
                    tuples[3 - i][3].disable,
                    // progress_callbacks.lock
                    tuples[0][2].lock,
                    // progress_handlers.lock
                    tuples[0][3].lock
                  );
                }
                list.add(tuple[3].fire);
                deferred[tuple[0]] = function() {
                  deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                  return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
              });
              promise.promise(deferred);
              if (func) {
                func.call(deferred, deferred);
              }
              return deferred;
            },
            // Deferred helper
            when: function(singleValue) {
              var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery2.Deferred(), updateFunc = function(i2) {
                return function(value) {
                  resolveContexts[i2] = this;
                  resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
                  if (!--remaining) {
                    primary.resolveWith(resolveContexts, resolveValues);
                  }
                };
              };
              if (remaining <= 1) {
                adoptValue(
                  singleValue,
                  primary.done(updateFunc(i)).resolve,
                  primary.reject,
                  !remaining
                );
                if (primary.state() === "pending" || isFunction2(resolveValues[i] && resolveValues[i].then)) {
                  return primary.then();
                }
              }
              while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), primary.reject);
              }
              return primary.promise();
            }
          });
          var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
          jQuery2.Deferred.exceptionHook = function(error, asyncError) {
            if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
              window2.console.warn(
                "jQuery.Deferred exception: " + error.message,
                error.stack,
                asyncError
              );
            }
          };
          jQuery2.readyException = function(error) {
            window2.setTimeout(function() {
              throw error;
            });
          };
          var readyList = jQuery2.Deferred();
          jQuery2.fn.ready = function(fn2) {
            readyList.then(fn2).catch(function(error) {
              jQuery2.readyException(error);
            });
            return this;
          };
          jQuery2.extend({
            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,
            // A counter to track how many items to wait for before
            // the ready event fires. See trac-6781
            readyWait: 1,
            // Handle when the DOM is ready
            ready: function(wait) {
              if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
                return;
              }
              jQuery2.isReady = true;
              if (wait !== true && --jQuery2.readyWait > 0) {
                return;
              }
              readyList.resolveWith(document2, [jQuery2]);
            }
          });
          jQuery2.ready.then = readyList.then;
          function completed() {
            document2.removeEventListener("DOMContentLoaded", completed);
            window2.removeEventListener("load", completed);
            jQuery2.ready();
          }
          if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
            window2.setTimeout(jQuery2.ready);
          } else {
            document2.addEventListener("DOMContentLoaded", completed);
            window2.addEventListener("load", completed);
          }
          var access = function(elems, fn2, key, value, chainable, emptyGet, raw) {
            var i = 0, len = elems.length, bulk = key == null;
            if (toType(key) === "object") {
              chainable = true;
              for (i in key) {
                access(elems, fn2, i, key[i], true, emptyGet, raw);
              }
            } else if (value !== void 0) {
              chainable = true;
              if (!isFunction2(value)) {
                raw = true;
              }
              if (bulk) {
                if (raw) {
                  fn2.call(elems, value);
                  fn2 = null;
                } else {
                  bulk = fn2;
                  fn2 = function(elem, _key, value2) {
                    return bulk.call(jQuery2(elem), value2);
                  };
                }
              }
              if (fn2) {
                for (; i < len; i++) {
                  fn2(
                    elems[i],
                    key,
                    raw ? value : value.call(elems[i], i, fn2(elems[i], key))
                  );
                }
              }
            }
            if (chainable) {
              return elems;
            }
            if (bulk) {
              return fn2.call(elems);
            }
            return len ? fn2(elems[0], key) : emptyGet;
          };
          var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
          function fcamelCase(_all, letter) {
            return letter.toUpperCase();
          }
          function camelCase2(string2) {
            return string2.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
          }
          var acceptData = function(owner) {
            return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
          };
          function Data() {
            this.expando = jQuery2.expando + Data.uid++;
          }
          Data.uid = 1;
          Data.prototype = {
            cache: function(owner) {
              var value = owner[this.expando];
              if (!value) {
                value = {};
                if (acceptData(owner)) {
                  if (owner.nodeType) {
                    owner[this.expando] = value;
                  } else {
                    Object.defineProperty(owner, this.expando, {
                      value,
                      configurable: true
                    });
                  }
                }
              }
              return value;
            },
            set: function(owner, data, value) {
              var prop, cache2 = this.cache(owner);
              if (typeof data === "string") {
                cache2[camelCase2(data)] = value;
              } else {
                for (prop in data) {
                  cache2[camelCase2(prop)] = data[prop];
                }
              }
              return cache2;
            },
            get: function(owner, key) {
              return key === void 0 ? this.cache(owner) : (
                // Always use camelCase key (gh-2257)
                owner[this.expando] && owner[this.expando][camelCase2(key)]
              );
            },
            access: function(owner, key, value) {
              if (key === void 0 || key && typeof key === "string" && value === void 0) {
                return this.get(owner, key);
              }
              this.set(owner, key, value);
              return value !== void 0 ? value : key;
            },
            remove: function(owner, key) {
              var i, cache2 = owner[this.expando];
              if (cache2 === void 0) {
                return;
              }
              if (key !== void 0) {
                if (Array.isArray(key)) {
                  key = key.map(camelCase2);
                } else {
                  key = camelCase2(key);
                  key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
                }
                i = key.length;
                while (i--) {
                  delete cache2[key[i]];
                }
              }
              if (key === void 0 || jQuery2.isEmptyObject(cache2)) {
                if (owner.nodeType) {
                  owner[this.expando] = void 0;
                } else {
                  delete owner[this.expando];
                }
              }
            },
            hasData: function(owner) {
              var cache2 = owner[this.expando];
              return cache2 !== void 0 && !jQuery2.isEmptyObject(cache2);
            }
          };
          var dataPriv = new Data();
          var dataUser = new Data();
          var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
          function getData(data) {
            if (data === "true") {
              return true;
            }
            if (data === "false") {
              return false;
            }
            if (data === "null") {
              return null;
            }
            if (data === +data + "") {
              return +data;
            }
            if (rbrace.test(data)) {
              return JSON.parse(data);
            }
            return data;
          }
          function dataAttr(elem, key, data) {
            var name;
            if (data === void 0 && elem.nodeType === 1) {
              name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
              data = elem.getAttribute(name);
              if (typeof data === "string") {
                try {
                  data = getData(data);
                } catch (e) {
                }
                dataUser.set(elem, key, data);
              } else {
                data = void 0;
              }
            }
            return data;
          }
          jQuery2.extend({
            hasData: function(elem) {
              return dataUser.hasData(elem) || dataPriv.hasData(elem);
            },
            data: function(elem, name, data) {
              return dataUser.access(elem, name, data);
            },
            removeData: function(elem, name) {
              dataUser.remove(elem, name);
            },
            // TODO: Now that all calls to _data and _removeData have been replaced
            // with direct calls to dataPriv methods, these can be deprecated.
            _data: function(elem, name, data) {
              return dataPriv.access(elem, name, data);
            },
            _removeData: function(elem, name) {
              dataPriv.remove(elem, name);
            }
          });
          jQuery2.fn.extend({
            data: function(key, value) {
              var i, name, data, elem = this[0], attrs = elem && elem.attributes;
              if (key === void 0) {
                if (this.length) {
                  data = dataUser.get(elem);
                  if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                    i = attrs.length;
                    while (i--) {
                      if (attrs[i]) {
                        name = attrs[i].name;
                        if (name.indexOf("data-") === 0) {
                          name = camelCase2(name.slice(5));
                          dataAttr(elem, name, data[name]);
                        }
                      }
                    }
                    dataPriv.set(elem, "hasDataAttrs", true);
                  }
                }
                return data;
              }
              if (typeof key === "object") {
                return this.each(function() {
                  dataUser.set(this, key);
                });
              }
              return access(this, function(value2) {
                var data2;
                if (elem && value2 === void 0) {
                  data2 = dataUser.get(elem, key);
                  if (data2 !== void 0) {
                    return data2;
                  }
                  data2 = dataAttr(elem, key);
                  if (data2 !== void 0) {
                    return data2;
                  }
                  return;
                }
                this.each(function() {
                  dataUser.set(this, key, value2);
                });
              }, null, value, arguments.length > 1, null, true);
            },
            removeData: function(key) {
              return this.each(function() {
                dataUser.remove(this, key);
              });
            }
          });
          jQuery2.extend({
            queue: function(elem, type, data) {
              var queue2;
              if (elem) {
                type = (type || "fx") + "queue";
                queue2 = dataPriv.get(elem, type);
                if (data) {
                  if (!queue2 || Array.isArray(data)) {
                    queue2 = dataPriv.access(elem, type, jQuery2.makeArray(data));
                  } else {
                    queue2.push(data);
                  }
                }
                return queue2 || [];
              }
            },
            dequeue: function(elem, type) {
              type = type || "fx";
              var queue2 = jQuery2.queue(elem, type), startLength = queue2.length, fn2 = queue2.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
                jQuery2.dequeue(elem, type);
              };
              if (fn2 === "inprogress") {
                fn2 = queue2.shift();
                startLength--;
              }
              if (fn2) {
                if (type === "fx") {
                  queue2.unshift("inprogress");
                }
                delete hooks.stop;
                fn2.call(elem, next, hooks);
              }
              if (!startLength && hooks) {
                hooks.empty.fire();
              }
            },
            // Not public - generate a queueHooks object, or return the current one
            _queueHooks: function(elem, type) {
              var key = type + "queueHooks";
              return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery2.Callbacks("once memory").add(function() {
                  dataPriv.remove(elem, [type + "queue", key]);
                })
              });
            }
          });
          jQuery2.fn.extend({
            queue: function(type, data) {
              var setter = 2;
              if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
              }
              if (arguments.length < setter) {
                return jQuery2.queue(this[0], type);
              }
              return data === void 0 ? this : this.each(function() {
                var queue2 = jQuery2.queue(this, type, data);
                jQuery2._queueHooks(this, type);
                if (type === "fx" && queue2[0] !== "inprogress") {
                  jQuery2.dequeue(this, type);
                }
              });
            },
            dequeue: function(type) {
              return this.each(function() {
                jQuery2.dequeue(this, type);
              });
            },
            clearQueue: function(type) {
              return this.queue(type || "fx", []);
            },
            // Get a promise resolved when queues of a certain type
            // are emptied (fx is the type by default)
            promise: function(type, obj) {
              var tmp, count = 1, defer = jQuery2.Deferred(), elements = this, i = this.length, resolve2 = function() {
                if (!--count) {
                  defer.resolveWith(elements, [elements]);
                }
              };
              if (typeof type !== "string") {
                obj = type;
                type = void 0;
              }
              type = type || "fx";
              while (i--) {
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                  count++;
                  tmp.empty.add(resolve2);
                }
              }
              resolve2();
              return defer.promise(obj);
            }
          });
          var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
          var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
          var cssExpand = ["Top", "Right", "Bottom", "Left"];
          var documentElement = document2.documentElement;
          var isAttached = function(elem) {
            return jQuery2.contains(elem.ownerDocument, elem);
          }, composed = { composed: true };
          if (documentElement.getRootNode) {
            isAttached = function(elem) {
              return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
            };
          }
          var isHiddenWithinTree = function(elem, el) {
            elem = el || elem;
            return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
            // Support: Firefox <=43 - 45
            // Disconnected elements can have computed display: none, so first confirm that elem is
            // in the document.
            isAttached(elem) && jQuery2.css(elem, "display") === "none";
          };
          function adjustCSS(elem, prop, valueParts, tween) {
            var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
              return tween.cur();
            } : function() {
              return jQuery2.css(elem, prop, "");
            }, initial2 = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial2) && rcssNum.exec(jQuery2.css(elem, prop));
            if (initialInUnit && initialInUnit[3] !== unit) {
              initial2 = initial2 / 2;
              unit = unit || initialInUnit[3];
              initialInUnit = +initial2 || 1;
              while (maxIterations--) {
                jQuery2.style(elem, prop, initialInUnit + unit);
                if ((1 - scale) * (1 - (scale = currentValue() / initial2 || 0.5)) <= 0) {
                  maxIterations = 0;
                }
                initialInUnit = initialInUnit / scale;
              }
              initialInUnit = initialInUnit * 2;
              jQuery2.style(elem, prop, initialInUnit + unit);
              valueParts = valueParts || [];
            }
            if (valueParts) {
              initialInUnit = +initialInUnit || +initial2 || 0;
              adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
              if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
              }
            }
            return adjusted;
          }
          var defaultDisplayMap = {};
          function getDefaultDisplay(elem) {
            var temp, doc2 = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
            if (display) {
              return display;
            }
            temp = doc2.body.appendChild(doc2.createElement(nodeName2));
            display = jQuery2.css(temp, "display");
            temp.parentNode.removeChild(temp);
            if (display === "none") {
              display = "block";
            }
            defaultDisplayMap[nodeName2] = display;
            return display;
          }
          function showHide(elements, show) {
            var display, elem, values2 = [], index = 0, length = elements.length;
            for (; index < length; index++) {
              elem = elements[index];
              if (!elem.style) {
                continue;
              }
              display = elem.style.display;
              if (show) {
                if (display === "none") {
                  values2[index] = dataPriv.get(elem, "display") || null;
                  if (!values2[index]) {
                    elem.style.display = "";
                  }
                }
                if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                  values2[index] = getDefaultDisplay(elem);
                }
              } else {
                if (display !== "none") {
                  values2[index] = "none";
                  dataPriv.set(elem, "display", display);
                }
              }
            }
            for (index = 0; index < length; index++) {
              if (values2[index] != null) {
                elements[index].style.display = values2[index];
              }
            }
            return elements;
          }
          jQuery2.fn.extend({
            show: function() {
              return showHide(this, true);
            },
            hide: function() {
              return showHide(this);
            },
            toggle: function(state) {
              if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
              }
              return this.each(function() {
                if (isHiddenWithinTree(this)) {
                  jQuery2(this).show();
                } else {
                  jQuery2(this).hide();
                }
              });
            }
          });
          var rcheckableType = /^(?:checkbox|radio)$/i;
          var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
          var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
          (function() {
            var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
            input.setAttribute("type", "radio");
            input.setAttribute("checked", "checked");
            input.setAttribute("name", "t");
            div.appendChild(input);
            support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
            div.innerHTML = "<textarea>x</textarea>";
            support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
            div.innerHTML = "<option></option>";
            support.option = !!div.lastChild;
          })();
          var wrapMap = {
            // XHTML parsers do not magically insert elements in the
            // same way that tag soup parsers do. So we cannot shorten
            // this by omitting <tbody> or other required elements.
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
          };
          wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
          wrapMap.th = wrapMap.td;
          if (!support.option) {
            wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
          }
          function getAll(context, tag) {
            var ret;
            if (typeof context.getElementsByTagName !== "undefined") {
              ret = context.getElementsByTagName(tag || "*");
            } else if (typeof context.querySelectorAll !== "undefined") {
              ret = context.querySelectorAll(tag || "*");
            } else {
              ret = [];
            }
            if (tag === void 0 || tag && nodeName(context, tag)) {
              return jQuery2.merge([context], ret);
            }
            return ret;
          }
          function setGlobalEval(elems, refElements) {
            var i = 0, l2 = elems.length;
            for (; i < l2; i++) {
              dataPriv.set(
                elems[i],
                "globalEval",
                !refElements || dataPriv.get(refElements[i], "globalEval")
              );
            }
          }
          var rhtml = /<|&#?\w+;/;
          function buildFragment(elems, context, scripts, selection, ignored) {
            var elem, tmp, tag, wrap2, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l2 = elems.length;
            for (; i < l2; i++) {
              elem = elems[i];
              if (elem || elem === 0) {
                if (toType(elem) === "object") {
                  jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
                } else if (!rhtml.test(elem)) {
                  nodes.push(context.createTextNode(elem));
                } else {
                  tmp = tmp || fragment.appendChild(context.createElement("div"));
                  tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                  wrap2 = wrapMap[tag] || wrapMap._default;
                  tmp.innerHTML = wrap2[1] + jQuery2.htmlPrefilter(elem) + wrap2[2];
                  j = wrap2[0];
                  while (j--) {
                    tmp = tmp.lastChild;
                  }
                  jQuery2.merge(nodes, tmp.childNodes);
                  tmp = fragment.firstChild;
                  tmp.textContent = "";
                }
              }
            }
            fragment.textContent = "";
            i = 0;
            while (elem = nodes[i++]) {
              if (selection && jQuery2.inArray(elem, selection) > -1) {
                if (ignored) {
                  ignored.push(elem);
                }
                continue;
              }
              attached = isAttached(elem);
              tmp = getAll(fragment.appendChild(elem), "script");
              if (attached) {
                setGlobalEval(tmp);
              }
              if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                  if (rscriptType.test(elem.type || "")) {
                    scripts.push(elem);
                  }
                }
              }
            }
            return fragment;
          }
          var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
          function returnTrue() {
            return true;
          }
          function returnFalse() {
            return false;
          }
          function on2(elem, types2, selector, data, fn2, one) {
            var origFn, type;
            if (typeof types2 === "object") {
              if (typeof selector !== "string") {
                data = data || selector;
                selector = void 0;
              }
              for (type in types2) {
                on2(elem, type, selector, data, types2[type], one);
              }
              return elem;
            }
            if (data == null && fn2 == null) {
              fn2 = selector;
              data = selector = void 0;
            } else if (fn2 == null) {
              if (typeof selector === "string") {
                fn2 = data;
                data = void 0;
              } else {
                fn2 = data;
                data = selector;
                selector = void 0;
              }
            }
            if (fn2 === false) {
              fn2 = returnFalse;
            } else if (!fn2) {
              return elem;
            }
            if (one === 1) {
              origFn = fn2;
              fn2 = function(event) {
                jQuery2().off(event);
                return origFn.apply(this, arguments);
              };
              fn2.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
            }
            return elem.each(function() {
              jQuery2.event.add(this, types2, fn2, data, selector);
            });
          }
          jQuery2.event = {
            global: {},
            add: function(elem, types2, handler, data, selector) {
              var handleObjIn, eventHandle, tmp, events, t2, handleObj, special, handlers2, type, namespaces, origType, elemData = dataPriv.get(elem);
              if (!acceptData(elem)) {
                return;
              }
              if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
              }
              if (selector) {
                jQuery2.find.matchesSelector(documentElement, selector);
              }
              if (!handler.guid) {
                handler.guid = jQuery2.guid++;
              }
              if (!(events = elemData.events)) {
                events = elemData.events = /* @__PURE__ */ Object.create(null);
              }
              if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                  return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
                };
              }
              types2 = (types2 || "").match(rnothtmlwhite) || [""];
              t2 = types2.length;
              while (t2--) {
                tmp = rtypenamespace.exec(types2[t2]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                  continue;
                }
                special = jQuery2.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery2.event.special[type] || {};
                handleObj = jQuery2.extend({
                  type,
                  origType,
                  data,
                  handler,
                  guid: handler.guid,
                  selector,
                  needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
                  namespace: namespaces.join(".")
                }, handleObjIn);
                if (!(handlers2 = events[type])) {
                  handlers2 = events[type] = [];
                  handlers2.delegateCount = 0;
                  if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                    if (elem.addEventListener) {
                      elem.addEventListener(type, eventHandle);
                    }
                  }
                }
                if (special.add) {
                  special.add.call(elem, handleObj);
                  if (!handleObj.handler.guid) {
                    handleObj.handler.guid = handler.guid;
                  }
                }
                if (selector) {
                  handlers2.splice(handlers2.delegateCount++, 0, handleObj);
                } else {
                  handlers2.push(handleObj);
                }
                jQuery2.event.global[type] = true;
              }
            },
            // Detach an event or set of events from an element
            remove: function(elem, types2, handler, selector, mappedTypes) {
              var j, origCount, tmp, events, t2, handleObj, special, handlers2, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
              if (!elemData || !(events = elemData.events)) {
                return;
              }
              types2 = (types2 || "").match(rnothtmlwhite) || [""];
              t2 = types2.length;
              while (t2--) {
                tmp = rtypenamespace.exec(types2[t2]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                  for (type in events) {
                    jQuery2.event.remove(elem, type + types2[t2], handler, selector, true);
                  }
                  continue;
                }
                special = jQuery2.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers2 = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers2.length;
                while (j--) {
                  handleObj = handlers2[j];
                  if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                    handlers2.splice(j, 1);
                    if (handleObj.selector) {
                      handlers2.delegateCount--;
                    }
                    if (special.remove) {
                      special.remove.call(elem, handleObj);
                    }
                  }
                }
                if (origCount && !handlers2.length) {
                  if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                    jQuery2.removeEvent(elem, type, elemData.handle);
                  }
                  delete events[type];
                }
              }
              if (jQuery2.isEmptyObject(events)) {
                dataPriv.remove(elem, "handle events");
              }
            },
            dispatch: function(nativeEvent) {
              var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery2.event.fix(nativeEvent), handlers2 = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery2.event.special[event.type] || {};
              args[0] = event;
              for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i];
              }
              event.delegateTarget = this;
              if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
              }
              handlerQueue = jQuery2.event.handlers.call(this, event, handlers2);
              i = 0;
              while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                  if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                    event.handleObj = handleObj;
                    event.data = handleObj.data;
                    ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                    if (ret !== void 0) {
                      if ((event.result = ret) === false) {
                        event.preventDefault();
                        event.stopPropagation();
                      }
                    }
                  }
                }
              }
              if (special.postDispatch) {
                special.postDispatch.call(this, event);
              }
              return event.result;
            },
            handlers: function(event, handlers2) {
              var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers2.delegateCount, cur = event.target;
              if (delegateCount && // Support: IE <=9
              // Black-hole SVG <use> instance trees (trac-13180)
              cur.nodeType && // Support: Firefox <=42
              // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
              // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
              // Support: IE 11 only
              // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
              !(event.type === "click" && event.button >= 1)) {
                for (; cur !== this; cur = cur.parentNode || this) {
                  if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                    matchedHandlers = [];
                    matchedSelectors = {};
                    for (i = 0; i < delegateCount; i++) {
                      handleObj = handlers2[i];
                      sel = handleObj.selector + " ";
                      if (matchedSelectors[sel] === void 0) {
                        matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                      }
                      if (matchedSelectors[sel]) {
                        matchedHandlers.push(handleObj);
                      }
                    }
                    if (matchedHandlers.length) {
                      handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                    }
                  }
                }
              }
              cur = this;
              if (delegateCount < handlers2.length) {
                handlerQueue.push({ elem: cur, handlers: handlers2.slice(delegateCount) });
              }
              return handlerQueue;
            },
            addProp: function(name, hook) {
              Object.defineProperty(jQuery2.Event.prototype, name, {
                enumerable: true,
                configurable: true,
                get: isFunction2(hook) ? function() {
                  if (this.originalEvent) {
                    return hook(this.originalEvent);
                  }
                } : function() {
                  if (this.originalEvent) {
                    return this.originalEvent[name];
                  }
                },
                set: function(value) {
                  Object.defineProperty(this, name, {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value
                  });
                }
              });
            },
            fix: function(originalEvent) {
              return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
            },
            special: {
              load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
              },
              click: {
                // Utilize native event to ensure correct state for checkable inputs
                setup: function(data) {
                  var el = this || data;
                  if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                    leverageNative(el, "click", true);
                  }
                  return false;
                },
                trigger: function(data) {
                  var el = this || data;
                  if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                    leverageNative(el, "click");
                  }
                  return true;
                },
                // For cross-browser consistency, suppress native .click() on links
                // Also prevent it if we're currently inside a leveraged native-event stack
                _default: function(event) {
                  var target = event.target;
                  return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
                }
              },
              beforeunload: {
                postDispatch: function(event) {
                  if (event.result !== void 0 && event.originalEvent) {
                    event.originalEvent.returnValue = event.result;
                  }
                }
              }
            }
          };
          function leverageNative(el, type, isSetup) {
            if (!isSetup) {
              if (dataPriv.get(el, type) === void 0) {
                jQuery2.event.add(el, type, returnTrue);
              }
              return;
            }
            dataPriv.set(el, type, false);
            jQuery2.event.add(el, type, {
              namespace: false,
              handler: function(event) {
                var result, saved = dataPriv.get(this, type);
                if (event.isTrigger & 1 && this[type]) {
                  if (!saved) {
                    saved = slice.call(arguments);
                    dataPriv.set(this, type, saved);
                    this[type]();
                    result = dataPriv.get(this, type);
                    dataPriv.set(this, type, false);
                    if (saved !== result) {
                      event.stopImmediatePropagation();
                      event.preventDefault();
                      return result;
                    }
                  } else if ((jQuery2.event.special[type] || {}).delegateType) {
                    event.stopPropagation();
                  }
                } else if (saved) {
                  dataPriv.set(this, type, jQuery2.event.trigger(
                    saved[0],
                    saved.slice(1),
                    this
                  ));
                  event.stopPropagation();
                  event.isImmediatePropagationStopped = returnTrue;
                }
              }
            });
          }
          jQuery2.removeEvent = function(elem, type, handle) {
            if (elem.removeEventListener) {
              elem.removeEventListener(type, handle);
            }
          };
          jQuery2.Event = function(src, props) {
            if (!(this instanceof jQuery2.Event)) {
              return new jQuery2.Event(src, props);
            }
            if (src && src.type) {
              this.originalEvent = src;
              this.type = src.type;
              this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
              src.returnValue === false ? returnTrue : returnFalse;
              this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
              this.currentTarget = src.currentTarget;
              this.relatedTarget = src.relatedTarget;
            } else {
              this.type = src;
            }
            if (props) {
              jQuery2.extend(this, props);
            }
            this.timeStamp = src && src.timeStamp || Date.now();
            this[jQuery2.expando] = true;
          };
          jQuery2.Event.prototype = {
            constructor: jQuery2.Event,
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            isSimulated: false,
            preventDefault: function() {
              var e = this.originalEvent;
              this.isDefaultPrevented = returnTrue;
              if (e && !this.isSimulated) {
                e.preventDefault();
              }
            },
            stopPropagation: function() {
              var e = this.originalEvent;
              this.isPropagationStopped = returnTrue;
              if (e && !this.isSimulated) {
                e.stopPropagation();
              }
            },
            stopImmediatePropagation: function() {
              var e = this.originalEvent;
              this.isImmediatePropagationStopped = returnTrue;
              if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
              }
              this.stopPropagation();
            }
          };
          jQuery2.each({
            altKey: true,
            bubbles: true,
            cancelable: true,
            changedTouches: true,
            ctrlKey: true,
            detail: true,
            eventPhase: true,
            metaKey: true,
            pageX: true,
            pageY: true,
            shiftKey: true,
            view: true,
            "char": true,
            code: true,
            charCode: true,
            key: true,
            keyCode: true,
            button: true,
            buttons: true,
            clientX: true,
            clientY: true,
            offsetX: true,
            offsetY: true,
            pointerId: true,
            pointerType: true,
            screenX: true,
            screenY: true,
            targetTouches: true,
            toElement: true,
            touches: true,
            which: true
          }, jQuery2.event.addProp);
          jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
            function focusMappedHandler(nativeEvent) {
              if (document2.documentMode) {
                var handle = dataPriv.get(this, "handle"), event = jQuery2.event.fix(nativeEvent);
                event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
                event.isSimulated = true;
                handle(nativeEvent);
                if (event.target === event.currentTarget) {
                  handle(event);
                }
              } else {
                jQuery2.event.simulate(
                  delegateType,
                  nativeEvent.target,
                  jQuery2.event.fix(nativeEvent)
                );
              }
            }
            jQuery2.event.special[type] = {
              // Utilize native event if possible so blur/focus sequence is correct
              setup: function() {
                var attaches;
                leverageNative(this, type, true);
                if (document2.documentMode) {
                  attaches = dataPriv.get(this, delegateType);
                  if (!attaches) {
                    this.addEventListener(delegateType, focusMappedHandler);
                  }
                  dataPriv.set(this, delegateType, (attaches || 0) + 1);
                } else {
                  return false;
                }
              },
              trigger: function() {
                leverageNative(this, type);
                return true;
              },
              teardown: function() {
                var attaches;
                if (document2.documentMode) {
                  attaches = dataPriv.get(this, delegateType) - 1;
                  if (!attaches) {
                    this.removeEventListener(delegateType, focusMappedHandler);
                    dataPriv.remove(this, delegateType);
                  } else {
                    dataPriv.set(this, delegateType, attaches);
                  }
                } else {
                  return false;
                }
              },
              // Suppress native focus or blur if we're currently inside
              // a leveraged native-event stack
              _default: function(event) {
                return dataPriv.get(event.target, type);
              },
              delegateType
            };
            jQuery2.event.special[delegateType] = {
              setup: function() {
                var doc2 = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc2, attaches = dataPriv.get(dataHolder, delegateType);
                if (!attaches) {
                  if (document2.documentMode) {
                    this.addEventListener(delegateType, focusMappedHandler);
                  } else {
                    doc2.addEventListener(type, focusMappedHandler, true);
                  }
                }
                dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
              },
              teardown: function() {
                var doc2 = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc2, attaches = dataPriv.get(dataHolder, delegateType) - 1;
                if (!attaches) {
                  if (document2.documentMode) {
                    this.removeEventListener(delegateType, focusMappedHandler);
                  } else {
                    doc2.removeEventListener(type, focusMappedHandler, true);
                  }
                  dataPriv.remove(dataHolder, delegateType);
                } else {
                  dataPriv.set(dataHolder, delegateType, attaches);
                }
              }
            };
          });
          jQuery2.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
          }, function(orig, fix) {
            jQuery2.event.special[orig] = {
              delegateType: fix,
              bindType: fix,
              handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery2.contains(target, related)) {
                  event.type = handleObj.origType;
                  ret = handleObj.handler.apply(this, arguments);
                  event.type = fix;
                }
                return ret;
              }
            };
          });
          jQuery2.fn.extend({
            on: function(types2, selector, data, fn2) {
              return on2(this, types2, selector, data, fn2);
            },
            one: function(types2, selector, data, fn2) {
              return on2(this, types2, selector, data, fn2, 1);
            },
            off: function(types2, selector, fn2) {
              var handleObj, type;
              if (types2 && types2.preventDefault && types2.handleObj) {
                handleObj = types2.handleObj;
                jQuery2(types2.delegateTarget).off(
                  handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                  handleObj.selector,
                  handleObj.handler
                );
                return this;
              }
              if (typeof types2 === "object") {
                for (type in types2) {
                  this.off(type, selector, types2[type]);
                }
                return this;
              }
              if (selector === false || typeof selector === "function") {
                fn2 = selector;
                selector = void 0;
              }
              if (fn2 === false) {
                fn2 = returnFalse;
              }
              return this.each(function() {
                jQuery2.event.remove(this, types2, fn2, selector);
              });
            }
          });
          var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
          function manipulationTarget(elem, content) {
            if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
              return jQuery2(elem).children("tbody")[0] || elem;
            }
            return elem;
          }
          function disableScript(elem) {
            elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
            return elem;
          }
          function restoreScript(elem) {
            if ((elem.type || "").slice(0, 5) === "true/") {
              elem.type = elem.type.slice(5);
            } else {
              elem.removeAttribute("type");
            }
            return elem;
          }
          function cloneCopyEvent(src, dest) {
            var i, l2, type, pdataOld, udataOld, udataCur, events;
            if (dest.nodeType !== 1) {
              return;
            }
            if (dataPriv.hasData(src)) {
              pdataOld = dataPriv.get(src);
              events = pdataOld.events;
              if (events) {
                dataPriv.remove(dest, "handle events");
                for (type in events) {
                  for (i = 0, l2 = events[type].length; i < l2; i++) {
                    jQuery2.event.add(dest, type, events[type][i]);
                  }
                }
              }
            }
            if (dataUser.hasData(src)) {
              udataOld = dataUser.access(src);
              udataCur = jQuery2.extend({}, udataOld);
              dataUser.set(dest, udataCur);
            }
          }
          function fixInput(src, dest) {
            var nodeName2 = dest.nodeName.toLowerCase();
            if (nodeName2 === "input" && rcheckableType.test(src.type)) {
              dest.checked = src.checked;
            } else if (nodeName2 === "input" || nodeName2 === "textarea") {
              dest.defaultValue = src.defaultValue;
            }
          }
          function domManip(collection, args, callback, ignored) {
            args = flat(args);
            var fragment, first, scripts, hasScripts, node, doc2, i = 0, l2 = collection.length, iNoClone = l2 - 1, value = args[0], valueIsFunction = isFunction2(value);
            if (valueIsFunction || l2 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
              return collection.each(function(index) {
                var self2 = collection.eq(index);
                if (valueIsFunction) {
                  args[0] = value.call(this, index, self2.html());
                }
                domManip(self2, args, callback, ignored);
              });
            }
            if (l2) {
              fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
              first = fragment.firstChild;
              if (fragment.childNodes.length === 1) {
                fragment = first;
              }
              if (first || ignored) {
                scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;
                for (; i < l2; i++) {
                  node = fragment;
                  if (i !== iNoClone) {
                    node = jQuery2.clone(node, true, true);
                    if (hasScripts) {
                      jQuery2.merge(scripts, getAll(node, "script"));
                    }
                  }
                  callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                  doc2 = scripts[scripts.length - 1].ownerDocument;
                  jQuery2.map(scripts, restoreScript);
                  for (i = 0; i < hasScripts; i++) {
                    node = scripts[i];
                    if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc2, node)) {
                      if (node.src && (node.type || "").toLowerCase() !== "module") {
                        if (jQuery2._evalUrl && !node.noModule) {
                          jQuery2._evalUrl(node.src, {
                            nonce: node.nonce || node.getAttribute("nonce")
                          }, doc2);
                        }
                      } else {
                        DOMEval(node.textContent.replace(rcleanScript, ""), node, doc2);
                      }
                    }
                  }
                }
              }
            }
            return collection;
          }
          function remove2(elem, selector, keepData) {
            var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i = 0;
            for (; (node = nodes[i]) != null; i++) {
              if (!keepData && node.nodeType === 1) {
                jQuery2.cleanData(getAll(node));
              }
              if (node.parentNode) {
                if (keepData && isAttached(node)) {
                  setGlobalEval(getAll(node, "script"));
                }
                node.parentNode.removeChild(node);
              }
            }
            return elem;
          }
          jQuery2.extend({
            htmlPrefilter: function(html2) {
              return html2;
            },
            clone: function(elem, dataAndEvents, deepDataAndEvents) {
              var i, l2, srcElements, destElements, clone2 = elem.cloneNode(true), inPage = isAttached(elem);
              if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
                destElements = getAll(clone2);
                srcElements = getAll(elem);
                for (i = 0, l2 = srcElements.length; i < l2; i++) {
                  fixInput(srcElements[i], destElements[i]);
                }
              }
              if (dataAndEvents) {
                if (deepDataAndEvents) {
                  srcElements = srcElements || getAll(elem);
                  destElements = destElements || getAll(clone2);
                  for (i = 0, l2 = srcElements.length; i < l2; i++) {
                    cloneCopyEvent(srcElements[i], destElements[i]);
                  }
                } else {
                  cloneCopyEvent(elem, clone2);
                }
              }
              destElements = getAll(clone2, "script");
              if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
              }
              return clone2;
            },
            cleanData: function(elems) {
              var data, elem, type, special = jQuery2.event.special, i = 0;
              for (; (elem = elems[i]) !== void 0; i++) {
                if (acceptData(elem)) {
                  if (data = elem[dataPriv.expando]) {
                    if (data.events) {
                      for (type in data.events) {
                        if (special[type]) {
                          jQuery2.event.remove(elem, type);
                        } else {
                          jQuery2.removeEvent(elem, type, data.handle);
                        }
                      }
                    }
                    elem[dataPriv.expando] = void 0;
                  }
                  if (elem[dataUser.expando]) {
                    elem[dataUser.expando] = void 0;
                  }
                }
              }
            }
          });
          jQuery2.fn.extend({
            detach: function(selector) {
              return remove2(this, selector, true);
            },
            remove: function(selector) {
              return remove2(this, selector);
            },
            text: function(value) {
              return access(this, function(value2) {
                return value2 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
                  if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    this.textContent = value2;
                  }
                });
              }, null, value, arguments.length);
            },
            append: function() {
              return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  var target = manipulationTarget(this, elem);
                  target.appendChild(elem);
                }
              });
            },
            prepend: function() {
              return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  var target = manipulationTarget(this, elem);
                  target.insertBefore(elem, target.firstChild);
                }
              });
            },
            before: function() {
              return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                  this.parentNode.insertBefore(elem, this);
                }
              });
            },
            after: function() {
              return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                  this.parentNode.insertBefore(elem, this.nextSibling);
                }
              });
            },
            empty: function() {
              var elem, i = 0;
              for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                  jQuery2.cleanData(getAll(elem, false));
                  elem.textContent = "";
                }
              }
              return this;
            },
            clone: function(dataAndEvents, deepDataAndEvents) {
              dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
              deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
              return this.map(function() {
                return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
              });
            },
            html: function(value) {
              return access(this, function(value2) {
                var elem = this[0] || {}, i = 0, l2 = this.length;
                if (value2 === void 0 && elem.nodeType === 1) {
                  return elem.innerHTML;
                }
                if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                  value2 = jQuery2.htmlPrefilter(value2);
                  try {
                    for (; i < l2; i++) {
                      elem = this[i] || {};
                      if (elem.nodeType === 1) {
                        jQuery2.cleanData(getAll(elem, false));
                        elem.innerHTML = value2;
                      }
                    }
                    elem = 0;
                  } catch (e) {
                  }
                }
                if (elem) {
                  this.empty().append(value2);
                }
              }, null, value, arguments.length);
            },
            replaceWith: function() {
              var ignored = [];
              return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                if (jQuery2.inArray(this, ignored) < 0) {
                  jQuery2.cleanData(getAll(this));
                  if (parent) {
                    parent.replaceChild(elem, this);
                  }
                }
              }, ignored);
            }
          });
          jQuery2.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
          }, function(name, original) {
            jQuery2.fn[name] = function(selector) {
              var elems, ret = [], insert = jQuery2(selector), last2 = insert.length - 1, i = 0;
              for (; i <= last2; i++) {
                elems = i === last2 ? this : this.clone(true);
                jQuery2(insert[i])[original](elems);
                push.apply(ret, elems.get());
              }
              return this.pushStack(ret);
            };
          });
          var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
          var rcustomProp = /^--/;
          var getStyles = function(elem) {
            var view = elem.ownerDocument.defaultView;
            if (!view || !view.opener) {
              view = window2;
            }
            return view.getComputedStyle(elem);
          };
          var swap = function(elem, options, callback) {
            var ret, name, old = {};
            for (name in options) {
              old[name] = elem.style[name];
              elem.style[name] = options[name];
            }
            ret = callback.call(elem);
            for (name in options) {
              elem.style[name] = old[name];
            }
            return ret;
          };
          var rboxStyle = new RegExp(cssExpand.join("|"), "i");
          (function() {
            function computeStyleTests() {
              if (!div) {
                return;
              }
              container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
              div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
              documentElement.appendChild(container).appendChild(div);
              var divStyle = window2.getComputedStyle(div);
              pixelPositionVal = divStyle.top !== "1%";
              reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
              div.style.right = "60%";
              pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
              boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
              div.style.position = "absolute";
              scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
              documentElement.removeChild(container);
              div = null;
            }
            function roundPixelMeasures(measure) {
              return Math.round(parseFloat(measure));
            }
            var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
            if (!div.style) {
              return;
            }
            div.style.backgroundClip = "content-box";
            div.cloneNode(true).style.backgroundClip = "";
            support.clearCloneStyle = div.style.backgroundClip === "content-box";
            jQuery2.extend(support, {
              boxSizingReliable: function() {
                computeStyleTests();
                return boxSizingReliableVal;
              },
              pixelBoxStyles: function() {
                computeStyleTests();
                return pixelBoxStylesVal;
              },
              pixelPosition: function() {
                computeStyleTests();
                return pixelPositionVal;
              },
              reliableMarginLeft: function() {
                computeStyleTests();
                return reliableMarginLeftVal;
              },
              scrollboxSize: function() {
                computeStyleTests();
                return scrollboxSizeVal;
              },
              // Support: IE 9 - 11+, Edge 15 - 18+
              // IE/Edge misreport `getComputedStyle` of table rows with width/height
              // set in CSS while `offset*` properties report correct values.
              // Behavior in IE 9 is more subtle than in newer versions & it passes
              // some versions of this test; make sure not to make it pass there!
              //
              // Support: Firefox 70+
              // Only Firefox includes border widths
              // in computed dimensions. (gh-4529)
              reliableTrDimensions: function() {
                var table, tr, trChild, trStyle;
                if (reliableTrDimensionsVal == null) {
                  table = document2.createElement("table");
                  tr = document2.createElement("tr");
                  trChild = document2.createElement("div");
                  table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                  tr.style.cssText = "box-sizing:content-box;border:1px solid";
                  tr.style.height = "1px";
                  trChild.style.height = "9px";
                  trChild.style.display = "block";
                  documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                  trStyle = window2.getComputedStyle(tr);
                  reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                  documentElement.removeChild(table);
                }
                return reliableTrDimensionsVal;
              }
            });
          })();
          function curCSS(elem, name, computed2) {
            var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
            computed2 = computed2 || getStyles(elem);
            if (computed2) {
              ret = computed2.getPropertyValue(name) || computed2[name];
              if (isCustomProp && ret) {
                ret = ret.replace(rtrimCSS, "$1") || void 0;
              }
              if (ret === "" && !isAttached(elem)) {
                ret = jQuery2.style(elem, name);
              }
              if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed2.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
              }
            }
            return ret !== void 0 ? (
              // Support: IE <=9 - 11 only
              // IE returns zIndex value as an integer.
              ret + ""
            ) : ret;
          }
          function addGetHookIf(conditionFn, hookFn) {
            return {
              get: function() {
                if (conditionFn()) {
                  delete this.get;
                  return;
                }
                return (this.get = hookFn).apply(this, arguments);
              }
            };
          }
          var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
          function vendorPropName(name) {
            var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
            while (i--) {
              name = cssPrefixes[i] + capName;
              if (name in emptyStyle) {
                return name;
              }
            }
          }
          function finalPropName(name) {
            var final = jQuery2.cssProps[name] || vendorProps[name];
            if (final) {
              return final;
            }
            if (name in emptyStyle) {
              return name;
            }
            return vendorProps[name] = vendorPropName(name) || name;
          }
          var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
          };
          function setPositiveNumber(_elem, value, subtract) {
            var matches = rcssNum.exec(value);
            return matches ? (
              // Guard against undefined "subtract", e.g., when used as in cssHooks
              Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
            ) : value;
          }
          function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
            var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
            if (box === (isBorderBox ? "border" : "content")) {
              return 0;
            }
            for (; i < 4; i += 2) {
              if (box === "margin") {
                marginDelta += jQuery2.css(elem, box + cssExpand[i], true, styles);
              }
              if (!isBorderBox) {
                delta += jQuery2.css(elem, "padding" + cssExpand[i], true, styles);
                if (box !== "padding") {
                  delta += jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                } else {
                  extra += jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
              } else {
                if (box === "content") {
                  delta -= jQuery2.css(elem, "padding" + cssExpand[i], true, styles);
                }
                if (box !== "margin") {
                  delta -= jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
              }
            }
            if (!isBorderBox && computedVal >= 0) {
              delta += Math.max(0, Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
                // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
                // Use an explicit zero to avoid NaN (gh-3964)
              )) || 0;
            }
            return delta + marginDelta;
          }
          function getWidthOrHeight(elem, dimension, extra) {
            var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
            if (rnumnonpx.test(val)) {
              if (!extra) {
                return val;
              }
              val = "auto";
            }
            if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Interestingly, in some cases IE 9 doesn't suffer from this issue.
            !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
            // This happens for inline elements with no explicit setting (gh-3571)
            val === "auto" || // Support: Android <=4.1 - 4.3 only
            // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
            !parseFloat(val) && jQuery2.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
            elem.getClientRects().length) {
              isBorderBox = jQuery2.css(elem, "boxSizing", false, styles) === "border-box";
              valueIsBorderBox = offsetProp in elem;
              if (valueIsBorderBox) {
                val = elem[offsetProp];
              }
            }
            val = parseFloat(val) || 0;
            return val + boxModelAdjustment(
              elem,
              dimension,
              extra || (isBorderBox ? "border" : "content"),
              valueIsBorderBox,
              styles,
              // Provide the current computed size to request scroll gutter calculation (gh-3589)
              val
            ) + "px";
          }
          jQuery2.extend({
            // Add in style property hooks for overriding the default
            // behavior of getting and setting a style property
            cssHooks: {
              opacity: {
                get: function(elem, computed2) {
                  if (computed2) {
                    var ret = curCSS(elem, "opacity");
                    return ret === "" ? "1" : ret;
                  }
                }
              }
            },
            // Don't automatically add "px" to these possibly-unitless properties
            cssNumber: {
              animationIterationCount: true,
              aspectRatio: true,
              borderImageSlice: true,
              columnCount: true,
              flexGrow: true,
              flexShrink: true,
              fontWeight: true,
              gridArea: true,
              gridColumn: true,
              gridColumnEnd: true,
              gridColumnStart: true,
              gridRow: true,
              gridRowEnd: true,
              gridRowStart: true,
              lineHeight: true,
              opacity: true,
              order: true,
              orphans: true,
              scale: true,
              widows: true,
              zIndex: true,
              zoom: true,
              // SVG-related
              fillOpacity: true,
              floodOpacity: true,
              stopOpacity: true,
              strokeMiterlimit: true,
              strokeOpacity: true
            },
            // Add in properties whose names you wish to fix before
            // setting or getting the value
            cssProps: {},
            // Get and set the style property on a DOM Node
            style: function(elem, name, value, extra) {
              if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
              }
              var ret, type, hooks, origName = camelCase2(name), isCustomProp = rcustomProp.test(name), style = elem.style;
              if (!isCustomProp) {
                name = finalPropName(origName);
              }
              hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
              if (value !== void 0) {
                type = typeof value;
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                  value = adjustCSS(elem, name, ret);
                  type = "number";
                }
                if (value == null || value !== value) {
                  return;
                }
                if (type === "number" && !isCustomProp) {
                  value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
                }
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                  style[name] = "inherit";
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                  if (isCustomProp) {
                    style.setProperty(name, value);
                  } else {
                    style[name] = value;
                  }
                }
              } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                  return ret;
                }
                return style[name];
              }
            },
            css: function(elem, name, extra, styles) {
              var val, num, hooks, origName = camelCase2(name), isCustomProp = rcustomProp.test(name);
              if (!isCustomProp) {
                name = finalPropName(origName);
              }
              hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
              if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
              }
              if (val === void 0) {
                val = curCSS(elem, name, styles);
              }
              if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
              }
              if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
              }
              return val;
            }
          });
          jQuery2.each(["height", "width"], function(_i, dimension) {
            jQuery2.cssHooks[dimension] = {
              get: function(elem, computed2, extra) {
                if (computed2) {
                  return rdisplayswap.test(jQuery2.css(elem, "display")) && // Support: Safari 8+
                  // Table columns in Safari have non-zero offsetWidth & zero
                  // getBoundingClientRect().width unless display is changed.
                  // Support: IE <=11 only
                  // Running getBoundingClientRect on a disconnected node
                  // in IE throws an error.
                  (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, dimension, extra);
                  }) : getWidthOrHeight(elem, dimension, extra);
                }
              },
              set: function(elem, value, extra) {
                var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                  elem,
                  dimension,
                  extra,
                  isBorderBox,
                  styles
                ) : 0;
                if (isBorderBox && scrollboxSizeBuggy) {
                  subtract -= Math.ceil(
                    elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                  );
                }
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                  elem.style[dimension] = value;
                  value = jQuery2.css(elem, dimension);
                }
                return setPositiveNumber(elem, value, subtract);
              }
            };
          });
          jQuery2.cssHooks.marginLeft = addGetHookIf(
            support.reliableMarginLeft,
            function(elem, computed2) {
              if (computed2) {
                return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                  return elem.getBoundingClientRect().left;
                })) + "px";
              }
            }
          );
          jQuery2.each({
            margin: "",
            padding: "",
            border: "Width"
          }, function(prefix, suffix) {
            jQuery2.cssHooks[prefix + suffix] = {
              expand: function(value) {
                var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
                for (; i < 4; i++) {
                  expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
              }
            };
            if (prefix !== "margin") {
              jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
            }
          });
          jQuery2.fn.extend({
            css: function(name, value) {
              return access(this, function(elem, name2, value2) {
                var styles, len, map2 = {}, i = 0;
                if (Array.isArray(name2)) {
                  styles = getStyles(elem);
                  len = name2.length;
                  for (; i < len; i++) {
                    map2[name2[i]] = jQuery2.css(elem, name2[i], false, styles);
                  }
                  return map2;
                }
                return value2 !== void 0 ? jQuery2.style(elem, name2, value2) : jQuery2.css(elem, name2);
              }, name, value, arguments.length > 1);
            }
          });
          function Tween(elem, options, prop, end2, easing) {
            return new Tween.prototype.init(elem, options, prop, end2, easing);
          }
          jQuery2.Tween = Tween;
          Tween.prototype = {
            constructor: Tween,
            init: function(elem, options, prop, end2, easing, unit) {
              this.elem = elem;
              this.prop = prop;
              this.easing = easing || jQuery2.easing._default;
              this.options = options;
              this.start = this.now = this.cur();
              this.end = end2;
              this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
            },
            cur: function() {
              var hooks = Tween.propHooks[this.prop];
              return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
            },
            run: function(percent) {
              var eased, hooks = Tween.propHooks[this.prop];
              if (this.options.duration) {
                this.pos = eased = jQuery2.easing[this.easing](
                  percent,
                  this.options.duration * percent,
                  0,
                  1,
                  this.options.duration
                );
              } else {
                this.pos = eased = percent;
              }
              this.now = (this.end - this.start) * eased + this.start;
              if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
              }
              if (hooks && hooks.set) {
                hooks.set(this);
              } else {
                Tween.propHooks._default.set(this);
              }
              return this;
            }
          };
          Tween.prototype.init.prototype = Tween.prototype;
          Tween.propHooks = {
            _default: {
              get: function(tween) {
                var result;
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                  return tween.elem[tween.prop];
                }
                result = jQuery2.css(tween.elem, tween.prop, "");
                return !result || result === "auto" ? 0 : result;
              },
              set: function(tween) {
                if (jQuery2.fx.step[tween.prop]) {
                  jQuery2.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (jQuery2.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                  jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                  tween.elem[tween.prop] = tween.now;
                }
              }
            }
          };
          Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function(tween) {
              if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
              }
            }
          };
          jQuery2.easing = {
            linear: function(p2) {
              return p2;
            },
            swing: function(p2) {
              return 0.5 - Math.cos(p2 * Math.PI) / 2;
            },
            _default: "swing"
          };
          jQuery2.fx = Tween.prototype.init;
          jQuery2.fx.step = {};
          var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
          function schedule() {
            if (inProgress) {
              if (document2.hidden === false && window2.requestAnimationFrame) {
                window2.requestAnimationFrame(schedule);
              } else {
                window2.setTimeout(schedule, jQuery2.fx.interval);
              }
              jQuery2.fx.tick();
            }
          }
          function createFxNow() {
            window2.setTimeout(function() {
              fxNow = void 0;
            });
            return fxNow = Date.now();
          }
          function genFx(type, includeWidth) {
            var which, i = 0, attrs = { height: type };
            includeWidth = includeWidth ? 1 : 0;
            for (; i < 4; i += 2 - includeWidth) {
              which = cssExpand[i];
              attrs["margin" + which] = attrs["padding" + which] = type;
            }
            if (includeWidth) {
              attrs.opacity = attrs.width = type;
            }
            return attrs;
          }
          function createTween(value, prop, animation) {
            var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
            for (; index < length; index++) {
              if (tween = collection[index].call(animation, prop, value)) {
                return tween;
              }
            }
          }
          function defaultPrefilter(elem, props, opts) {
            var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
            if (!opts.queue) {
              hooks = jQuery2._queueHooks(elem, "fx");
              if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                  if (!hooks.unqueued) {
                    oldfire();
                  }
                };
              }
              hooks.unqueued++;
              anim.always(function() {
                anim.always(function() {
                  hooks.unqueued--;
                  if (!jQuery2.queue(elem, "fx").length) {
                    hooks.empty.fire();
                  }
                });
              });
            }
            for (prop in props) {
              value = props[prop];
              if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                  if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                    hidden = true;
                  } else {
                    continue;
                  }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
              }
            }
            propTween = !jQuery2.isEmptyObject(props);
            if (!propTween && jQuery2.isEmptyObject(orig)) {
              return;
            }
            if (isBox && elem.nodeType === 1) {
              opts.overflow = [style.overflow, style.overflowX, style.overflowY];
              restoreDisplay = dataShow && dataShow.display;
              if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, "display");
              }
              display = jQuery2.css(elem, "display");
              if (display === "none") {
                if (restoreDisplay) {
                  display = restoreDisplay;
                } else {
                  showHide([elem], true);
                  restoreDisplay = elem.style.display || restoreDisplay;
                  display = jQuery2.css(elem, "display");
                  showHide([elem]);
                }
              }
              if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                if (jQuery2.css(elem, "float") === "none") {
                  if (!propTween) {
                    anim.done(function() {
                      style.display = restoreDisplay;
                    });
                    if (restoreDisplay == null) {
                      display = style.display;
                      restoreDisplay = display === "none" ? "" : display;
                    }
                  }
                  style.display = "inline-block";
                }
              }
            }
            if (opts.overflow) {
              style.overflow = "hidden";
              anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
              });
            }
            propTween = false;
            for (prop in orig) {
              if (!propTween) {
                if (dataShow) {
                  if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                  }
                } else {
                  dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
                }
                if (toggle) {
                  dataShow.hidden = !hidden;
                }
                if (hidden) {
                  showHide([elem], true);
                }
                anim.done(function() {
                  if (!hidden) {
                    showHide([elem]);
                  }
                  dataPriv.remove(elem, "fxshow");
                  for (prop in orig) {
                    jQuery2.style(elem, prop, orig[prop]);
                  }
                });
              }
              propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
              if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                  propTween.end = propTween.start;
                  propTween.start = 0;
                }
              }
            }
          }
          function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks;
            for (index in props) {
              name = camelCase2(index);
              easing = specialEasing[name];
              value = props[index];
              if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
              }
              if (index !== name) {
                props[name] = value;
                delete props[index];
              }
              hooks = jQuery2.cssHooks[name];
              if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                  if (!(index in props)) {
                    props[index] = value[index];
                    specialEasing[index] = easing;
                  }
                }
              } else {
                specialEasing[name] = easing;
              }
            }
          }
          function Animation(elem, properties, options) {
            var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery2.Deferred().always(function() {
              delete tick.elem;
            }), tick = function() {
              if (stopped) {
                return false;
              }
              var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(percent);
              }
              deferred.notifyWith(elem, [animation, percent, remaining]);
              if (percent < 1 && length2) {
                return remaining;
              }
              if (!length2) {
                deferred.notifyWith(elem, [animation, 1, 0]);
              }
              deferred.resolveWith(elem, [animation]);
              return false;
            }, animation = deferred.promise({
              elem,
              props: jQuery2.extend({}, properties),
              opts: jQuery2.extend(true, {
                specialEasing: {},
                easing: jQuery2.easing._default
              }, options),
              originalProperties: properties,
              originalOptions: options,
              startTime: fxNow || createFxNow(),
              duration: options.duration,
              tweens: [],
              createTween: function(prop, end2) {
                var tween = jQuery2.Tween(
                  elem,
                  animation.opts,
                  prop,
                  end2,
                  animation.opts.specialEasing[prop] || animation.opts.easing
                );
                animation.tweens.push(tween);
                return tween;
              },
              stop: function(gotoEnd) {
                var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                  return this;
                }
                stopped = true;
                for (; index2 < length2; index2++) {
                  animation.tweens[index2].run(1);
                }
                if (gotoEnd) {
                  deferred.notifyWith(elem, [animation, 1, 0]);
                  deferred.resolveWith(elem, [animation, gotoEnd]);
                } else {
                  deferred.rejectWith(elem, [animation, gotoEnd]);
                }
                return this;
              }
            }), props = animation.props;
            propFilter(props, animation.opts.specialEasing);
            for (; index < length; index++) {
              result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
              if (result) {
                if (isFunction2(result.stop)) {
                  jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
                }
                return result;
              }
            }
            jQuery2.map(props, createTween, animation);
            if (isFunction2(animation.opts.start)) {
              animation.opts.start.call(elem, animation);
            }
            animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
            jQuery2.fx.timer(
              jQuery2.extend(tick, {
                elem,
                anim: animation,
                queue: animation.opts.queue
              })
            );
            return animation;
          }
          jQuery2.Animation = jQuery2.extend(Animation, {
            tweeners: {
              "*": [function(prop, value) {
                var tween = this.createTween(prop, value);
                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                return tween;
              }]
            },
            tweener: function(props, callback) {
              if (isFunction2(props)) {
                callback = props;
                props = ["*"];
              } else {
                props = props.match(rnothtmlwhite);
              }
              var prop, index = 0, length = props.length;
              for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
              }
            },
            prefilters: [defaultPrefilter],
            prefilter: function(callback, prepend) {
              if (prepend) {
                Animation.prefilters.unshift(callback);
              } else {
                Animation.prefilters.push(callback);
              }
            }
          });
          jQuery2.speed = function(speed, easing, fn2) {
            var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
              complete: fn2 || !fn2 && easing || isFunction2(speed) && speed,
              duration: speed,
              easing: fn2 && easing || easing && !isFunction2(easing) && easing
            };
            if (jQuery2.fx.off) {
              opt.duration = 0;
            } else {
              if (typeof opt.duration !== "number") {
                if (opt.duration in jQuery2.fx.speeds) {
                  opt.duration = jQuery2.fx.speeds[opt.duration];
                } else {
                  opt.duration = jQuery2.fx.speeds._default;
                }
              }
            }
            if (opt.queue == null || opt.queue === true) {
              opt.queue = "fx";
            }
            opt.old = opt.complete;
            opt.complete = function() {
              if (isFunction2(opt.old)) {
                opt.old.call(this);
              }
              if (opt.queue) {
                jQuery2.dequeue(this, opt.queue);
              }
            };
            return opt;
          };
          jQuery2.fn.extend({
            fadeTo: function(speed, to, easing, callback) {
              return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
            },
            animate: function(prop, speed, easing, callback) {
              var empty = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery2.extend({}, prop), optall);
                if (empty || dataPriv.get(this, "finish")) {
                  anim.stop(true);
                }
              };
              doAnimation.finish = doAnimation;
              return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
            },
            stop: function(type, clearQueue, gotoEnd) {
              var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
              };
              if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = void 0;
              }
              if (clearQueue) {
                this.queue(type || "fx", []);
              }
              return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery2.timers, data = dataPriv.get(this);
                if (index) {
                  if (data[index] && data[index].stop) {
                    stopQueue(data[index]);
                  }
                } else {
                  for (index in data) {
                    if (data[index] && data[index].stop && rrun.test(index)) {
                      stopQueue(data[index]);
                    }
                  }
                }
                for (index = timers.length; index--; ) {
                  if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                    timers[index].anim.stop(gotoEnd);
                    dequeue = false;
                    timers.splice(index, 1);
                  }
                }
                if (dequeue || !gotoEnd) {
                  jQuery2.dequeue(this, type);
                }
              });
            },
            finish: function(type) {
              if (type !== false) {
                type = type || "fx";
              }
              return this.each(function() {
                var index, data = dataPriv.get(this), queue2 = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery2.timers, length = queue2 ? queue2.length : 0;
                data.finish = true;
                jQuery2.queue(this, type, []);
                if (hooks && hooks.stop) {
                  hooks.stop.call(this, true);
                }
                for (index = timers.length; index--; ) {
                  if (timers[index].elem === this && timers[index].queue === type) {
                    timers[index].anim.stop(true);
                    timers.splice(index, 1);
                  }
                }
                for (index = 0; index < length; index++) {
                  if (queue2[index] && queue2[index].finish) {
                    queue2[index].finish.call(this);
                  }
                }
                delete data.finish;
              });
            }
          });
          jQuery2.each(["toggle", "show", "hide"], function(_i, name) {
            var cssFn = jQuery2.fn[name];
            jQuery2.fn[name] = function(speed, easing, callback) {
              return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
            };
          });
          jQuery2.each({
            slideDown: genFx("show"),
            slideUp: genFx("hide"),
            slideToggle: genFx("toggle"),
            fadeIn: { opacity: "show" },
            fadeOut: { opacity: "hide" },
            fadeToggle: { opacity: "toggle" }
          }, function(name, props) {
            jQuery2.fn[name] = function(speed, easing, callback) {
              return this.animate(props, speed, easing, callback);
            };
          });
          jQuery2.timers = [];
          jQuery2.fx.tick = function() {
            var timer, i = 0, timers = jQuery2.timers;
            fxNow = Date.now();
            for (; i < timers.length; i++) {
              timer = timers[i];
              if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
              }
            }
            if (!timers.length) {
              jQuery2.fx.stop();
            }
            fxNow = void 0;
          };
          jQuery2.fx.timer = function(timer) {
            jQuery2.timers.push(timer);
            jQuery2.fx.start();
          };
          jQuery2.fx.interval = 13;
          jQuery2.fx.start = function() {
            if (inProgress) {
              return;
            }
            inProgress = true;
            schedule();
          };
          jQuery2.fx.stop = function() {
            inProgress = null;
          };
          jQuery2.fx.speeds = {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
          };
          jQuery2.fn.delay = function(time, type) {
            time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
            type = type || "fx";
            return this.queue(type, function(next, hooks) {
              var timeout = window2.setTimeout(next, time);
              hooks.stop = function() {
                window2.clearTimeout(timeout);
              };
            });
          };
          (function() {
            var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
            input.type = "checkbox";
            support.checkOn = input.value !== "";
            support.optSelected = opt.selected;
            input = document2.createElement("input");
            input.value = "t";
            input.type = "radio";
            support.radioValue = input.value === "t";
          })();
          var boolHook, attrHandle = jQuery2.expr.attrHandle;
          jQuery2.fn.extend({
            attr: function(name, value) {
              return access(this, jQuery2.attr, name, value, arguments.length > 1);
            },
            removeAttr: function(name) {
              return this.each(function() {
                jQuery2.removeAttr(this, name);
              });
            }
          });
          jQuery2.extend({
            attr: function(elem, name, value) {
              var ret, hooks, nType = elem.nodeType;
              if (nType === 3 || nType === 8 || nType === 2) {
                return;
              }
              if (typeof elem.getAttribute === "undefined") {
                return jQuery2.prop(elem, name, value);
              }
              if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
                hooks = jQuery2.attrHooks[name.toLowerCase()] || (jQuery2.expr.match.bool.test(name) ? boolHook : void 0);
              }
              if (value !== void 0) {
                if (value === null) {
                  jQuery2.removeAttr(elem, name);
                  return;
                }
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                  return ret;
                }
                elem.setAttribute(name, value + "");
                return value;
              }
              if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
              }
              ret = jQuery2.find.attr(elem, name);
              return ret == null ? void 0 : ret;
            },
            attrHooks: {
              type: {
                set: function(elem, value) {
                  if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                    var val = elem.value;
                    elem.setAttribute("type", value);
                    if (val) {
                      elem.value = val;
                    }
                    return value;
                  }
                }
              }
            },
            removeAttr: function(elem, value) {
              var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
              if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                  elem.removeAttribute(name);
                }
              }
            }
          });
          boolHook = {
            set: function(elem, value, name) {
              if (value === false) {
                jQuery2.removeAttr(elem, name);
              } else {
                elem.setAttribute(name, name);
              }
              return name;
            }
          };
          jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i, name) {
            var getter = attrHandle[name] || jQuery2.find.attr;
            attrHandle[name] = function(elem, name2, isXML) {
              var ret, handle, lowercaseName = name2.toLowerCase();
              if (!isXML) {
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
              }
              return ret;
            };
          });
          var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
          jQuery2.fn.extend({
            prop: function(name, value) {
              return access(this, jQuery2.prop, name, value, arguments.length > 1);
            },
            removeProp: function(name) {
              return this.each(function() {
                delete this[jQuery2.propFix[name] || name];
              });
            }
          });
          jQuery2.extend({
            prop: function(elem, name, value) {
              var ret, hooks, nType = elem.nodeType;
              if (nType === 3 || nType === 8 || nType === 2) {
                return;
              }
              if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
                name = jQuery2.propFix[name] || name;
                hooks = jQuery2.propHooks[name];
              }
              if (value !== void 0) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                  return ret;
                }
                return elem[name] = value;
              }
              if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
              }
              return elem[name];
            },
            propHooks: {
              tabIndex: {
                get: function(elem) {
                  var tabindex = jQuery2.find.attr(elem, "tabindex");
                  if (tabindex) {
                    return parseInt(tabindex, 10);
                  }
                  if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                    return 0;
                  }
                  return -1;
                }
              }
            },
            propFix: {
              "for": "htmlFor",
              "class": "className"
            }
          });
          if (!support.optSelected) {
            jQuery2.propHooks.selected = {
              get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
                return null;
              },
              set: function(elem) {
                var parent = elem.parentNode;
                if (parent) {
                  parent.selectedIndex;
                  if (parent.parentNode) {
                    parent.parentNode.selectedIndex;
                  }
                }
              }
            };
          }
          jQuery2.each([
            "tabIndex",
            "readOnly",
            "maxLength",
            "cellSpacing",
            "cellPadding",
            "rowSpan",
            "colSpan",
            "useMap",
            "frameBorder",
            "contentEditable"
          ], function() {
            jQuery2.propFix[this.toLowerCase()] = this;
          });
          function stripAndCollapse(value) {
            var tokens = value.match(rnothtmlwhite) || [];
            return tokens.join(" ");
          }
          function getClass(elem) {
            return elem.getAttribute && elem.getAttribute("class") || "";
          }
          function classesToArray(value) {
            if (Array.isArray(value)) {
              return value;
            }
            if (typeof value === "string") {
              return value.match(rnothtmlwhite) || [];
            }
            return [];
          }
          jQuery2.fn.extend({
            addClass: function(value) {
              var classNames, cur, curValue, className, i, finalValue;
              if (isFunction2(value)) {
                return this.each(function(j) {
                  jQuery2(this).addClass(value.call(this, j, getClass(this)));
                });
              }
              classNames = classesToArray(value);
              if (classNames.length) {
                return this.each(function() {
                  curValue = getClass(this);
                  cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                  if (cur) {
                    for (i = 0; i < classNames.length; i++) {
                      className = classNames[i];
                      if (cur.indexOf(" " + className + " ") < 0) {
                        cur += className + " ";
                      }
                    }
                    finalValue = stripAndCollapse(cur);
                    if (curValue !== finalValue) {
                      this.setAttribute("class", finalValue);
                    }
                  }
                });
              }
              return this;
            },
            removeClass: function(value) {
              var classNames, cur, curValue, className, i, finalValue;
              if (isFunction2(value)) {
                return this.each(function(j) {
                  jQuery2(this).removeClass(value.call(this, j, getClass(this)));
                });
              }
              if (!arguments.length) {
                return this.attr("class", "");
              }
              classNames = classesToArray(value);
              if (classNames.length) {
                return this.each(function() {
                  curValue = getClass(this);
                  cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                  if (cur) {
                    for (i = 0; i < classNames.length; i++) {
                      className = classNames[i];
                      while (cur.indexOf(" " + className + " ") > -1) {
                        cur = cur.replace(" " + className + " ", " ");
                      }
                    }
                    finalValue = stripAndCollapse(cur);
                    if (curValue !== finalValue) {
                      this.setAttribute("class", finalValue);
                    }
                  }
                });
              }
              return this;
            },
            toggleClass: function(value, stateVal) {
              var classNames, className, i, self2, type = typeof value, isValidValue2 = type === "string" || Array.isArray(value);
              if (isFunction2(value)) {
                return this.each(function(i2) {
                  jQuery2(this).toggleClass(
                    value.call(this, i2, getClass(this), stateVal),
                    stateVal
                  );
                });
              }
              if (typeof stateVal === "boolean" && isValidValue2) {
                return stateVal ? this.addClass(value) : this.removeClass(value);
              }
              classNames = classesToArray(value);
              return this.each(function() {
                if (isValidValue2) {
                  self2 = jQuery2(this);
                  for (i = 0; i < classNames.length; i++) {
                    className = classNames[i];
                    if (self2.hasClass(className)) {
                      self2.removeClass(className);
                    } else {
                      self2.addClass(className);
                    }
                  }
                } else if (value === void 0 || type === "boolean") {
                  className = getClass(this);
                  if (className) {
                    dataPriv.set(this, "__className__", className);
                  }
                  if (this.setAttribute) {
                    this.setAttribute(
                      "class",
                      className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                    );
                  }
                }
              });
            },
            hasClass: function(selector) {
              var className, elem, i = 0;
              className = " " + selector + " ";
              while (elem = this[i++]) {
                if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                  return true;
                }
              }
              return false;
            }
          });
          var rreturn = /\r/g;
          jQuery2.fn.extend({
            val: function(value) {
              var hooks, ret, valueIsFunction, elem = this[0];
              if (!arguments.length) {
                if (elem) {
                  hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
                  if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                    return ret;
                  }
                  ret = elem.value;
                  if (typeof ret === "string") {
                    return ret.replace(rreturn, "");
                  }
                  return ret == null ? "" : ret;
                }
                return;
              }
              valueIsFunction = isFunction2(value);
              return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                  return;
                }
                if (valueIsFunction) {
                  val = value.call(this, i, jQuery2(this).val());
                } else {
                  val = value;
                }
                if (val == null) {
                  val = "";
                } else if (typeof val === "number") {
                  val += "";
                } else if (Array.isArray(val)) {
                  val = jQuery2.map(val, function(value2) {
                    return value2 == null ? "" : value2 + "";
                  });
                }
                hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                  this.value = val;
                }
              });
            }
          });
          jQuery2.extend({
            valHooks: {
              option: {
                get: function(elem) {
                  var val = jQuery2.find.attr(elem, "value");
                  return val != null ? val : (
                    // Support: IE <=10 - 11 only
                    // option.text throws exceptions (trac-14686, trac-14858)
                    // Strip and collapse whitespace
                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                    stripAndCollapse(jQuery2.text(elem))
                  );
                }
              },
              select: {
                get: function(elem) {
                  var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values2 = one ? null : [], max = one ? index + 1 : options.length;
                  if (index < 0) {
                    i = max;
                  } else {
                    i = one ? index : 0;
                  }
                  for (; i < max; i++) {
                    option = options[i];
                    if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                    !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                      value = jQuery2(option).val();
                      if (one) {
                        return value;
                      }
                      values2.push(value);
                    }
                  }
                  return values2;
                },
                set: function(elem, value) {
                  var optionSet, option, options = elem.options, values2 = jQuery2.makeArray(value), i = options.length;
                  while (i--) {
                    option = options[i];
                    if (option.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option), values2) > -1) {
                      optionSet = true;
                    }
                  }
                  if (!optionSet) {
                    elem.selectedIndex = -1;
                  }
                  return values2;
                }
              }
            }
          });
          jQuery2.each(["radio", "checkbox"], function() {
            jQuery2.valHooks[this] = {
              set: function(elem, value) {
                if (Array.isArray(value)) {
                  return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
                }
              }
            };
            if (!support.checkOn) {
              jQuery2.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
              };
            }
          });
          var location2 = window2.location;
          var nonce = { guid: Date.now() };
          var rquery = /\?/;
          jQuery2.parseXML = function(data) {
            var xml, parserErrorElem;
            if (!data || typeof data !== "string") {
              return null;
            }
            try {
              xml = new window2.DOMParser().parseFromString(data, "text/xml");
            } catch (e) {
            }
            parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
            if (!xml || parserErrorElem) {
              jQuery2.error("Invalid XML: " + (parserErrorElem ? jQuery2.map(parserErrorElem.childNodes, function(el) {
                return el.textContent;
              }).join("\n") : data));
            }
            return xml;
          };
          var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
            e.stopPropagation();
          };
          jQuery2.extend(jQuery2.event, {
            trigger: function(event, data, elem, onlyHandlers) {
              var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn2.call(event, "type") ? event.type : event, namespaces = hasOwn2.call(event, "namespace") ? event.namespace.split(".") : [];
              cur = lastElement = tmp = elem = elem || document2;
              if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
              }
              if (rfocusMorph.test(type + jQuery2.event.triggered)) {
                return;
              }
              if (type.indexOf(".") > -1) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
              }
              ontype = type.indexOf(":") < 0 && "on" + type;
              event = event[jQuery2.expando] ? event : new jQuery2.Event(type, typeof event === "object" && event);
              event.isTrigger = onlyHandlers ? 2 : 3;
              event.namespace = namespaces.join(".");
              event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
              event.result = void 0;
              if (!event.target) {
                event.target = elem;
              }
              data = data == null ? [event] : jQuery2.makeArray(data, [event]);
              special = jQuery2.event.special[type] || {};
              if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
              }
              if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                  cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                  eventPath.push(cur);
                  tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document2)) {
                  eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
                }
              }
              i = 0;
              while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                lastElement = cur;
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
                if (handle) {
                  handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                  event.result = handle.apply(cur, data);
                  if (event.result === false) {
                    event.preventDefault();
                  }
                }
              }
              event.type = type;
              if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                  if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
                    tmp = elem[ontype];
                    if (tmp) {
                      elem[ontype] = null;
                    }
                    jQuery2.event.triggered = type;
                    if (event.isPropagationStopped()) {
                      lastElement.addEventListener(type, stopPropagationCallback);
                    }
                    elem[type]();
                    if (event.isPropagationStopped()) {
                      lastElement.removeEventListener(type, stopPropagationCallback);
                    }
                    jQuery2.event.triggered = void 0;
                    if (tmp) {
                      elem[ontype] = tmp;
                    }
                  }
                }
              }
              return event.result;
            },
            // Piggyback on a donor event to simulate a different one
            // Used only for `focus(in | out)` events
            simulate: function(type, elem, event) {
              var e = jQuery2.extend(
                new jQuery2.Event(),
                event,
                {
                  type,
                  isSimulated: true
                }
              );
              jQuery2.event.trigger(e, null, elem);
            }
          });
          jQuery2.fn.extend({
            trigger: function(type, data) {
              return this.each(function() {
                jQuery2.event.trigger(type, data, this);
              });
            },
            triggerHandler: function(type, data) {
              var elem = this[0];
              if (elem) {
                return jQuery2.event.trigger(type, data, elem, true);
              }
            }
          });
          var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
          function buildParams(prefix, obj, traditional, add2) {
            var name;
            if (Array.isArray(obj)) {
              jQuery2.each(obj, function(i, v2) {
                if (traditional || rbracket.test(prefix)) {
                  add2(prefix, v2);
                } else {
                  buildParams(
                    prefix + "[" + (typeof v2 === "object" && v2 != null ? i : "") + "]",
                    v2,
                    traditional,
                    add2
                  );
                }
              });
            } else if (!traditional && toType(obj) === "object") {
              for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
              }
            } else {
              add2(prefix, obj);
            }
          }
          jQuery2.param = function(a2, traditional) {
            var prefix, s2 = [], add2 = function(key, valueOrFunction) {
              var value = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
              s2[s2.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
            };
            if (a2 == null) {
              return "";
            }
            if (Array.isArray(a2) || a2.jquery && !jQuery2.isPlainObject(a2)) {
              jQuery2.each(a2, function() {
                add2(this.name, this.value);
              });
            } else {
              for (prefix in a2) {
                buildParams(prefix, a2[prefix], traditional, add2);
              }
            }
            return s2.join("&");
          };
          jQuery2.fn.extend({
            serialize: function() {
              return jQuery2.param(this.serializeArray());
            },
            serializeArray: function() {
              return this.map(function() {
                var elements = jQuery2.prop(this, "elements");
                return elements ? jQuery2.makeArray(elements) : this;
              }).filter(function() {
                var type = this.type;
                return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
              }).map(function(_i, elem) {
                var val = jQuery2(this).val();
                if (val == null) {
                  return null;
                }
                if (Array.isArray(val)) {
                  return jQuery2.map(val, function(val2) {
                    return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                  });
                }
                return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
              }).get();
            }
          });
          var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
          originAnchor.href = location2.href;
          function addToPrefiltersOrTransports(structure) {
            return function(dataTypeExpression, func) {
              if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
              }
              var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
              if (isFunction2(func)) {
                while (dataType = dataTypes[i++]) {
                  if (dataType[0] === "+") {
                    dataType = dataType.slice(1) || "*";
                    (structure[dataType] = structure[dataType] || []).unshift(func);
                  } else {
                    (structure[dataType] = structure[dataType] || []).push(func);
                  }
                }
              }
            };
          }
          function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            var inspected = {}, seekingTransport = structure === transports;
            function inspect(dataType) {
              var selected;
              inspected[dataType] = true;
              jQuery2.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                  options.dataTypes.unshift(dataTypeOrTransport);
                  inspect(dataTypeOrTransport);
                  return false;
                } else if (seekingTransport) {
                  return !(selected = dataTypeOrTransport);
                }
              });
              return selected;
            }
            return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
          }
          function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
            for (key in src) {
              if (src[key] !== void 0) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
              }
            }
            if (deep) {
              jQuery2.extend(true, target, deep);
            }
            return target;
          }
          function ajaxHandleResponses(s2, jqXHR, responses) {
            var ct2, type, finalDataType, firstDataType, contents = s2.contents, dataTypes = s2.dataTypes;
            while (dataTypes[0] === "*") {
              dataTypes.shift();
              if (ct2 === void 0) {
                ct2 = s2.mimeType || jqXHR.getResponseHeader("Content-Type");
              }
            }
            if (ct2) {
              for (type in contents) {
                if (contents[type] && contents[type].test(ct2)) {
                  dataTypes.unshift(type);
                  break;
                }
              }
            }
            if (dataTypes[0] in responses) {
              finalDataType = dataTypes[0];
            } else {
              for (type in responses) {
                if (!dataTypes[0] || s2.converters[type + " " + dataTypes[0]]) {
                  finalDataType = type;
                  break;
                }
                if (!firstDataType) {
                  firstDataType = type;
                }
              }
              finalDataType = finalDataType || firstDataType;
            }
            if (finalDataType) {
              if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
              }
              return responses[finalDataType];
            }
          }
          function ajaxConvert(s2, response, jqXHR, isSuccess) {
            var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s2.dataTypes.slice();
            if (dataTypes[1]) {
              for (conv in s2.converters) {
                converters[conv.toLowerCase()] = s2.converters[conv];
              }
            }
            current = dataTypes.shift();
            while (current) {
              if (s2.responseFields[current]) {
                jqXHR[s2.responseFields[current]] = response;
              }
              if (!prev && isSuccess && s2.dataFilter) {
                response = s2.dataFilter(response, s2.dataType);
              }
              prev = current;
              current = dataTypes.shift();
              if (current) {
                if (current === "*") {
                  current = prev;
                } else if (prev !== "*" && prev !== current) {
                  conv = converters[prev + " " + current] || converters["* " + current];
                  if (!conv) {
                    for (conv2 in converters) {
                      tmp = conv2.split(" ");
                      if (tmp[1] === current) {
                        conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                        if (conv) {
                          if (conv === true) {
                            conv = converters[conv2];
                          } else if (converters[conv2] !== true) {
                            current = tmp[0];
                            dataTypes.unshift(tmp[1]);
                          }
                          break;
                        }
                      }
                    }
                  }
                  if (conv !== true) {
                    if (conv && s2.throws) {
                      response = conv(response);
                    } else {
                      try {
                        response = conv(response);
                      } catch (e) {
                        return {
                          state: "parsererror",
                          error: conv ? e : "No conversion from " + prev + " to " + current
                        };
                      }
                    }
                  }
                }
              }
            }
            return { state: "success", data: response };
          }
          jQuery2.extend({
            // Counter for holding the number of active queries
            active: 0,
            // Last-Modified header cache for next request
            lastModified: {},
            etag: {},
            ajaxSettings: {
              url: location2.href,
              type: "GET",
              isLocal: rlocalProtocol.test(location2.protocol),
              global: true,
              processData: true,
              async: true,
              contentType: "application/x-www-form-urlencoded; charset=UTF-8",
              /*
              timeout: 0,
              data: null,
              dataType: null,
              username: null,
              password: null,
              cache: null,
              throws: false,
              traditional: false,
              headers: {},
              */
              accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
              },
              contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
              },
              responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
              },
              // Data converters
              // Keys separate source (or catchall "*") and destination types with a single space
              converters: {
                // Convert anything to text
                "* text": String,
                // Text to html (true = no transformation)
                "text html": true,
                // Evaluate text as a json expression
                "text json": JSON.parse,
                // Parse text as xml
                "text xml": jQuery2.parseXML
              },
              // For options that shouldn't be deep extended:
              // you can add your own custom options here if
              // and when you create one that shouldn't be
              // deep extended (see ajaxExtend)
              flatOptions: {
                url: true,
                context: true
              }
            },
            // Creates a full fledged settings object into target
            // with both ajaxSettings and settings fields.
            // If target is omitted, writes into ajaxSettings.
            ajaxSetup: function(target, settings2) {
              return settings2 ? (
                // Building a settings object
                ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings2)
              ) : (
                // Extending ajaxSettings
                ajaxExtend(jQuery2.ajaxSettings, target)
              );
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            // Main method
            ajax: function(url, options) {
              if (typeof url === "object") {
                options = url;
                url = void 0;
              }
              options = options || {};
              var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s2 = jQuery2.ajaxSetup({}, options), callbackContext = s2.context || s2, globalEventContext = s2.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s2.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
                readyState: 0,
                // Builds headers hashtable if needed
                getResponseHeader: function(key) {
                  var match2;
                  if (completed2) {
                    if (!responseHeaders) {
                      responseHeaders = {};
                      while (match2 = rheaders.exec(responseHeadersString)) {
                        responseHeaders[match2[1].toLowerCase() + " "] = (responseHeaders[match2[1].toLowerCase() + " "] || []).concat(match2[2]);
                      }
                    }
                    match2 = responseHeaders[key.toLowerCase() + " "];
                  }
                  return match2 == null ? null : match2.join(", ");
                },
                // Raw string
                getAllResponseHeaders: function() {
                  return completed2 ? responseHeadersString : null;
                },
                // Caches the header
                setRequestHeader: function(name, value) {
                  if (completed2 == null) {
                    name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                    requestHeaders[name] = value;
                  }
                  return this;
                },
                // Overrides response content-type header
                overrideMimeType: function(type) {
                  if (completed2 == null) {
                    s2.mimeType = type;
                  }
                  return this;
                },
                // Status-dependent callbacks
                statusCode: function(map2) {
                  var code2;
                  if (map2) {
                    if (completed2) {
                      jqXHR.always(map2[jqXHR.status]);
                    } else {
                      for (code2 in map2) {
                        statusCode[code2] = [statusCode[code2], map2[code2]];
                      }
                    }
                  }
                  return this;
                },
                // Cancel the request
                abort: function(statusText) {
                  var finalText = statusText || strAbort;
                  if (transport) {
                    transport.abort(finalText);
                  }
                  done(0, finalText);
                  return this;
                }
              };
              deferred.promise(jqXHR);
              s2.url = ((url || s2.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
              s2.type = options.method || options.type || s2.method || s2.type;
              s2.dataTypes = (s2.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
              if (s2.crossDomain == null) {
                urlAnchor = document2.createElement("a");
                try {
                  urlAnchor.href = s2.url;
                  urlAnchor.href = urlAnchor.href;
                  s2.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                  s2.crossDomain = true;
                }
              }
              if (s2.data && s2.processData && typeof s2.data !== "string") {
                s2.data = jQuery2.param(s2.data, s2.traditional);
              }
              inspectPrefiltersOrTransports(prefilters, s2, options, jqXHR);
              if (completed2) {
                return jqXHR;
              }
              fireGlobals = jQuery2.event && s2.global;
              if (fireGlobals && jQuery2.active++ === 0) {
                jQuery2.event.trigger("ajaxStart");
              }
              s2.type = s2.type.toUpperCase();
              s2.hasContent = !rnoContent.test(s2.type);
              cacheURL = s2.url.replace(rhash, "");
              if (!s2.hasContent) {
                uncached = s2.url.slice(cacheURL.length);
                if (s2.data && (s2.processData || typeof s2.data === "string")) {
                  cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s2.data;
                  delete s2.data;
                }
                if (s2.cache === false) {
                  cacheURL = cacheURL.replace(rantiCache, "$1");
                  uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
                }
                s2.url = cacheURL + uncached;
              } else if (s2.data && s2.processData && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
                s2.data = s2.data.replace(r20, "+");
              }
              if (s2.ifModified) {
                if (jQuery2.lastModified[cacheURL]) {
                  jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
                }
                if (jQuery2.etag[cacheURL]) {
                  jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
                }
              }
              if (s2.data && s2.hasContent && s2.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s2.contentType);
              }
              jqXHR.setRequestHeader(
                "Accept",
                s2.dataTypes[0] && s2.accepts[s2.dataTypes[0]] ? s2.accepts[s2.dataTypes[0]] + (s2.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s2.accepts["*"]
              );
              for (i in s2.headers) {
                jqXHR.setRequestHeader(i, s2.headers[i]);
              }
              if (s2.beforeSend && (s2.beforeSend.call(callbackContext, jqXHR, s2) === false || completed2)) {
                return jqXHR.abort();
              }
              strAbort = "abort";
              completeDeferred.add(s2.complete);
              jqXHR.done(s2.success);
              jqXHR.fail(s2.error);
              transport = inspectPrefiltersOrTransports(transports, s2, options, jqXHR);
              if (!transport) {
                done(-1, "No Transport");
              } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                  globalEventContext.trigger("ajaxSend", [jqXHR, s2]);
                }
                if (completed2) {
                  return jqXHR;
                }
                if (s2.async && s2.timeout > 0) {
                  timeoutTimer = window2.setTimeout(function() {
                    jqXHR.abort("timeout");
                  }, s2.timeout);
                }
                try {
                  completed2 = false;
                  transport.send(requestHeaders, done);
                } catch (e) {
                  if (completed2) {
                    throw e;
                  }
                  done(-1, e);
                }
              }
              function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (completed2) {
                  return;
                }
                completed2 = true;
                if (timeoutTimer) {
                  window2.clearTimeout(timeoutTimer);
                }
                transport = void 0;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                  response = ajaxHandleResponses(s2, jqXHR, responses);
                }
                if (!isSuccess && jQuery2.inArray("script", s2.dataTypes) > -1 && jQuery2.inArray("json", s2.dataTypes) < 0) {
                  s2.converters["text script"] = function() {
                  };
                }
                response = ajaxConvert(s2, response, jqXHR, isSuccess);
                if (isSuccess) {
                  if (s2.ifModified) {
                    modified = jqXHR.getResponseHeader("Last-Modified");
                    if (modified) {
                      jQuery2.lastModified[cacheURL] = modified;
                    }
                    modified = jqXHR.getResponseHeader("etag");
                    if (modified) {
                      jQuery2.etag[cacheURL] = modified;
                    }
                  }
                  if (status === 204 || s2.type === "HEAD") {
                    statusText = "nocontent";
                  } else if (status === 304) {
                    statusText = "notmodified";
                  } else {
                    statusText = response.state;
                    success = response.data;
                    error = response.error;
                    isSuccess = !error;
                  }
                } else {
                  error = statusText;
                  if (status || !statusText) {
                    statusText = "error";
                    if (status < 0) {
                      status = 0;
                    }
                  }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                  deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                  deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = void 0;
                if (fireGlobals) {
                  globalEventContext.trigger(
                    isSuccess ? "ajaxSuccess" : "ajaxError",
                    [jqXHR, s2, isSuccess ? success : error]
                  );
                }
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
                if (fireGlobals) {
                  globalEventContext.trigger("ajaxComplete", [jqXHR, s2]);
                  if (!--jQuery2.active) {
                    jQuery2.event.trigger("ajaxStop");
                  }
                }
              }
              return jqXHR;
            },
            getJSON: function(url, data, callback) {
              return jQuery2.get(url, data, callback, "json");
            },
            getScript: function(url, callback) {
              return jQuery2.get(url, void 0, callback, "script");
            }
          });
          jQuery2.each(["get", "post"], function(_i, method) {
            jQuery2[method] = function(url, data, callback, type) {
              if (isFunction2(data)) {
                type = type || callback;
                callback = data;
                data = void 0;
              }
              return jQuery2.ajax(jQuery2.extend({
                url,
                type: method,
                dataType: type,
                data,
                success: callback
              }, jQuery2.isPlainObject(url) && url));
            };
          });
          jQuery2.ajaxPrefilter(function(s2) {
            var i;
            for (i in s2.headers) {
              if (i.toLowerCase() === "content-type") {
                s2.contentType = s2.headers[i] || "";
              }
            }
          });
          jQuery2._evalUrl = function(url, options, doc2) {
            return jQuery2.ajax({
              url,
              // Make this explicit, since user can override this through ajaxSetup (trac-11264)
              type: "GET",
              dataType: "script",
              cache: true,
              async: false,
              global: false,
              // Only evaluate the response if it is successful (gh-4126)
              // dataFilter is not invoked for failure responses, so using it instead
              // of the default converter is kludgy but it works.
              converters: {
                "text script": function() {
                }
              },
              dataFilter: function(response) {
                jQuery2.globalEval(response, options, doc2);
              }
            });
          };
          jQuery2.fn.extend({
            wrapAll: function(html2) {
              var wrap2;
              if (this[0]) {
                if (isFunction2(html2)) {
                  html2 = html2.call(this[0]);
                }
                wrap2 = jQuery2(html2, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                  wrap2.insertBefore(this[0]);
                }
                wrap2.map(function() {
                  var elem = this;
                  while (elem.firstElementChild) {
                    elem = elem.firstElementChild;
                  }
                  return elem;
                }).append(this);
              }
              return this;
            },
            wrapInner: function(html2) {
              if (isFunction2(html2)) {
                return this.each(function(i) {
                  jQuery2(this).wrapInner(html2.call(this, i));
                });
              }
              return this.each(function() {
                var self2 = jQuery2(this), contents = self2.contents();
                if (contents.length) {
                  contents.wrapAll(html2);
                } else {
                  self2.append(html2);
                }
              });
            },
            wrap: function(html2) {
              var htmlIsFunction = isFunction2(html2);
              return this.each(function(i) {
                jQuery2(this).wrapAll(htmlIsFunction ? html2.call(this, i) : html2);
              });
            },
            unwrap: function(selector) {
              this.parent(selector).not("body").each(function() {
                jQuery2(this).replaceWith(this.childNodes);
              });
              return this;
            }
          });
          jQuery2.expr.pseudos.hidden = function(elem) {
            return !jQuery2.expr.pseudos.visible(elem);
          };
          jQuery2.expr.pseudos.visible = function(elem) {
            return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
          };
          jQuery2.ajaxSettings.xhr = function() {
            try {
              return new window2.XMLHttpRequest();
            } catch (e) {
            }
          };
          var xhrSuccessStatus = {
            // File protocol always yields status code 0, assume 200
            0: 200,
            // Support: IE <=9 only
            // trac-1450: sometimes IE returns 1223 when it should be 204
            1223: 204
          }, xhrSupported = jQuery2.ajaxSettings.xhr();
          support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
          support.ajax = xhrSupported = !!xhrSupported;
          jQuery2.ajaxTransport(function(options) {
            var callback, errorCallback;
            if (support.cors || xhrSupported && !options.crossDomain) {
              return {
                send: function(headers, complete) {
                  var i, xhr = options.xhr();
                  xhr.open(
                    options.type,
                    options.url,
                    options.async,
                    options.username,
                    options.password
                  );
                  if (options.xhrFields) {
                    for (i in options.xhrFields) {
                      xhr[i] = options.xhrFields[i];
                    }
                  }
                  if (options.mimeType && xhr.overrideMimeType) {
                    xhr.overrideMimeType(options.mimeType);
                  }
                  if (!options.crossDomain && !headers["X-Requested-With"]) {
                    headers["X-Requested-With"] = "XMLHttpRequest";
                  }
                  for (i in headers) {
                    xhr.setRequestHeader(i, headers[i]);
                  }
                  callback = function(type) {
                    return function() {
                      if (callback) {
                        callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                        if (type === "abort") {
                          xhr.abort();
                        } else if (type === "error") {
                          if (typeof xhr.status !== "number") {
                            complete(0, "error");
                          } else {
                            complete(
                              // File: protocol always yields status 0; see trac-8605, trac-14207
                              xhr.status,
                              xhr.statusText
                            );
                          }
                        } else {
                          complete(
                            xhrSuccessStatus[xhr.status] || xhr.status,
                            xhr.statusText,
                            // Support: IE <=9 only
                            // IE9 has no XHR2 but throws on binary (trac-11426)
                            // For XHR2 non-text, let the caller handle it (gh-2498)
                            (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                            xhr.getAllResponseHeaders()
                          );
                        }
                      }
                    };
                  };
                  xhr.onload = callback();
                  errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                  if (xhr.onabort !== void 0) {
                    xhr.onabort = errorCallback;
                  } else {
                    xhr.onreadystatechange = function() {
                      if (xhr.readyState === 4) {
                        window2.setTimeout(function() {
                          if (callback) {
                            errorCallback();
                          }
                        });
                      }
                    };
                  }
                  callback = callback("abort");
                  try {
                    xhr.send(options.hasContent && options.data || null);
                  } catch (e) {
                    if (callback) {
                      throw e;
                    }
                  }
                },
                abort: function() {
                  if (callback) {
                    callback();
                  }
                }
              };
            }
          });
          jQuery2.ajaxPrefilter(function(s2) {
            if (s2.crossDomain) {
              s2.contents.script = false;
            }
          });
          jQuery2.ajaxSetup({
            accepts: {
              script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
              script: /\b(?:java|ecma)script\b/
            },
            converters: {
              "text script": function(text) {
                jQuery2.globalEval(text);
                return text;
              }
            }
          });
          jQuery2.ajaxPrefilter("script", function(s2) {
            if (s2.cache === void 0) {
              s2.cache = false;
            }
            if (s2.crossDomain) {
              s2.type = "GET";
            }
          });
          jQuery2.ajaxTransport("script", function(s2) {
            if (s2.crossDomain || s2.scriptAttrs) {
              var script, callback;
              return {
                send: function(_2, complete) {
                  script = jQuery2("<script>").attr(s2.scriptAttrs || {}).prop({ charset: s2.scriptCharset, src: s2.url }).on("load error", callback = function(evt) {
                    script.remove();
                    callback = null;
                    if (evt) {
                      complete(evt.type === "error" ? 404 : 200, evt.type);
                    }
                  });
                  document2.head.appendChild(script[0]);
                },
                abort: function() {
                  if (callback) {
                    callback();
                  }
                }
              };
            }
          });
          var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
          jQuery2.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
              var callback = oldCallbacks.pop() || jQuery2.expando + "_" + nonce.guid++;
              this[callback] = true;
              return callback;
            }
          });
          jQuery2.ajaxPrefilter("json jsonp", function(s2, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = s2.jsonp !== false && (rjsonp.test(s2.url) ? "url" : typeof s2.data === "string" && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s2.data) && "data");
            if (jsonProp || s2.dataTypes[0] === "jsonp") {
              callbackName = s2.jsonpCallback = isFunction2(s2.jsonpCallback) ? s2.jsonpCallback() : s2.jsonpCallback;
              if (jsonProp) {
                s2[jsonProp] = s2[jsonProp].replace(rjsonp, "$1" + callbackName);
              } else if (s2.jsonp !== false) {
                s2.url += (rquery.test(s2.url) ? "&" : "?") + s2.jsonp + "=" + callbackName;
              }
              s2.converters["script json"] = function() {
                if (!responseContainer) {
                  jQuery2.error(callbackName + " was not called");
                }
                return responseContainer[0];
              };
              s2.dataTypes[0] = "json";
              overwritten = window2[callbackName];
              window2[callbackName] = function() {
                responseContainer = arguments;
              };
              jqXHR.always(function() {
                if (overwritten === void 0) {
                  jQuery2(window2).removeProp(callbackName);
                } else {
                  window2[callbackName] = overwritten;
                }
                if (s2[callbackName]) {
                  s2.jsonpCallback = originalSettings.jsonpCallback;
                  oldCallbacks.push(callbackName);
                }
                if (responseContainer && isFunction2(overwritten)) {
                  overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = void 0;
              });
              return "script";
            }
          });
          support.createHTMLDocument = function() {
            var body = document2.implementation.createHTMLDocument("").body;
            body.innerHTML = "<form></form><form></form>";
            return body.childNodes.length === 2;
          }();
          jQuery2.parseHTML = function(data, context, keepScripts) {
            if (typeof data !== "string") {
              return [];
            }
            if (typeof context === "boolean") {
              keepScripts = context;
              context = false;
            }
            var base, parsed, scripts;
            if (!context) {
              if (support.createHTMLDocument) {
                context = document2.implementation.createHTMLDocument("");
                base = context.createElement("base");
                base.href = document2.location.href;
                context.head.appendChild(base);
              } else {
                context = document2;
              }
            }
            parsed = rsingleTag.exec(data);
            scripts = !keepScripts && [];
            if (parsed) {
              return [context.createElement(parsed[1])];
            }
            parsed = buildFragment([data], context, scripts);
            if (scripts && scripts.length) {
              jQuery2(scripts).remove();
            }
            return jQuery2.merge([], parsed.childNodes);
          };
          jQuery2.fn.load = function(url, params, callback) {
            var selector, type, response, self2 = this, off = url.indexOf(" ");
            if (off > -1) {
              selector = stripAndCollapse(url.slice(off));
              url = url.slice(0, off);
            }
            if (isFunction2(params)) {
              callback = params;
              params = void 0;
            } else if (params && typeof params === "object") {
              type = "POST";
            }
            if (self2.length > 0) {
              jQuery2.ajax({
                url,
                // If "type" variable is undefined, then "GET" method will be used.
                // Make value of this field explicit since
                // user can override it through ajaxSetup method
                type: type || "GET",
                dataType: "html",
                data: params
              }).done(function(responseText) {
                response = arguments;
                self2.html(selector ? (
                  // If a selector was specified, locate the right elements in a dummy div
                  // Exclude scripts to avoid IE 'Permission Denied' errors
                  jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector)
                ) : (
                  // Otherwise use the full result
                  responseText
                ));
              }).always(callback && function(jqXHR, status) {
                self2.each(function() {
                  callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                });
              });
            }
            return this;
          };
          jQuery2.expr.pseudos.animated = function(elem) {
            return jQuery2.grep(jQuery2.timers, function(fn2) {
              return elem === fn2.elem;
            }).length;
          };
          jQuery2.offset = {
            setOffset: function(elem, options, i) {
              var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
              if (position === "static") {
                elem.style.position = "relative";
              }
              curOffset = curElem.offset();
              curCSSTop = jQuery2.css(elem, "top");
              curCSSLeft = jQuery2.css(elem, "left");
              calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
              if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
              } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
              }
              if (isFunction2(options)) {
                options = options.call(elem, i, jQuery2.extend({}, curOffset));
              }
              if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
              }
              if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
              }
              if ("using" in options) {
                options.using.call(elem, props);
              } else {
                curElem.css(props);
              }
            }
          };
          jQuery2.fn.extend({
            // offset() relates an element's border box to the document origin
            offset: function(options) {
              if (arguments.length) {
                return options === void 0 ? this : this.each(function(i) {
                  jQuery2.offset.setOffset(this, options, i);
                });
              }
              var rect, win, elem = this[0];
              if (!elem) {
                return;
              }
              if (!elem.getClientRects().length) {
                return { top: 0, left: 0 };
              }
              rect = elem.getBoundingClientRect();
              win = elem.ownerDocument.defaultView;
              return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
              };
            },
            // position() relates an element's margin box to its offset parent's padding box
            // This corresponds to the behavior of CSS absolute positioning
            position: function() {
              if (!this[0]) {
                return;
              }
              var offsetParent, offset, doc2, elem = this[0], parentOffset = { top: 0, left: 0 };
              if (jQuery2.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect();
              } else {
                offset = this.offset();
                doc2 = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc2.documentElement;
                while (offsetParent && (offsetParent === doc2.body || offsetParent === doc2.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
                  offsetParent = offsetParent.parentNode;
                }
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                  parentOffset = jQuery2(offsetParent).offset();
                  parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
                  parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
                }
              }
              return {
                top: offset.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
              };
            },
            // This method will return documentElement in the following cases:
            // 1) For the element inside the iframe without offsetParent, this method will return
            //    documentElement of the parent window
            // 2) For the hidden or detached element
            // 3) For body or html element, i.e. in case of the html node - it will return itself
            //
            // but those exceptions were never presented as a real life use-cases
            // and might be considered as more preferable results.
            //
            // This logic, however, is not guaranteed and can change at any point in the future
            offsetParent: function() {
              return this.map(function() {
                var offsetParent = this.offsetParent;
                while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
                  offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || documentElement;
              });
            }
          });
          jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
            var top = "pageYOffset" === prop;
            jQuery2.fn[method] = function(val) {
              return access(this, function(elem, method3, val2) {
                var win;
                if (isWindow(elem)) {
                  win = elem;
                } else if (elem.nodeType === 9) {
                  win = elem.defaultView;
                }
                if (val2 === void 0) {
                  return win ? win[prop] : elem[method3];
                }
                if (win) {
                  win.scrollTo(
                    !top ? val2 : win.pageXOffset,
                    top ? val2 : win.pageYOffset
                  );
                } else {
                  elem[method3] = val2;
                }
              }, method, val, arguments.length);
            };
          });
          jQuery2.each(["top", "left"], function(_i, prop) {
            jQuery2.cssHooks[prop] = addGetHookIf(
              support.pixelPosition,
              function(elem, computed2) {
                if (computed2) {
                  computed2 = curCSS(elem, prop);
                  return rnumnonpx.test(computed2) ? jQuery2(elem).position()[prop] + "px" : computed2;
                }
              }
            );
          });
          jQuery2.each({ Height: "height", Width: "width" }, function(name, type) {
            jQuery2.each({
              padding: "inner" + name,
              content: type,
              "": "outer" + name
            }, function(defaultExtra, funcName) {
              jQuery2.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type3, value2) {
                  var doc2;
                  if (isWindow(elem)) {
                    return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                  }
                  if (elem.nodeType === 9) {
                    doc2 = elem.documentElement;
                    return Math.max(
                      elem.body["scroll" + name],
                      doc2["scroll" + name],
                      elem.body["offset" + name],
                      doc2["offset" + name],
                      doc2["client" + name]
                    );
                  }
                  return value2 === void 0 ? (
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery2.css(elem, type3, extra)
                  ) : (
                    // Set width or height on the element
                    jQuery2.style(elem, type3, value2, extra)
                  );
                }, type, chainable ? margin : void 0, chainable);
              };
            });
          });
          jQuery2.each([
            "ajaxStart",
            "ajaxStop",
            "ajaxComplete",
            "ajaxError",
            "ajaxSuccess",
            "ajaxSend"
          ], function(_i, type) {
            jQuery2.fn[type] = function(fn2) {
              return this.on(type, fn2);
            };
          });
          jQuery2.fn.extend({
            bind: function(types2, data, fn2) {
              return this.on(types2, null, data, fn2);
            },
            unbind: function(types2, fn2) {
              return this.off(types2, null, fn2);
            },
            delegate: function(selector, types2, data, fn2) {
              return this.on(types2, selector, data, fn2);
            },
            undelegate: function(selector, types2, fn2) {
              return arguments.length === 1 ? this.off(selector, "**") : this.off(types2, selector || "**", fn2);
            },
            hover: function(fnOver, fnOut) {
              return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
            }
          });
          jQuery2.each(
            "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
            function(_i, name) {
              jQuery2.fn[name] = function(data, fn2) {
                return arguments.length > 0 ? this.on(name, null, data, fn2) : this.trigger(name);
              };
            }
          );
          var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
          jQuery2.proxy = function(fn2, context) {
            var tmp, args, proxy2;
            if (typeof context === "string") {
              tmp = fn2[context];
              context = fn2;
              fn2 = tmp;
            }
            if (!isFunction2(fn2)) {
              return void 0;
            }
            args = slice.call(arguments, 2);
            proxy2 = function() {
              return fn2.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy2.guid = fn2.guid = fn2.guid || jQuery2.guid++;
            return proxy2;
          };
          jQuery2.holdReady = function(hold) {
            if (hold) {
              jQuery2.readyWait++;
            } else {
              jQuery2.ready(true);
            }
          };
          jQuery2.isArray = Array.isArray;
          jQuery2.parseJSON = JSON.parse;
          jQuery2.nodeName = nodeName;
          jQuery2.isFunction = isFunction2;
          jQuery2.isWindow = isWindow;
          jQuery2.camelCase = camelCase2;
          jQuery2.type = toType;
          jQuery2.now = Date.now;
          jQuery2.isNumeric = function(obj) {
            var type = jQuery2.type(obj);
            return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            !isNaN(obj - parseFloat(obj));
          };
          jQuery2.trim = function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "$1");
          };
          var _jQuery = window2.jQuery, _$ = window2.$;
          jQuery2.noConflict = function(deep) {
            if (window2.$ === jQuery2) {
              window2.$ = _$;
            }
            if (deep && window2.jQuery === jQuery2) {
              window2.jQuery = _jQuery;
            }
            return jQuery2;
          };
          if (typeof noGlobal === "undefined") {
            window2.jQuery = window2.$ = jQuery2;
          }
          return jQuery2;
        });
      })(jquery);
      var jqueryExports = jquery.exports;
      const $ = /* @__PURE__ */ getDefaultExportFromCjs(jqueryExports);
      {
        _monkeyWindow.jQuery = $;
      }
      /*!
       * Copyright 2012, Chris Wanstrath
       * Released under the MIT License
       * https://github.com/defunkt/jquery-pjax
       */
      (function($2) {
        function fnPjax(selector, container, options) {
          options = optionsFor(container, options);
          return this.on("click.pjax", selector, function(event) {
            var opts = options;
            if (!opts.container) {
              opts = $2.extend({}, options);
              opts.container = $2(this).attr("data-pjax");
            }
            handleClick(event, opts);
          });
        }
        function handleClick(event, container, options) {
          options = optionsFor(container, options);
          var link = event.currentTarget;
          var $link = $2(link);
          if (link.tagName.toUpperCase() !== "A")
            throw "$.fn.pjax or $.pjax.click requires an anchor element";
          if (event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey)
            return;
          if (location.protocol !== link.protocol || location.hostname !== link.hostname)
            return;
          if (link.href.indexOf("#") > -1 && stripHash(link) == stripHash(location))
            return;
          if (event.isDefaultPrevented())
            return;
          var defaults = {
            url: link.href,
            container: $link.attr("data-pjax"),
            target: link
          };
          var opts = $2.extend({}, defaults, options);
          var clickEvent = $2.Event("pjax:click");
          $link.trigger(clickEvent, [opts]);
          if (!clickEvent.isDefaultPrevented()) {
            pjax(opts);
            event.preventDefault();
            $link.trigger("pjax:clicked", [opts]);
          }
        }
        function handleSubmit(event, container, options) {
          options = optionsFor(container, options);
          var form = event.currentTarget;
          var $form = $2(form);
          if (form.tagName.toUpperCase() !== "FORM")
            throw "$.pjax.submit requires a form element";
          var defaults = {
            type: ($form.attr("method") || "GET").toUpperCase(),
            url: $form.attr("action"),
            container: $form.attr("data-pjax"),
            target: form
          };
          if (defaults.type !== "GET" && window.FormData !== void 0) {
            defaults.data = new FormData(form);
            defaults.processData = false;
            defaults.contentType = false;
          } else {
            if ($form.find(":file").length) {
              return;
            }
            defaults.data = $form.serializeArray();
          }
          pjax($2.extend({}, defaults, options));
          event.preventDefault();
        }
        function pjax(options) {
          options = $2.extend(true, {}, $2.ajaxSettings, pjax.defaults, options);
          if ($2.isFunction(options.url)) {
            options.url = options.url();
          }
          var hash = parseURL(options.url).hash;
          var containerType = $2.type(options.container);
          if (containerType !== "string") {
            throw "expected string value for 'container' option; got " + containerType;
          }
          var context = options.context = $2(options.container);
          if (!context.length) {
            throw "the container selector '" + options.container + "' did not match anything";
          }
          if (!options.data)
            options.data = {};
          if ($2.isArray(options.data)) {
            options.data.push({ name: "_pjax", value: options.container });
          } else {
            options.data._pjax = options.container;
          }
          function fire(type, args, props) {
            if (!props)
              props = {};
            props.relatedTarget = options.target;
            var event = $2.Event(type, props);
            context.trigger(event, args);
            return !event.isDefaultPrevented();
          }
          var timeoutTimer;
          options.beforeSend = function(xhr2, settings2) {
            if (settings2.type !== "GET") {
              settings2.timeout = 0;
            }
            xhr2.setRequestHeader("X-PJAX", "true");
            xhr2.setRequestHeader("X-PJAX-Container", options.container);
            if (!fire("pjax:beforeSend", [xhr2, settings2]))
              return false;
            if (settings2.timeout > 0) {
              timeoutTimer = setTimeout(function() {
                if (fire("pjax:timeout", [xhr2, options]))
                  xhr2.abort("timeout");
              }, settings2.timeout);
              settings2.timeout = 0;
            }
            var url = parseURL(settings2.url);
            if (hash)
              url.hash = hash;
            options.requestUrl = stripInternalParams(url);
          };
          options.complete = function(xhr2, textStatus) {
            if (timeoutTimer)
              clearTimeout(timeoutTimer);
            fire("pjax:complete", [xhr2, textStatus, options]);
            fire("pjax:end", [xhr2, options]);
          };
          options.error = function(xhr2, textStatus, errorThrown) {
            var container = extractContainer("", xhr2, options);
            var allowed = fire("pjax:error", [xhr2, textStatus, errorThrown, options]);
            if (options.type == "GET" && textStatus !== "abort" && allowed) {
              locationReplace(container.url);
            }
          };
          options.success = function(data, status, xhr2) {
            var previousState = pjax.state;
            var currentVersion = typeof $2.pjax.defaults.version === "function" ? $2.pjax.defaults.version() : $2.pjax.defaults.version;
            var latestVersion = xhr2.getResponseHeader("X-PJAX-Version");
            var container = extractContainer(data, xhr2, options);
            var url = parseURL(container.url);
            if (hash) {
              url.hash = hash;
              container.url = url.href;
            }
            if (currentVersion && latestVersion && currentVersion !== latestVersion) {
              locationReplace(container.url);
              return;
            }
            if (!container.contents) {
              locationReplace(container.url);
              return;
            }
            pjax.state = {
              id: options.id || uniqueId(),
              url: container.url,
              title: container.title,
              container: options.container,
              fragment: options.fragment,
              timeout: options.timeout
            };
            if (options.push || options.replace) {
              window.history.replaceState(pjax.state, container.title, container.url);
            }
            var blurFocus = $2.contains(context, document.activeElement);
            if (blurFocus) {
              try {
                document.activeElement.blur();
              } catch (e) {
              }
            }
            if (container.title)
              document.title = container.title;
            fire("pjax:beforeReplace", [container.contents, options], {
              state: pjax.state,
              previousState
            });
            context.html(container.contents);
            var autofocusEl = context.find("input[autofocus], textarea[autofocus]").last()[0];
            if (autofocusEl && document.activeElement !== autofocusEl) {
              autofocusEl.focus();
            }
            executeScriptTags(container.scripts);
            var scrollTo = options.scrollTo;
            if (hash) {
              var name = decodeURIComponent(hash.slice(1));
              var target = document.getElementById(name) || document.getElementsByName(name)[0];
              if (target)
                scrollTo = $2(target).offset().top;
            }
            if (typeof scrollTo == "number")
              $2(window).scrollTop(scrollTo);
            fire("pjax:success", [data, status, xhr2, options]);
          };
          if (!pjax.state) {
            pjax.state = {
              id: uniqueId(),
              url: window.location.href,
              title: document.title,
              container: options.container,
              fragment: options.fragment,
              timeout: options.timeout
            };
            window.history.replaceState(pjax.state, document.title);
          }
          abortXHR(pjax.xhr);
          pjax.options = options;
          var xhr = pjax.xhr = $2.ajax(options);
          if (xhr.readyState > 0) {
            if (options.push && !options.replace) {
              cachePush(pjax.state.id, [options.container, cloneContents(context)]);
              window.history.pushState(null, "", options.requestUrl);
            }
            fire("pjax:start", [xhr, options]);
            fire("pjax:send", [xhr, options]);
          }
          return pjax.xhr;
        }
        function pjaxReload(container, options) {
          var defaults = {
            url: window.location.href,
            push: false,
            replace: true,
            scrollTo: false
          };
          return pjax($2.extend(defaults, optionsFor(container, options)));
        }
        function locationReplace(url) {
          window.history.replaceState(null, "", pjax.state.url);
          window.location.replace(url);
        }
        var initialPop = true;
        var initialURL = window.location.href;
        var initialState = window.history.state;
        if (initialState && initialState.container) {
          pjax.state = initialState;
        }
        if ("state" in window.history) {
          initialPop = false;
        }
        function onPjaxPopstate(event) {
          if (!initialPop) {
            abortXHR(pjax.xhr);
          }
          var previousState = pjax.state;
          var state = event.state;
          var direction;
          if (state && state.container) {
            if (initialPop && initialURL == state.url)
              return;
            if (previousState) {
              if (previousState.id === state.id)
                return;
              direction = previousState.id < state.id ? "forward" : "back";
            }
            var cache2 = cacheMapping[state.id] || [];
            var containerSelector = cache2[0] || state.container;
            var container = $2(containerSelector), contents = cache2[1];
            if (container.length) {
              if (previousState) {
                cachePop(direction, previousState.id, [containerSelector, cloneContents(container)]);
              }
              var popstateEvent = $2.Event("pjax:popstate", {
                state,
                direction
              });
              container.trigger(popstateEvent);
              var options = {
                id: state.id,
                url: state.url,
                container: containerSelector,
                push: false,
                fragment: state.fragment,
                timeout: state.timeout,
                scrollTo: false
              };
              if (contents) {
                container.trigger("pjax:start", [null, options]);
                pjax.state = state;
                if (state.title)
                  document.title = state.title;
                var beforeReplaceEvent = $2.Event("pjax:beforeReplace", {
                  state,
                  previousState
                });
                container.trigger(beforeReplaceEvent, [contents, options]);
                container.html(contents);
                container.trigger("pjax:end", [null, options]);
              } else {
                pjax(options);
              }
              container[0].offsetHeight;
            } else {
              locationReplace(location.href);
            }
          }
          initialPop = false;
        }
        function fallbackPjax(options) {
          var url = $2.isFunction(options.url) ? options.url() : options.url, method = options.type ? options.type.toUpperCase() : "GET";
          var form = $2("<form>", {
            method: method === "GET" ? "GET" : "POST",
            action: url,
            style: "display:none"
          });
          if (method !== "GET" && method !== "POST") {
            form.append($2("<input>", {
              type: "hidden",
              name: "_method",
              value: method.toLowerCase()
            }));
          }
          var data = options.data;
          if (typeof data === "string") {
            $2.each(data.split("&"), function(index, value) {
              var pair = value.split("=");
              form.append($2("<input>", { type: "hidden", name: pair[0], value: pair[1] }));
            });
          } else if ($2.isArray(data)) {
            $2.each(data, function(index, value) {
              form.append($2("<input>", { type: "hidden", name: value.name, value: value.value }));
            });
          } else if (typeof data === "object") {
            var key;
            for (key in data)
              form.append($2("<input>", { type: "hidden", name: key, value: data[key] }));
          }
          $2(document.body).append(form);
          form.submit();
        }
        function abortXHR(xhr) {
          if (xhr && xhr.readyState < 4) {
            xhr.onreadystatechange = $2.noop;
            xhr.abort();
          }
        }
        function uniqueId() {
          return (/* @__PURE__ */ new Date()).getTime();
        }
        function cloneContents(container) {
          var cloned = container.clone();
          cloned.find("script").each(function() {
            if (!this.src)
              $2._data(this, "globalEval", false);
          });
          return cloned.contents();
        }
        function stripInternalParams(url) {
          url.search = url.search.replace(/([?&])(_pjax|_)=[^&]*/g, "").replace(/^&/, "");
          return url.href.replace(/\?($|#)/, "$1");
        }
        function parseURL(url) {
          var a2 = document.createElement("a");
          a2.href = url;
          return a2;
        }
        function stripHash(location2) {
          return location2.href.replace(/#.*/, "");
        }
        function optionsFor(container, options) {
          if (container && options) {
            options = $2.extend({}, options);
            options.container = container;
            return options;
          } else if ($2.isPlainObject(container)) {
            return container;
          } else {
            return { container };
          }
        }
        function findAll(elems, selector) {
          return elems.filter(selector).add(elems.find(selector));
        }
        function parseHTML(html2) {
          return $2.parseHTML(html2, document, true);
        }
        function extractContainer(data, xhr, options) {
          var obj = {}, fullDocument = /<html/i.test(data);
          var serverUrl = xhr.getResponseHeader("X-PJAX-URL");
          obj.url = serverUrl ? stripInternalParams(parseURL(serverUrl)) : options.requestUrl;
          var $head, $body;
          if (fullDocument) {
            $body = $2(parseHTML(data.match(/<body[^>]*>([\s\S.]*)<\/body>/i)[0]));
            var head = data.match(/<head[^>]*>([\s\S.]*)<\/head>/i);
            $head = head != null ? $2(parseHTML(head[0])) : $body;
          } else {
            $head = $body = $2(parseHTML(data));
          }
          if ($body.length === 0)
            return obj;
          obj.title = findAll($head, "title").last().text();
          if (options.fragment) {
            var $fragment = $body;
            if (options.fragment !== "body") {
              $fragment = findAll($fragment, options.fragment).first();
            }
            if ($fragment.length) {
              obj.contents = options.fragment === "body" ? $fragment : $fragment.contents();
              if (!obj.title)
                obj.title = $fragment.attr("title") || $fragment.data("title");
            }
          } else if (!fullDocument) {
            obj.contents = $body;
          }
          if (obj.contents) {
            obj.contents = obj.contents.not(function() {
              return $2(this).is("title");
            });
            obj.contents.find("title").remove();
            obj.scripts = findAll(obj.contents, "script[src]").remove();
            obj.contents = obj.contents.not(obj.scripts);
          }
          if (obj.title)
            obj.title = $2.trim(obj.title);
          return obj;
        }
        function executeScriptTags(scripts) {
          if (!scripts)
            return;
          var existingScripts = $2("script[src]");
          scripts.each(function() {
            var src = this.src;
            var matchedScripts = existingScripts.filter(function() {
              return this.src === src;
            });
            if (matchedScripts.length)
              return;
            var script = document.createElement("script");
            var type = $2(this).attr("type");
            if (type)
              script.type = type;
            script.src = $2(this).attr("src");
            document.head.appendChild(script);
          });
        }
        var cacheMapping = {};
        var cacheForwardStack = [];
        var cacheBackStack = [];
        function cachePush(id, value) {
          cacheMapping[id] = value;
          cacheBackStack.push(id);
          trimCacheStack(cacheForwardStack, 0);
          trimCacheStack(cacheBackStack, pjax.defaults.maxCacheLength);
        }
        function cachePop(direction, id, value) {
          var pushStack, popStack;
          cacheMapping[id] = value;
          if (direction === "forward") {
            pushStack = cacheBackStack;
            popStack = cacheForwardStack;
          } else {
            pushStack = cacheForwardStack;
            popStack = cacheBackStack;
          }
          pushStack.push(id);
          id = popStack.pop();
          if (id)
            delete cacheMapping[id];
          trimCacheStack(pushStack, pjax.defaults.maxCacheLength);
        }
        function trimCacheStack(stack2, length) {
          while (stack2.length > length)
            delete cacheMapping[stack2.shift()];
        }
        function findVersion() {
          return $2("meta").filter(function() {
            var name = $2(this).attr("http-equiv");
            return name && name.toUpperCase() === "X-PJAX-VERSION";
          }).attr("content");
        }
        function enable() {
          $2.fn.pjax = fnPjax;
          $2.pjax = pjax;
          $2.pjax.enable = $2.noop;
          $2.pjax.disable = disable;
          $2.pjax.click = handleClick;
          $2.pjax.submit = handleSubmit;
          $2.pjax.reload = pjaxReload;
          $2.pjax.defaults = {
            timeout: 650,
            push: true,
            replace: false,
            type: "GET",
            dataType: "html",
            scrollTo: 0,
            maxCacheLength: 20,
            version: findVersion
          };
          $2(window).on("popstate.pjax", onPjaxPopstate);
        }
        function disable() {
          $2.fn.pjax = function() {
            return this;
          };
          $2.pjax = fallbackPjax;
          $2.pjax.enable = enable;
          $2.pjax.disable = $2.noop;
          $2.pjax.click = $2.noop;
          $2.pjax.submit = $2.noop;
          $2.pjax.reload = function() {
            window.location.reload();
          };
          $2(window).off("popstate.pjax", onPjaxPopstate);
        }
        if ($2.event.props && $2.inArray("state", $2.event.props) < 0) {
          $2.event.props.push("state");
        } else if (!("state" in $2.Event.prototype)) {
          $2.event.addProp("state");
        }
        $2.support.pjax = window.history && window.history.pushState && window.history.replaceState && // pushState isn't reliable on iOS until 5.
        !navigator.userAgent.match(/((iPod|iPhone|iPad).+\bOS\s+[1-4]\D|WebApps\/.+CFNetwork)/);
        if ($2.support.pjax) {
          enable();
        } else {
          disable();
        }
      })(jQuery);
      /**
      * @vue/shared v3.4.21
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      function makeMap(str, expectsLowerCase) {
        const set2 = new Set(str.split(","));
        return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
      }
      const EMPTY_OBJ = {};
      const EMPTY_ARR = [];
      const NOOP = () => {
      };
      const NO = () => false;
      const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
      (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
      const isModelListener = (key) => key.startsWith("onUpdate:");
      const extend = Object.assign;
      const remove = (arr, el) => {
        const i = arr.indexOf(el);
        if (i > -1) {
          arr.splice(i, 1);
        }
      };
      const hasOwnProperty$i = Object.prototype.hasOwnProperty;
      const hasOwn$1 = (val, key) => hasOwnProperty$i.call(val, key);
      const isArray$2 = Array.isArray;
      const isMap$1 = (val) => toTypeString$1(val) === "[object Map]";
      const isSet$1 = (val) => toTypeString$1(val) === "[object Set]";
      const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
      const isFunction$2 = (val) => typeof val === "function";
      const isString$3 = (val) => typeof val === "string";
      const isSymbol$1 = (val) => typeof val === "symbol";
      const isObject$5 = (val) => val !== null && typeof val === "object";
      const isPromise$1 = (val) => {
        return (isObject$5(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
      };
      const objectToString$2 = Object.prototype.toString;
      const toTypeString$1 = (value) => objectToString$2.call(value);
      const toRawType = (value) => {
        return toTypeString$1(value).slice(8, -1);
      };
      const isPlainObject$2 = (val) => toTypeString$1(val) === "[object Object]";
      const isIntegerKey = (key) => isString$3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      const isReservedProp = /* @__PURE__ */ makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      );
      const cacheStringFunction = (fn2) => {
        const cache2 = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache2[str];
          return hit || (cache2[str] = fn2(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
      });
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction(
        (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
      );
      const capitalize$2 = cacheStringFunction((str) => {
        return str.charAt(0).toUpperCase() + str.slice(1);
      });
      const toHandlerKey = cacheStringFunction((str) => {
        const s2 = str ? `on${capitalize$2(str)}` : ``;
        return s2;
      });
      const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      const invokeArrayFns = (fns, arg) => {
        for (let i = 0; i < fns.length; i++) {
          fns[i](arg);
        }
      };
      const def = (obj, key, value) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
        });
      };
      const looseToNumber = (val) => {
        const n = parseFloat(val);
        return isNaN(n) ? val : n;
      };
      const toNumber$1 = (val) => {
        const n = isString$3(val) ? Number(val) : NaN;
        return isNaN(n) ? val : n;
      };
      let _globalThis$1;
      const getGlobalThis$1 = () => {
        return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      function normalizeStyle(value) {
        if (isArray$2(value)) {
          const res = {};
          for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString$3(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) {
              for (const key in normalized) {
                res[key] = normalized[key];
              }
            }
          }
          return res;
        } else if (isString$3(value) || isObject$5(value)) {
          return value;
        }
      }
      const listDelimiterRE = /;(?![^(]*\))/g;
      const propertyDelimiterRE = /:([^]+)/;
      const styleCommentRE = /\/\*[^]*?\*\//g;
      function parseStringStyle(cssText) {
        const ret = {};
        cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return ret;
      }
      function normalizeClass(value) {
        let res = "";
        if (isString$3(value)) {
          res = value;
        } else if (isArray$2(value)) {
          for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
              res += normalized + " ";
            }
          }
        } else if (isObject$5(value)) {
          for (const name in value) {
            if (value[name]) {
              res += name + " ";
            }
          }
        }
        return res.trim();
      }
      const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      function includeBooleanAttr(value) {
        return !!value || value === "";
      }
      function looseCompareArrays(a2, b2) {
        if (a2.length !== b2.length)
          return false;
        let equal = true;
        for (let i = 0; equal && i < a2.length; i++) {
          equal = looseEqual(a2[i], b2[i]);
        }
        return equal;
      }
      function looseEqual(a2, b2) {
        if (a2 === b2)
          return true;
        let aValidType = isDate$1(a2);
        let bValidType = isDate$1(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
        }
        aValidType = isSymbol$1(a2);
        bValidType = isSymbol$1(b2);
        if (aValidType || bValidType) {
          return a2 === b2;
        }
        aValidType = isArray$2(a2);
        bValidType = isArray$2(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
        }
        aValidType = isObject$5(a2);
        bValidType = isObject$5(b2);
        if (aValidType || bValidType) {
          if (!aValidType || !bValidType) {
            return false;
          }
          const aKeysCount = Object.keys(a2).length;
          const bKeysCount = Object.keys(b2).length;
          if (aKeysCount !== bKeysCount) {
            return false;
          }
          for (const key in a2) {
            const aHasKey = a2.hasOwnProperty(key);
            const bHasKey = b2.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
              return false;
            }
          }
        }
        return String(a2) === String(b2);
      }
      function looseIndexOf(arr, val) {
        return arr.findIndex((item) => looseEqual(item, val));
      }
      const toDisplayString$1 = (val) => {
        return isString$3(val) ? val : val == null ? "" : isArray$2(val) || isObject$5(val) && (val.toString === objectToString$2 || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
      };
      const replacer = (_key, val) => {
        if (val && val.__v_isRef) {
          return replacer(_key, val.value);
        } else if (isMap$1(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce(
              (entries, [key, val2], i) => {
                entries[stringifySymbol(key, i) + " =>"] = val2;
                return entries;
              },
              {}
            )
          };
        } else if (isSet$1(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
          };
        } else if (isSymbol$1(val)) {
          return stringifySymbol(val);
        } else if (isObject$5(val) && !isArray$2(val) && !isPlainObject$2(val)) {
          return String(val);
        }
        return val;
      };
      const stringifySymbol = (v2, i = "") => {
        var _a2;
        return isSymbol$1(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i})` : v2;
      };
      /**
      * @vue/reactivity v3.4.21
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      let activeEffectScope;
      class EffectScope {
        constructor(detached = false) {
          this.detached = detached;
          this._active = true;
          this.effects = [];
          this.cleanups = [];
          this.parent = activeEffectScope;
          if (!detached && activeEffectScope) {
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
              this
            ) - 1;
          }
        }
        get active() {
          return this._active;
        }
        run(fn2) {
          if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
              activeEffectScope = this;
              return fn2();
            } finally {
              activeEffectScope = currentEffectScope;
            }
          }
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        on() {
          activeEffectScope = this;
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        off() {
          activeEffectScope = this.parent;
        }
        stop(fromParent) {
          if (this._active) {
            let i, l2;
            for (i = 0, l2 = this.effects.length; i < l2; i++) {
              this.effects[i].stop();
            }
            for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
              this.cleanups[i]();
            }
            if (this.scopes) {
              for (i = 0, l2 = this.scopes.length; i < l2; i++) {
                this.scopes[i].stop(true);
              }
            }
            if (!this.detached && this.parent && !fromParent) {
              const last2 = this.parent.scopes.pop();
              if (last2 && last2 !== this) {
                this.parent.scopes[this.index] = last2;
                last2.index = this.index;
              }
            }
            this.parent = void 0;
            this._active = false;
          }
        }
      }
      function effectScope(detached) {
        return new EffectScope(detached);
      }
      function recordEffectScope(effect2, scope = activeEffectScope) {
        if (scope && scope.active) {
          scope.effects.push(effect2);
        }
      }
      function getCurrentScope() {
        return activeEffectScope;
      }
      function onScopeDispose(fn2) {
        if (activeEffectScope) {
          activeEffectScope.cleanups.push(fn2);
        }
      }
      let activeEffect;
      class ReactiveEffect {
        constructor(fn2, trigger2, scheduler, scope) {
          this.fn = fn2;
          this.trigger = trigger2;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          this._dirtyLevel = 4;
          this._trackId = 0;
          this._runnings = 0;
          this._shouldSchedule = false;
          this._depsLength = 0;
          recordEffectScope(this, scope);
        }
        get dirty() {
          if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1;
            pauseTracking();
            for (let i = 0; i < this._depsLength; i++) {
              const dep = this.deps[i];
              if (dep.computed) {
                triggerComputed(dep.computed);
                if (this._dirtyLevel >= 4) {
                  break;
                }
              }
            }
            if (this._dirtyLevel === 1) {
              this._dirtyLevel = 0;
            }
            resetTracking();
          }
          return this._dirtyLevel >= 4;
        }
        set dirty(v2) {
          this._dirtyLevel = v2 ? 4 : 0;
        }
        run() {
          this._dirtyLevel = 0;
          if (!this.active) {
            return this.fn();
          }
          let lastShouldTrack = shouldTrack;
          let lastEffect = activeEffect;
          try {
            shouldTrack = true;
            activeEffect = this;
            this._runnings++;
            preCleanupEffect(this);
            return this.fn();
          } finally {
            postCleanupEffect(this);
            this._runnings--;
            activeEffect = lastEffect;
            shouldTrack = lastShouldTrack;
          }
        }
        stop() {
          var _a2;
          if (this.active) {
            preCleanupEffect(this);
            postCleanupEffect(this);
            (_a2 = this.onStop) == null ? void 0 : _a2.call(this);
            this.active = false;
          }
        }
      }
      function triggerComputed(computed2) {
        return computed2.value;
      }
      function preCleanupEffect(effect2) {
        effect2._trackId++;
        effect2._depsLength = 0;
      }
      function postCleanupEffect(effect2) {
        if (effect2.deps.length > effect2._depsLength) {
          for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
            cleanupDepEffect(effect2.deps[i], effect2);
          }
          effect2.deps.length = effect2._depsLength;
        }
      }
      function cleanupDepEffect(dep, effect2) {
        const trackId = dep.get(effect2);
        if (trackId !== void 0 && effect2._trackId !== trackId) {
          dep.delete(effect2);
          if (dep.size === 0) {
            dep.cleanup();
          }
        }
      }
      let shouldTrack = true;
      let pauseScheduleStack = 0;
      const trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function resetTracking() {
        const last2 = trackStack.pop();
        shouldTrack = last2 === void 0 ? true : last2;
      }
      function pauseScheduling() {
        pauseScheduleStack++;
      }
      function resetScheduling() {
        pauseScheduleStack--;
        while (!pauseScheduleStack && queueEffectSchedulers.length) {
          queueEffectSchedulers.shift()();
        }
      }
      function trackEffect(effect2, dep, debuggerEventExtraInfo) {
        if (dep.get(effect2) !== effect2._trackId) {
          dep.set(effect2, effect2._trackId);
          const oldDep = effect2.deps[effect2._depsLength];
          if (oldDep !== dep) {
            if (oldDep) {
              cleanupDepEffect(oldDep, effect2);
            }
            effect2.deps[effect2._depsLength++] = dep;
          } else {
            effect2._depsLength++;
          }
        }
      }
      const queueEffectSchedulers = [];
      function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
        pauseScheduling();
        for (const effect2 of dep.keys()) {
          let tracking;
          if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
            effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
            effect2._dirtyLevel = dirtyLevel;
          }
          if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
            effect2.trigger();
            if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
              effect2._shouldSchedule = false;
              if (effect2.scheduler) {
                queueEffectSchedulers.push(effect2.scheduler);
              }
            }
          }
        }
        resetScheduling();
      }
      const createDep = (cleanup, computed2) => {
        const dep = /* @__PURE__ */ new Map();
        dep.cleanup = cleanup;
        dep.computed = computed2;
        return dep;
      };
      const targetMap = /* @__PURE__ */ new WeakMap();
      const ITERATE_KEY = Symbol("");
      const MAP_KEY_ITERATE_KEY = Symbol("");
      function track(target, type, key) {
        if (shouldTrack && activeEffect) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
            targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
          }
          let dep = depsMap.get(key);
          if (!dep) {
            depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
          }
          trackEffect(
            activeEffect,
            dep
          );
        }
      }
      function trigger(target, type, key, newValue, oldValue, oldTarget) {
        const depsMap = targetMap.get(target);
        if (!depsMap) {
          return;
        }
        let deps = [];
        if (type === "clear") {
          deps = [...depsMap.values()];
        } else if (key === "length" && isArray$2(target)) {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || !isSymbol$1(key2) && key2 >= newLength) {
              deps.push(dep);
            }
          });
        } else {
          if (key !== void 0) {
            deps.push(depsMap.get(key));
          }
          switch (type) {
            case "add":
              if (!isArray$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (isMap$1(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isIntegerKey(key)) {
                deps.push(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!isArray$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (isMap$1(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap$1(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
        pauseScheduling();
        for (const dep of deps) {
          if (dep) {
            triggerEffects(
              dep,
              4
            );
          }
        }
        resetScheduling();
      }
      function getDepFromReactive(object, key) {
        var _a2;
        return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
      }
      const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
      const builtInSymbols = new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
      );
      const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
      function createArrayInstrumentations() {
        const instrumentations = {};
        ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
          instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for (let i = 0, l2 = this.length; i < l2; i++) {
              track(arr, "get", i + "");
            }
            const res = arr[key](...args);
            if (res === -1 || res === false) {
              return arr[key](...args.map(toRaw));
            } else {
              return res;
            }
          };
        });
        ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
          instrumentations[key] = function(...args) {
            pauseTracking();
            pauseScheduling();
            const res = toRaw(this)[key].apply(this, args);
            resetScheduling();
            resetTracking();
            return res;
          };
        });
        return instrumentations;
      }
      function hasOwnProperty$h(key) {
        const obj = toRaw(this);
        track(obj, "has", key);
        return obj.hasOwnProperty(key);
      }
      class BaseReactiveHandler {
        constructor(_isReadonly = false, _isShallow = false) {
          this._isReadonly = _isReadonly;
          this._isShallow = _isShallow;
        }
        get(target, key, receiver) {
          const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_isShallow") {
            return isShallow2;
          } else if (key === "__v_raw") {
            if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
            // this means the reciever is a user proxy of the reactive proxy
            Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
              return target;
            }
            return;
          }
          const targetIsArray = isArray$2(target);
          if (!isReadonly2) {
            if (targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
              return Reflect.get(arrayInstrumentations, key, receiver);
            }
            if (key === "hasOwnProperty") {
              return hasOwnProperty$h;
            }
          }
          const res = Reflect.get(target, key, receiver);
          if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
          }
          if (!isReadonly2) {
            track(target, "get", key);
          }
          if (isShallow2) {
            return res;
          }
          if (isRef(res)) {
            return targetIsArray && isIntegerKey(key) ? res : res.value;
          }
          if (isObject$5(res)) {
            return isReadonly2 ? readonly(res) : reactive(res);
          }
          return res;
        }
      }
      class MutableReactiveHandler extends BaseReactiveHandler {
        constructor(isShallow2 = false) {
          super(false, isShallow2);
        }
        set(target, key, value, receiver) {
          let oldValue = target[key];
          if (!this._isShallow) {
            const isOldValueReadonly = isReadonly(oldValue);
            if (!isShallow(value) && !isReadonly(value)) {
              oldValue = toRaw(oldValue);
              value = toRaw(value);
            }
            if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
              if (isOldValueReadonly) {
                return false;
              } else {
                oldValue.value = value;
                return true;
              }
            }
          }
          const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
          const result = Reflect.set(target, key, value, receiver);
          if (target === toRaw(receiver)) {
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger(target, "set", key, value);
            }
          }
          return result;
        }
        deleteProperty(target, key) {
          const hadKey = hasOwn$1(target, key);
          target[key];
          const result = Reflect.deleteProperty(target, key);
          if (result && hadKey) {
            trigger(target, "delete", key, void 0);
          }
          return result;
        }
        has(target, key) {
          const result = Reflect.has(target, key);
          if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
            track(target, "has", key);
          }
          return result;
        }
        ownKeys(target) {
          track(
            target,
            "iterate",
            isArray$2(target) ? "length" : ITERATE_KEY
          );
          return Reflect.ownKeys(target);
        }
      }
      class ReadonlyReactiveHandler extends BaseReactiveHandler {
        constructor(isShallow2 = false) {
          super(true, isShallow2);
        }
        set(target, key) {
          return true;
        }
        deleteProperty(target, key) {
          return true;
        }
      }
      const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
      const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
      const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
        true
      );
      const toShallow = (value) => value;
      const getProto = (v2) => Reflect.getPrototypeOf(v2);
      function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
        target = target["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has: has2 } = getProto(rawTarget);
        const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        if (has2.call(rawTarget, key)) {
          return wrap2(target.get(key));
        } else if (has2.call(rawTarget, rawKey)) {
          return wrap2(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      }
      function has(key, isReadonly2 = false) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      }
      function size(target, isReadonly2 = false) {
        target = target["__v_raw"];
        !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      }
      function add(value) {
        value = toRaw(value);
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      }
      function set$1(key, value) {
        value = toRaw(value);
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        }
        const oldValue = get2.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      }
      function deleteEntry(key) {
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        }
        get2 ? get2.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      function clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(target, "clear", void 0, void 0);
        }
        return result;
      }
      function createForEach(isReadonly2, isShallow2) {
        return function forEach2(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap2(value), wrap2(key), observed);
          });
        };
      }
      function createIterableMethod(method, isReadonly2, isShallow2) {
        return function(...args) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const targetIsMap = isMap$1(rawTarget);
          const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
          const isKeyOnly = method === "keys" && targetIsMap;
          const innerIterator = target[method](...args);
          const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(
            rawTarget,
            "iterate",
            isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
          );
          return {
            // iterator protocol
            next() {
              const { value, done } = innerIterator.next();
              return done ? { value, done } : {
                value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
                done
              };
            },
            // iterable protocol
            [Symbol.iterator]() {
              return this;
            }
          };
        };
      }
      function createReadonlyMethod(type) {
        return function(...args) {
          return type === "delete" ? false : type === "clear" ? void 0 : this;
        };
      }
      function createInstrumentations() {
        const mutableInstrumentations2 = {
          get(key) {
            return get$1(this, key);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set: set$1,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, false)
        };
        const shallowInstrumentations2 = {
          get(key) {
            return get$1(this, key, false, true);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set: set$1,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, true)
        };
        const readonlyInstrumentations2 = {
          get(key) {
            return get$1(this, key, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, false)
        };
        const shallowReadonlyInstrumentations2 = {
          get(key) {
            return get$1(this, key, true, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, true)
        };
        const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
        iteratorMethods.forEach((method) => {
          mutableInstrumentations2[method] = createIterableMethod(
            method,
            false,
            false
          );
          readonlyInstrumentations2[method] = createIterableMethod(
            method,
            true,
            false
          );
          shallowInstrumentations2[method] = createIterableMethod(
            method,
            false,
            true
          );
          shallowReadonlyInstrumentations2[method] = createIterableMethod(
            method,
            true,
            true
          );
        });
        return [
          mutableInstrumentations2,
          readonlyInstrumentations2,
          shallowInstrumentations2,
          shallowReadonlyInstrumentations2
        ];
      }
      const [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
      ] = /* @__PURE__ */ createInstrumentations();
      function createInstrumentationGetter(isReadonly2, shallow) {
        const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
        return (target, key, receiver) => {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_raw") {
            return target;
          }
          return Reflect.get(
            hasOwn$1(instrumentations, key) && key in target ? instrumentations : target,
            key,
            receiver
          );
        };
      }
      const mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      const shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      const readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      const reactiveMap = /* @__PURE__ */ new WeakMap();
      const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
      const readonlyMap = /* @__PURE__ */ new WeakMap();
      const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
      function targetTypeMap(rawType) {
        switch (rawType) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      }
      function getTargetType(value) {
        return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
      }
      function reactive(target) {
        if (isReadonly(target)) {
          return target;
        }
        return createReactiveObject(
          target,
          false,
          mutableHandlers,
          mutableCollectionHandlers,
          reactiveMap
        );
      }
      function shallowReactive(target) {
        return createReactiveObject(
          target,
          false,
          shallowReactiveHandlers,
          shallowCollectionHandlers,
          shallowReactiveMap
        );
      }
      function readonly(target) {
        return createReactiveObject(
          target,
          true,
          readonlyHandlers,
          readonlyCollectionHandlers,
          readonlyMap
        );
      }
      function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
        if (!isObject$5(target)) {
          return target;
        }
        if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
          return target;
        }
        const existingProxy = proxyMap.get(target);
        if (existingProxy) {
          return existingProxy;
        }
        const targetType = getTargetType(target);
        if (targetType === 0) {
          return target;
        }
        const proxy2 = new Proxy(
          target,
          targetType === 2 ? collectionHandlers : baseHandlers
        );
        proxyMap.set(target, proxy2);
        return proxy2;
      }
      function isReactive(value) {
        if (isReadonly(value)) {
          return isReactive(value["__v_raw"]);
        }
        return !!(value && value["__v_isReactive"]);
      }
      function isReadonly(value) {
        return !!(value && value["__v_isReadonly"]);
      }
      function isShallow(value) {
        return !!(value && value["__v_isShallow"]);
      }
      function isProxy(value) {
        return isReactive(value) || isReadonly(value);
      }
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      function markRaw(value) {
        if (Object.isExtensible(value)) {
          def(value, "__v_skip", true);
        }
        return value;
      }
      const toReactive = (value) => isObject$5(value) ? reactive(value) : value;
      const toReadonly = (value) => isObject$5(value) ? readonly(value) : value;
      class ComputedRefImpl {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this.getter = getter;
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this["__v_isReadonly"] = false;
          this.effect = new ReactiveEffect(
            () => getter(this._value),
            () => triggerRefValue(
              this,
              this.effect._dirtyLevel === 2 ? 2 : 3
            )
          );
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
            triggerRefValue(self2, 4);
          }
          trackRefValue(self2);
          if (self2.effect._dirtyLevel >= 2) {
            triggerRefValue(self2, 2);
          }
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
        // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
        get _dirty() {
          return this.effect.dirty;
        }
        set _dirty(v2) {
          this.effect.dirty = v2;
        }
        // #endregion
      }
      function computed$1(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        const onlyGetter = isFunction$2(getterOrOptions);
        if (onlyGetter) {
          getter = getterOrOptions;
          setter = NOOP;
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        return cRef;
      }
      function trackRefValue(ref2) {
        var _a2;
        if (shouldTrack && activeEffect) {
          ref2 = toRaw(ref2);
          trackEffect(
            activeEffect,
            (_a2 = ref2.dep) != null ? _a2 : ref2.dep = createDep(
              () => ref2.dep = void 0,
              ref2 instanceof ComputedRefImpl ? ref2 : void 0
            )
          );
        }
      }
      function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
        ref2 = toRaw(ref2);
        const dep = ref2.dep;
        if (dep) {
          triggerEffects(
            dep,
            dirtyLevel
          );
        }
      }
      function isRef(r) {
        return !!(r && r.__v_isRef === true);
      }
      function ref(value) {
        return createRef(value, false);
      }
      function shallowRef(value) {
        return createRef(value, true);
      }
      function createRef(rawValue, shallow) {
        if (isRef(rawValue)) {
          return rawValue;
        }
        return new RefImpl(rawValue, shallow);
      }
      class RefImpl {
        constructor(value, __v_isShallow) {
          this.__v_isShallow = __v_isShallow;
          this.dep = void 0;
          this.__v_isRef = true;
          this._rawValue = __v_isShallow ? value : toRaw(value);
          this._value = __v_isShallow ? value : toReactive(value);
        }
        get value() {
          trackRefValue(this);
          return this._value;
        }
        set value(newVal) {
          const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
          newVal = useDirectValue ? newVal : toRaw(newVal);
          if (hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this, 4);
          }
        }
      }
      function unref(ref2) {
        return isRef(ref2) ? ref2.value : ref2;
      }
      const shallowUnwrapHandlers = {
        get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
        set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          } else {
            return Reflect.set(target, key, value, receiver);
          }
        }
      };
      function proxyRefs(objectWithRefs) {
        return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
      }
      function toRefs(object) {
        const ret = isArray$2(object) ? new Array(object.length) : {};
        for (const key in object) {
          ret[key] = propertyToRef(object, key);
        }
        return ret;
      }
      class ObjectRefImpl {
        constructor(_object, _key, _defaultValue) {
          this._object = _object;
          this._key = _key;
          this._defaultValue = _defaultValue;
          this.__v_isRef = true;
        }
        get value() {
          const val = this._object[this._key];
          return val === void 0 ? this._defaultValue : val;
        }
        set value(newVal) {
          this._object[this._key] = newVal;
        }
        get dep() {
          return getDepFromReactive(toRaw(this._object), this._key);
        }
      }
      class GetterRefImpl {
        constructor(_getter) {
          this._getter = _getter;
          this.__v_isRef = true;
          this.__v_isReadonly = true;
        }
        get value() {
          return this._getter();
        }
      }
      function toRef(source, key, defaultValue) {
        if (isRef(source)) {
          return source;
        } else if (isFunction$2(source)) {
          return new GetterRefImpl(source);
        } else if (isObject$5(source) && arguments.length > 1) {
          return propertyToRef(source, key, defaultValue);
        } else {
          return ref(source);
        }
      }
      function propertyToRef(source, key, defaultValue) {
        const val = source[key];
        return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
      }
      /**
      * @vue/runtime-core v3.4.21
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const stack = [];
      function warn$1(msg, ...args) {
        pauseTracking();
        const instance = stack.length ? stack[stack.length - 1].component : null;
        const appWarnHandler = instance && instance.appContext.config.warnHandler;
        const trace = getComponentTrace();
        if (appWarnHandler) {
          callWithErrorHandling(
            appWarnHandler,
            instance,
            11,
            [
              msg + args.map((a2) => {
                var _a2, _b;
                return (_b = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b : JSON.stringify(a2);
              }).join(""),
              instance && instance.proxy,
              trace.map(
                ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
              ).join("\n"),
              trace
            ]
          );
        } else {
          const warnArgs = [`[Vue warn]: ${msg}`, ...args];
          if (trace.length && // avoid spamming console during tests
          true) {
            warnArgs.push(`
`, ...formatTrace(trace));
          }
          console.warn(...warnArgs);
        }
        resetTracking();
      }
      function getComponentTrace() {
        let currentVNode = stack[stack.length - 1];
        if (!currentVNode) {
          return [];
        }
        const normalizedStack = [];
        while (currentVNode) {
          const last2 = normalizedStack[0];
          if (last2 && last2.vnode === currentVNode) {
            last2.recurseCount++;
          } else {
            normalizedStack.push({
              vnode: currentVNode,
              recurseCount: 0
            });
          }
          const parentInstance = currentVNode.component && currentVNode.component.parent;
          currentVNode = parentInstance && parentInstance.vnode;
        }
        return normalizedStack;
      }
      function formatTrace(trace) {
        const logs = [];
        trace.forEach((entry, i) => {
          logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
        });
        return logs;
      }
      function formatTraceEntry({ vnode, recurseCount }) {
        const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
        const isRoot = vnode.component ? vnode.component.parent == null : false;
        const open2 = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
        const close = `>` + postfix;
        return vnode.props ? [open2, ...formatProps(vnode.props), close] : [open2 + close];
      }
      function formatProps(props) {
        const res = [];
        const keys2 = Object.keys(props);
        keys2.slice(0, 3).forEach((key) => {
          res.push(...formatProp(key, props[key]));
        });
        if (keys2.length > 3) {
          res.push(` ...`);
        }
        return res;
      }
      function formatProp(key, value, raw) {
        if (isString$3(value)) {
          value = JSON.stringify(value);
          return raw ? value : [`${key}=${value}`];
        } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
          return raw ? value : [`${key}=${value}`];
        } else if (isRef(value)) {
          value = formatProp(key, toRaw(value.value), true);
          return raw ? value : [`${key}=Ref<`, value, `>`];
        } else if (isFunction$2(value)) {
          return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
        } else {
          value = toRaw(value);
          return raw ? value : [`${key}=`, value];
        }
      }
      function callWithErrorHandling(fn2, instance, type, args) {
        try {
          return args ? fn2(...args) : fn2();
        } catch (err) {
          handleError(err, instance, type);
        }
      }
      function callWithAsyncErrorHandling(fn2, instance, type, args) {
        if (isFunction$2(fn2)) {
          const res = callWithErrorHandling(fn2, instance, type, args);
          if (res && isPromise$1(res)) {
            res.catch((err) => {
              handleError(err, instance, type);
            });
          }
          return res;
        }
        const values2 = [];
        for (let i = 0; i < fn2.length; i++) {
          values2.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
        }
        return values2;
      }
      function handleError(err, instance, type, throwInDev = true) {
        const contextVNode = instance ? instance.vnode : null;
        if (instance) {
          let cur = instance.parent;
          const exposedInstance = instance.proxy;
          const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
          while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
              for (let i = 0; i < errorCapturedHooks.length; i++) {
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                  return;
                }
              }
            }
            cur = cur.parent;
          }
          const appErrorHandler = instance.appContext.config.errorHandler;
          if (appErrorHandler) {
            callWithErrorHandling(
              appErrorHandler,
              null,
              10,
              [err, exposedInstance, errorInfo]
            );
            return;
          }
        }
        logError(err, type, contextVNode, throwInDev);
      }
      function logError(err, type, contextVNode, throwInDev = true) {
        {
          console.error(err);
        }
      }
      let isFlushing = false;
      let isFlushPending = false;
      const queue = [];
      let flushIndex = 0;
      const pendingPostFlushCbs = [];
      let activePostFlushCbs = null;
      let postFlushIndex = 0;
      const resolvedPromise = /* @__PURE__ */ Promise.resolve();
      let currentFlushPromise = null;
      function nextTick(fn2) {
        const p2 = currentFlushPromise || resolvedPromise;
        return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
      }
      function findInsertionIndex(id) {
        let start = flushIndex + 1;
        let end2 = queue.length;
        while (start < end2) {
          const middle = start + end2 >>> 1;
          const middleJob = queue[middle];
          const middleJobId = getId(middleJob);
          if (middleJobId < id || middleJobId === id && middleJob.pre) {
            start = middle + 1;
          } else {
            end2 = middle;
          }
        }
        return start;
      }
      function queueJob(job) {
        if (!queue.length || !queue.includes(
          job,
          isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
        )) {
          if (job.id == null) {
            queue.push(job);
          } else {
            queue.splice(findInsertionIndex(job.id), 0, job);
          }
          queueFlush();
        }
      }
      function queueFlush() {
        if (!isFlushing && !isFlushPending) {
          isFlushPending = true;
          currentFlushPromise = resolvedPromise.then(flushJobs);
        }
      }
      function invalidateJob(job) {
        const i = queue.indexOf(job);
        if (i > flushIndex) {
          queue.splice(i, 1);
        }
      }
      function queuePostFlushCb(cb) {
        if (!isArray$2(cb)) {
          if (!activePostFlushCbs || !activePostFlushCbs.includes(
            cb,
            cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
          )) {
            pendingPostFlushCbs.push(cb);
          }
        } else {
          pendingPostFlushCbs.push(...cb);
        }
        queueFlush();
      }
      function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
        for (; i < queue.length; i++) {
          const cb = queue[i];
          if (cb && cb.pre) {
            if (instance && cb.id !== instance.uid) {
              continue;
            }
            queue.splice(i, 1);
            i--;
            cb();
          }
        }
      }
      function flushPostFlushCbs(seen) {
        if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)].sort(
            (a2, b2) => getId(a2) - getId(b2)
          );
          pendingPostFlushCbs.length = 0;
          if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
          }
          activePostFlushCbs = deduped;
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            activePostFlushCbs[postFlushIndex]();
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
        }
      }
      const getId = (job) => job.id == null ? Infinity : job.id;
      const comparator = (a2, b2) => {
        const diff = getId(a2) - getId(b2);
        if (diff === 0) {
          if (a2.pre && !b2.pre)
            return -1;
          if (b2.pre && !a2.pre)
            return 1;
        }
        return diff;
      };
      function flushJobs(seen) {
        isFlushPending = false;
        isFlushing = true;
        queue.sort(comparator);
        try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
              if (false)
                ;
              callWithErrorHandling(job, null, 14);
            }
          }
        } finally {
          flushIndex = 0;
          queue.length = 0;
          flushPostFlushCbs();
          isFlushing = false;
          currentFlushPromise = null;
          if (queue.length || pendingPostFlushCbs.length) {
            flushJobs();
          }
        }
      }
      function emit(instance, event, ...rawArgs) {
        if (instance.isUnmounted)
          return;
        const props = instance.vnode.props || EMPTY_OBJ;
        let args = rawArgs;
        const isModelListener2 = event.startsWith("update:");
        const modelArg = isModelListener2 && event.slice(7);
        if (modelArg && modelArg in props) {
          const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
          const { number: number3, trim } = props[modifiersKey] || EMPTY_OBJ;
          if (trim) {
            args = rawArgs.map((a2) => isString$3(a2) ? a2.trim() : a2);
          }
          if (number3) {
            args = rawArgs.map(looseToNumber);
          }
        }
        let handlerName;
        let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
        props[handlerName = toHandlerKey(camelize(event))];
        if (!handler && isModelListener2) {
          handler = props[handlerName = toHandlerKey(hyphenate(event))];
        }
        if (handler) {
          callWithAsyncErrorHandling(
            handler,
            instance,
            6,
            args
          );
        }
        const onceHandler = props[handlerName + `Once`];
        if (onceHandler) {
          if (!instance.emitted) {
            instance.emitted = {};
          } else if (instance.emitted[handlerName]) {
            return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(
            onceHandler,
            instance,
            6,
            args
          );
        }
      }
      function normalizeEmitsOptions(comp, appContext, asMixin = false) {
        const cache2 = appContext.emitsCache;
        const cached = cache2.get(comp);
        if (cached !== void 0) {
          return cached;
        }
        const raw = comp.emits;
        let normalized = {};
        let hasExtends = false;
        if (!isFunction$2(comp)) {
          const extendEmits = (raw2) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
              hasExtends = true;
              extend(normalized, normalizedFromExtend);
            }
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
            extendEmits(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$5(comp)) {
            cache2.set(comp, null);
          }
          return null;
        }
        if (isArray$2(raw)) {
          raw.forEach((key) => normalized[key] = null);
        } else {
          extend(normalized, raw);
        }
        if (isObject$5(comp)) {
          cache2.set(comp, normalized);
        }
        return normalized;
      }
      function isEmitListener(options, key) {
        if (!options || !isOn(key)) {
          return false;
        }
        key = key.slice(2).replace(/Once$/, "");
        return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
      }
      let currentRenderingInstance = null;
      let currentScopeId = null;
      function setCurrentRenderingInstance(instance) {
        const prev = currentRenderingInstance;
        currentRenderingInstance = instance;
        currentScopeId = instance && instance.type.__scopeId || null;
        return prev;
      }
      function pushScopeId(id) {
        currentScopeId = id;
      }
      function popScopeId() {
        currentScopeId = null;
      }
      function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
        if (!ctx)
          return fn2;
        if (fn2._n) {
          return fn2;
        }
        const renderFnWithContext = (...args) => {
          if (renderFnWithContext._d) {
            setBlockTracking(-1);
          }
          const prevInstance = setCurrentRenderingInstance(ctx);
          let res;
          try {
            res = fn2(...args);
          } finally {
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
              setBlockTracking(1);
            }
          }
          return res;
        };
        renderFnWithContext._n = true;
        renderFnWithContext._c = true;
        renderFnWithContext._d = true;
        return renderFnWithContext;
      }
      function markAttrsAccessed() {
      }
      function renderComponentRoot(instance) {
        const {
          type: Component,
          vnode,
          proxy: proxy2,
          withProxy,
          props,
          propsOptions: [propsOptions],
          slots,
          attrs,
          emit: emit2,
          render: render2,
          renderCache,
          data,
          setupState,
          ctx,
          inheritAttrs
        } = instance;
        let result;
        let fallthroughAttrs;
        const prev = setCurrentRenderingInstance(instance);
        try {
          if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy2;
            const thisProxy = false ? new Proxy(proxyToUse, {
              get(target, key, receiver) {
                warn$1(
                  `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
                );
                return Reflect.get(target, key, receiver);
              }
            }) : proxyToUse;
            result = normalizeVNode(
              render2.call(
                thisProxy,
                proxyToUse,
                renderCache,
                props,
                setupState,
                data,
                ctx
              )
            );
            fallthroughAttrs = attrs;
          } else {
            const render22 = Component;
            if (false)
              ;
            result = normalizeVNode(
              render22.length > 1 ? render22(
                props,
                false ? {
                  get attrs() {
                    markAttrsAccessed();
                    return attrs;
                  },
                  slots,
                  emit: emit2
                } : { attrs, slots, emit: emit2 }
              ) : render22(
                props,
                null
                /* we know it doesn't need it */
              )
            );
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
          }
        } catch (err) {
          blockStack.length = 0;
          handleError(err, instance, 1);
          result = createVNode(Comment);
        }
        let root2 = result;
        if (fallthroughAttrs && inheritAttrs !== false) {
          const keys2 = Object.keys(fallthroughAttrs);
          const { shapeFlag } = root2;
          if (keys2.length) {
            if (shapeFlag & (1 | 6)) {
              if (propsOptions && keys2.some(isModelListener)) {
                fallthroughAttrs = filterModelListeners(
                  fallthroughAttrs,
                  propsOptions
                );
              }
              root2 = cloneVNode(root2, fallthroughAttrs);
            }
          }
        }
        if (vnode.dirs) {
          root2 = cloneVNode(root2);
          root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        if (vnode.transition) {
          root2.transition = vnode.transition;
        }
        {
          result = root2;
        }
        setCurrentRenderingInstance(prev);
        return result;
      }
      const getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key in attrs) {
          if (key === "class" || key === "style" || isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
          }
        }
        return res;
      };
      const filterModelListeners = (attrs, props) => {
        const res = {};
        for (const key in attrs) {
          if (!isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
          }
        }
        return res;
      };
      function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
        const { props: prevProps, children: prevChildren, component } = prevVNode;
        const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
        const emits = component.emitsOptions;
        if (nextVNode.dirs || nextVNode.transition) {
          return true;
        }
        if (optimized && patchFlag >= 0) {
          if (patchFlag & 1024) {
            return true;
          }
          if (patchFlag & 16) {
            if (!prevProps) {
              return !!nextProps;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
              const key = dynamicProps[i];
              if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                return true;
              }
            }
          }
        } else {
          if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
              return true;
            }
          }
          if (prevProps === nextProps) {
            return false;
          }
          if (!prevProps) {
            return !!nextProps;
          }
          if (!nextProps) {
            return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        }
        return false;
      }
      function hasPropsChanged(prevProps, nextProps, emitsOptions) {
        const nextKeys = Object.keys(nextProps);
        if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
        }
        for (let i = 0; i < nextKeys.length; i++) {
          const key = nextKeys[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
            return true;
          }
        }
        return false;
      }
      function updateHOCHostEl({ vnode, parent }, el) {
        while (parent) {
          const root2 = parent.subTree;
          if (root2.suspense && root2.suspense.activeBranch === vnode) {
            root2.el = vnode.el;
          }
          if (root2 === vnode) {
            (vnode = parent.vnode).el = el;
            parent = parent.parent;
          } else {
            break;
          }
        }
      }
      const COMPONENTS = "components";
      const DIRECTIVES = "directives";
      function resolveComponent(name, maybeSelfReference) {
        return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
      }
      const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
      function resolveDynamicComponent(component) {
        if (isString$3(component)) {
          return resolveAsset(COMPONENTS, component, false) || component;
        } else {
          return component || NULL_DYNAMIC_COMPONENT;
        }
      }
      function resolveDirective(name) {
        return resolveAsset(DIRECTIVES, name);
      }
      function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
        const instance = currentRenderingInstance || currentInstance;
        if (instance) {
          const Component = instance.type;
          if (type === COMPONENTS) {
            const selfName = getComponentName(
              Component,
              false
            );
            if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$2(camelize(name)))) {
              return Component;
            }
          }
          const res = (
            // local registration
            // check instance[type] first which is resolved for options API
            resolve(instance[type] || Component[type], name) || // global registration
            resolve(instance.appContext[type], name)
          );
          if (!res && maybeSelfReference) {
            return Component;
          }
          return res;
        }
      }
      function resolve(registry, name) {
        return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$2(camelize(name))]);
      }
      const isSuspense = (type) => type.__isSuspense;
      function queueEffectWithSuspense(fn2, suspense) {
        if (suspense && suspense.pendingBranch) {
          if (isArray$2(fn2)) {
            suspense.effects.push(...fn2);
          } else {
            suspense.effects.push(fn2);
          }
        } else {
          queuePostFlushCb(fn2);
        }
      }
      const ssrContextKey = Symbol.for("v-scx");
      const useSSRContext = () => {
        {
          const ctx = inject(ssrContextKey);
          return ctx;
        }
      };
      function watchEffect(effect2, options) {
        return doWatch(effect2, null, options);
      }
      const INITIAL_WATCHER_VALUE = {};
      function watch(source, cb, options) {
        return doWatch(source, cb, options);
      }
      function doWatch(source, cb, {
        immediate,
        deep,
        flush,
        once: once2,
        onTrack,
        onTrigger
      } = EMPTY_OBJ) {
        if (cb && once2) {
          const _cb = cb;
          cb = (...args) => {
            _cb(...args);
            unwatch();
          };
        }
        const instance = currentInstance;
        const reactiveGetter = (source2) => deep === true ? source2 : (
          // for deep: false, only traverse root-level properties
          traverse(source2, deep === false ? 1 : void 0)
        );
        let getter;
        let forceTrigger = false;
        let isMultiSource = false;
        if (isRef(source)) {
          getter = () => source.value;
          forceTrigger = isShallow(source);
        } else if (isReactive(source)) {
          getter = () => reactiveGetter(source);
          forceTrigger = true;
        } else if (isArray$2(source)) {
          isMultiSource = true;
          forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
          getter = () => source.map((s2) => {
            if (isRef(s2)) {
              return s2.value;
            } else if (isReactive(s2)) {
              return reactiveGetter(s2);
            } else if (isFunction$2(s2)) {
              return callWithErrorHandling(s2, instance, 2);
            } else
              ;
          });
        } else if (isFunction$2(source)) {
          if (cb) {
            getter = () => callWithErrorHandling(source, instance, 2);
          } else {
            getter = () => {
              if (cleanup) {
                cleanup();
              }
              return callWithAsyncErrorHandling(
                source,
                instance,
                3,
                [onCleanup]
              );
            };
          }
        } else {
          getter = NOOP;
        }
        if (cb && deep) {
          const baseGetter = getter;
          getter = () => traverse(baseGetter());
        }
        let cleanup;
        let onCleanup = (fn2) => {
          cleanup = effect2.onStop = () => {
            callWithErrorHandling(fn2, instance, 4);
            cleanup = effect2.onStop = void 0;
          };
        };
        let ssrCleanup;
        if (isInSSRComponentSetup) {
          onCleanup = NOOP;
          if (!cb) {
            getter();
          } else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3, [
              getter(),
              isMultiSource ? [] : void 0,
              onCleanup
            ]);
          }
          if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
          } else {
            return NOOP;
          }
        }
        let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
        const job = () => {
          if (!effect2.active || !effect2.dirty) {
            return;
          }
          if (cb) {
            const newValue = effect2.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
              if (cleanup) {
                cleanup();
              }
              callWithAsyncErrorHandling(cb, instance, 3, [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                onCleanup
              ]);
              oldValue = newValue;
            }
          } else {
            effect2.run();
          }
        };
        job.allowRecurse = !!cb;
        let scheduler;
        if (flush === "sync") {
          scheduler = job;
        } else if (flush === "post") {
          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
        } else {
          job.pre = true;
          if (instance)
            job.id = instance.uid;
          scheduler = () => queueJob(job);
        }
        const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
        const scope = getCurrentScope();
        const unwatch = () => {
          effect2.stop();
          if (scope) {
            remove(scope.effects, effect2);
          }
        };
        if (cb) {
          if (immediate) {
            job();
          } else {
            oldValue = effect2.run();
          }
        } else if (flush === "post") {
          queuePostRenderEffect(
            effect2.run.bind(effect2),
            instance && instance.suspense
          );
        } else {
          effect2.run();
        }
        if (ssrCleanup)
          ssrCleanup.push(unwatch);
        return unwatch;
      }
      function instanceWatch(source, value, options) {
        const publicThis = this.proxy;
        const getter = isString$3(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
        let cb;
        if (isFunction$2(value)) {
          cb = value;
        } else {
          cb = value.handler;
          options = value;
        }
        const reset = setCurrentInstance(this);
        const res = doWatch(getter, cb.bind(publicThis), options);
        reset();
        return res;
      }
      function createPathGetter(ctx, path) {
        const segments = path.split(".");
        return () => {
          let cur = ctx;
          for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
          }
          return cur;
        };
      }
      function traverse(value, depth, currentDepth = 0, seen) {
        if (!isObject$5(value) || value["__v_skip"]) {
          return value;
        }
        if (depth && depth > 0) {
          if (currentDepth >= depth) {
            return value;
          }
          currentDepth++;
        }
        seen = seen || /* @__PURE__ */ new Set();
        if (seen.has(value)) {
          return value;
        }
        seen.add(value);
        if (isRef(value)) {
          traverse(value.value, depth, currentDepth, seen);
        } else if (isArray$2(value)) {
          for (let i = 0; i < value.length; i++) {
            traverse(value[i], depth, currentDepth, seen);
          }
        } else if (isSet$1(value) || isMap$1(value)) {
          value.forEach((v2) => {
            traverse(v2, depth, currentDepth, seen);
          });
        } else if (isPlainObject$2(value)) {
          for (const key in value) {
            traverse(value[key], depth, currentDepth, seen);
          }
        }
        return value;
      }
      function withDirectives(vnode, directives) {
        if (currentRenderingInstance === null) {
          return vnode;
        }
        const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
        const bindings = vnode.dirs || (vnode.dirs = []);
        for (let i = 0; i < directives.length; i++) {
          let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
          if (dir) {
            if (isFunction$2(dir)) {
              dir = {
                mounted: dir,
                updated: dir
              };
            }
            if (dir.deep) {
              traverse(value);
            }
            bindings.push({
              dir,
              instance,
              value,
              oldValue: void 0,
              arg,
              modifiers
            });
          }
        }
        return vnode;
      }
      function invokeDirectiveHook(vnode, prevVNode, instance, name) {
        const bindings = vnode.dirs;
        const oldBindings = prevVNode && prevVNode.dirs;
        for (let i = 0; i < bindings.length; i++) {
          const binding = bindings[i];
          if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
          }
          let hook = binding.dir[name];
          if (hook) {
            pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8, [
              vnode.el,
              binding,
              vnode,
              prevVNode
            ]);
            resetTracking();
          }
        }
      }
      const leaveCbKey = Symbol("_leaveCb");
      const enterCbKey$1 = Symbol("_enterCb");
      function useTransitionState() {
        const state = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: /* @__PURE__ */ new Map()
        };
        onMounted(() => {
          state.isMounted = true;
        });
        onBeforeUnmount(() => {
          state.isUnmounting = true;
        });
        return state;
      }
      const TransitionHookValidator = [Function, Array];
      const BaseTransitionPropsValidators = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      };
      const BaseTransitionImpl = {
        name: `BaseTransition`,
        props: BaseTransitionPropsValidators,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
              return;
            }
            let child = children[0];
            if (children.length > 1) {
              for (const c2 of children) {
                if (c2.type !== Comment) {
                  child = c2;
                  break;
                }
              }
            }
            const rawProps = toRaw(props);
            const { mode } = rawProps;
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(
              innerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild)) {
              const leavingHooks = resolveTransitionHooks(
                oldInnerChild,
                rawProps,
                state,
                instance
              );
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode === "out-in") {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  if (instance.update.active !== false) {
                    instance.effect.dirty = true;
                    instance.update();
                  }
                };
                return emptyPlaceholder(child);
              } else if (mode === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(
                    state,
                    oldInnerChild
                  );
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el[leaveCbKey] = () => {
                    earlyRemove();
                    el[leaveCbKey] = void 0;
                    delete enterHooks.delayedLeave;
                  };
                  enterHooks.delayedLeave = delayedLeave;
                };
              }
            }
            return child;
          };
        }
      };
      const BaseTransition = BaseTransitionImpl;
      function getLeavingNodesForType(state, vnode) {
        const { leavingVNodes } = state;
        let leavingVNodesCache = leavingVNodes.get(vnode.type);
        if (!leavingVNodesCache) {
          leavingVNodesCache = /* @__PURE__ */ Object.create(null);
          leavingVNodes.set(vnode.type, leavingVNodesCache);
        }
        return leavingVNodesCache;
      }
      function resolveTransitionHooks(vnode, props, state, instance) {
        const {
          appear,
          mode,
          persisted = false,
          onBeforeEnter,
          onEnter,
          onAfterEnter,
          onEnterCancelled,
          onBeforeLeave,
          onLeave,
          onAfterLeave,
          onLeaveCancelled,
          onBeforeAppear,
          onAppear,
          onAfterAppear,
          onAppearCancelled
        } = props;
        const key = String(vnode.key);
        const leavingVNodesCache = getLeavingNodesForType(state, vnode);
        const callHook2 = (hook, args) => {
          hook && callWithAsyncErrorHandling(
            hook,
            instance,
            9,
            args
          );
        };
        const callAsyncHook = (hook, args) => {
          const done = args[1];
          callHook2(hook, args);
          if (isArray$2(hook)) {
            if (hook.every((hook2) => hook2.length <= 1))
              done();
          } else if (hook.length <= 1) {
            done();
          }
        };
        const hooks = {
          mode,
          persisted,
          beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
              if (appear) {
                hook = onBeforeAppear || onBeforeEnter;
              } else {
                return;
              }
            }
            if (el[leaveCbKey]) {
              el[leaveCbKey](
                true
                /* cancelled */
              );
            }
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
              leavingVNode.el[leaveCbKey]();
            }
            callHook2(hook, [el]);
          },
          enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
              if (appear) {
                hook = onAppear || onEnter;
                afterHook = onAfterAppear || onAfterEnter;
                cancelHook = onAppearCancelled || onEnterCancelled;
              } else {
                return;
              }
            }
            let called = false;
            const done = el[enterCbKey$1] = (cancelled) => {
              if (called)
                return;
              called = true;
              if (cancelled) {
                callHook2(cancelHook, [el]);
              } else {
                callHook2(afterHook, [el]);
              }
              if (hooks.delayedLeave) {
                hooks.delayedLeave();
              }
              el[enterCbKey$1] = void 0;
            };
            if (hook) {
              callAsyncHook(hook, [el, done]);
            } else {
              done();
            }
          },
          leave(el, remove2) {
            const key2 = String(vnode.key);
            if (el[enterCbKey$1]) {
              el[enterCbKey$1](
                true
                /* cancelled */
              );
            }
            if (state.isUnmounting) {
              return remove2();
            }
            callHook2(onBeforeLeave, [el]);
            let called = false;
            const done = el[leaveCbKey] = (cancelled) => {
              if (called)
                return;
              called = true;
              remove2();
              if (cancelled) {
                callHook2(onLeaveCancelled, [el]);
              } else {
                callHook2(onAfterLeave, [el]);
              }
              el[leaveCbKey] = void 0;
              if (leavingVNodesCache[key2] === vnode) {
                delete leavingVNodesCache[key2];
              }
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) {
              callAsyncHook(onLeave, [el, done]);
            } else {
              done();
            }
          },
          clone(vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
          }
        };
        return hooks;
      }
      function emptyPlaceholder(vnode) {
        if (isKeepAlive(vnode)) {
          vnode = cloneVNode(vnode);
          vnode.children = null;
          return vnode;
        }
      }
      function getKeepAliveChild(vnode) {
        return isKeepAlive(vnode) ? (
          // #7121 ensure get the child component subtree in case
          // it's been replaced during HMR
          vnode.children ? vnode.children[0] : void 0
        ) : vnode;
      }
      function setTransitionHooks(vnode, hooks) {
        if (vnode.shapeFlag & 6 && vnode.component) {
          setTransitionHooks(vnode.component.subTree, hooks);
        } else if (vnode.shapeFlag & 128) {
          vnode.ssContent.transition = hooks.clone(vnode.ssContent);
          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
        } else {
          vnode.transition = hooks;
        }
      }
      function getTransitionRawChildren(children, keepComment = false, parentKey) {
        let ret = [];
        let keyedFragmentCount = 0;
        for (let i = 0; i < children.length; i++) {
          let child = children[i];
          const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
          if (child.type === Fragment$1) {
            if (child.patchFlag & 128)
              keyedFragmentCount++;
            ret = ret.concat(
              getTransitionRawChildren(child.children, keepComment, key)
            );
          } else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
          }
        }
        if (keyedFragmentCount > 1) {
          for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2;
          }
        }
        return ret;
      }
      /*! #__NO_SIDE_EFFECTS__ */
      // @__NO_SIDE_EFFECTS__
      function defineComponent(options, extraOptions) {
        return isFunction$2(options) ? (
          // #8326: extend call and options.name access are considered side-effects
          // by Rollup, so we have to wrap it in a pure-annotated IIFE.
          /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
        ) : options;
      }
      const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
      const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      function onActivated(hook, target) {
        registerKeepAliveHook(hook, "a", target);
      }
      function onDeactivated(hook, target) {
        registerKeepAliveHook(hook, "da", target);
      }
      function registerKeepAliveHook(hook, type, target = currentInstance) {
        const wrappedHook = hook.__wdc || (hook.__wdc = () => {
          let current = target;
          while (current) {
            if (current.isDeactivated) {
              return;
            }
            current = current.parent;
          }
          return hook();
        });
        injectHook(type, wrappedHook, target);
        if (target) {
          let current = target.parent;
          while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
              injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
          }
        }
      }
      function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
        const injected = injectHook(
          type,
          hook,
          keepAliveRoot,
          true
          /* prepend */
        );
        onUnmounted(() => {
          remove(keepAliveRoot[type], injected);
        }, target);
      }
      function injectHook(type, hook, target = currentInstance, prepend = false) {
        if (target) {
          const hooks = target[type] || (target[type] = []);
          const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
            if (target.isUnmounted) {
              return;
            }
            pauseTracking();
            const reset = setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            reset();
            resetTracking();
            return res;
          });
          if (prepend) {
            hooks.unshift(wrappedHook);
          } else {
            hooks.push(wrappedHook);
          }
          return wrappedHook;
        }
      }
      const createHook = (lifecycle) => (hook, target = currentInstance) => (
        // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
      );
      const onBeforeMount = createHook("bm");
      const onMounted = createHook("m");
      const onBeforeUpdate = createHook("bu");
      const onUpdated = createHook("u");
      const onBeforeUnmount = createHook("bum");
      const onUnmounted = createHook("um");
      const onServerPrefetch = createHook("sp");
      const onRenderTriggered = createHook(
        "rtg"
      );
      const onRenderTracked = createHook(
        "rtc"
      );
      function onErrorCaptured(hook, target = currentInstance) {
        injectHook("ec", hook, target);
      }
      function renderList(source, renderItem, cache2, index) {
        let ret;
        const cached = cache2 && cache2[index];
        if (isArray$2(source) || isString$3(source)) {
          ret = new Array(source.length);
          for (let i = 0, l2 = source.length; i < l2; i++) {
            ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
          }
        } else if (typeof source === "number") {
          ret = new Array(source);
          for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
          }
        } else if (isObject$5(source)) {
          if (source[Symbol.iterator]) {
            ret = Array.from(
              source,
              (item, i) => renderItem(item, i, void 0, cached && cached[i])
            );
          } else {
            const keys2 = Object.keys(source);
            ret = new Array(keys2.length);
            for (let i = 0, l2 = keys2.length; i < l2; i++) {
              const key = keys2[i];
              ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
          }
        } else {
          ret = [];
        }
        if (cache2) {
          cache2[index] = ret;
        }
        return ret;
      }
      function createSlots(slots, dynamicSlots) {
        for (let i = 0; i < dynamicSlots.length; i++) {
          const slot = dynamicSlots[i];
          if (isArray$2(slot)) {
            for (let j = 0; j < slot.length; j++) {
              slots[slot[j].name] = slot[j].fn;
            }
          } else if (slot) {
            slots[slot.name] = slot.key ? (...args) => {
              const res = slot.fn(...args);
              if (res)
                res.key = slot.key;
              return res;
            } : slot.fn;
          }
        }
        return slots;
      }
      function renderSlot(slots, name, props = {}, fallback, noSlotted) {
        if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
          if (name !== "default")
            props.name = name;
          return createVNode("slot", props, fallback && fallback());
        }
        let slot = slots[name];
        if (slot && slot._c) {
          slot._d = false;
        }
        openBlock();
        const validSlotContent = slot && ensureValidVNode(slot(props));
        const rendered = createBlock(
          Fragment$1,
          {
            key: props.key || // slot content array of a dynamic conditional slot may have a branch
            // key attached in the `createSlots` helper, respect that
            validSlotContent && validSlotContent.key || `_${name}`
          },
          validSlotContent || (fallback ? fallback() : []),
          validSlotContent && slots._ === 1 ? 64 : -2
        );
        if (!noSlotted && rendered.scopeId) {
          rendered.slotScopeIds = [rendered.scopeId + "-s"];
        }
        if (slot && slot._c) {
          slot._d = true;
        }
        return rendered;
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!isVNode$1(child))
            return true;
          if (child.type === Comment)
            return false;
          if (child.type === Fragment$1 && !ensureValidVNode(child.children))
            return false;
          return true;
        }) ? vnodes : null;
      }
      function toHandlers(obj, preserveCaseIfNecessary) {
        const ret = {};
        for (const key in obj) {
          ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
        }
        return ret;
      }
      const getPublicInstance = (i) => {
        if (!i)
          return null;
        if (isStatefulComponent(i))
          return getExposeProxy(i) || i.proxy;
        return getPublicInstance(i.parent);
      };
      const publicPropertiesMap = (
        // Move PURE marker to new line to workaround compiler discarding it
        // due to type annotation
        /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
          $: (i) => i,
          $el: (i) => i.vnode.el,
          $data: (i) => i.data,
          $props: (i) => i.props,
          $attrs: (i) => i.attrs,
          $slots: (i) => i.slots,
          $refs: (i) => i.refs,
          $parent: (i) => getPublicInstance(i.parent),
          $root: (i) => getPublicInstance(i.root),
          $emit: (i) => i.emit,
          $options: (i) => resolveMergedOptions(i),
          $forceUpdate: (i) => i.f || (i.f = () => {
            i.effect.dirty = true;
            queueJob(i.update);
          }),
          $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
          $watch: (i) => instanceWatch.bind(i)
        })
      );
      const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
      const PublicInstanceProxyHandlers = {
        get({ _: instance }, key) {
          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
          let normalizedProps;
          if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) {
              switch (n) {
                case 1:
                  return setupState[key];
                case 2:
                  return data[key];
                case 4:
                  return ctx[key];
                case 3:
                  return props[key];
              }
            } else if (hasSetupBinding(setupState, key)) {
              accessCache[key] = 1;
              return setupState[key];
            } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
              accessCache[key] = 2;
              return data[key];
            } else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)
            ) {
              accessCache[key] = 3;
              return props[key];
            } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (shouldCacheAccess) {
              accessCache[key] = 0;
            }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key === "$attrs") {
              track(instance, "get", key);
            }
            return publicGetter(instance);
          } else if (
            // css module (injected by vue-loader)
            (cssModule = type.__cssModules) && (cssModule = cssModule[key])
          ) {
            return cssModule;
          } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
          ) {
            {
              return globalProperties[key];
            }
          } else
            ;
        },
        set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
          } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
            data[key] = value;
            return true;
          } else if (hasOwn$1(instance.props, key)) {
            return false;
          }
          if (key[0] === "$" && key.slice(1) in instance) {
            return false;
          } else {
            {
              ctx[key] = value;
            }
          }
          return true;
        },
        has({
          _: { data, setupState, accessCache, ctx, appContext, propsOptions }
        }, key) {
          let normalizedProps;
          return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
        },
        defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
            target._.accessCache[key] = 0;
          } else if (hasOwn$1(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
        }
      };
      function useSlots() {
        return getContext().slots;
      }
      function useAttrs$1() {
        return getContext().attrs;
      }
      function getContext() {
        const i = getCurrentInstance();
        return i.setupContext || (i.setupContext = createSetupContext(i));
      }
      function normalizePropsOrEmits(props) {
        return isArray$2(props) ? props.reduce(
          (normalized, p2) => (normalized[p2] = null, normalized),
          {}
        ) : props;
      }
      let shouldCacheAccess = true;
      function applyOptions(instance) {
        const options = resolveMergedOptions(instance);
        const publicThis = instance.proxy;
        const ctx = instance.ctx;
        shouldCacheAccess = false;
        if (options.beforeCreate) {
          callHook$1(options.beforeCreate, instance, "bc");
        }
        const {
          // state
          data: dataOptions,
          computed: computedOptions,
          methods,
          watch: watchOptions,
          provide: provideOptions,
          inject: injectOptions,
          // lifecycle
          created,
          beforeMount,
          mounted,
          beforeUpdate,
          updated,
          activated,
          deactivated,
          beforeDestroy,
          beforeUnmount,
          destroyed,
          unmounted,
          render: render2,
          renderTracked,
          renderTriggered,
          errorCaptured,
          serverPrefetch,
          // public API
          expose: expose2,
          inheritAttrs,
          // assets
          components,
          directives,
          filters
        } = options;
        const checkDuplicateProperties = null;
        if (injectOptions) {
          resolveInjections(injectOptions, ctx, checkDuplicateProperties);
        }
        if (methods) {
          for (const key in methods) {
            const methodHandler = methods[key];
            if (isFunction$2(methodHandler)) {
              {
                ctx[key] = methodHandler.bind(publicThis);
              }
            }
          }
        }
        if (dataOptions) {
          const data = dataOptions.call(publicThis, publicThis);
          if (!isObject$5(data))
            ;
          else {
            instance.data = reactive(data);
          }
        }
        shouldCacheAccess = true;
        if (computedOptions) {
          for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
            const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
            const c2 = computed({
              get: get2,
              set: set2
            });
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => c2.value,
              set: (v2) => c2.value = v2
            });
          }
        }
        if (watchOptions) {
          for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
          }
        }
        if (provideOptions) {
          const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
          Reflect.ownKeys(provides).forEach((key) => {
            provide(key, provides[key]);
          });
        }
        if (created) {
          callHook$1(created, instance, "c");
        }
        function registerLifecycleHook(register, hook) {
          if (isArray$2(hook)) {
            hook.forEach((_hook) => register(_hook.bind(publicThis)));
          } else if (hook) {
            register(hook.bind(publicThis));
          }
        }
        registerLifecycleHook(onBeforeMount, beforeMount);
        registerLifecycleHook(onMounted, mounted);
        registerLifecycleHook(onBeforeUpdate, beforeUpdate);
        registerLifecycleHook(onUpdated, updated);
        registerLifecycleHook(onActivated, activated);
        registerLifecycleHook(onDeactivated, deactivated);
        registerLifecycleHook(onErrorCaptured, errorCaptured);
        registerLifecycleHook(onRenderTracked, renderTracked);
        registerLifecycleHook(onRenderTriggered, renderTriggered);
        registerLifecycleHook(onBeforeUnmount, beforeUnmount);
        registerLifecycleHook(onUnmounted, unmounted);
        registerLifecycleHook(onServerPrefetch, serverPrefetch);
        if (isArray$2(expose2)) {
          if (expose2.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose2.forEach((key) => {
              Object.defineProperty(exposed, key, {
                get: () => publicThis[key],
                set: (val) => publicThis[key] = val
              });
            });
          } else if (!instance.exposed) {
            instance.exposed = {};
          }
        }
        if (render2 && instance.render === NOOP) {
          instance.render = render2;
        }
        if (inheritAttrs != null) {
          instance.inheritAttrs = inheritAttrs;
        }
        if (components)
          instance.components = components;
        if (directives)
          instance.directives = directives;
      }
      function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
        if (isArray$2(injectOptions)) {
          injectOptions = normalizeInject(injectOptions);
        }
        for (const key in injectOptions) {
          const opt = injectOptions[key];
          let injected;
          if (isObject$5(opt)) {
            if ("default" in opt) {
              injected = inject(
                opt.from || key,
                opt.default,
                true
              );
            } else {
              injected = inject(opt.from || key);
            }
          } else {
            injected = inject(opt);
          }
          if (isRef(injected)) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v2) => injected.value = v2
            });
          } else {
            ctx[key] = injected;
          }
        }
      }
      function callHook$1(hook, instance, type) {
        callWithAsyncErrorHandling(
          isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
          instance,
          type
        );
      }
      function createWatcher(raw, ctx, publicThis, key) {
        const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
        if (isString$3(raw)) {
          const handler = ctx[raw];
          if (isFunction$2(handler)) {
            watch(getter, handler);
          }
        } else if (isFunction$2(raw)) {
          watch(getter, raw.bind(publicThis));
        } else if (isObject$5(raw)) {
          if (isArray$2(raw)) {
            raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
          } else {
            const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (isFunction$2(handler)) {
              watch(getter, handler, raw);
            }
          }
        } else
          ;
      }
      function resolveMergedOptions(instance) {
        const base = instance.type;
        const { mixins, extends: extendsOptions } = base;
        const {
          mixins: globalMixins,
          optionsCache: cache2,
          config: { optionMergeStrategies }
        } = instance.appContext;
        const cached = cache2.get(base);
        let resolved;
        if (cached) {
          resolved = cached;
        } else if (!globalMixins.length && !mixins && !extendsOptions) {
          {
            resolved = base;
          }
        } else {
          resolved = {};
          if (globalMixins.length) {
            globalMixins.forEach(
              (m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true)
            );
          }
          mergeOptions$1(resolved, base, optionMergeStrategies);
        }
        if (isObject$5(base)) {
          cache2.set(base, resolved);
        }
        return resolved;
      }
      function mergeOptions$1(to, from, strats, asMixin = false) {
        const { mixins, extends: extendsOptions } = from;
        if (extendsOptions) {
          mergeOptions$1(to, extendsOptions, strats, true);
        }
        if (mixins) {
          mixins.forEach(
            (m2) => mergeOptions$1(to, m2, strats, true)
          );
        }
        for (const key in from) {
          if (asMixin && key === "expose")
            ;
          else {
            const strat = internalOptionMergeStrats[key] || strats && strats[key];
            to[key] = strat ? strat(to[key], from[key]) : from[key];
          }
        }
        return to;
      }
      const internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeEmitsOrPropsOptions,
        emits: mergeEmitsOrPropsOptions,
        // objects
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        // lifecycle
        beforeCreate: mergeAsArray,
        created: mergeAsArray,
        beforeMount: mergeAsArray,
        mounted: mergeAsArray,
        beforeUpdate: mergeAsArray,
        updated: mergeAsArray,
        beforeDestroy: mergeAsArray,
        beforeUnmount: mergeAsArray,
        destroyed: mergeAsArray,
        unmounted: mergeAsArray,
        activated: mergeAsArray,
        deactivated: mergeAsArray,
        errorCaptured: mergeAsArray,
        serverPrefetch: mergeAsArray,
        // assets
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        // watch
        watch: mergeWatchOptions,
        // provide / inject
        provide: mergeDataFn,
        inject: mergeInject
      };
      function mergeDataFn(to, from) {
        if (!from) {
          return to;
        }
        if (!to) {
          return from;
        }
        return function mergedDataFn() {
          return extend(
            isFunction$2(to) ? to.call(this, this) : to,
            isFunction$2(from) ? from.call(this, this) : from
          );
        };
      }
      function mergeInject(to, from) {
        return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
      }
      function normalizeInject(raw) {
        if (isArray$2(raw)) {
          const res = {};
          for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
          }
          return res;
        }
        return raw;
      }
      function mergeAsArray(to, from) {
        return to ? [...new Set([].concat(to, from))] : from;
      }
      function mergeObjectOptions(to, from) {
        return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
      }
      function mergeEmitsOrPropsOptions(to, from) {
        if (to) {
          if (isArray$2(to) && isArray$2(from)) {
            return [.../* @__PURE__ */ new Set([...to, ...from])];
          }
          return extend(
            /* @__PURE__ */ Object.create(null),
            normalizePropsOrEmits(to),
            normalizePropsOrEmits(from != null ? from : {})
          );
        } else {
          return from;
        }
      }
      function mergeWatchOptions(to, from) {
        if (!to)
          return from;
        if (!from)
          return to;
        const merged = extend(/* @__PURE__ */ Object.create(null), to);
        for (const key in from) {
          merged[key] = mergeAsArray(to[key], from[key]);
        }
        return merged;
      }
      function createAppContext() {
        return {
          app: null,
          config: {
            isNativeTag: NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: /* @__PURE__ */ Object.create(null),
          optionsCache: /* @__PURE__ */ new WeakMap(),
          propsCache: /* @__PURE__ */ new WeakMap(),
          emitsCache: /* @__PURE__ */ new WeakMap()
        };
      }
      let uid$1 = 0;
      function createAppAPI(render2, hydrate) {
        return function createApp2(rootComponent, rootProps = null) {
          if (!isFunction$2(rootComponent)) {
            rootComponent = extend({}, rootComponent);
          }
          if (rootProps != null && !isObject$5(rootProps)) {
            rootProps = null;
          }
          const context = createAppContext();
          const installedPlugins = /* @__PURE__ */ new WeakSet();
          let isMounted = false;
          const app = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
              return context.config;
            },
            set config(v2) {
            },
            use(plugin, ...options) {
              if (installedPlugins.has(plugin))
                ;
              else if (plugin && isFunction$2(plugin.install)) {
                installedPlugins.add(plugin);
                plugin.install(app, ...options);
              } else if (isFunction$2(plugin)) {
                installedPlugins.add(plugin);
                plugin(app, ...options);
              } else
                ;
              return app;
            },
            mixin(mixin) {
              {
                if (!context.mixins.includes(mixin)) {
                  context.mixins.push(mixin);
                }
              }
              return app;
            },
            component(name, component) {
              if (!component) {
                return context.components[name];
              }
              context.components[name] = component;
              return app;
            },
            directive(name, directive) {
              if (!directive) {
                return context.directives[name];
              }
              context.directives[name] = directive;
              return app;
            },
            mount(rootContainer, isHydrate, namespace) {
              if (!isMounted) {
                const vnode = createVNode(rootComponent, rootProps);
                vnode.appContext = context;
                if (namespace === true) {
                  namespace = "svg";
                } else if (namespace === false) {
                  namespace = void 0;
                }
                if (isHydrate && hydrate) {
                  hydrate(vnode, rootContainer);
                } else {
                  render2(vnode, rootContainer, namespace);
                }
                isMounted = true;
                app._container = rootContainer;
                rootContainer.__vue_app__ = app;
                return getExposeProxy(vnode.component) || vnode.component.proxy;
              }
            },
            unmount() {
              if (isMounted) {
                render2(null, app._container);
                delete app._container.__vue_app__;
              }
            },
            provide(key, value) {
              context.provides[key] = value;
              return app;
            },
            runWithContext(fn2) {
              const lastApp = currentApp;
              currentApp = app;
              try {
                return fn2();
              } finally {
                currentApp = lastApp;
              }
            }
          };
          return app;
        };
      }
      let currentApp = null;
      function provide(key, value) {
        if (!currentInstance)
          ;
        else {
          let provides = currentInstance.provides;
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
          }
          provides[key] = value;
        }
      }
      function inject(key, defaultValue, treatDefaultAsFactory = false) {
        const instance = currentInstance || currentRenderingInstance;
        if (instance || currentApp) {
          const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
          if (provides && key in provides) {
            return provides[key];
          } else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
          } else
            ;
        }
      }
      function initProps(instance, rawProps, isStateful, isSSR = false) {
        const props = {};
        const attrs = {};
        def(attrs, InternalObjectKey, 1);
        instance.propsDefaults = /* @__PURE__ */ Object.create(null);
        setFullProps(instance, rawProps, props, attrs);
        for (const key in instance.propsOptions[0]) {
          if (!(key in props)) {
            props[key] = void 0;
          }
        }
        if (isStateful) {
          instance.props = isSSR ? props : shallowReactive(props);
        } else {
          if (!instance.type.props) {
            instance.props = attrs;
          } else {
            instance.props = props;
          }
        }
        instance.attrs = attrs;
      }
      function updateProps(instance, rawProps, rawPrevProps, optimized) {
        const {
          props,
          attrs,
          vnode: { patchFlag }
        } = instance;
        const rawCurrentProps = toRaw(props);
        const [options] = instance.propsOptions;
        let hasAttrsChanged = false;
        if (
          // always force full diff in dev
          // - #1942 if hmr is enabled with sfc component
          // - vite#872 non-sfc component used by sfc component
          (optimized || patchFlag > 0) && !(patchFlag & 16)
        ) {
          if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              let key = propsToUpdate[i];
              if (isEmitListener(instance.emitsOptions, key)) {
                continue;
              }
              const value = rawProps[key];
              if (options) {
                if (hasOwn$1(attrs, key)) {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                } else {
                  const camelizedKey = camelize(key);
                  props[camelizedKey] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    camelizedKey,
                    value,
                    instance,
                    false
                  );
                }
              } else {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
        } else {
          if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
          }
          let kebabKey;
          for (const key in rawCurrentProps) {
            if (!rawProps || // for camelCase
            !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
            // and converted to camelCase (#955)
            ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
              if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) {
                  props[key] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    key,
                    void 0,
                    instance,
                    true
                  );
                }
              } else {
                delete props[key];
              }
            }
          }
          if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
              if (!rawProps || !hasOwn$1(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (hasAttrsChanged) {
          trigger(instance, "set", "$attrs");
        }
      }
      function setFullProps(instance, rawProps, props, attrs) {
        const [options, needCastKeys] = instance.propsOptions;
        let hasAttrsChanged = false;
        let rawCastValues;
        if (rawProps) {
          for (let key in rawProps) {
            if (isReservedProp(key)) {
              continue;
            }
            const value = rawProps[key];
            let camelKey;
            if (options && hasOwn$1(options, camelKey = camelize(key))) {
              if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                props[camelKey] = value;
              } else {
                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
              }
            } else if (!isEmitListener(instance.emitsOptions, key)) {
              if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (needCastKeys) {
          const rawCurrentProps = toRaw(props);
          const castValues = rawCastValues || EMPTY_OBJ;
          for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              castValues[key],
              instance,
              !hasOwn$1(castValues, key)
            );
          }
        }
        return hasAttrsChanged;
      }
      function resolvePropValue(options, props, key, value, instance, isAbsent) {
        const opt = options[key];
        if (opt != null) {
          const hasDefault = hasOwn$1(opt, "default");
          if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
              const { propsDefaults } = instance;
              if (key in propsDefaults) {
                value = propsDefaults[key];
              } else {
                const reset = setCurrentInstance(instance);
                value = propsDefaults[key] = defaultValue.call(
                  null,
                  props
                );
                reset();
              }
            } else {
              value = defaultValue;
            }
          }
          if (opt[
            0
            /* shouldCast */
          ]) {
            if (isAbsent && !hasDefault) {
              value = false;
            } else if (opt[
              1
              /* shouldCastTrue */
            ] && (value === "" || value === hyphenate(key))) {
              value = true;
            }
          }
        }
        return value;
      }
      function normalizePropsOptions(comp, appContext, asMixin = false) {
        const cache2 = appContext.propsCache;
        const cached = cache2.get(comp);
        if (cached) {
          return cached;
        }
        const raw = comp.props;
        const normalized = {};
        const needCastKeys = [];
        let hasExtends = false;
        if (!isFunction$2(comp)) {
          const extendProps = (raw2) => {
            hasExtends = true;
            const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
            extend(normalized, props);
            if (keys2)
              needCastKeys.push(...keys2);
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
            extendProps(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendProps);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$5(comp)) {
            cache2.set(comp, EMPTY_ARR);
          }
          return EMPTY_ARR;
        }
        if (isArray$2(raw)) {
          for (let i = 0; i < raw.length; i++) {
            const normalizedKey = camelize(raw[i]);
            if (validatePropName(normalizedKey)) {
              normalized[normalizedKey] = EMPTY_OBJ;
            }
          }
        } else if (raw) {
          for (const key in raw) {
            const normalizedKey = camelize(key);
            if (validatePropName(normalizedKey)) {
              const opt = raw[key];
              const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend({}, opt);
              if (prop) {
                const booleanIndex = getTypeIndex(Boolean, prop.type);
                const stringIndex = getTypeIndex(String, prop.type);
                prop[
                  0
                  /* shouldCast */
                ] = booleanIndex > -1;
                prop[
                  1
                  /* shouldCastTrue */
                ] = stringIndex < 0 || booleanIndex < stringIndex;
                if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
                  needCastKeys.push(normalizedKey);
                }
              }
            }
          }
        }
        const res = [normalized, needCastKeys];
        if (isObject$5(comp)) {
          cache2.set(comp, res);
        }
        return res;
      }
      function validatePropName(key) {
        if (key[0] !== "$" && !isReservedProp(key)) {
          return true;
        }
        return false;
      }
      function getType(ctor) {
        if (ctor === null) {
          return "null";
        }
        if (typeof ctor === "function") {
          return ctor.name || "";
        } else if (typeof ctor === "object") {
          const name = ctor.constructor && ctor.constructor.name;
          return name || "";
        }
        return "";
      }
      function isSameType(a2, b2) {
        return getType(a2) === getType(b2);
      }
      function getTypeIndex(type, expectedTypes) {
        if (isArray$2(expectedTypes)) {
          return expectedTypes.findIndex((t2) => isSameType(t2, type));
        } else if (isFunction$2(expectedTypes)) {
          return isSameType(expectedTypes, type) ? 0 : -1;
        }
        return -1;
      }
      const isInternalKey = (key) => key[0] === "_" || key === "$stable";
      const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
      const normalizeSlot = (key, rawSlot, ctx) => {
        if (rawSlot._n) {
          return rawSlot;
        }
        const normalized = withCtx((...args) => {
          if (false)
            ;
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      const normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key in rawSlots) {
          if (isInternalKey(key))
            continue;
          const value = rawSlots[key];
          if (isFunction$2(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
          } else if (value != null) {
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
          }
        }
      };
      const normalizeVNodeSlots = (instance, children) => {
        const normalized = normalizeSlotValue(children);
        instance.slots.default = () => normalized;
      };
      const initSlots = (instance, children) => {
        if (instance.vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            instance.slots = toRaw(children);
            def(children, "_", type);
          } else {
            normalizeObjectSlots(
              children,
              instance.slots = {}
            );
          }
        } else {
          instance.slots = {};
          if (children) {
            normalizeVNodeSlots(instance, children);
          }
        }
        def(instance.slots, InternalObjectKey, 1);
      };
      const updateSlots = (instance, children, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            if (optimized && type === 1) {
              needDeletionCheck = false;
            } else {
              extend(slots, children);
              if (!optimized && type === 1) {
                delete slots._;
              }
            }
          } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
        } else if (children) {
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key in slots) {
            if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
              delete slots[key];
            }
          }
        }
      };
      function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
        if (isArray$2(rawRef)) {
          rawRef.forEach(
            (r, i) => setRef(
              r,
              oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
              parentSuspense,
              vnode,
              isUnmount
            )
          );
          return;
        }
        if (isAsyncWrapper(vnode) && !isUnmount) {
          return;
        }
        const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
        const value = isUnmount ? null : refValue;
        const { i: owner, r: ref3 } = rawRef;
        const oldRef = oldRawRef && oldRawRef.r;
        const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
        const setupState = owner.setupState;
        if (oldRef != null && oldRef !== ref3) {
          if (isString$3(oldRef)) {
            refs[oldRef] = null;
            if (hasOwn$1(setupState, oldRef)) {
              setupState[oldRef] = null;
            }
          } else if (isRef(oldRef)) {
            oldRef.value = null;
          }
        }
        if (isFunction$2(ref3)) {
          callWithErrorHandling(ref3, owner, 12, [value, refs]);
        } else {
          const _isString = isString$3(ref3);
          const _isRef = isRef(ref3);
          if (_isString || _isRef) {
            const doSet = () => {
              if (rawRef.f) {
                const existing = _isString ? hasOwn$1(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
                if (isUnmount) {
                  isArray$2(existing) && remove(existing, refValue);
                } else {
                  if (!isArray$2(existing)) {
                    if (_isString) {
                      refs[ref3] = [refValue];
                      if (hasOwn$1(setupState, ref3)) {
                        setupState[ref3] = refs[ref3];
                      }
                    } else {
                      ref3.value = [refValue];
                      if (rawRef.k)
                        refs[rawRef.k] = ref3.value;
                    }
                  } else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                  }
                }
              } else if (_isString) {
                refs[ref3] = value;
                if (hasOwn$1(setupState, ref3)) {
                  setupState[ref3] = value;
                }
              } else if (_isRef) {
                ref3.value = value;
                if (rawRef.k)
                  refs[rawRef.k] = value;
              } else
                ;
            };
            if (value) {
              doSet.id = -1;
              queuePostRenderEffect(doSet, parentSuspense);
            } else {
              doSet();
            }
          }
        }
      }
      const queuePostRenderEffect = queueEffectWithSuspense;
      function createRenderer(options) {
        return baseCreateRenderer(options);
      }
      function baseCreateRenderer(options, createHydrationFns) {
        const target = getGlobalThis$1();
        target.__VUE__ = true;
        const {
          insert: hostInsert,
          remove: hostRemove,
          patchProp: hostPatchProp,
          createElement: hostCreateElement,
          createText: hostCreateText,
          createComment: hostCreateComment,
          setText: hostSetText,
          setElementText: hostSetElementText,
          parentNode: hostParentNode,
          nextSibling: hostNextSibling,
          setScopeId: hostSetScopeId = NOOP,
          insertStaticContent: hostInsertStaticContent
        } = options;
        const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
          if (n1 === n2) {
            return;
          }
          if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
          }
          if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
          }
          const { type, ref: ref3, shapeFlag } = n2;
          switch (type) {
            case Text:
              processText(n1, n2, container, anchor);
              break;
            case Comment:
              processCommentNode(n1, n2, container, anchor);
              break;
            case Static:
              if (n1 == null) {
                mountStaticNode(n2, container, anchor, namespace);
              }
              break;
            case Fragment$1:
              processFragment(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              break;
            default:
              if (shapeFlag & 1) {
                processElement(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 6) {
                processComponent(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 64) {
                type.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else if (shapeFlag & 128) {
                type.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else
                ;
          }
          if (ref3 != null && parentComponent) {
            setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
          }
        };
        const processText = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateText(n2.children),
              container,
              anchor
            );
          } else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) {
              hostSetText(el, n2.children);
            }
          }
        };
        const processCommentNode = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateComment(n2.children || ""),
              container,
              anchor
            );
          } else {
            n2.el = n1.el;
          }
        };
        const mountStaticNode = (n2, container, anchor, namespace) => {
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            namespace,
            n2.el,
            n2.anchor
          );
        };
        const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
          }
          hostInsert(anchor, container, nextSibling);
        };
        const removeStaticNode = ({ el, anchor }) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
          }
          hostRemove(anchor);
        };
        const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          if (n2.type === "svg") {
            namespace = "svg";
          } else if (n2.type === "math") {
            namespace = "mathml";
          }
          if (n1 == null) {
            mountElement(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            patchElement(
              n1,
              n2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          let el;
          let vnodeHook;
          const { props, shapeFlag, transition, dirs } = vnode;
          el = vnode.el = hostCreateElement(
            vnode.type,
            namespace,
            props && props.is,
            props
          );
          if (shapeFlag & 8) {
            hostSetElementText(el, vnode.children);
          } else if (shapeFlag & 16) {
            mountChildren(
              vnode.children,
              el,
              null,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(vnode, namespace),
              slotScopeIds,
              optimized
            );
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
          if (props) {
            for (const key in props) {
              if (key !== "value" && !isReservedProp(key)) {
                hostPatchProp(
                  el,
                  key,
                  null,
                  props[key],
                  namespace,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in props) {
              hostPatchProp(el, "value", null, props.value, namespace);
            }
            if (vnodeHook = props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          const needCallTransitionHooks = needTransition(parentSuspense, transition);
          if (needCallTransitionHooks) {
            transition.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        };
        const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
          if (scopeId) {
            hostSetScopeId(el, scopeId);
          }
          if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
              hostSetScopeId(el, slotScopeIds[i]);
            }
          }
          if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (vnode === subTree) {
              const parentVNode = parentComponent.vnode;
              setScopeId(
                el,
                parentVNode,
                parentVNode.scopeId,
                parentVNode.slotScopeIds,
                parentComponent.parent
              );
            }
          }
        };
        const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
          for (let i = start; i < children.length; i++) {
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(
              null,
              child,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          const el = n2.el = n1.el;
          let { patchFlag, dynamicChildren, dirs } = n2;
          patchFlag |= n1.patchFlag & 16;
          const oldProps = n1.props || EMPTY_OBJ;
          const newProps = n2.props || EMPTY_OBJ;
          let vnodeHook;
          parentComponent && toggleRecurse(parentComponent, false);
          if (vnodeHook = newProps.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          }
          if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
          }
          parentComponent && toggleRecurse(parentComponent, true);
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              el,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(n2, namespace),
              slotScopeIds
            );
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              el,
              null,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(n2, namespace),
              slotScopeIds,
              false
            );
          }
          if (patchFlag > 0) {
            if (patchFlag & 16) {
              patchProps(
                el,
                n2,
                oldProps,
                newProps,
                parentComponent,
                parentSuspense,
                namespace
              );
            } else {
              if (patchFlag & 2) {
                if (oldProps.class !== newProps.class) {
                  hostPatchProp(el, "class", null, newProps.class, namespace);
                }
              }
              if (patchFlag & 4) {
                hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
              }
              if (patchFlag & 8) {
                const propsToUpdate = n2.dynamicProps;
                for (let i = 0; i < propsToUpdate.length; i++) {
                  const key = propsToUpdate[i];
                  const prev = oldProps[key];
                  const next = newProps[key];
                  if (next !== prev || key === "value") {
                    hostPatchProp(
                      el,
                      key,
                      prev,
                      next,
                      namespace,
                      n1.children,
                      parentComponent,
                      parentSuspense,
                      unmountChildren
                    );
                  }
                }
              }
            }
            if (patchFlag & 1) {
              if (n1.children !== n2.children) {
                hostSetElementText(el, n2.children);
              }
            }
          } else if (!optimized && dynamicChildren == null) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              namespace
            );
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
              dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
            }, parentSuspense);
          }
        };
        const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
          for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = (
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              (oldVNode.type === Fragment$1 || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
                // In other cases, the parent container is not actually used so we
                // just pass the block element here to avoid a DOM parentNode call.
                fallbackContainer
              )
            );
            patch(
              oldVNode,
              newVNode,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              true
            );
          }
        };
        const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
          if (oldProps !== newProps) {
            if (oldProps !== EMPTY_OBJ) {
              for (const key in oldProps) {
                if (!isReservedProp(key) && !(key in newProps)) {
                  hostPatchProp(
                    el,
                    key,
                    oldProps[key],
                    null,
                    namespace,
                    vnode.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
            for (const key in newProps) {
              if (isReservedProp(key))
                continue;
              const next = newProps[key];
              const prev = oldProps[key];
              if (next !== prev && key !== "value") {
                hostPatchProp(
                  el,
                  key,
                  prev,
                  next,
                  namespace,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in newProps) {
              hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
            }
          }
        };
        const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
          const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(
              // #10007
              // such fragment like `<></>` will be compiled into
              // a fragment which doesn't have a children.
              // In this case fallback to an empty array
              n2.children || [],
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
            // of renderSlot() with no valid children
            n1.dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                container,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds
              );
              if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null || parentComponent && n2 === parentComponent.subTree
              ) {
                traverseStaticChildren(
                  n1,
                  n2,
                  true
                  /* shallow */
                );
              }
            } else {
              patchChildren(
                n1,
                n2,
                container,
                fragmentEndAnchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        };
        const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          n2.slotScopeIds = slotScopeIds;
          if (n1 == null) {
            if (n2.shapeFlag & 512) {
              parentComponent.ctx.activate(
                n2,
                container,
                anchor,
                namespace,
                optimized
              );
            } else {
              mountComponent(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                optimized
              );
            }
          } else {
            updateComponent(n1, n2, optimized);
          }
        };
        const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
          const instance = initialVNode.component = createComponentInstance(
            initialVNode,
            parentComponent,
            parentSuspense
          );
          if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
          }
          {
            setupComponent(instance);
          }
          if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
              const placeholder = instance.subTree = createVNode(Comment);
              processCommentNode(null, placeholder, container, anchor);
            }
          } else {
            setupRenderEffect(
              instance,
              initialVNode,
              container,
              anchor,
              parentSuspense,
              namespace,
              optimized
            );
          }
        };
        const updateComponent = (n1, n2, optimized) => {
          const instance = n2.component = n1.component;
          if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
              updateComponentPreRender(instance, n2, optimized);
              return;
            } else {
              instance.next = n2;
              invalidateJob(instance.update);
              instance.effect.dirty = true;
              instance.update();
            }
          } else {
            n2.el = n1.el;
            instance.vnode = n2;
          }
        };
        const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
          const componentUpdateFn = () => {
            if (!instance.isMounted) {
              let vnodeHook;
              const { el, props } = initialVNode;
              const { bm, m: m2, parent } = instance;
              const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
              toggleRecurse(instance, false);
              if (bm) {
                invokeArrayFns(bm);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parent, initialVNode);
              }
              toggleRecurse(instance, true);
              if (el && hydrateNode) {
                const hydrateSubTree = () => {
                  instance.subTree = renderComponentRoot(instance);
                  hydrateNode(
                    el,
                    instance.subTree,
                    instance,
                    parentSuspense,
                    null
                  );
                };
                if (isAsyncWrapperVNode) {
                  initialVNode.type.__asyncLoader().then(
                    // note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    () => !instance.isUnmounted && hydrateSubTree()
                  );
                } else {
                  hydrateSubTree();
                }
              } else {
                const subTree = instance.subTree = renderComponentRoot(instance);
                patch(
                  null,
                  subTree,
                  container,
                  anchor,
                  instance,
                  parentSuspense,
                  namespace
                );
                initialVNode.el = subTree.el;
              }
              if (m2) {
                queuePostRenderEffect(m2, parentSuspense);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                const scopedInitialVNode = initialVNode;
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                  parentSuspense
                );
              }
              if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
              }
              instance.isMounted = true;
              initialVNode = container = anchor = null;
            } else {
              let { next, bu, u: u2, parent, vnode } = instance;
              {
                const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                if (nonHydratedAsyncRoot) {
                  if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                  }
                  nonHydratedAsyncRoot.asyncDep.then(() => {
                    if (!instance.isUnmounted) {
                      componentUpdateFn();
                    }
                  });
                  return;
                }
              }
              let originNext = next;
              let vnodeHook;
              toggleRecurse(instance, false);
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              } else {
                next = vnode;
              }
              if (bu) {
                invokeArrayFns(bu);
              }
              if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parent, next, vnode);
              }
              toggleRecurse(instance, true);
              const nextTree = renderComponentRoot(instance);
              const prevTree = instance.subTree;
              instance.subTree = nextTree;
              patch(
                prevTree,
                nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree),
                instance,
                parentSuspense,
                namespace
              );
              next.el = nextTree.el;
              if (originNext === null) {
                updateHOCHostEl(instance, nextTree.el);
              }
              if (u2) {
                queuePostRenderEffect(u2, parentSuspense);
              }
              if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                  parentSuspense
                );
              }
            }
          };
          const effect2 = instance.effect = new ReactiveEffect(
            componentUpdateFn,
            NOOP,
            () => queueJob(update),
            instance.scope
            // track it in component's effect scope
          );
          const update = instance.update = () => {
            if (effect2.dirty) {
              effect2.run();
            }
          };
          update.id = instance.uid;
          toggleRecurse(instance, true);
          update();
        };
        const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children, optimized);
          pauseTracking();
          flushPreFlushCbs(instance);
          resetTracking();
        };
        const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c2 = n2.children;
          const { patchFlag, shapeFlag } = n2;
          if (patchFlag > 0) {
            if (patchFlag & 128) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              return;
            } else if (patchFlag & 256) {
              patchUnkeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              return;
            }
          }
          if (shapeFlag & 8) {
            if (prevShapeFlag & 16) {
              unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
              hostSetElementText(container, c2);
            }
          } else {
            if (prevShapeFlag & 16) {
              if (shapeFlag & 16) {
                patchKeyedChildren(
                  c1,
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else {
                unmountChildren(c1, parentComponent, parentSuspense, true);
              }
            } else {
              if (prevShapeFlag & 8) {
                hostSetElementText(container, "");
              }
              if (shapeFlag & 16) {
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              }
            }
          }
        };
        const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          c1 = c1 || EMPTY_ARR;
          c2 = c2 || EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c2.length;
          const commonLength = Math.min(oldLength, newLength);
          let i;
          for (i = 0; i < commonLength; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(
              c1[i],
              nextChild,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
          if (oldLength > newLength) {
            unmountChildren(
              c1,
              parentComponent,
              parentSuspense,
              true,
              false,
              commonLength
            );
          } else {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              commonLength
            );
          }
        };
        const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          let i = 0;
          const l2 = c2.length;
          let e1 = c1.length - 1;
          let e2 = l2 - 1;
          while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            i++;
          }
          while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            e1--;
            e2--;
          }
          if (i > e1) {
            if (i <= e2) {
              const nextPos = e2 + 1;
              const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
              while (i <= e2) {
                patch(
                  null,
                  c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
                i++;
              }
            }
          } else if (i > e2) {
            while (i <= e1) {
              unmount(c1[i], parentComponent, parentSuspense, true);
              i++;
            }
          } else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for (i = s2; i <= e2; i++) {
              const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
              if (nextChild.key != null) {
                keyToNewIndexMap.set(nextChild.key, i);
              }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
              newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
              const prevChild = c1[i];
              if (patched >= toBePatched) {
                unmount(prevChild, parentComponent, parentSuspense, true);
                continue;
              }
              let newIndex;
              if (prevChild.key != null) {
                newIndex = keyToNewIndexMap.get(prevChild.key);
              } else {
                for (j = s2; j <= e2; j++) {
                  if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                    newIndex = j;
                    break;
                  }
                }
              }
              if (newIndex === void 0) {
                unmount(prevChild, parentComponent, parentSuspense, true);
              } else {
                newIndexToOldIndexMap[newIndex - s2] = i + 1;
                if (newIndex >= maxNewIndexSoFar) {
                  maxNewIndexSoFar = newIndex;
                } else {
                  moved = true;
                }
                patch(
                  prevChild,
                  c2[newIndex],
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
                patched++;
              }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            for (i = toBePatched - 1; i >= 0; i--) {
              const nextIndex = s2 + i;
              const nextChild = c2[nextIndex];
              const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
              if (newIndexToOldIndexMap[i] === 0) {
                patch(
                  null,
                  nextChild,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (moved) {
                if (j < 0 || i !== increasingNewIndexSequence[j]) {
                  move(nextChild, container, anchor, 2);
                } else {
                  j--;
                }
              }
            }
          }
        };
        const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type, transition, children, shapeFlag } = vnode;
          if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
          }
          if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
          }
          if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
          }
          if (type === Fragment$1) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
              move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
          }
          if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
          }
          const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
          if (needTransition2) {
            if (moveType === 0) {
              transition.beforeEnter(el);
              hostInsert(el, container, anchor);
              queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            } else {
              const { leave, delayLeave, afterLeave } = transition;
              const remove22 = () => hostInsert(el, container, anchor);
              const performLeave = () => {
                leave(el, () => {
                  remove22();
                  afterLeave && afterLeave();
                });
              };
              if (delayLeave) {
                delayLeave(el, remove22, performLeave);
              } else {
                performLeave();
              }
            }
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
          const {
            type,
            props,
            ref: ref3,
            children,
            dynamicChildren,
            shapeFlag,
            patchFlag,
            dirs
          } = vnode;
          if (ref3 != null) {
            setRef(ref3, null, parentSuspense, vnode, true);
          }
          if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
          }
          const shouldInvokeDirs = shapeFlag & 1 && dirs;
          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
          let vnodeHook;
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
          } else {
            if (shapeFlag & 128) {
              vnode.suspense.unmount(parentSuspense, doRemove);
              return;
            }
            if (shouldInvokeDirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            }
            if (shapeFlag & 64) {
              vnode.type.remove(
                vnode,
                parentComponent,
                parentSuspense,
                optimized,
                internals,
                doRemove
              );
            } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment$1 || patchFlag > 0 && patchFlag & 64)) {
              unmountChildren(
                dynamicChildren,
                parentComponent,
                parentSuspense,
                false,
                true
              );
            } else if (type === Fragment$1 && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
              unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
              remove2(vnode);
            }
          }
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
            }, parentSuspense);
          }
        };
        const remove2 = (vnode) => {
          const { type, el, anchor, transition } = vnode;
          if (type === Fragment$1) {
            {
              removeFragment(el, anchor);
            }
            return;
          }
          if (type === Static) {
            removeStaticNode(vnode);
            return;
          }
          const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
              transition.afterLeave();
            }
          };
          if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
              delayLeave(vnode.el, performRemove, performLeave);
            } else {
              performLeave();
            }
          } else {
            performRemove();
          }
        };
        const removeFragment = (cur, end2) => {
          let next;
          while (cur !== end2) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
          }
          hostRemove(end2);
        };
        const unmountComponent = (instance, parentSuspense, doRemove) => {
          const { bum, scope, update, subTree, um } = instance;
          if (bum) {
            invokeArrayFns(bum);
          }
          scope.stop();
          if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
          }
          if (um) {
            queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
            instance.isUnmounted = true;
          }, parentSuspense);
          if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
              parentSuspense.resolve();
            }
          }
        };
        const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
          for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
          }
        };
        const getNextHostNode = (vnode) => {
          if (vnode.shapeFlag & 6) {
            return getNextHostNode(vnode.component.subTree);
          }
          if (vnode.shapeFlag & 128) {
            return vnode.suspense.next();
          }
          return hostNextSibling(vnode.anchor || vnode.el);
        };
        let isFlushing2 = false;
        const render2 = (vnode, container, namespace) => {
          if (vnode == null) {
            if (container._vnode) {
              unmount(container._vnode, null, null, true);
            }
          } else {
            patch(
              container._vnode || null,
              vnode,
              container,
              null,
              null,
              null,
              namespace
            );
          }
          if (!isFlushing2) {
            isFlushing2 = true;
            flushPreFlushCbs();
            flushPostFlushCbs();
            isFlushing2 = false;
          }
          container._vnode = vnode;
        };
        const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove2,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
        };
        let hydrate;
        let hydrateNode;
        if (createHydrationFns) {
          [hydrate, hydrateNode] = createHydrationFns(
            internals
          );
        }
        return {
          render: render2,
          hydrate,
          createApp: createAppAPI(render2, hydrate)
        };
      }
      function resolveChildrenNamespace({ type, props }, currentNamespace) {
        return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
      }
      function toggleRecurse({ effect: effect2, update }, allowed) {
        effect2.allowRecurse = update.allowRecurse = allowed;
      }
      function needTransition(parentSuspense, transition) {
        return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
      }
      function traverseStaticChildren(n1, n2, shallow = false) {
        const ch1 = n1.children;
        const ch2 = n2.children;
        if (isArray$2(ch1) && isArray$2(ch2)) {
          for (let i = 0; i < ch1.length; i++) {
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
              if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
              }
              if (!shallow)
                traverseStaticChildren(c1, c2);
            }
            if (c2.type === Text) {
              c2.el = c1.el;
            }
          }
        }
      }
      function getSequence(arr) {
        const p2 = arr.slice();
        const result = [0];
        let i, j, u2, v2, c2;
        const len = arr.length;
        for (i = 0; i < len; i++) {
          const arrI = arr[i];
          if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
              p2[i] = j;
              result.push(i);
              continue;
            }
            u2 = 0;
            v2 = result.length - 1;
            while (u2 < v2) {
              c2 = u2 + v2 >> 1;
              if (arr[result[c2]] < arrI) {
                u2 = c2 + 1;
              } else {
                v2 = c2;
              }
            }
            if (arrI < arr[result[u2]]) {
              if (u2 > 0) {
                p2[i] = result[u2 - 1];
              }
              result[u2] = i;
            }
          }
        }
        u2 = result.length;
        v2 = result[u2 - 1];
        while (u2-- > 0) {
          result[u2] = v2;
          v2 = p2[v2];
        }
        return result;
      }
      function locateNonHydratedAsyncRoot(instance) {
        const subComponent = instance.subTree.component;
        if (subComponent) {
          if (subComponent.asyncDep && !subComponent.asyncResolved) {
            return subComponent;
          } else {
            return locateNonHydratedAsyncRoot(subComponent);
          }
        }
      }
      const isTeleport = (type) => type.__isTeleport;
      const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
      const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
      const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
      const resolveTarget = (props, select) => {
        const targetSelector = props && props.to;
        if (isString$3(targetSelector)) {
          if (!select) {
            return null;
          } else {
            const target = select(targetSelector);
            return target;
          }
        } else {
          return targetSelector;
        }
      };
      const TeleportImpl = {
        name: "Teleport",
        __isTeleport: true,
        process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
          const {
            mc: mountChildren,
            pc: patchChildren,
            pbc: patchBlockChildren,
            o: { insert, querySelector, createText, createComment }
          } = internals;
          const disabled = isTeleportDisabled(n2.props);
          let { shapeFlag, children, dynamicChildren } = n2;
          if (n1 == null) {
            const placeholder = n2.el = createText("");
            const mainAnchor = n2.anchor = createText("");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
              insert(targetAnchor, target);
              if (namespace === "svg" || isTargetSVG(target)) {
                namespace = "svg";
              } else if (namespace === "mathml" || isTargetMathML(target)) {
                namespace = "mathml";
              }
            }
            const mount = (container2, anchor2) => {
              if (shapeFlag & 16) {
                mountChildren(
                  children,
                  container2,
                  anchor2,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              }
            };
            if (disabled) {
              mount(container, mainAnchor);
            } else if (target) {
              mount(target, targetAnchor);
            }
          } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            if (namespace === "svg" || isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace === "mathml" || isTargetMathML(target)) {
              namespace = "mathml";
            }
            if (dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                currentContainer,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds
              );
              traverseStaticChildren(n1, n2, true);
            } else if (!optimized) {
              patchChildren(
                n1,
                n2,
                currentContainer,
                currentAnchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                false
              );
            }
            if (disabled) {
              if (!wasDisabled) {
                moveTeleport(
                  n2,
                  container,
                  mainAnchor,
                  internals,
                  1
                );
              } else {
                if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                  n2.props.to = n1.props.to;
                }
              }
            } else {
              if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                const nextTarget = n2.target = resolveTarget(
                  n2.props,
                  querySelector
                );
                if (nextTarget) {
                  moveTeleport(
                    n2,
                    nextTarget,
                    null,
                    internals,
                    0
                  );
                }
              } else if (wasDisabled) {
                moveTeleport(
                  n2,
                  target,
                  targetAnchor,
                  internals,
                  1
                );
              }
            }
          }
          updateCssVars(n2);
        },
        remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
          if (target) {
            hostRemove(targetAnchor);
          }
          doRemove && hostRemove(anchor);
          if (shapeFlag & 16) {
            const shouldRemove = doRemove || !isTeleportDisabled(props);
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              unmount(
                child,
                parentComponent,
                parentSuspense,
                shouldRemove,
                !!child.dynamicChildren
              );
            }
          }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
      };
      function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
        if (moveType === 0) {
          insert(vnode.targetAnchor, container, parentAnchor);
        }
        const { el, anchor, shapeFlag, children, props } = vnode;
        const isReorder = moveType === 2;
        if (isReorder) {
          insert(el, container, parentAnchor);
        }
        if (!isReorder || isTeleportDisabled(props)) {
          if (shapeFlag & 16) {
            for (let i = 0; i < children.length; i++) {
              move(
                children[i],
                container,
                parentAnchor,
                2
              );
            }
          }
        }
        if (isReorder) {
          insert(anchor, container, parentAnchor);
        }
      }
      function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
        o: { nextSibling, parentNode, querySelector }
      }, hydrateChildren) {
        const target = vnode.target = resolveTarget(
          vnode.props,
          querySelector
        );
        if (target) {
          const targetNode = target._lpa || target.firstChild;
          if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
              vnode.anchor = hydrateChildren(
                nextSibling(node),
                vnode,
                parentNode(node),
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
              vnode.targetAnchor = targetNode;
            } else {
              vnode.anchor = nextSibling(node);
              let targetAnchor = targetNode;
              while (targetAnchor) {
                targetAnchor = nextSibling(targetAnchor);
                if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              hydrateChildren(
                targetNode,
                vnode,
                target,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
          }
          updateCssVars(vnode);
        }
        return vnode.anchor && nextSibling(vnode.anchor);
      }
      const Teleport = TeleportImpl;
      function updateCssVars(vnode) {
        const ctx = vnode.ctx;
        if (ctx && ctx.ut) {
          let node = vnode.children[0].el;
          while (node && node !== vnode.targetAnchor) {
            if (node.nodeType === 1)
              node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
          }
          ctx.ut();
        }
      }
      const Fragment$1 = Symbol.for("v-fgt");
      const Text = Symbol.for("v-txt");
      const Comment = Symbol.for("v-cmt");
      const Static = Symbol.for("v-stc");
      const blockStack = [];
      let currentBlock = null;
      function openBlock(disableTracking = false) {
        blockStack.push(currentBlock = disableTracking ? null : []);
      }
      function closeBlock() {
        blockStack.pop();
        currentBlock = blockStack[blockStack.length - 1] || null;
      }
      let isBlockTreeEnabled = 1;
      function setBlockTracking(value) {
        isBlockTreeEnabled += value;
      }
      function setupBlock(vnode) {
        vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
        closeBlock();
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
        return setupBlock(
          createBaseVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            shapeFlag,
            true
          )
        );
      }
      function createBlock(type, props, children, patchFlag, dynamicProps) {
        return setupBlock(
          createVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            true
          )
        );
      }
      function isVNode$1(value) {
        return value ? value.__v_isVNode === true : false;
      }
      function isSameVNodeType(n1, n2) {
        return n1.type === n2.type && n1.key === n2.key;
      }
      const InternalObjectKey = `__vInternal`;
      const normalizeKey = ({ key }) => key != null ? key : null;
      const normalizeRef = ({
        ref: ref3,
        ref_key,
        ref_for
      }) => {
        if (typeof ref3 === "number") {
          ref3 = "" + ref3;
        }
        return ref3 != null ? isString$3(ref3) || isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
      };
      function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment$1 ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
        const vnode = {
          __v_isVNode: true,
          __v_skip: true,
          type,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          scopeId: currentScopeId,
          slotScopeIds: null,
          children,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null,
          ctx: currentRenderingInstance
        };
        if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children);
          if (shapeFlag & 128) {
            type.normalize(vnode);
          }
        } else if (children) {
          vnode.shapeFlag |= isString$3(children) ? 8 : 16;
        }
        if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
        !isBlockNode && // has current parent block
        currentBlock && // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      const createVNode = _createVNode;
      function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
        if (!type || type === NULL_DYNAMIC_COMPONENT) {
          type = Comment;
        }
        if (isVNode$1(type)) {
          const cloned = cloneVNode(
            type,
            props,
            true
            /* mergeRef: true */
          );
          if (children) {
            normalizeChildren(cloned, children);
          }
          if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) {
              currentBlock[currentBlock.indexOf(type)] = cloned;
            } else {
              currentBlock.push(cloned);
            }
          }
          cloned.patchFlag |= -2;
          return cloned;
        }
        if (isClassComponent(type)) {
          type = type.__vccOpts;
        }
        if (props) {
          props = guardReactiveProps(props);
          let { class: klass, style } = props;
          if (klass && !isString$3(klass)) {
            props.class = normalizeClass(klass);
          }
          if (isObject$5(style)) {
            if (isProxy(style) && !isArray$2(style)) {
              style = extend({}, style);
            }
            props.style = normalizeStyle(style);
          }
        }
        const shapeFlag = isString$3(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$5(type) ? 4 : isFunction$2(type) ? 2 : 0;
        return createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          isBlockNode,
          true
        );
      }
      function guardReactiveProps(props) {
        if (!props)
          return null;
        return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
      }
      function cloneVNode(vnode, extraProps, mergeRef = false) {
        const { props, ref: ref3, patchFlag, children } = vnode;
        const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
        const cloned = {
          __v_isVNode: true,
          __v_skip: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref ? (
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
          ) : ref3,
          scopeId: vnode.scopeId,
          slotScopeIds: vnode.slotScopeIds,
          children,
          target: vnode.target,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: preserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment$1 ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition: vnode.transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          el: vnode.el,
          anchor: vnode.anchor,
          ctx: vnode.ctx,
          ce: vnode.ce
        };
        return cloned;
      }
      function createTextVNode(text = " ", flag = 0) {
        return createVNode(Text, null, text, flag);
      }
      function createCommentVNode(text = "", asBlock = false) {
        return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
      }
      function normalizeVNode(child) {
        if (child == null || typeof child === "boolean") {
          return createVNode(Comment);
        } else if (isArray$2(child)) {
          return createVNode(
            Fragment$1,
            null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice()
          );
        } else if (typeof child === "object") {
          return cloneIfMounted(child);
        } else {
          return createVNode(Text, null, String(child));
        }
      }
      function cloneIfMounted(child) {
        return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
      }
      function normalizeChildren(vnode, children) {
        let type = 0;
        const { shapeFlag } = vnode;
        if (children == null) {
          children = null;
        } else if (isArray$2(children)) {
          type = 16;
        } else if (typeof children === "object") {
          if (shapeFlag & (1 | 64)) {
            const slot = children.default;
            if (slot) {
              slot._c && (slot._d = false);
              normalizeChildren(vnode, slot());
              slot._c && (slot._d = true);
            }
            return;
          } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
              children._ctx = currentRenderingInstance;
            } else if (slotFlag === 3 && currentRenderingInstance) {
              if (currentRenderingInstance.slots._ === 1) {
                children._ = 1;
              } else {
                children._ = 2;
                vnode.patchFlag |= 1024;
              }
            }
          }
        } else if (isFunction$2(children)) {
          children = { default: children, _ctx: currentRenderingInstance };
          type = 32;
        } else {
          children = String(children);
          if (shapeFlag & 64) {
            type = 16;
            children = [createTextVNode(children)];
          } else {
            type = 8;
          }
        }
        vnode.children = children;
        vnode.shapeFlag |= type;
      }
      function mergeProps(...args) {
        const ret = {};
        for (let i = 0; i < args.length; i++) {
          const toMerge = args[i];
          for (const key in toMerge) {
            if (key === "class") {
              if (ret.class !== toMerge.class) {
                ret.class = normalizeClass([ret.class, toMerge.class]);
              }
            } else if (key === "style") {
              ret.style = normalizeStyle([ret.style, toMerge.style]);
            } else if (isOn(key)) {
              const existing = ret[key];
              const incoming = toMerge[key];
              if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
                ret[key] = existing ? [].concat(existing, incoming) : incoming;
              }
            } else if (key !== "") {
              ret[key] = toMerge[key];
            }
          }
        }
        return ret;
      }
      function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
        callWithAsyncErrorHandling(hook, instance, 7, [
          vnode,
          prevVNode
        ]);
      }
      const emptyAppContext = createAppContext();
      let uid = 0;
      function createComponentInstance(vnode, parent, suspense) {
        const type = vnode.type;
        const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
        const instance = {
          uid: uid++,
          vnode,
          type,
          parent,
          appContext,
          root: null,
          // to be immediately set
          next: null,
          subTree: null,
          // will be set synchronously right after creation
          effect: null,
          update: null,
          // will be set synchronously right after creation
          scope: new EffectScope(
            true
            /* detached */
          ),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: parent ? parent.provides : Object.create(appContext.provides),
          accessCache: null,
          renderCache: [],
          // local resolved assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type, appContext),
          emitsOptions: normalizeEmitsOptions(type, appContext),
          // emit
          emit: null,
          // to be set immediately
          emitted: null,
          // props default value
          propsDefaults: EMPTY_OBJ,
          // inheritAttrs
          inheritAttrs: type.inheritAttrs,
          // state
          ctx: EMPTY_OBJ,
          data: EMPTY_OBJ,
          props: EMPTY_OBJ,
          attrs: EMPTY_OBJ,
          slots: EMPTY_OBJ,
          refs: EMPTY_OBJ,
          setupState: EMPTY_OBJ,
          setupContext: null,
          attrsProxy: null,
          slotsProxy: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
        };
        {
          instance.ctx = { _: instance };
        }
        instance.root = parent ? parent.root : instance;
        instance.emit = emit.bind(null, instance);
        if (vnode.ce) {
          vnode.ce(instance);
        }
        return instance;
      }
      let currentInstance = null;
      const getCurrentInstance = () => currentInstance || currentRenderingInstance;
      let internalSetCurrentInstance;
      let setInSSRSetupState;
      {
        const g = getGlobalThis$1();
        const registerGlobalSetter = (key, setter) => {
          let setters;
          if (!(setters = g[key]))
            setters = g[key] = [];
          setters.push(setter);
          return (v2) => {
            if (setters.length > 1)
              setters.forEach((set2) => set2(v2));
            else
              setters[0](v2);
          };
        };
        internalSetCurrentInstance = registerGlobalSetter(
          `__VUE_INSTANCE_SETTERS__`,
          (v2) => currentInstance = v2
        );
        setInSSRSetupState = registerGlobalSetter(
          `__VUE_SSR_SETTERS__`,
          (v2) => isInSSRComponentSetup = v2
        );
      }
      const setCurrentInstance = (instance) => {
        const prev = currentInstance;
        internalSetCurrentInstance(instance);
        instance.scope.on();
        return () => {
          instance.scope.off();
          internalSetCurrentInstance(prev);
        };
      };
      const unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        internalSetCurrentInstance(null);
      };
      function isStatefulComponent(instance) {
        return instance.vnode.shapeFlag & 4;
      }
      let isInSSRComponentSetup = false;
      function setupComponent(instance, isSSR = false) {
        isSSR && setInSSRSetupState(isSSR);
        const { props, children } = instance.vnode;
        const isStateful = isStatefulComponent(instance);
        initProps(instance, props, isStateful, isSSR);
        initSlots(instance, children);
        const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
        isSSR && setInSSRSetupState(false);
        return setupResult;
      }
      function setupStatefulComponent(instance, isSSR) {
        const Component = instance.type;
        instance.accessCache = /* @__PURE__ */ Object.create(null);
        instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
        const { setup } = Component;
        if (setup) {
          const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
          const reset = setCurrentInstance(instance);
          pauseTracking();
          const setupResult = callWithErrorHandling(
            setup,
            instance,
            0,
            [
              instance.props,
              setupContext
            ]
          );
          resetTracking();
          reset();
          if (isPromise$1(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
              return setupResult.then((resolvedResult) => {
                handleSetupResult(instance, resolvedResult, isSSR);
              }).catch((e) => {
                handleError(e, instance, 0);
              });
            } else {
              instance.asyncDep = setupResult;
            }
          } else {
            handleSetupResult(instance, setupResult, isSSR);
          }
        } else {
          finishComponentSetup(instance, isSSR);
        }
      }
      function handleSetupResult(instance, setupResult, isSSR) {
        if (isFunction$2(setupResult)) {
          if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
          } else {
            instance.render = setupResult;
          }
        } else if (isObject$5(setupResult)) {
          instance.setupState = proxyRefs(setupResult);
        } else
          ;
        finishComponentSetup(instance, isSSR);
      }
      let compile$1;
      function finishComponentSetup(instance, isSSR, skipOptions) {
        const Component = instance.type;
        if (!instance.render) {
          if (!isSSR && compile$1 && !Component.render) {
            const template2 = Component.template || resolveMergedOptions(instance).template;
            if (template2) {
              const { isCustomElement, compilerOptions } = instance.appContext.config;
              const { delimiters, compilerOptions: componentCompilerOptions } = Component;
              const finalCompilerOptions = extend(
                extend(
                  {
                    isCustomElement,
                    delimiters
                  },
                  compilerOptions
                ),
                componentCompilerOptions
              );
              Component.render = compile$1(template2, finalCompilerOptions);
            }
          }
          instance.render = Component.render || NOOP;
        }
        {
          const reset = setCurrentInstance(instance);
          pauseTracking();
          try {
            applyOptions(instance);
          } finally {
            resetTracking();
            reset();
          }
        }
      }
      function getAttrsProxy(instance) {
        return instance.attrsProxy || (instance.attrsProxy = new Proxy(
          instance.attrs,
          {
            get(target, key) {
              track(instance, "get", "$attrs");
              return target[key];
            }
          }
        ));
      }
      function createSetupContext(instance) {
        const expose2 = (exposed) => {
          instance.exposed = exposed || {};
        };
        {
          return {
            get attrs() {
              return getAttrsProxy(instance);
            },
            slots: instance.slots,
            emit: instance.emit,
            expose: expose2
          };
        }
      }
      function getExposeProxy(instance) {
        if (instance.exposed) {
          return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
            get(target, key) {
              if (key in target) {
                return target[key];
              } else if (key in publicPropertiesMap) {
                return publicPropertiesMap[key](instance);
              }
            },
            has(target, key) {
              return key in target || key in publicPropertiesMap;
            }
          }));
        }
      }
      const classifyRE = /(?:^|[-_])(\w)/g;
      const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
      function getComponentName(Component, includeInferred = true) {
        return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
      }
      function formatComponentName(instance, Component, isRoot = false) {
        let name = getComponentName(Component);
        if (!name && Component.__file) {
          const match2 = Component.__file.match(/([^/\\]+)\.\w+$/);
          if (match2) {
            name = match2[1];
          }
        }
        if (!name && instance && instance.parent) {
          const inferFromRegistry = (registry) => {
            for (const key in registry) {
              if (registry[key] === Component) {
                return key;
              }
            }
          };
          name = inferFromRegistry(
            instance.components || instance.parent.type.components
          ) || inferFromRegistry(instance.appContext.components);
        }
        return name ? classify(name) : isRoot ? `App` : `Anonymous`;
      }
      function isClassComponent(value) {
        return isFunction$2(value) && "__vccOpts" in value;
      }
      const computed = (getterOrOptions, debugOptions) => {
        const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
        return c2;
      };
      function h$1(type, propsOrChildren, children) {
        const l2 = arguments.length;
        if (l2 === 2) {
          if (isObject$5(propsOrChildren) && !isArray$2(propsOrChildren)) {
            if (isVNode$1(propsOrChildren)) {
              return createVNode(type, null, [propsOrChildren]);
            }
            return createVNode(type, propsOrChildren);
          } else {
            return createVNode(type, null, propsOrChildren);
          }
        } else {
          if (l2 > 3) {
            children = Array.prototype.slice.call(arguments, 2);
          } else if (l2 === 3 && isVNode$1(children)) {
            children = [children];
          }
          return createVNode(type, propsOrChildren, children);
        }
      }
      const version = "3.4.21";
      const warn$2 = NOOP;
      /**
      * @vue/runtime-dom v3.4.21
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const svgNS = "http://www.w3.org/2000/svg";
      const mathmlNS = "http://www.w3.org/1998/Math/MathML";
      const doc = typeof document !== "undefined" ? document : null;
      const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
      const nodeOps = {
        insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createElement: (tag, namespace, is, props) => {
          const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
          if (tag === "select" && props && props.multiple != null) {
            el.setAttribute("multiple", props.multiple);
          }
          return el;
        },
        createText: (text) => doc.createTextNode(text),
        createComment: (text) => doc.createComment(text),
        setText: (node, text) => {
          node.nodeValue = text;
        },
        setElementText: (el, text) => {
          el.textContent = text;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector) => doc.querySelector(selector),
        setScopeId(el, id) {
          el.setAttribute(id, "");
        },
        // __UNSAFE__
        // Reason: innerHTML.
        // Static content here can only come from compiled templates.
        // As long as the user only uses trusted templates, this is safe.
        insertStaticContent(content, parent, anchor, namespace, start, end2) {
          const before2 = anchor ? anchor.previousSibling : parent.lastChild;
          if (start && (start === end2 || start.nextSibling)) {
            while (true) {
              parent.insertBefore(start.cloneNode(true), anchor);
              if (start === end2 || !(start = start.nextSibling))
                break;
            }
          } else {
            templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
            const template2 = templateContainer.content;
            if (namespace === "svg" || namespace === "mathml") {
              const wrapper = template2.firstChild;
              while (wrapper.firstChild) {
                template2.appendChild(wrapper.firstChild);
              }
              template2.removeChild(wrapper);
            }
            parent.insertBefore(template2, anchor);
          }
          return [
            // first
            before2 ? before2.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
          ];
        }
      };
      const TRANSITION = "transition";
      const ANIMATION = "animation";
      const vtcKey = Symbol("_vtc");
      const Transition = (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots);
      Transition.displayName = "Transition";
      const DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
        {},
        BaseTransitionPropsValidators,
        DOMTransitionPropsValidators
      );
      const callHook = (hook, args = []) => {
        if (isArray$2(hook)) {
          hook.forEach((h2) => h2(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      const hasExplicitCallback = (hook) => {
        return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
      };
      function resolveTransitionProps(rawProps) {
        const baseProps = {};
        for (const key in rawProps) {
          if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
          }
        }
        if (rawProps.css === false) {
          return baseProps;
        }
        const {
          name = "v",
          type,
          duration,
          enterFromClass = `${name}-enter-from`,
          enterActiveClass = `${name}-enter-active`,
          enterToClass = `${name}-enter-to`,
          appearFromClass = enterFromClass,
          appearActiveClass = enterActiveClass,
          appearToClass = enterToClass,
          leaveFromClass = `${name}-leave-from`,
          leaveActiveClass = `${name}-leave-active`,
          leaveToClass = `${name}-leave-to`
        } = rawProps;
        const durations = normalizeDuration(duration);
        const enterDuration = durations && durations[0];
        const leaveDuration = durations && durations[1];
        const {
          onBeforeEnter,
          onEnter,
          onEnterCancelled,
          onLeave,
          onLeaveCancelled,
          onBeforeAppear = onBeforeEnter,
          onAppear = onEnter,
          onAppearCancelled = onEnterCancelled
        } = baseProps;
        const finishEnter = (el, isAppear, done) => {
          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
          done && done();
        };
        const finishLeave = (el, done) => {
          el._isLeaving = false;
          removeTransitionClass(el, leaveFromClass);
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
          done && done();
        };
        const makeEnterHook = (isAppear) => {
          return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve2 = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve2]);
            nextFrame(() => {
              removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
              addTransitionClass(el, isAppear ? appearToClass : enterToClass);
              if (!hasExplicitCallback(hook)) {
                whenTransitionEnds(el, type, enterDuration, resolve2);
              }
            });
          };
        };
        return extend(baseProps, {
          onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
          },
          onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
          },
          onEnter: makeEnterHook(false),
          onAppear: makeEnterHook(true),
          onLeave(el, done) {
            el._isLeaving = true;
            const resolve2 = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
              if (!el._isLeaving) {
                return;
              }
              removeTransitionClass(el, leaveFromClass);
              addTransitionClass(el, leaveToClass);
              if (!hasExplicitCallback(onLeave)) {
                whenTransitionEnds(el, type, leaveDuration, resolve2);
              }
            });
            callHook(onLeave, [el, resolve2]);
          },
          onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
          },
          onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
          },
          onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
          }
        });
      }
      function normalizeDuration(duration) {
        if (duration == null) {
          return null;
        } else if (isObject$5(duration)) {
          return [NumberOf(duration.enter), NumberOf(duration.leave)];
        } else {
          const n = NumberOf(duration);
          return [n, n];
        }
      }
      function NumberOf(val) {
        const res = toNumber$1(val);
        return res;
      }
      function addTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
        (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
      }
      function removeTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
        const _vtc = el[vtcKey];
        if (_vtc) {
          _vtc.delete(cls);
          if (!_vtc.size) {
            el[vtcKey] = void 0;
          }
        }
      }
      function nextFrame(cb) {
        requestAnimationFrame(() => {
          requestAnimationFrame(cb);
        });
      }
      let endId = 0;
      function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
        const id = el._endId = ++endId;
        const resolveIfNotStale = () => {
          if (id === el._endId) {
            resolve2();
          }
        };
        if (explicitTimeout) {
          return setTimeout(resolveIfNotStale, explicitTimeout);
        }
        const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
        if (!type) {
          return resolve2();
        }
        const endEvent = type + "end";
        let ended = 0;
        const end2 = () => {
          el.removeEventListener(endEvent, onEnd);
          resolveIfNotStale();
        };
        const onEnd = (e) => {
          if (e.target === el && ++ended >= propCount) {
            end2();
          }
        };
        setTimeout(() => {
          if (ended < propCount) {
            end2();
          }
        }, timeout + 1);
        el.addEventListener(endEvent, onEnd);
      }
      function getTransitionInfo(el, expectedType) {
        const styles = window.getComputedStyle(el);
        const getStyleProperties = (key) => (styles[key] || "").split(", ");
        const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
        const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
        const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
        const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
        const animationTimeout = getTimeout(animationDelays, animationDurations);
        let type = null;
        let timeout = 0;
        let propCount = 0;
        if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
          }
        } else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
          }
        } else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
          propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
        }
        const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
          getStyleProperties(`${TRANSITION}Property`).toString()
        );
        return {
          type,
          timeout,
          propCount,
          hasTransform
        };
      }
      function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
          delays = delays.concat(delays);
        }
        return Math.max(...durations.map((d2, i) => toMs(d2) + toMs(delays[i])));
      }
      function toMs(s2) {
        if (s2 === "auto")
          return 0;
        return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
      }
      function forceReflow() {
        return document.body.offsetHeight;
      }
      function patchClass(el, value, isSVG) {
        const transitionClasses = el[vtcKey];
        if (transitionClasses) {
          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
        }
        if (value == null) {
          el.removeAttribute("class");
        } else if (isSVG) {
          el.setAttribute("class", value);
        } else {
          el.className = value;
        }
      }
      const vShowOriginalDisplay = Symbol("_vod");
      const vShowHidden = Symbol("_vsh");
      const vShow = {
        beforeMount(el, { value }, { transition }) {
          el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
          if (transition && value) {
            transition.beforeEnter(el);
          } else {
            setDisplay(el, value);
          }
        },
        mounted(el, { value }, { transition }) {
          if (transition && value) {
            transition.enter(el);
          }
        },
        updated(el, { value, oldValue }, { transition }) {
          if (!value === !oldValue)
            return;
          if (transition) {
            if (value) {
              transition.beforeEnter(el);
              setDisplay(el, true);
              transition.enter(el);
            } else {
              transition.leave(el, () => {
                setDisplay(el, false);
              });
            }
          } else {
            setDisplay(el, value);
          }
        },
        beforeUnmount(el, { value }) {
          setDisplay(el, value);
        }
      };
      function setDisplay(el, value) {
        el.style.display = value ? el[vShowOriginalDisplay] : "none";
        el[vShowHidden] = !value;
      }
      const CSS_VAR_TEXT = Symbol("");
      const displayRE = /(^|;)\s*display\s*:/;
      function patchStyle(el, prev, next) {
        const style = el.style;
        const isCssString = isString$3(next);
        let hasControlledDisplay = false;
        if (next && !isCssString) {
          if (prev) {
            if (!isString$3(prev)) {
              for (const key in prev) {
                if (next[key] == null) {
                  setStyle(style, key, "");
                }
              }
            } else {
              for (const prevStyle of prev.split(";")) {
                const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                if (next[key] == null) {
                  setStyle(style, key, "");
                }
              }
            }
          }
          for (const key in next) {
            if (key === "display") {
              hasControlledDisplay = true;
            }
            setStyle(style, key, next[key]);
          }
        } else {
          if (isCssString) {
            if (prev !== next) {
              const cssVarText = style[CSS_VAR_TEXT];
              if (cssVarText) {
                next += ";" + cssVarText;
              }
              style.cssText = next;
              hasControlledDisplay = displayRE.test(next);
            }
          } else if (prev) {
            el.removeAttribute("style");
          }
        }
        if (vShowOriginalDisplay in el) {
          el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
          if (el[vShowHidden]) {
            style.display = "none";
          }
        }
      }
      const importantRE = /\s*!important$/;
      function setStyle(style, name, val) {
        if (isArray$2(val)) {
          val.forEach((v2) => setStyle(style, name, v2));
        } else {
          if (val == null)
            val = "";
          if (name.startsWith("--")) {
            style.setProperty(name, val);
          } else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
              style.setProperty(
                hyphenate(prefixed),
                val.replace(importantRE, ""),
                "important"
              );
            } else {
              style[prefixed] = val;
            }
          }
        }
      }
      const prefixes = ["Webkit", "Moz", "ms"];
      const prefixCache = {};
      function autoPrefix(style, rawName) {
        const cached = prefixCache[rawName];
        if (cached) {
          return cached;
        }
        let name = camelize(rawName);
        if (name !== "filter" && name in style) {
          return prefixCache[rawName] = name;
        }
        name = capitalize$2(name);
        for (let i = 0; i < prefixes.length; i++) {
          const prefixed = prefixes[i] + name;
          if (prefixed in style) {
            return prefixCache[rawName] = prefixed;
          }
        }
        return rawName;
      }
      const xlinkNS = "http://www.w3.org/1999/xlink";
      function patchAttr(el, key, value, isSVG, instance) {
        if (isSVG && key.startsWith("xlink:")) {
          if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          } else {
            el.setAttributeNS(xlinkNS, key, value);
          }
        } else {
          const isBoolean2 = isSpecialBooleanAttr(key);
          if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
            el.removeAttribute(key);
          } else {
            el.setAttribute(key, isBoolean2 ? "" : value);
          }
        }
      }
      function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
        if (key === "innerHTML" || key === "textContent") {
          if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
          }
          el[key] = value == null ? "" : value;
          return;
        }
        const tag = el.tagName;
        if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
        !tag.includes("-")) {
          const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
          const newValue = value == null ? "" : value;
          if (oldValue !== newValue || !("_value" in el)) {
            el.value = newValue;
          }
          if (value == null) {
            el.removeAttribute(key);
          }
          el._value = value;
          return;
        }
        let needRemove = false;
        if (value === "" || value == null) {
          const type = typeof el[key];
          if (type === "boolean") {
            value = includeBooleanAttr(value);
          } else if (value == null && type === "string") {
            value = "";
            needRemove = true;
          } else if (type === "number") {
            value = 0;
            needRemove = true;
          }
        }
        try {
          el[key] = value;
        } catch (e) {
        }
        needRemove && el.removeAttribute(key);
      }
      function addEventListener(el, event, handler, options) {
        el.addEventListener(event, handler, options);
      }
      function removeEventListener(el, event, handler, options) {
        el.removeEventListener(event, handler, options);
      }
      const veiKey = Symbol("_vei");
      function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
        const invokers = el[veiKey] || (el[veiKey] = {});
        const existingInvoker = invokers[rawName];
        if (nextValue && existingInvoker) {
          existingInvoker.value = nextValue;
        } else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
          } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
          }
        }
      }
      const optionsModifierRE = /(?:Once|Passive|Capture)$/;
      function parseName(name) {
        let options;
        if (optionsModifierRE.test(name)) {
          options = {};
          let m2;
          while (m2 = name.match(optionsModifierRE)) {
            name = name.slice(0, name.length - m2[0].length);
            options[m2[0].toLowerCase()] = true;
          }
        }
        const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
        return [event, options];
      }
      let cachedNow = 0;
      const p$1 = /* @__PURE__ */ Promise.resolve();
      const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
      function createInvoker(initialValue, instance) {
        const invoker = (e) => {
          if (!e._vts) {
            e._vts = Date.now();
          } else if (e._vts <= invoker.attached) {
            return;
          }
          callWithAsyncErrorHandling(
            patchStopImmediatePropagation(e, invoker.value),
            instance,
            5,
            [e]
          );
        };
        invoker.value = initialValue;
        invoker.attached = getNow();
        return invoker;
      }
      function patchStopImmediatePropagation(e, value) {
        if (isArray$2(value)) {
          const originalStop = e.stopImmediatePropagation;
          e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
          };
          return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
        } else {
          return value;
        }
      }
      const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
      key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
      const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
        const isSVG = namespace === "svg";
        if (key === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (isOn(key)) {
          if (!isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
        } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(
            el,
            key,
            nextValue,
            prevChildren,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        } else {
          if (key === "true-value") {
            el._trueValue = nextValue;
          } else if (key === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
        }
      };
      function shouldSetAsProp(el, key, value, isSVG) {
        if (isSVG) {
          if (key === "innerHTML" || key === "textContent") {
            return true;
          }
          if (key in el && isNativeOn(key) && isFunction$2(value)) {
            return true;
          }
          return false;
        }
        if (key === "spellcheck" || key === "draggable" || key === "translate") {
          return false;
        }
        if (key === "form") {
          return false;
        }
        if (key === "list" && el.tagName === "INPUT") {
          return false;
        }
        if (key === "type" && el.tagName === "TEXTAREA") {
          return false;
        }
        if (key === "width" || key === "height") {
          const tag = el.tagName;
          if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
            return false;
          }
        }
        if (isNativeOn(key) && isString$3(value)) {
          return false;
        }
        return key in el;
      }
      const positionMap = /* @__PURE__ */ new WeakMap();
      const newPositionMap = /* @__PURE__ */ new WeakMap();
      const moveCbKey = Symbol("_moveCb");
      const enterCbKey = Symbol("_enterCb");
      const TransitionGroupImpl = {
        name: "TransitionGroup",
        props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
          tag: String,
          moveClass: String
        }),
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevChildren;
          let children;
          onUpdated(() => {
            if (!prevChildren.length) {
              return;
            }
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(
              prevChildren[0].el,
              instance.vnode.el,
              moveClass
            )) {
              return;
            }
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c2) => {
              const el = c2.el;
              const style = el.style;
              addTransitionClass(el, moveClass);
              style.transform = style.webkitTransform = style.transitionDuration = "";
              const cb = el[moveCbKey] = (e) => {
                if (e && e.target !== el) {
                  return;
                }
                if (!e || /transform$/.test(e.propertyName)) {
                  el.removeEventListener("transitionend", cb);
                  el[moveCbKey] = null;
                  removeTransitionClass(el, moveClass);
                }
              };
              el.addEventListener("transitionend", cb);
            });
          });
          return () => {
            const rawProps = toRaw(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || Fragment$1;
            prevChildren = children;
            children = slots.default ? getTransitionRawChildren(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.key != null) {
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(child, cssTransitionProps, state, instance)
                );
              }
            }
            if (prevChildren) {
              for (let i = 0; i < prevChildren.length; i++) {
                const child = prevChildren[i];
                setTransitionHooks(
                  child,
                  resolveTransitionHooks(child, cssTransitionProps, state, instance)
                );
                positionMap.set(child, child.el.getBoundingClientRect());
              }
            }
            return createVNode(tag, null, children);
          };
        }
      };
      const removeMode = (props) => delete props.mode;
      /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
      const TransitionGroup = TransitionGroupImpl;
      function callPendingCbs(c2) {
        const el = c2.el;
        if (el[moveCbKey]) {
          el[moveCbKey]();
        }
        if (el[enterCbKey]) {
          el[enterCbKey]();
        }
      }
      function recordPosition(c2) {
        newPositionMap.set(c2, c2.el.getBoundingClientRect());
      }
      function applyTranslation(c2) {
        const oldPos = positionMap.get(c2);
        const newPos = newPositionMap.get(c2);
        const dx = oldPos.left - newPos.left;
        const dy = oldPos.top - newPos.top;
        if (dx || dy) {
          const s2 = c2.el.style;
          s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
          s2.transitionDuration = "0s";
          return c2;
        }
      }
      function hasCSSTransform(el, root2, moveClass) {
        const clone2 = el.cloneNode();
        const _vtc = el[vtcKey];
        if (_vtc) {
          _vtc.forEach((cls) => {
            cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
          });
        }
        moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
        clone2.style.display = "none";
        const container = root2.nodeType === 1 ? root2 : root2.parentNode;
        container.appendChild(clone2);
        const { hasTransform } = getTransitionInfo(clone2);
        container.removeChild(clone2);
        return hasTransform;
      }
      const getModelAssigner = (vnode) => {
        const fn2 = vnode.props["onUpdate:modelValue"] || false;
        return isArray$2(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
      };
      function onCompositionStart(e) {
        e.target.composing = true;
      }
      function onCompositionEnd(e) {
        const target = e.target;
        if (target.composing) {
          target.composing = false;
          target.dispatchEvent(new Event("input"));
        }
      }
      const assignKey = Symbol("_assign");
      const vModelText = {
        created(el, { modifiers: { lazy, trim, number: number3 } }, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          const castToNumber = number3 || vnode.props && vnode.props.type === "number";
          addEventListener(el, lazy ? "change" : "input", (e) => {
            if (e.target.composing)
              return;
            let domValue = el.value;
            if (trim) {
              domValue = domValue.trim();
            }
            if (castToNumber) {
              domValue = looseToNumber(domValue);
            }
            el[assignKey](domValue);
          });
          if (trim) {
            addEventListener(el, "change", () => {
              el.value = el.value.trim();
            });
          }
          if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
          }
        },
        // set value on mounted so it's after min/max for type="range"
        mounted(el, { value }) {
          el.value = value == null ? "" : value;
        },
        beforeUpdate(el, { value, modifiers: { lazy, trim, number: number3 } }, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          if (el.composing)
            return;
          const elValue = number3 || el.type === "number" ? looseToNumber(el.value) : el.value;
          const newValue = value == null ? "" : value;
          if (elValue === newValue) {
            return;
          }
          if (document.activeElement === el && el.type !== "range") {
            if (lazy) {
              return;
            }
            if (trim && el.value.trim() === newValue) {
              return;
            }
          }
          el.value = newValue;
        }
      };
      const vModelCheckbox = {
        // #4096 array checkboxes need to be deep traversed
        deep: true,
        created(el, _2, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          addEventListener(el, "change", () => {
            const modelValue = el._modelValue;
            const elementValue = getValue$2(el);
            const checked = el.checked;
            const assign2 = el[assignKey];
            if (isArray$2(modelValue)) {
              const index = looseIndexOf(modelValue, elementValue);
              const found = index !== -1;
              if (checked && !found) {
                assign2(modelValue.concat(elementValue));
              } else if (!checked && found) {
                const filtered = [...modelValue];
                filtered.splice(index, 1);
                assign2(filtered);
              }
            } else if (isSet$1(modelValue)) {
              const cloned = new Set(modelValue);
              if (checked) {
                cloned.add(elementValue);
              } else {
                cloned.delete(elementValue);
              }
              assign2(cloned);
            } else {
              assign2(getCheckboxValue(el, checked));
            }
          });
        },
        // set initial checked on mount to wait for true-value/false-value
        mounted: setChecked,
        beforeUpdate(el, binding, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
        }
      };
      function setChecked(el, { value, oldValue }, vnode) {
        el._modelValue = value;
        if (isArray$2(value)) {
          el.checked = looseIndexOf(value, vnode.props.value) > -1;
        } else if (isSet$1(value)) {
          el.checked = value.has(vnode.props.value);
        } else if (value !== oldValue) {
          el.checked = looseEqual(value, getCheckboxValue(el, true));
        }
      }
      function getValue$2(el) {
        return "_value" in el ? el._value : el.value;
      }
      function getCheckboxValue(el, checked) {
        const key = checked ? "_trueValue" : "_falseValue";
        return key in el ? el[key] : checked;
      }
      const systemModifiers = ["ctrl", "shift", "alt", "meta"];
      const modifierGuards = {
        stop: (e) => e.stopPropagation(),
        prevent: (e) => e.preventDefault(),
        self: (e) => e.target !== e.currentTarget,
        ctrl: (e) => !e.ctrlKey,
        shift: (e) => !e.shiftKey,
        alt: (e) => !e.altKey,
        meta: (e) => !e.metaKey,
        left: (e) => "button" in e && e.button !== 0,
        middle: (e) => "button" in e && e.button !== 1,
        right: (e) => "button" in e && e.button !== 2,
        exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
      };
      const withModifiers = (fn2, modifiers) => {
        const cache2 = fn2._withMods || (fn2._withMods = {});
        const cacheKey = modifiers.join(".");
        return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
          for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
              return;
          }
          return fn2(event, ...args);
        });
      };
      const keyNames = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      const withKeys = (fn2, modifiers) => {
        const cache2 = fn2._withKeys || (fn2._withKeys = {});
        const cacheKey = modifiers.join(".");
        return cache2[cacheKey] || (cache2[cacheKey] = (event) => {
          if (!("key" in event)) {
            return;
          }
          const eventKey = hyphenate(event.key);
          if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
            return fn2(event);
          }
        });
      };
      const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
      let renderer;
      function ensureRenderer() {
        return renderer || (renderer = createRenderer(rendererOptions));
      }
      const render = (...args) => {
        ensureRenderer().render(...args);
      };
      const createApp = (...args) => {
        const app = ensureRenderer().createApp(...args);
        const { mount } = app;
        app.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
            return;
          const component = app._component;
          if (!isFunction$2(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          container.innerHTML = "";
          const proxy2 = mount(container, false, resolveRootNamespace(container));
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy2;
        };
        return app;
      };
      function resolveRootNamespace(container) {
        if (container instanceof SVGElement) {
          return "svg";
        }
        if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
          return "mathml";
        }
      }
      function normalizeContainer(container) {
        if (isString$3(container)) {
          const res = document.querySelector(container);
          return res;
        }
        return container;
      }
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = root.Symbol;
      var objectProto$j = Object.prototype;
      var hasOwnProperty$g = objectProto$j.hasOwnProperty;
      var nativeObjectToString$2 = objectProto$j.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$g.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString$2.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$i = Object.prototype;
      var nativeObjectToString$1 = objectProto$i.toString;
      function objectToString$1(value) {
        return nativeObjectToString$1.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$3 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      var isArray$1 = Array.isArray;
      var INFINITY$2 = 1 / 0;
      var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray$1(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function isObject$4(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject$4(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject$4(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY$1 || value === -INFINITY$1) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function identity$1(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction$1(value) {
        if (!isObject$4(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$2 = Function.prototype;
      var funcToString$2 = funcProto$2.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto$1 = Function.prototype, objectProto$h = Object.prototype;
      var funcToString$1 = funcProto$1.toString;
      var hasOwnProperty$f = objectProto$h.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString$1.call(hasOwnProperty$f).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject$4(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function getValue$1(object, key) {
        return object == null ? void 0 : object[key];
      }
      function getNative(object, key) {
        var value = getValue$1(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root, "WeakMap");
      var objectCreate = Object.create;
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject$4(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      function apply$1(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var baseSetToString = !defineProperty ? identity$1 : function(func, string2) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      const baseSetToString$1 = baseSetToString;
      var setToString = shortOut(baseSetToString$1);
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$g = Object.prototype;
      var hasOwnProperty$e = objectProto$g.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty$e.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      var nativeMax$2 = Math.max;
      function overRest(func, start, transform2) {
        start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$2(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply$1(func, this, otherArgs);
        };
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity$1), func + "");
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction$1(value);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject$4(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      var objectProto$f = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$f;
        return value === proto;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$3 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$3;
      }
      var objectProto$e = Object.prototype;
      var hasOwnProperty$d = objectProto$e.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$d.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer$1 = nativeIsBuffer || stubFalse;
      var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$3 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
      var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
      typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$d = Object.prototype;
      var hasOwnProperty$c = objectProto$d.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$c.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$c = Object.prototype;
      var hasOwnProperty$b = objectProto$c.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty$b.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$b = Object.prototype;
      var hasOwnProperty$a = objectProto$b.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject$4(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$a.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray$1(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      var nativeCreate = getNative(Object, "create");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$a = Object.prototype;
      var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root, "Map");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$1 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$2 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key, result) || cache2;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string2) {
        var result = [];
        if (string2.charCodeAt(0) === 46) {
          result.push("");
        }
        string2.replace(rePropName, function(match2, number3, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match2);
        });
        return result;
      });
      function toString$1(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object) {
        if (isArray$1(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString$1(value));
      }
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array, values2) {
        var index = -1, length = values2.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values2[index];
        }
        return array;
      }
      var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray$1(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten), func + "");
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      var objectTag$3 = "[object Object]";
      var funcProto = Function.prototype, objectProto$8 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject$1(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty$7.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var domExcTag = "[object DOMException]", errorTag$2 = "[object Error]";
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag$2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject$1(value);
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply$1(func, void 0, args);
        } catch (e) {
          return isError(e) ? e : new Error(e);
        }
      });
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      function before(n, func) {
        var result;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = void 0;
          }
          return result;
        };
      }
      function baseSlice(array, start, end2) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end2 = end2 > length ? length : end2;
        if (end2 < 0) {
          end2 += length;
        }
        length = start > end2 ? 0 : end2 - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start];
        }
        return result;
      }
      function castSlice(array, start, end2) {
        var length = array.length;
        end2 = end2 === void 0 ? length : end2;
        return !start && end2 >= length ? array : baseSlice(array, start, end2);
      }
      var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
      var rsZWJ$2 = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function asciiToArray(string2) {
        return string2.split("");
      }
      var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
      var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString$1(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      var upperFirst = createCaseFirst("toUpperCase");
      function capitalize$1(string2) {
        return upperFirst(toString$1(string2).toLowerCase());
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? void 0 : object[key];
        };
      }
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var deburrLetter = basePropertyOf(deburredLetters);
      const deburrLetter$1 = deburrLetter;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
      var rsCombo$1 = "[" + rsComboRange$1 + "]";
      var reComboMark = RegExp(rsCombo$1, "g");
      function deburr(string2) {
        string2 = toString$1(string2);
        return string2 && string2.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
      }
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      function words(string2, pattern, guard) {
        string2 = toString$1(string2);
        pattern = guard ? void 0 : pattern;
        if (pattern === void 0) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      var rsApos = "['’]";
      var reApos = RegExp(rsApos, "g");
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      var camelCase = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize$1(word) : word);
      });
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray$1(value) ? value : [value];
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$7 = Object.prototype;
      var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;
      var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var DataView = getNative(root, "DataView");
      var Promise$1 = getNative(root, "Promise");
      var Set$1 = getNative(root, "Set");
      var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
      var dataViewTag$3 = "[object DataView]";
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$3;
              case mapCtorString:
                return mapTag$4;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$4;
              case weakMapCtorString:
                return weakMapTag$1;
            }
          }
          return result;
        };
      }
      const getTag$1 = getTag;
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
      function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty$6.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      var Uint8Array$1 = root.Uint8Array;
      const Uint8Array$2 = Uint8Array$1;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
        return result;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
      var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag$2:
            return cloneArrayBuffer(object);
          case boolTag$2:
          case dateTag$2:
            return new Ctor(+object);
          case dataViewTag$2:
            return cloneDataView(object, isDeep);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray(object, isDeep);
          case mapTag$3:
            return new Ctor();
          case numberTag$2:
          case stringTag$2:
            return new Ctor(object);
          case regexpTag$2:
            return cloneRegExp(object);
          case setTag$3:
            return new Ctor();
          case symbolTag$2:
            return cloneSymbol(object);
        }
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      var mapTag$2 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag$1(value) == mapTag$2;
      }
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      var setTag$2 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag$1(value) == setTag$2;
      }
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object, stack2) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
        if (customizer) {
          result = object ? customizer(value, key, object, stack2) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject$4(value)) {
          return value;
        }
        var isArr = isArray$1(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer$1(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack2 || (stack2 = new Stack());
        var stacked = stack2.get(value);
        if (stacked) {
          return stacked;
        }
        stack2.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
        });
        return result;
      }
      var CLONE_SYMBOLS_FLAG = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack2.set(array, other);
        stack2.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result = false;
            break;
          }
        }
        stack2["delete"](array);
        stack2["delete"](other);
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack2.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack2.get(object);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer$1(object)) {
          if (!isBuffer$1(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$4.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack2) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack2);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject$4(value);
      }
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments(object));
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity$1;
        }
        if (typeof value == "object") {
          return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      var baseFor = createBaseFor();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      var baseEach = createBaseEach(baseForOwn);
      const baseEach$1 = baseEach;
      function baseAggregator(collection, setter, iteratee, accumulator) {
        baseEach$1(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee(value), collection2);
        });
        return accumulator;
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee) {
          var func = isArray$1(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, baseIteratee(iteratee), accumulator);
        };
      }
      var now = function() {
        return root.Date.now();
      };
      var FUNC_ERROR_TEXT = "Expected a function";
      var nativeMax$1 = Math.max, nativeMin$2 = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject$4(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin$2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray$1(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject$4(objValue) || isFunction$1(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseMerge(object, source, srcIndex, customizer, stack2) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack2 || (stack2 = new Stack());
          if (isObject$4(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function arrayIncludesWith(array, value, comparator2) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator2(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : void 0;
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity$1;
      }
      function forEach(collection, iteratee) {
        var func = isArray$1(collection) ? arrayEach : baseEach$1;
        return func(collection, castFunction(iteratee));
      }
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      const escapeHtmlChar$1 = escapeHtmlChar;
      var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      function escape$1(string2) {
        string2 = toString$1(string2);
        return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar$1) : string2;
      }
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach$1(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result.push(value);
          }
        });
        return result;
      }
      function filter(collection, predicate) {
        var func = isArray$1(collection) ? arrayFilter : baseFilter;
        return func(collection, baseIteratee(predicate));
      }
      var nativeMax = Math.max, nativeMin$1 = Math.min;
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== void 0) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin$1(index, length - 1);
        }
        return baseFindIndex(array, baseIteratee(predicate), index, true);
      }
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach$1(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      function map(collection, iteratee) {
        var func = isArray$1(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee));
      }
      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), 1);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      var objectProto$3 = Object.prototype;
      var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
      var groupBy = createAggregator(function(result, value, key) {
        if (hasOwnProperty$3.call(result, key)) {
          result[key].push(value);
        } else {
          baseAssignValue(result, key, [value]);
        }
      });
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      var nativeMin = Math.min;
      function baseIntersection(arrays, iteratee, comparator2) {
        var includes = comparator2 ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee) {
            array = arrayMap(array, baseUnary(iteratee));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator2 && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : void 0;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result.length < maxLength) {
            var value = array[index], computed2 = iteratee ? iteratee(value) : value;
            value = comparator2 || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes(result, computed2, comparator2))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed2) : includes(arrays[othIndex], computed2, comparator2))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result.push(value);
            }
          }
        return result;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      const intersection$1 = intersection;
      function baseInverter(object, setter, iteratee, accumulator) {
        baseForOwn(object, function(value, key, object3) {
          setter(accumulator, iteratee(value), key, object3);
        });
        return accumulator;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee) {
          return baseInverter(object, setter, toIteratee(iteratee), {});
        };
      }
      var objectProto$2 = Object.prototype;
      var nativeObjectToString = objectProto$2.toString;
      var invert = createInverter(function(result, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result[value] = key;
      }, constant(identity$1));
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isNil(value) {
        return value == null;
      }
      function isUndefined$1(value) {
        return value === void 0;
      }
      var kebabCase = createCompounder(function(result, word, index) {
        return result + (index ? "-" : "") + word.toLowerCase();
      });
      function baseLt(value, other) {
        return value < other;
      }
      function mapValues(object, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee);
        baseForOwn(object, function(value, key, object3) {
          baseAssignValue(result, key, iteratee(value, key, object3));
        });
        return result;
      }
      function baseExtremum(array, iteratee, comparator2) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee(value);
          if (current != null && (computed2 === void 0 ? current === current && !isSymbol(current) : comparator2(current, computed2))) {
            var computed2 = current, result = value;
          }
        }
        return result;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      const merge$1 = merge;
      function minBy(array, iteratee) {
        return array && array.length ? baseExtremum(array, baseIteratee(iteratee), baseLt) : void 0;
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject$4(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject$4(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }
      function once(func) {
        return before(2, func);
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      var nativeFloor = Math.floor, nativeRandom = Math.random;
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : void 0;
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function sample(collection) {
        var func = isArray$1(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === void 0 || eq(objValue, objectProto$1[key]) && !hasOwnProperty$2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      var reInterpolate = /<%=([\s\S]+?)%>/g;
      const reInterpolate$1 = reInterpolate;
      var reEscape = /<%-([\s\S]+?)%>/g;
      const reEscape$1 = reEscape;
      var reEvaluate = /<%([\s\S]+?)%>/g;
      const reEvaluate$1 = reEvaluate;
      var templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape$1,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate$1,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate$1,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": { "escape": escape$1 }
        }
      };
      var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var objectProto = Object.prototype;
      var hasOwnProperty$1 = objectProto.hasOwnProperty;
      function template(string2, options, guard) {
        var settings2 = templateSettings.imports._.templateSettings || templateSettings;
        if (guard && isIterateeCall(string2, options, guard)) {
          options = void 0;
        }
        string2 = toString$1(string2);
        options = assignInWith({}, options, settings2, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings2.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate$1 ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = hasOwnProperty$1.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
        string2.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match2.length;
          return match2;
        });
        source += "';\n";
        var variable = hasOwnProperty$1.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result = attempt(function() {
          return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
        });
        result.source = source;
        if (isError(result)) {
          throw result;
        }
        return result;
      }
      var eventemitter3 = { exports: {} };
      (function(module2) {
        var has2 = Object.prototype.hasOwnProperty, prefix = "~";
        function Events() {
        }
        if (Object.create) {
          Events.prototype = /* @__PURE__ */ Object.create(null);
          if (!new Events().__proto__)
            prefix = false;
        }
        function EE(fn2, context, once2) {
          this.fn = fn2;
          this.context = context;
          this.once = once2 || false;
        }
        function addListener(emitter, event, fn2, context, once2) {
          if (typeof fn2 !== "function") {
            throw new TypeError("The listener must be a function");
          }
          var listener = new EE(fn2, context || emitter, once2), evt = prefix ? prefix + event : event;
          if (!emitter._events[evt])
            emitter._events[evt] = listener, emitter._eventsCount++;
          else if (!emitter._events[evt].fn)
            emitter._events[evt].push(listener);
          else
            emitter._events[evt] = [emitter._events[evt], listener];
          return emitter;
        }
        function clearEvent(emitter, evt) {
          if (--emitter._eventsCount === 0)
            emitter._events = new Events();
          else
            delete emitter._events[evt];
        }
        function EventEmitter2() {
          this._events = new Events();
          this._eventsCount = 0;
        }
        EventEmitter2.prototype.eventNames = function eventNames() {
          var names2 = [], events, name;
          if (this._eventsCount === 0)
            return names2;
          for (name in events = this._events) {
            if (has2.call(events, name))
              names2.push(prefix ? name.slice(1) : name);
          }
          if (Object.getOwnPropertySymbols) {
            return names2.concat(Object.getOwnPropertySymbols(events));
          }
          return names2;
        };
        EventEmitter2.prototype.listeners = function listeners(event) {
          var evt = prefix ? prefix + event : event, handlers2 = this._events[evt];
          if (!handlers2)
            return [];
          if (handlers2.fn)
            return [handlers2.fn];
          for (var i = 0, l2 = handlers2.length, ee2 = new Array(l2); i < l2; i++) {
            ee2[i] = handlers2[i].fn;
          }
          return ee2;
        };
        EventEmitter2.prototype.listenerCount = function listenerCount(event) {
          var evt = prefix ? prefix + event : event, listeners = this._events[evt];
          if (!listeners)
            return 0;
          if (listeners.fn)
            return 1;
          return listeners.length;
        };
        EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            return false;
          var listeners = this._events[evt], len = arguments.length, args, i;
          if (listeners.fn) {
            if (listeners.once)
              this.removeListener(event, listeners.fn, void 0, true);
            switch (len) {
              case 1:
                return listeners.fn.call(listeners.context), true;
              case 2:
                return listeners.fn.call(listeners.context, a1), true;
              case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
              case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
              case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
              case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }
            for (i = 1, args = new Array(len - 1); i < len; i++) {
              args[i - 1] = arguments[i];
            }
            listeners.fn.apply(listeners.context, args);
          } else {
            var length = listeners.length, j;
            for (i = 0; i < length; i++) {
              if (listeners[i].once)
                this.removeListener(event, listeners[i].fn, void 0, true);
              switch (len) {
                case 1:
                  listeners[i].fn.call(listeners[i].context);
                  break;
                case 2:
                  listeners[i].fn.call(listeners[i].context, a1);
                  break;
                case 3:
                  listeners[i].fn.call(listeners[i].context, a1, a2);
                  break;
                case 4:
                  listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                  break;
                default:
                  if (!args)
                    for (j = 1, args = new Array(len - 1); j < len; j++) {
                      args[j - 1] = arguments[j];
                    }
                  listeners[i].fn.apply(listeners[i].context, args);
              }
            }
          }
          return true;
        };
        EventEmitter2.prototype.on = function on2(event, fn2, context) {
          return addListener(this, event, fn2, context, false);
        };
        EventEmitter2.prototype.once = function once2(event, fn2, context) {
          return addListener(this, event, fn2, context, true);
        };
        EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context, once2) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            return this;
          if (!fn2) {
            clearEvent(this, evt);
            return this;
          }
          var listeners = this._events[evt];
          if (listeners.fn) {
            if (listeners.fn === fn2 && (!once2 || listeners.once) && (!context || listeners.context === context)) {
              clearEvent(this, evt);
            }
          } else {
            for (var i = 0, events = [], length = listeners.length; i < length; i++) {
              if (listeners[i].fn !== fn2 || once2 && !listeners[i].once || context && listeners[i].context !== context) {
                events.push(listeners[i]);
              }
            }
            if (events.length)
              this._events[evt] = events.length === 1 ? events[0] : events;
            else
              clearEvent(this, evt);
          }
          return this;
        };
        EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
          var evt;
          if (event) {
            evt = prefix ? prefix + event : event;
            if (this._events[evt])
              clearEvent(this, evt);
          } else {
            this._events = new Events();
            this._eventsCount = 0;
          }
          return this;
        };
        EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
        EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
        EventEmitter2.prefixed = prefix;
        EventEmitter2.EventEmitter = EventEmitter2;
        {
          module2.exports = EventEmitter2;
        }
      })(eventemitter3);
      var eventemitter3Exports = eventemitter3.exports;
      const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
      let getRandomValues;
      const rnds8 = new Uint8Array(16);
      function rng() {
        if (!getRandomValues) {
          getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
          if (!getRandomValues) {
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
          }
        }
        return getRandomValues(rnds8);
      }
      const byteToHex = [];
      for (let i = 0; i < 256; ++i) {
        byteToHex.push((i + 256).toString(16).slice(1));
      }
      function unsafeStringify(arr, offset = 0) {
        return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
      }
      const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
      const native = {
        randomUUID
      };
      function v4(options, buf, offset) {
        if (native.randomUUID && !buf && !options) {
          return native.randomUUID();
        }
        options = options || {};
        const rnds = options.random || (options.rng || rng)();
        rnds[6] = rnds[6] & 15 | 64;
        rnds[8] = rnds[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i];
          }
          return buf;
        }
        return unsafeStringify(rnds);
      }
      const removeAt = (array, index) => array.splice(index, 1)[0];
      class AsyncQueue {
        constructor(thread = 1) {
          __publicField(this, "queue", reactive([]));
          __publicField(this, "emitter", new EventEmitter());
          __publicField(this, "canSingleStart", () => true);
          __publicField(this, "singleRunning", false);
          this.thread = thread;
        }
        get runningThreadNum() {
          return this.queue.filter(({ running }) => running).length;
        }
        get length() {
          return this.queue.length;
        }
        push(fn2, info) {
          this.queue.push({
            id: v4(),
            running: false,
            fn: fn2,
            info
          });
        }
        async start() {
          if (this.thread <= 1) {
            if (this.singleRunning || this.queue.length === 0)
              return;
            this.singleRunning = true;
            do {
              if (!this.canSingleStart()) {
                this.singleRunning = false;
                return;
              }
              await this.queue[0].fn();
              this.queue.shift();
            } while (this.queue.length > 0);
            this.singleRunning = false;
            this.emitter.emit("finish");
          } else {
            const running = this.runningThreadNum;
            if (running >= this.thread || this.queue.length === running)
              return;
            const idleItems = this.queue.filter(({ running: running2 }) => !running2);
            for (let i = 0; i < Math.min(idleItems.length, this.thread - running); i++) {
              const item = idleItems[i];
              item.running = true;
              item.fn().then(async () => {
                removeAt(
                  this.queue,
                  this.queue.findIndex(({ id }) => id === item.id)
                );
                if (this.queue.length)
                  await this.start();
                else
                  this.emitter.emit("finish");
              }).catch(logger.error);
            }
          }
        }
        async skipFromError() {
          this.queue.shift();
          await this.restartFromError();
        }
        async restartFromError() {
          this.singleRunning = false;
          await this.start();
        }
      }
      var __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l2 = from.length, ar; i < l2; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      var BrowserInfo = (
        /** @class */
        /* @__PURE__ */ function() {
          function BrowserInfo2(name, version2, os) {
            this.name = name;
            this.version = version2;
            this.os = os;
            this.type = "browser";
          }
          return BrowserInfo2;
        }()
      );
      var NodeInfo = (
        /** @class */
        /* @__PURE__ */ function() {
          function NodeInfo2(version2) {
            this.version = version2;
            this.type = "node";
            this.name = "node";
            this.os = process.platform;
          }
          return NodeInfo2;
        }()
      );
      var SearchBotDeviceInfo = (
        /** @class */
        /* @__PURE__ */ function() {
          function SearchBotDeviceInfo2(name, version2, os, bot) {
            this.name = name;
            this.version = version2;
            this.os = os;
            this.bot = bot;
            this.type = "bot-device";
          }
          return SearchBotDeviceInfo2;
        }()
      );
      var BotInfo = (
        /** @class */
        /* @__PURE__ */ function() {
          function BotInfo2() {
            this.type = "bot";
            this.bot = true;
            this.name = "bot";
            this.version = null;
            this.os = null;
          }
          return BotInfo2;
        }()
      );
      var ReactNativeInfo = (
        /** @class */
        /* @__PURE__ */ function() {
          function ReactNativeInfo2() {
            this.type = "react-native";
            this.name = "react-native";
            this.version = null;
            this.os = null;
          }
          return ReactNativeInfo2;
        }()
      );
      var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
      var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
      var REQUIRED_VERSION_PARTS = 3;
      var userAgentRules = [
        ["aol", /AOLShield\/([0-9\._]+)/],
        ["edge", /Edge\/([0-9\._]+)/],
        ["edge-ios", /EdgiOS\/([0-9\._]+)/],
        ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
        ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
        ["samsung", /SamsungBrowser\/([0-9\.]+)/],
        ["silk", /\bSilk\/([0-9._-]+)\b/],
        ["miui", /MiuiBrowser\/([0-9\.]+)$/],
        ["beaker", /BeakerBrowser\/([0-9\.]+)/],
        ["edge-chromium", /EdgA?\/([0-9\.]+)/],
        [
          "chromium-webview",
          /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
        ],
        ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
        ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
        ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
        ["fxios", /FxiOS\/([0-9\.]+)/],
        ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
        ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
        ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
        ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
        ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
        ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
        ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
        ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
        ["ie", /MSIE\s(7\.0)/],
        ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
        ["android", /Android\s([0-9\.]+)/],
        ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
        ["safari", /Version\/([0-9\._]+).*Safari/],
        ["facebook", /FB[AS]V\/([0-9\.]+)/],
        ["instagram", /Instagram\s([0-9\.]+)/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
        ["curl", /^curl\/([0-9\.]+)$/],
        ["searchbot", SEARCHBOX_UA_REGEX]
      ];
      var operatingSystemRules = [
        ["iOS", /iP(hone|od|ad)/],
        ["Android OS", /Android/],
        ["BlackBerry OS", /BlackBerry|BB10/],
        ["Windows Mobile", /IEMobile/],
        ["Amazon OS", /Kindle/],
        ["Windows 3.11", /Win16/],
        ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
        ["Windows 98", /(Windows 98)|(Win98)/],
        ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
        ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
        ["Windows Server 2003", /(Windows NT 5.2)/],
        ["Windows Vista", /(Windows NT 6.0)/],
        ["Windows 7", /(Windows NT 6.1)/],
        ["Windows 8", /(Windows NT 6.2)/],
        ["Windows 8.1", /(Windows NT 6.3)/],
        ["Windows 10", /(Windows NT 10.0)/],
        ["Windows ME", /Windows ME/],
        ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
        ["Open BSD", /OpenBSD/],
        ["Sun OS", /SunOS/],
        ["Chrome OS", /CrOS/],
        ["Linux", /(Linux)|(X11)/],
        ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
        ["QNX", /QNX/],
        ["BeOS", /BeOS/],
        ["OS/2", /OS\/2/]
      ];
      function detect(userAgent) {
        if (!!userAgent) {
          return parseUserAgent(userAgent);
        }
        if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
          return new ReactNativeInfo();
        }
        if (typeof navigator !== "undefined") {
          return parseUserAgent(navigator.userAgent);
        }
        return getNodeVersion();
      }
      function matchUserAgent(ua) {
        return ua !== "" && userAgentRules.reduce(function(matched, _a2) {
          var browser = _a2[0], regex = _a2[1];
          if (matched) {
            return matched;
          }
          var uaMatch = regex.exec(ua);
          return !!uaMatch && [browser, uaMatch];
        }, false);
      }
      function parseUserAgent(ua) {
        var matchedRule = matchUserAgent(ua);
        if (!matchedRule) {
          return null;
        }
        var name = matchedRule[0], match2 = matchedRule[1];
        if (name === "searchbot") {
          return new BotInfo();
        }
        var versionParts = match2[1] && match2[1].split(".").join("_").split("_").slice(0, 3);
        if (versionParts) {
          if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
          }
        } else {
          versionParts = [];
        }
        var version2 = versionParts.join(".");
        var os = detectOS(ua);
        var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
        if (searchBotMatch && searchBotMatch[1]) {
          return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);
        }
        return new BrowserInfo(name, version2, os);
      }
      function detectOS(ua) {
        for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
          var _a2 = operatingSystemRules[ii], os = _a2[0], regex = _a2[1];
          var match2 = regex.exec(ua);
          if (match2) {
            return os;
          }
        }
        return null;
      }
      function getNodeVersion() {
        var isNode = typeof process !== "undefined" && process.version;
        return isNode ? new NodeInfo(process.version.slice(1)) : null;
      }
      function createVersionParts(count) {
        var output = [];
        for (var ii = 0; ii < count; ii++) {
          output.push("0");
        }
        return output;
      }
      const supportLanguage = /* @__PURE__ */ new Set(["zh", "en"]);
      const defaultLocale = (() => {
        const languages = castArray(navigator.languages || navigator.language);
        for (const language of languages) {
          const lang = language.split("-")[0];
          if (supportLanguage.has(lang))
            return lang;
        }
        return "en";
      })();
      const nHentaiDownloadHosts = [
        "i.nhentai.net",
        "i2.nhentai.net",
        "i3.nhentai.net",
        "i5.nhentai.net",
        "i7.nhentai.net"
      ];
      var NHentaiDownloadHostSpecial = /* @__PURE__ */ ((NHentaiDownloadHostSpecial2) => {
        NHentaiDownloadHostSpecial2["RANDOM"] = "random";
        NHentaiDownloadHostSpecial2["BALANCE"] = "balance";
        return NHentaiDownloadHostSpecial2;
      })(NHentaiDownloadHostSpecial || {});
      const booleanValidator = (val) => typeof val === "boolean";
      const stringValidator = (val) => typeof val === "string";
      const createNumberValidator = (min, max) => (val) => typeof val === "number" && min <= val && val <= max;
      const trimFormatter = (val) => val.trim();
      const availableMetaFiles = ["ComicInfoXml", "EzeInfoJson"];
      const availableMetaFileTitleLanguage = /* @__PURE__ */ new Set(["english", "japanese"]);
      const settingDefinitions = {
        language: {
          key: "language",
          default: defaultLocale,
          validator: (val) => supportLanguage.has(val)
        },
        threadNum: {
          key: "thread_num",
          default: 8,
          validator: createNumberValidator(1, 32),
          formatter: (val) => Math.floor(val)
        },
        openOnNewTab: {
          key: "open_on_new_tab",
          default: true,
          validator: booleanValidator
        },
        customDownloadUrl: {
          key: "custom_download_url",
          default: "",
          validator: stringValidator,
          formatter: trimFormatter
        },
        compressionFilename: {
          key: "cf_name",
          default: "{{japanese}}.zip",
          validator: stringValidator,
          formatter: trimFormatter
        },
        filenameMaxArtistsNumber: {
          key: "cf_name_max_artists_number",
          default: 3,
          validator: createNumberValidator(0, Infinity)
        },
        filenameArtistsSeparator: {
          key: "cf_name_artists_separator",
          default: ", ",
          validator: stringValidator
        },
        compressionLevel: {
          key: "c_lv",
          default: 0,
          validator: createNumberValidator(0, 9),
          formatter: (val) => Math.floor(val)
        },
        compressionStreamFiles: {
          key: "c_stream_files",
          default: false,
          validator: booleanValidator
        },
        streamDownload: {
          key: "stream_download",
          default: false,
          validator: booleanValidator
        },
        seriesMode: {
          key: "series_mode",
          default: false,
          validator: booleanValidator
        },
        filenameLength: {
          key: "filename_length",
          default: 0,
          validator: (val) => val === "auto" || typeof val === "number" && val >= 0,
          formatter: (val) => typeof val === "number" ? Math.floor(val) : val
        },
        autoCancelDownloadedManga: {
          key: "auto_cancel_downloaded_doujin",
          default: false,
          validator: booleanValidator
        },
        autoRetryWhenErrorOccurs: {
          key: "auto_retry_when_error_occurs",
          default: false,
          validator: booleanValidator
        },
        autoShowAll: {
          key: "auto_show_all",
          default: false,
          validator: booleanValidator
        },
        showIgnoreButton: {
          key: "show_ignore_button",
          default: false,
          validator: booleanValidator
        },
        preventConsoleClearing: {
          key: "prevent_console_clear",
          default: false,
          validator: booleanValidator
        },
        judgeDownloadedByEnglish: {
          key: "judge_downloaded_by_english",
          default: false,
          validator: booleanValidator
        },
        judgeDownloadedByJapanese: {
          key: "judge_downloaded_by_japanese",
          default: true,
          validator: booleanValidator
        },
        judgeDownloadedByPretty: {
          key: "judge_downloaded_by_pretty",
          default: false,
          validator: booleanValidator
        },
        nHentaiDownloadHost: {
          key: "nHentai_media_host",
          default: nHentaiDownloadHosts[0],
          validator: (val) => val === "random" || val === "balance" || nHentaiDownloadHosts.includes(val)
        },
        addMetaFile: {
          key: "add_meta_file",
          default: () => [],
          validator: (val) => Array.isArray(val),
          formatter: (val) => intersection$1(val, availableMetaFiles)
        },
        metaFileTitleLanguage: {
          key: "meta_file_title_language",
          default: "english",
          validator: (val) => availableMetaFileTitleLanguage.has(val)
        },
        titleReplacement: {
          key: "title_replacement",
          default: () => [],
          validator: (val) => Array.isArray(val),
          itemValidator: (item) => item && stringValidator(item.from) && stringValidator(item.to) && booleanValidator(item.regexp)
        }
      };
      const browserDetect = detect();
      const DISABLE_STREAM_DOWNLOAD = !!browserDetect && (browserDetect.name === "safari" || browserDetect.name === "firefox");
      const readSettings = () => mapValues(
        settingDefinitions,
        ({ key, default: defaultVal }) => _GM_getValue(key, typeof defaultVal === "function" ? defaultVal() : defaultVal)
      );
      const writeableSettings = reactive(readSettings());
      const settings = writeableSettings;
      if (DISABLE_STREAM_DOWNLOAD && settings.streamDownload)
        writeableSettings.streamDownload = false;
      const startWatchSettings = once(() => {
        const settingRefs = toRefs(writeableSettings);
        forEach(settingRefs, (ref2, key) => {
          const cur = settingDefinitions[key];
          let valChanged = false;
          const saveValue = (val) => {
            logger.log("update setting", cur.key, toRaw(val));
            _GM_setValue(cur.key, val);
          };
          watch(
            ref2,
            (val) => {
              if (valChanged) {
                valChanged = false;
                saveValue(val);
                return;
              }
              const applyChange = (newVal) => {
                val = newVal;
                ref2.value = newVal;
                valChanged = true;
              };
              if (!cur.validator(val)) {
                applyChange(typeof cur.default === "function" ? cur.default() : cur.default);
                return;
              }
              if (Array.isArray(val) && cur.itemValidator) {
                const validItems = val.filter(cur.itemValidator);
                if (val.length !== validItems.length) {
                  applyChange(validItems);
                }
              }
              if (cur.formatter) {
                const formattedVal = cur.formatter(val);
                if (typeof formattedVal === "object" ? !isEqual(val, formattedVal) : val !== formattedVal) {
                  applyChange(formattedVal);
                }
              }
              if (!valChanged)
                saveValue(val);
            },
            typeof ref2.value === "object" ? { deep: true } : void 0
          );
        });
      });
      const validTitleReplacement = computed(
        () => settings.titleReplacement.filter((item) => item == null ? void 0 : item.from)
      );
      const dlQueue = new AsyncQueue();
      const zipQueue = new AsyncQueue(WORKER_THREAD_NUM);
      dlQueue.canSingleStart = () => !(settings.seriesMode && zipQueue.length);
      zipQueue.emitter.on("finish", () => {
        if (settings.seriesMode)
          dlQueue.start().catch(logger.error);
      });
      const _withScopeId = (n) => (pushScopeId("data-v-83b954f2"), n = n(), popScopeId(), n);
      const _hoisted_1$l = ["title"];
      const _hoisted_2$e = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("i", { class: "fa fa-times" }, null, -1));
      const _hoisted_3$5 = [
        _hoisted_2$e
      ];
      const _hoisted_4$2 = { class: "download-item__title" };
      const _hoisted_5$2 = { class: "download-item__progress-text" };
      const _sfc_main$J = /* @__PURE__ */ defineComponent({
        __name: "DownloadItem",
        props: {
          item: {},
          index: {}
        },
        setup(__props) {
          const props = __props;
          const title = computed(() => {
            const { english: english2, japanese: japanese2, pretty } = props.item.gallery.title;
            return japanese2 || english2 || pretty;
          });
          const progressWidth = computed(() => {
            const {
              gallery: { pages: pages2 },
              done,
              compressing,
              compressingPercent
            } = props.item;
            const page = pages2.length;
            return compressing ? compressingPercent : page && done ? (100 * done / page).toFixed(2) : 0;
          });
          const canCancel = computed(() => !props.item.compressing);
          const cancel = () => {
            var _a2;
            const { info } = props.index === 0 ? dlQueue.queue[0] : removeAt(dlQueue.queue, props.index);
            (_a2 = info == null ? void 0 : info.cancel) == null ? void 0 : _a2.call(info);
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(["download-item", {
                "download-item--error": _ctx.item.error,
                "download-item--compressing": _ctx.item.compressing && !_ctx.item.error,
                "download-item--can-cancel": canCancel.value
              }]),
              title: title.value
            }, [
              canCancel.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "download-item__cancel",
                onClick: cancel
              }, _hoisted_3$5)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_4$2, toDisplayString$1(title.value), 1),
              createBaseVNode("div", {
                class: "download-item__progress",
                style: normalizeStyle({ width: `${progressWidth.value}%` })
              }, [
                createBaseVNode("div", _hoisted_5$2, toDisplayString$1(progressWidth.value) + "%", 1)
              ], 4)
            ], 10, _hoisted_1$l);
          };
        }
      });
      const _export_sfc$1 = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const DownloadItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__scopeId", "data-v-83b954f2"]]);
      const _hoisted_1$k = { id: "download-panel" };
      const _sfc_main$I = /* @__PURE__ */ defineComponent({
        __name: "DownloadList",
        props: {
          zipList: {},
          dlList: {}
        },
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$k, [
              (openBlock(true), createElementBlock(Fragment$1, null, renderList(_ctx.zipList, (item, index) => {
                return openBlock(), createBlock(DownloadItem, {
                  key: index,
                  item,
                  index
                }, null, 8, ["item", "index"]);
              }), 128)),
              (openBlock(true), createElementBlock(Fragment$1, null, renderList(_ctx.dlList, (item, index) => {
                return openBlock(), createBlock(DownloadItem, {
                  key: index,
                  item,
                  index
                }, null, 8, ["item", "index"]);
              }), 128))
            ]);
          };
        }
      });
      const DownloadList = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__scopeId", "data-v-f37e74c3"]]);
      const _sfc_main$H = /* @__PURE__ */ defineComponent({
        __name: "DownloadPanel",
        setup(__props) {
          const { title } = document;
          const zipList = computed(() => zipQueue.queue.map(({ info }) => info));
          const dlList = computed(() => dlQueue.queue.map(({ info }) => info));
          const infoList = computed(() => [...zipList.value, ...dlList.value]);
          const error = computed(() => {
            var _a2;
            return !!((_a2 = dlList.value[0]) == null ? void 0 : _a2.error);
          });
          const titleWithStatus = computed(() => {
            if (error.value)
              return `[×] ${title}`;
            const len = infoList.value.length;
            return `[${len || "✓"}] ${title}`;
          });
          watch(infoList, (val) => {
            sessionStorage.setItem("downloadQueue", JSON.stringify(val.map(({ gallery: gallery2 }) => gallery2)));
          });
          watch(titleWithStatus, (val) => {
            document.title = val;
          });
          return (_ctx, _cache) => {
            return infoList.value.length ? (openBlock(), createBlock(DownloadList, {
              key: 0,
              "zip-list": zipList.value,
              "dl-list": dlList.value
            }, null, 8, ["zip-list", "dl-list"])) : createCommentVNode("", true);
          };
        }
      });
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      var _a;
      const isClient$1 = typeof window !== "undefined";
      const isString$2 = (val) => typeof val === "string";
      const noop$1 = () => {
      };
      const isIOS = isClient$1 && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
      function resolveUnref(r) {
        return typeof r === "function" ? r() : unref(r);
      }
      function createFilterWrapper$1(filter2, fn2) {
        function wrapper(...args) {
          return new Promise((resolve2, reject) => {
            Promise.resolve(filter2(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve2).catch(reject);
          });
        }
        return wrapper;
      }
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop$1;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop$1;
        };
        const filter2 = (invoke) => {
          const duration = resolveUnref(ms);
          const maxDuration = resolveUnref(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke());
          }
          return new Promise((resolve2, reject) => {
            lastRejector = options.rejectOnCancel ? reject : resolve2;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve2(invoke());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve2(invoke());
            }, duration);
          });
        };
        return filter2;
      }
      function identity(arg) {
        return arg;
      }
      function tryOnScopeDispose$1(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function useDebounceFn(fn2, ms = 200, options = {}) {
        return createFilterWrapper$1(debounceFilter(ms, options), fn2);
      }
      function refDebounced(value, ms = 200, options = {}) {
        const debounced = ref(value.value);
        const updater = useDebounceFn(() => {
          debounced.value = value.value;
        }, ms, options);
        watch(value, () => updater());
        return debounced;
      }
      function tryOnMounted$1(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear2() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear2();
        }
        function start(...args) {
          clear2();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, resolveUnref(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient$1)
            start();
        }
        tryOnScopeDispose$1(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement$1(elRef) {
        var _a2;
        const plain = resolveUnref(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow$1 = isClient$1 ? window : void 0;
      function useEventListener$1(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (isString$2(args[0]) || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow$1;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop$1;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(() => [unrefElement$1(target), resolveUnref(options)], ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          cleanups.push(...events.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener, options2));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose$1(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow$1, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$1));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement$1(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement$1(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener$1(window2, "click", listener, { passive: true, capture }),
          useEventListener$1(window2, "pointerdown", (e) => {
            const el = unrefElement$1(target);
            if (el)
              shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
          }, { passive: true }),
          detectIframe && useEventListener$1(window2, "blur", (event) => {
            var _a2;
            const el = unrefElement$1(target);
            if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useSupported(callback, sync = false) {
        const isSupported = ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted$1(update, sync);
        return isSupported;
      }
      const _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey$1 = "__vueuse_ssr_handlers__";
      _global$1[globalKey$1] = _global$1[globalKey$1] || {};
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow$1 } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement$1(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose$1(stop);
        return {
          isSupported,
          stop
        };
      }
      var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
      var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
      var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
      var __objRest$1 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$8)
          for (var prop of __getOwnPropSymbols$8(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useMutationObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow$1 } = _a2, mutationOptions = __objRest$1(_a2, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement$1(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new MutationObserver(callback);
            observer.observe(el, mutationOptions);
          }
        }, { immediate: true });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose$1(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp.call(b2, prop))
            __defNormalProp(a2, prop, b2[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b2)) {
            if (__propIsEnum.call(b2, prop))
              __defNormalProp(a2, prop, b2[prop]);
          }
        return a2;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity
      }, _TransitionPresets);
      const isFirefox = () => isClient$1 && /firefox/i.test(window.navigator.userAgent);
      const isUndefined = (val) => val === void 0;
      const isBoolean$1 = (val) => typeof val === "boolean";
      const isNumber$1 = (val) => typeof val === "number";
      const isElement = (e) => {
        if (typeof Element === "undefined")
          return false;
        return e instanceof Element;
      };
      const isPropAbsent = (prop) => {
        return isNil(prop);
      };
      const isStringNumber = (val) => {
        if (!isString$3(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      const rAF = (fn2) => isClient$1 ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
      const escapeStringRegexp = (string2 = "") => string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      const keysOf = (arr) => Object.keys(arr);
      const getProp = (obj, path, defaultValue) => {
        return {
          get value() {
            return get(obj, path, defaultValue);
          },
          set value(val) {
            set(obj, path, val);
          }
        };
      };
      class ElementPlusError extends Error {
        constructor(m2) {
          super(m2);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m2) {
        throw new ElementPlusError(`[${scope}] ${m2}`);
      }
      function debugWarn(scope, message2) {
      }
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      };
      const addClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      };
      const removeClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      };
      const getStyle = (element, styleName) => {
        var _a2;
        if (!isClient$1 || !element || !styleName)
          return "";
        let key = camelize(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style = element.style[key];
          if (style)
            return style;
          const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e) {
          return element.style[key];
        }
      };
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber$1(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString$3(value)) {
          return value;
        }
      }
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a2;
        if (!isClient$1)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      function scrollIntoView(container, selected) {
        if (!isClient$1)
          return;
        if (!selected) {
          container.scrollTop = 0;
          return;
        }
        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer !== null && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;
        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      /*! Element Plus Icons Vue v2.3.1 */
      var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowDown",
        __name: "arrow-down",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
            })
          ]));
        }
      });
      var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
      var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowRight",
        __name: "arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_right_default = arrow_right_vue_vue_type_script_setup_true_lang_default;
      var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowUp",
        __name: "arrow-up",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
            })
          ]));
        }
      });
      var arrow_up_default = arrow_up_vue_vue_type_script_setup_true_lang_default;
      var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCheck",
        __name: "circle-check",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
            })
          ]));
        }
      });
      var circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default;
      var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCloseFilled",
        __name: "circle-close-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
            })
          ]));
        }
      });
      var circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
      var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleClose",
        __name: "circle-close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      });
      var circle_close_default = circle_close_vue_vue_type_script_setup_true_lang_default;
      var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Close",
        __name: "close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
            })
          ]));
        }
      });
      var close_default = close_vue_vue_type_script_setup_true_lang_default;
      var delete_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Delete",
        __name: "delete",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
            })
          ]));
        }
      });
      var delete_default = delete_vue_vue_type_script_setup_true_lang_default;
      var download_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Download",
        __name: "download",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-253.696 236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64z"
            })
          ]));
        }
      });
      var download_default = download_vue_vue_type_script_setup_true_lang_default;
      var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Hide",
        __name: "hide",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
            })
          ]));
        }
      });
      var hide_default = hide_vue_vue_type_script_setup_true_lang_default;
      var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "InfoFilled",
        __name: "info-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
            })
          ]));
        }
      });
      var info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default;
      var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Loading",
        __name: "loading",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
            })
          ]));
        }
      });
      var loading_default = loading_vue_vue_type_script_setup_true_lang_default;
      var minus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Minus",
        __name: "minus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
            })
          ]));
        }
      });
      var minus_default = minus_vue_vue_type_script_setup_true_lang_default;
      var plus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Plus",
        __name: "plus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var plus_default = plus_vue_vue_type_script_setup_true_lang_default;
      var question_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "QuestionFilled",
        __name: "question-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
            })
          ]));
        }
      });
      var question_filled_default = question_filled_vue_vue_type_script_setup_true_lang_default;
      var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "SuccessFilled",
        __name: "success-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
            })
          ]));
        }
      });
      var success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default;
      var upload_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Upload",
        __name: "upload",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248z"
            })
          ]));
        }
      });
      var upload_default = upload_vue_vue_type_script_setup_true_lang_default;
      var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "View",
        __name: "view",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
            })
          ]));
        }
      });
      var view_default = view_vue_vue_type_script_setup_true_lang_default;
      var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "WarningFilled",
        __name: "warning-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
            })
          ]));
        }
      });
      var warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default;
      const epPropKey = "__epPropKey";
      const definePropType = (val) => val;
      const isEpProp = (val) => isObject$5(val) && !!val[epPropKey];
      const buildProp = (prop, key) => {
        if (!isObject$5(prop) || isEpProp(prop))
          return prop;
        const { values: values2, required, default: defaultValue, type, validator } = prop;
        const _validator = values2 || validator ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values2) {
            allowedValues = Array.from(values2);
            if (hasOwn$1(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator)
            valid || (valid = validator(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            warn$2(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type,
          required: !!required,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn$1(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      };
      const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
        key,
        buildProp(option, key)
      ]));
      const iconPropType = definePropType([
        String,
        Object,
        Function
      ]);
      const CloseComponents = {
        Close: close_default
      };
      const TypeComponents = {
        Close: close_default,
        SuccessFilled: success_filled_default,
        InfoFilled: info_filled_default,
        WarningFilled: warning_filled_default,
        CircleCloseFilled: circle_close_filled_default
      };
      const TypeComponentsMap = {
        success: success_filled_default,
        warning: warning_filled_default,
        error: circle_close_filled_default,
        info: info_filled_default
      };
      const ValidateComponentsMap = {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      };
      const withInstall = (main, extra) => {
        main.install = (app) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      };
      const withInstallFunction = (fn2, name) => {
        fn2.install = (app) => {
          fn2._context = app._context;
          app.config.globalProperties[name] = fn2;
        };
        return fn2;
      };
      const withNoopInstall = (component) => {
        component.install = NOOP;
        return component;
      };
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$2(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const EVENT_CODE = {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        delete: "Delete",
        backspace: "Backspace",
        numpadEnter: "NumpadEnter",
        pageUp: "PageUp",
        pageDown: "PageDown",
        home: "Home",
        end: "End"
      };
      const UPDATE_MODEL_EVENT = "update:modelValue";
      const CHANGE_EVENT = "change";
      const INPUT_EVENT = "input";
      const componentSizes = ["", "default", "small", "large"];
      const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      const mutable = (val) => val;
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = computed(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = getCurrentInstance();
        if (!instance) {
          return computed(() => ({}));
        }
        return computed(() => {
          var _a2;
          return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
        watch(() => unref(condition), (val) => {
        }, {
          immediate: true
        });
      };
      const useDraggable = (targetRef, dragRef, draggable, overflow) => {
        let transform2 = {
          offsetX: 0,
          offsetY: 0
        };
        const onMousedown = (e) => {
          const downX = e.clientX;
          const downY = e.clientY;
          const { offsetX, offsetY } = transform2;
          const targetRect = targetRef.value.getBoundingClientRect();
          const targetLeft = targetRect.left;
          const targetTop = targetRect.top;
          const targetWidth = targetRect.width;
          const targetHeight = targetRect.height;
          const clientWidth = document.documentElement.clientWidth;
          const clientHeight = document.documentElement.clientHeight;
          const minLeft = -targetLeft + offsetX;
          const minTop = -targetTop + offsetY;
          const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
          const maxTop = clientHeight - targetTop - targetHeight + offsetY;
          const onMousemove = (e2) => {
            let moveX = offsetX + e2.clientX - downX;
            let moveY = offsetY + e2.clientY - downY;
            if (!(overflow == null ? void 0 : overflow.value)) {
              moveX = Math.min(Math.max(moveX, minLeft), maxLeft);
              moveY = Math.min(Math.max(moveY, minTop), maxTop);
            }
            transform2 = {
              offsetX: moveX,
              offsetY: moveY
            };
            if (targetRef.value) {
              targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
            }
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
          }
        };
        onMounted(() => {
          watchEffect(() => {
            if (draggable.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        onBeforeUnmount(() => {
          offDraggable();
        });
      };
      var English = {
        name: "en",
        el: {
          breadcrumb: {
            label: "Breadcrumb"
          },
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color."
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tour: {
            next: "Next",
            previous: "Previous",
            finish: "Finish"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          },
          carousel: {
            leftArrow: "Carousel arrow left",
            rightArrow: "Carousel arrow right",
            indicator: "Carousel switch to index {index}"
          }
        }
      };
      const buildTranslator = (locale) => (path, option) => translate$1(path, option, unref(locale));
      const translate$1 = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a2;
        return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
      });
      const buildLocaleContext = (locale) => {
        const lang = computed(() => unref(locale).name);
        const localeRef = isRef(locale) ? locale : ref(locale);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = (localeOverrides) => {
        const locale = localeOverrides || inject(localeContextKey, ref());
        return buildLocaleContext(computed(() => locale.value || English));
      };
      const defaultNamespace = "el";
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = (namespaceOverrides) => {
        const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
        const namespace = computed(() => {
          return unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      };
      const useNamespace = (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace(namespaceOverrides);
        const b2 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m2 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b: b2,
          e,
          m: m2,
          be: be2,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      };
      const useLockscreen = (trigger2, options = {}) => {
        if (!isRef(trigger2)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options.ns || useNamespace("popup");
        const hiddenCls = computed$1(() => ns.bm("parent", "hidden"));
        if (!isClient$1 || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup = () => {
          setTimeout(() => {
            removeClass(document == null ? void 0 : document.body, hiddenCls.value);
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
            }
          }, 200);
        };
        watch(trigger2, (val) => {
          if (!val) {
            cleanup();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
          addClass(document.body, hiddenCls.value);
        });
        onScopeDispose(() => cleanup());
      };
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = getCurrentInstance();
          const { emit: emit2 } = instance;
          const props = instance.props;
          const hasUpdateHandler = computed(() => isFunction$2(props[updateEventKeyRaw]));
          const isModelBindingAbsent = computed(() => props[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$2(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$2(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props.disabled === true || isFunction$2(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient$1;
            if (shouldEmit) {
              emit2(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props.disabled === true || !isClient$1)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient$1;
            if (shouldEmit) {
              emit2(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean$1(val))
              return;
            if (props.disabled && val) {
              if (hasUpdateHandler.value) {
                emit2(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          watch(() => props[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          onMounted(() => {
            onChange(props[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      const useProp = (name) => {
        const vm = getCurrentInstance();
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      var E$1 = "top", R = "bottom", W = "right", P$1 = "left", me = "auto", G = [E$1, R, W, P$1], U$1 = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t2, e) {
        return t2.concat([e + "-" + U$1, e + "-" + J]);
      }, []), Ee = [].concat(G, [me]).reduce(function(t2, e) {
        return t2.concat([e, e + "-" + U$1, e + "-" + J]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
      function C(t2) {
        return t2 ? (t2.nodeName || "").toLowerCase() : null;
      }
      function H(t2) {
        if (t2 == null)
          return window;
        if (t2.toString() !== "[object Window]") {
          var e = t2.ownerDocument;
          return e && e.defaultView || window;
        }
        return t2;
      }
      function Q(t2) {
        var e = H(t2).Element;
        return t2 instanceof e || t2 instanceof Element;
      }
      function B(t2) {
        var e = H(t2).HTMLElement;
        return t2 instanceof e || t2 instanceof HTMLElement;
      }
      function Pe(t2) {
        if (typeof ShadowRoot == "undefined")
          return false;
        var e = H(t2).ShadowRoot;
        return t2 instanceof e || t2 instanceof ShadowRoot;
      }
      function Mt(t2) {
        var e = t2.state;
        Object.keys(e.elements).forEach(function(n) {
          var r = e.styles[n] || {}, o2 = e.attributes[n] || {}, i = e.elements[n];
          !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o2).forEach(function(a2) {
            var s2 = o2[a2];
            s2 === false ? i.removeAttribute(a2) : i.setAttribute(a2, s2 === true ? "" : s2);
          }));
        });
      }
      function Rt(t2) {
        var e = t2.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
          Object.keys(e.elements).forEach(function(r) {
            var o2 = e.elements[r], i = e.attributes[r] || {}, a2 = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s2 = a2.reduce(function(f2, c2) {
              return f2[c2] = "", f2;
            }, {});
            !B(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i).forEach(function(f2) {
              o2.removeAttribute(f2);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
      function q(t2) {
        return t2.split("-")[0];
      }
      var X$1 = Math.max, ve = Math.min, Z = Math.round;
      function ee(t2, e) {
        e === void 0 && (e = false);
        var n = t2.getBoundingClientRect(), r = 1, o2 = 1;
        if (B(t2) && e) {
          var i = t2.offsetHeight, a2 = t2.offsetWidth;
          a2 > 0 && (r = Z(n.width) / a2 || 1), i > 0 && (o2 = Z(n.height) / i || 1);
        }
        return { width: n.width / r, height: n.height / o2, top: n.top / o2, right: n.right / r, bottom: n.bottom / o2, left: n.left / r, x: n.left / r, y: n.top / o2 };
      }
      function ke(t2) {
        var e = ee(t2), n = t2.offsetWidth, r = t2.offsetHeight;
        return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t2.offsetLeft, y: t2.offsetTop, width: n, height: r };
      }
      function it(t2, e) {
        var n = e.getRootNode && e.getRootNode();
        if (t2.contains(e))
          return true;
        if (n && Pe(n)) {
          var r = e;
          do {
            if (r && t2.isSameNode(r))
              return true;
            r = r.parentNode || r.host;
          } while (r);
        }
        return false;
      }
      function N$1(t2) {
        return H(t2).getComputedStyle(t2);
      }
      function Wt(t2) {
        return ["table", "td", "th"].indexOf(C(t2)) >= 0;
      }
      function I$1(t2) {
        return ((Q(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
      }
      function ge(t2) {
        return C(t2) === "html" ? t2 : t2.assignedSlot || t2.parentNode || (Pe(t2) ? t2.host : null) || I$1(t2);
      }
      function at(t2) {
        return !B(t2) || N$1(t2).position === "fixed" ? null : t2.offsetParent;
      }
      function Bt(t2) {
        var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
        if (n && B(t2)) {
          var r = N$1(t2);
          if (r.position === "fixed")
            return null;
        }
        var o2 = ge(t2);
        for (Pe(o2) && (o2 = o2.host); B(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
          var i = N$1(o2);
          if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
            return o2;
          o2 = o2.parentNode;
        }
        return null;
      }
      function se(t2) {
        for (var e = H(t2), n = at(t2); n && Wt(n) && N$1(n).position === "static"; )
          n = at(n);
        return n && (C(n) === "html" || C(n) === "body" && N$1(n).position === "static") ? e : n || Bt(t2) || e;
      }
      function Le(t2) {
        return ["top", "bottom"].indexOf(t2) >= 0 ? "x" : "y";
      }
      function fe(t2, e, n) {
        return X$1(t2, ve(e, n));
      }
      function St(t2, e, n) {
        var r = fe(t2, e, n);
        return r > n ? n : r;
      }
      function st() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft(t2) {
        return Object.assign({}, st(), t2);
      }
      function ct(t2, e) {
        return e.reduce(function(n, r) {
          return n[r] = t2, n;
        }, {});
      }
      var Tt = function(t2, e) {
        return t2 = typeof t2 == "function" ? t2(Object.assign({}, e.rects, { placement: e.placement })) : t2, ft(typeof t2 != "number" ? t2 : ct(t2, G));
      };
      function Ht(t2) {
        var e, n = t2.state, r = t2.name, o2 = t2.options, i = n.elements.arrow, a2 = n.modifiersData.popperOffsets, s2 = q(n.placement), f2 = Le(s2), c2 = [P$1, W].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
        if (!(!i || !a2)) {
          var m2 = Tt(o2.padding, n), v2 = ke(i), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R : W, p2 = n.rects.reference[u2] + n.rects.reference[f2] - a2[f2] - n.rects.popper[u2], g = a2[f2] - n.rects.reference[f2], x2 = se(i), y = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $2 = p2 / 2 - g / 2, d2 = m2[l2], b2 = y - v2[u2] - m2[h2], w2 = y / 2 - v2[u2] / 2 + $2, O2 = fe(d2, w2, b2), j = f2;
          n.modifiersData[r] = (e = {}, e[j] = O2, e.centerOffset = O2 - w2, e);
        }
      }
      function Ct(t2) {
        var e = t2.state, n = t2.options, r = n.element, o2 = r === void 0 ? "[data-popper-arrow]" : r;
        o2 != null && (typeof o2 == "string" && (o2 = e.elements.popper.querySelector(o2), !o2) || !it(e.elements.popper, o2) || (e.elements.arrow = o2));
      }
      var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t2) {
        return t2.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t2) {
        var e = t2.x, n = t2.y, r = window, o2 = r.devicePixelRatio || 1;
        return { x: Z(e * o2) / o2 || 0, y: Z(n * o2) / o2 || 0 };
      }
      function ut(t2) {
        var e, n = t2.popper, r = t2.popperRect, o2 = t2.placement, i = t2.variation, a2 = t2.offsets, s2 = t2.position, f2 = t2.gpuAcceleration, c2 = t2.adaptive, u2 = t2.roundOffsets, m2 = t2.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
        l2 = g.x, p2 = g.y;
        var x2 = a2.hasOwnProperty("x"), y = a2.hasOwnProperty("y"), $2 = P$1, d2 = E$1, b2 = window;
        if (c2) {
          var w2 = se(n), O2 = "clientHeight", j = "clientWidth";
          if (w2 === H(n) && (w2 = I$1(n), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W) && i === J) {
            d2 = R;
            var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
            p2 -= A2 - r.height, p2 *= f2 ? 1 : -1;
          }
          if (o2 === P$1 || (o2 === E$1 || o2 === R) && i === J) {
            $2 = W;
            var k = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j];
            l2 -= k - r.width, l2 *= f2 ? 1 : -1;
          }
        }
        var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
        if (l2 = S2.x, p2 = S2.y, f2) {
          var L;
          return Object.assign({}, D2, (L = {}, L[d2] = y ? "0" : "", L[$2] = x2 ? "0" : "", L.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L));
        }
        return Object.assign({}, D2, (e = {}, e[d2] = y ? p2 + "px" : "", e[$2] = x2 ? l2 + "px" : "", e.transform = "", e));
      }
      function Nt(t2) {
        var e = t2.state, n = t2.options, r = n.gpuAcceleration, o2 = r === void 0 ? true : r, i = n.adaptive, a2 = i === void 0 ? true : i, s2 = n.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o2, isFixed: e.options.strategy === "fixed" };
        e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c2, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a2, roundOffsets: f2 })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c2, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
      function It(t2) {
        var e = t2.state, n = t2.instance, r = t2.options, o2 = r.scroll, i = o2 === void 0 ? true : o2, a2 = r.resize, s2 = a2 === void 0 ? true : a2, f2 = H(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
        return i && c2.forEach(function(u2) {
          u2.addEventListener("scroll", n.update, ye);
        }), s2 && f2.addEventListener("resize", n.update, ye), function() {
          i && c2.forEach(function(u2) {
            u2.removeEventListener("scroll", n.update, ye);
          }), s2 && f2.removeEventListener("resize", n.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t2) {
        return t2.replace(/left|right|bottom|top/g, function(e) {
          return _t[e];
        });
      }
      var zt = { start: "end", end: "start" };
      function lt(t2) {
        return t2.replace(/start|end/g, function(e) {
          return zt[e];
        });
      }
      function We(t2) {
        var e = H(t2), n = e.pageXOffset, r = e.pageYOffset;
        return { scrollLeft: n, scrollTop: r };
      }
      function Be(t2) {
        return ee(I$1(t2)).left + We(t2).scrollLeft;
      }
      function Ft(t2) {
        var e = H(t2), n = I$1(t2), r = e.visualViewport, o2 = n.clientWidth, i = n.clientHeight, a2 = 0, s2 = 0;
        return r && (o2 = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r.offsetLeft, s2 = r.offsetTop)), { width: o2, height: i, x: a2 + Be(t2), y: s2 };
      }
      function Ut(t2) {
        var e, n = I$1(t2), r = We(t2), o2 = (e = t2.ownerDocument) == null ? void 0 : e.body, i = X$1(n.scrollWidth, n.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X$1(n.scrollHeight, n.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r.scrollLeft + Be(t2), f2 = -r.scrollTop;
        return N$1(o2 || n).direction === "rtl" && (s2 += X$1(n.clientWidth, o2 ? o2.clientWidth : 0) - i), { width: i, height: a2, x: s2, y: f2 };
      }
      function Se(t2) {
        var e = N$1(t2), n = e.overflow, r = e.overflowX, o2 = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + o2 + r);
      }
      function dt(t2) {
        return ["html", "body", "#document"].indexOf(C(t2)) >= 0 ? t2.ownerDocument.body : B(t2) && Se(t2) ? t2 : dt(ge(t2));
      }
      function ce(t2, e) {
        var n;
        e === void 0 && (e = []);
        var r = dt(t2), o2 = r === ((n = t2.ownerDocument) == null ? void 0 : n.body), i = H(r), a2 = o2 ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s2 = e.concat(a2);
        return o2 ? s2 : s2.concat(ce(ge(a2)));
      }
      function Te(t2) {
        return Object.assign({}, t2, { left: t2.x, top: t2.y, right: t2.x + t2.width, bottom: t2.y + t2.height });
      }
      function Xt(t2) {
        var e = ee(t2);
        return e.top = e.top + t2.clientTop, e.left = e.left + t2.clientLeft, e.bottom = e.top + t2.clientHeight, e.right = e.left + t2.clientWidth, e.width = t2.clientWidth, e.height = t2.clientHeight, e.x = e.left, e.y = e.top, e;
      }
      function ht(t2, e) {
        return e === je ? Te(Ft(t2)) : Q(e) ? Xt(e) : Te(Ut(I$1(t2)));
      }
      function Yt(t2) {
        var e = ce(ge(t2)), n = ["absolute", "fixed"].indexOf(N$1(t2).position) >= 0, r = n && B(t2) ? se(t2) : t2;
        return Q(r) ? e.filter(function(o2) {
          return Q(o2) && it(o2, r) && C(o2) !== "body";
        }) : [];
      }
      function Gt(t2, e, n) {
        var r = e === "clippingParents" ? Yt(t2) : [].concat(e), o2 = [].concat(r, [n]), i = o2[0], a2 = o2.reduce(function(s2, f2) {
          var c2 = ht(t2, f2);
          return s2.top = X$1(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X$1(c2.left, s2.left), s2;
        }, ht(t2, i));
        return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
      }
      function mt(t2) {
        var e = t2.reference, n = t2.element, r = t2.placement, o2 = r ? q(r) : null, i = r ? te(r) : null, a2 = e.x + e.width / 2 - n.width / 2, s2 = e.y + e.height / 2 - n.height / 2, f2;
        switch (o2) {
          case E$1:
            f2 = { x: a2, y: e.y - n.height };
            break;
          case R:
            f2 = { x: a2, y: e.y + e.height };
            break;
          case W:
            f2 = { x: e.x + e.width, y: s2 };
            break;
          case P$1:
            f2 = { x: e.x - n.width, y: s2 };
            break;
          default:
            f2 = { x: e.x, y: e.y };
        }
        var c2 = o2 ? Le(o2) : null;
        if (c2 != null) {
          var u2 = c2 === "y" ? "height" : "width";
          switch (i) {
            case U$1:
              f2[c2] = f2[c2] - (e[u2] / 2 - n[u2] / 2);
              break;
            case J:
              f2[c2] = f2[c2] + (e[u2] / 2 - n[u2] / 2);
              break;
          }
        }
        return f2;
      }
      function ne(t2, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = r === void 0 ? t2.placement : r, i = n.boundary, a2 = i === void 0 ? Xe : i, s2 = n.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n.elementContext, u2 = c2 === void 0 ? K : c2, m2 = n.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u2 === K ? Ye : K, x2 = t2.rects.popper, y = t2.elements[v2 ? g : u2], $2 = Gt(Q(y) ? y : y.contextElement || I$1(t2.elements.popper), a2, f2), d2 = ee(t2.elements.reference), b2 = mt({ reference: d2, element: x2, strategy: "absolute", placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K ? w2 : d2, j = { top: $2.top - O2.top + p2.top, bottom: O2.bottom - $2.bottom + p2.bottom, left: $2.left - O2.left + p2.left, right: O2.right - $2.right + p2.right }, A2 = t2.modifiersData.offset;
        if (u2 === K && A2) {
          var k = A2[o2];
          Object.keys(j).forEach(function(D2) {
            var S2 = [W, R].indexOf(D2) >= 0 ? 1 : -1, L = [E$1, R].indexOf(D2) >= 0 ? "y" : "x";
            j[D2] += k[L] * S2;
          });
        }
        return j;
      }
      function Jt(t2, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = n.boundary, i = n.rootBoundary, a2 = n.padding, s2 = n.flipVariations, f2 = n.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r), m2 = u2 ? s2 ? De : De.filter(function(h2) {
          return te(h2) === u2;
        }) : G, v2 = m2.filter(function(h2) {
          return c2.indexOf(h2) >= 0;
        });
        v2.length === 0 && (v2 = m2);
        var l2 = v2.reduce(function(h2, p2) {
          return h2[p2] = ne(t2, { placement: p2, boundary: o2, rootBoundary: i, padding: a2 })[q(p2)], h2;
        }, {});
        return Object.keys(l2).sort(function(h2, p2) {
          return l2[h2] - l2[p2];
        });
      }
      function Kt(t2) {
        if (q(t2) === me)
          return [];
        var e = be(t2);
        return [lt(t2), e, lt(e)];
      }
      function Qt(t2) {
        var e = t2.state, n = t2.options, r = t2.name;
        if (!e.modifiersData[r]._skip) {
          for (var o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n.fallbackPlacements, c2 = n.padding, u2 = n.boundary, m2 = n.rootBoundary, v2 = n.altBoundary, l2 = n.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n.allowedAutoPlacements, g = e.options.placement, x2 = q(g), y = x2 === g, $2 = f2 || (y || !h2 ? [be(g)] : Kt(g)), d2 = [g].concat($2).reduce(function(z, V) {
            return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
          }, []), b2 = e.rects.reference, w2 = e.rects.popper, O2 = /* @__PURE__ */ new Map(), j = true, A2 = d2[0], k = 0; k < d2.length; k++) {
            var D2 = d2[k], S2 = q(D2), L = te(D2) === U$1, re = [E$1, R].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L ? W : P$1 : L ? R : E$1;
            b2[oe] > w2[oe] && (T2 = be(T2));
            var pe = be(T2), _2 = [];
            if (i && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z) {
              return z;
            })) {
              A2 = D2, j = false;
              break;
            }
            O2.set(D2, _2);
          }
          if (j)
            for (var ue = h2 ? 3 : 1, xe = function(z) {
              var V = d2.find(function(de) {
                var ae = O2.get(de);
                if (ae)
                  return ae.slice(0, z).every(function(Y2) {
                    return Y2;
                  });
              });
              if (V)
                return A2 = V, "break";
            }, ie = ue; ie > 0; ie--) {
              var le = xe(ie);
              if (le === "break")
                break;
            }
          e.placement !== A2 && (e.modifiersData[r]._skip = true, e.placement = A2, e.reset = true);
        }
      }
      var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt(t2, e, n) {
        return n === void 0 && (n = { x: 0, y: 0 }), { top: t2.top - e.height - n.y, right: t2.right - e.width + n.x, bottom: t2.bottom - e.height + n.y, left: t2.left - e.width - n.x };
      }
      function yt(t2) {
        return [E$1, W, R, P$1].some(function(e) {
          return t2[e] >= 0;
        });
      }
      function Zt(t2) {
        var e = t2.state, n = t2.name, r = e.rects.reference, o2 = e.rects.popper, i = e.modifiersData.preventOverflow, a2 = ne(e, { elementContext: "reference" }), s2 = ne(e, { altBoundary: true }), f2 = gt(a2, r), c2 = gt(s2, o2, i), u2 = yt(f2), m2 = yt(c2);
        e.modifiersData[n] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
      }
      var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t2, e, n) {
        var r = q(t2), o2 = [P$1, E$1].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t2 })) : n, a2 = i[0], s2 = i[1];
        return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W].indexOf(r) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
      }
      function tn(t2) {
        var e = t2.state, n = t2.options, r = t2.name, o2 = n.offset, i = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
          return u2[m2] = en(m2, e.rects, i), u2;
        }, {}), s2 = a2[e.placement], f2 = s2.x, c2 = s2.y;
        e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f2, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = a2;
      }
      var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t2) {
        var e = t2.state, n = t2.name;
        e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t2) {
        return t2 === "x" ? "y" : "x";
      }
      function on(t2) {
        var e = t2.state, n = t2.options, r = t2.name, o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n.boundary, c2 = n.rootBoundary, u2 = n.altBoundary, m2 = n.padding, v2 = n.tether, l2 = v2 === void 0 ? true : v2, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q(e.placement), y = te(e.placement), $2 = !y, d2 = Le(x2), b2 = rn(d2), w2 = e.modifiersData.popperOffsets, O2 = e.rects.reference, j = e.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S2 = { x: 0, y: 0 };
        if (w2) {
          if (i) {
            var L, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R : W, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g[re], _2 = T2 - g[oe], ue = l2 ? -j[M2] / 2 : 0, xe = y === U$1 ? O2[M2] : j[M2], ie = y === U$1 ? -j[M2] : -O2[M2], le = e.elements.arrow, z = l2 && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y2 = fe(0, O2[M2], z[M2]), jt = $2 ? O2[M2] / 2 - ue - Y2 - de - k.mainAxis : xe - Y2 - de - k.mainAxis, Dt = $2 ? -O2[M2] / 2 + ue + Y2 + ae + k.mainAxis : ie + Y2 + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D2 == null ? void 0 : D2[d2]) != null ? L : 0, Pt = T2 + jt - Ce - Et, At = T2 + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T2, l2 ? X$1(_2, At) : _2);
            w2[d2] = qe, S2[d2] = qe - T2;
          }
          if (s2) {
            var Ve, kt = d2 === "x" ? E$1 : P$1, Lt = d2 === "x" ? R : W, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g[kt], Ie = F2 - g[Lt], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j[he] - _e + k.altAxis, Fe = $e ? F2 + O2[he] + j[he] - _e - k.altAxis : Ie, Ue = l2 && $e ? St(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
            w2[b2] = Ue, S2[b2] = Ue - F2;
          }
          e.modifiersData[r] = S2;
        }
      }
      var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t2) {
        return { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop };
      }
      function sn(t2) {
        return t2 === H(t2) || !B(t2) ? We(t2) : an(t2);
      }
      function fn(t2) {
        var e = t2.getBoundingClientRect(), n = Z(e.width) / t2.offsetWidth || 1, r = Z(e.height) / t2.offsetHeight || 1;
        return n !== 1 || r !== 1;
      }
      function cn(t2, e, n) {
        n === void 0 && (n = false);
        var r = B(e), o2 = B(e) && fn(e), i = I$1(e), a2 = ee(t2, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
        return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s2 = sn(e)), B(e) ? (f2 = ee(e, true), f2.x += e.clientLeft, f2.y += e.clientTop) : i && (f2.x = Be(i))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
      }
      function pn(t2) {
        var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
        t2.forEach(function(i) {
          e.set(i.name, i);
        });
        function o2(i) {
          n.add(i.name);
          var a2 = [].concat(i.requires || [], i.requiresIfExists || []);
          a2.forEach(function(s2) {
            if (!n.has(s2)) {
              var f2 = e.get(s2);
              f2 && o2(f2);
            }
          }), r.push(i);
        }
        return t2.forEach(function(i) {
          n.has(i.name) || o2(i);
        }), r;
      }
      function un(t2) {
        var e = pn(t2);
        return ot.reduce(function(n, r) {
          return n.concat(e.filter(function(o2) {
            return o2.phase === r;
          }));
        }, []);
      }
      function ln(t2) {
        var e;
        return function() {
          return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
              e = void 0, n(t2());
            });
          })), e;
        };
      }
      function dn(t2) {
        var e = t2.reduce(function(n, r) {
          var o2 = n[r.name];
          return n[r.name] = o2 ? Object.assign({}, o2, r, { options: Object.assign({}, o2.options, r.options), data: Object.assign({}, o2.data, r.data) }) : r, n;
        }, {});
        return Object.keys(e).map(function(n) {
          return e[n];
        });
      }
      var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t2 = arguments.length, e = new Array(t2), n = 0; n < t2; n++)
          e[n] = arguments[n];
        return !e.some(function(r) {
          return !(r && typeof r.getBoundingClientRect == "function");
        });
      }
      function we(t2) {
        t2 === void 0 && (t2 = {});
        var e = t2, n = e.defaultModifiers, r = n === void 0 ? [] : n, o2 = e.defaultOptions, i = o2 === void 0 ? Ot : o2;
        return function(a2, s2, f2) {
          f2 === void 0 && (f2 = i);
          var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p2) {
            var g = typeof p2 == "function" ? p2(c2.options) : p2;
            h2(), c2.options = Object.assign({}, i, c2.options, g), c2.scrollParents = { reference: Q(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
            var x2 = un(dn([].concat(r, c2.options.modifiers)));
            return c2.orderedModifiers = x2.filter(function(y) {
              return y.enabled;
            }), l2(), v2.update();
          }, forceUpdate: function() {
            if (!m2) {
              var p2 = c2.elements, g = p2.reference, x2 = p2.popper;
              if ($t(g, x2)) {
                c2.rects = { reference: cn(g, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j) {
                  return c2.modifiersData[j.name] = Object.assign({}, j.data);
                });
                for (var y = 0; y < c2.orderedModifiers.length; y++) {
                  if (c2.reset === true) {
                    c2.reset = false, y = -1;
                    continue;
                  }
                  var $2 = c2.orderedModifiers[y], d2 = $2.fn, b2 = $2.options, w2 = b2 === void 0 ? {} : b2, O2 = $2.name;
                  typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p2) {
              v2.forceUpdate(), p2(c2);
            });
          }), destroy: function() {
            h2(), m2 = true;
          } };
          if (!$t(a2, s2))
            return v2;
          v2.setOptions(f2).then(function(p2) {
            !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
          });
          function l2() {
            c2.orderedModifiers.forEach(function(p2) {
              var g = p2.name, x2 = p2.options, y = x2 === void 0 ? {} : x2, $2 = p2.effect;
              if (typeof $2 == "function") {
                var d2 = $2({ state: c2, name: g, instance: v2, options: y }), b2 = function() {
                };
                u2.push(d2 || b2);
              }
            });
          }
          function h2() {
            u2.forEach(function(p2) {
              return p2();
            }), u2 = [];
          }
          return v2;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = computed(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = shallowRef();
        const states = ref({
          styles: {
            popper: {
              position: unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        watch(options, (newOptions) => {
          const instance = unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, unref(options));
        });
        onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: computed(() => {
            var _a2;
            return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
          }),
          styles: computed(() => unref(states).styles),
          attributes: computed(() => unref(states).attributes),
          update: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
          },
          forceUpdate: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
          },
          instanceRef: computed(() => unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const useSameTarget = (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e) => {
          mousedownTarget = e.target === e.currentTarget;
        };
        const onMouseup = (e) => {
          mouseupTarget = e.target === e.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      };
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose$1(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = () => {
        return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      };
      const useId = (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      };
      let registeredEscapeHandlers = [];
      const cachedHandler = (e) => {
        const event = e;
        if (event.key === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient$1)
            registeredEscapeHandlers.push(handler);
        });
        onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient$1)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      let cachedContainer;
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id = computed(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = computed(() => `#${id.value}`);
        return {
          id,
          selector
        };
      };
      const createContainer = (id) => {
        const container = document.createElement("div");
        container.id = id;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id, selector } = usePopperContainerId();
        onBeforeMount(() => {
          if (!isClient$1)
            return;
          if (!cachedContainer && !document.body.querySelector(selector.value)) {
            cachedContainer = createContainer(id.value);
          }
        });
        return {
          id,
          selector
        };
      };
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open: open2,
        close
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open2(event);
            const _autoClose = unref(autoClose);
            if (isNumber$1(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close(event);
              }, _autoClose);
            }
          }, unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close(event);
          }, unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const initial = {
        current: 0
      };
      const zIndex = ref(0);
      const defaultInitialZIndex = 2e3;
      const ZINDEX_INJECTION_KEY = Symbol("elZIndexContextKey");
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const increasingInjection = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial;
        const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
        const initialZIndex = computed(() => {
          const zIndexFromInjection = unref(zIndexInjection);
          return isNumber$1(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          increasingInjection.current++;
          zIndex.value = increasingInjection.current;
          return currentZIndex.value;
        };
        if (!isClient$1 && !inject(ZINDEX_INJECTION_KEY))
          ;
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      function useCursor(input) {
        const selectionRef = ref();
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionRef.value = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionRef.value == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const useSizeProp = buildProp({
        type: String,
        values: componentSizes,
        required: false
      });
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = inject(SIZE_INJECTION_KEY, {});
        return computed(() => {
          return unref(injectedSize.size) || "";
        });
      };
      function useFocusController(target, { afterFocus, beforeBlur, afterBlur } = {}) {
        const instance = getCurrentInstance();
        const { emit: emit2 } = instance;
        const wrapperRef = shallowRef();
        const isFocused = ref(false);
        const handleFocus = (event) => {
          if (isFocused.value)
            return;
          isFocused.value = true;
          emit2("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a2;
          const cancelBlur = isFunction$2(beforeBlur) ? beforeBlur(event) : false;
          if (cancelBlur || event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit2("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a2;
          (_a2 = target.value) == null ? void 0 : _a2.focus();
        };
        watch(wrapperRef, (el) => {
          if (el) {
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener$1(wrapperRef, "click", handleClick);
        return {
          wrapperRef,
          isFocused,
          handleFocus,
          handleBlur
        };
      }
      const DEFAULT_EMPTY_VALUES = ["", void 0, null];
      const DEFAULT_VALUE_ON_CLEAR = void 0;
      const useEmptyValuesProps = buildProps({
        emptyValues: Array,
        valueOnClear: {
          type: [String, Number, Boolean, Function],
          default: void 0,
          validator: (val) => isFunction$2(val) ? !val() : !val
        }
      });
      const useEmptyValues = (props, defaultValue) => {
        const config = useGlobalConfig();
        config.value = config.value || {};
        const emptyValues = computed(() => props.emptyValues || config.value.emptyValues || DEFAULT_EMPTY_VALUES);
        const valueOnClear = computed(() => {
          if (isFunction$2(props.valueOnClear)) {
            return props.valueOnClear();
          } else if (props.valueOnClear !== void 0) {
            return props.valueOnClear;
          } else if (isFunction$2(config.value.valueOnClear)) {
            return config.value.valueOnClear();
          } else if (config.value.valueOnClear !== void 0) {
            return config.value.valueOnClear;
          }
          return defaultValue !== void 0 ? defaultValue : DEFAULT_VALUE_ON_CLEAR;
        });
        const isEmptyValue2 = (value) => {
          return emptyValues.value.includes(value);
        };
        if (!emptyValues.value.includes(valueOnClear.value))
          ;
        return {
          emptyValues,
          valueOnClear,
          isEmptyValue: isEmptyValue2
        };
      };
      const configProviderContextKey = Symbol();
      const globalConfig = ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return computed(() => {
            var _a2, _b;
            return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      function useGlobalComponentSettings(block, sizeFallback) {
        const config = useGlobalConfig();
        const ns = useNamespace(block, computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
        }));
        const locale = useLocale(computed(() => {
          var _a2;
          return (_a2 = config.value) == null ? void 0 : _a2.locale;
        }));
        const zIndex2 = useZIndex(computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
        }));
        const size2 = computed(() => {
          var _a2;
          return unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
        });
        provideGlobalConfig(computed(() => unref(config) || {}));
        return {
          ns,
          locale,
          zIndex: zIndex2,
          size: size2
        };
      }
      const provideGlobalConfig = (config, app, global2 = false) => {
        var _a2;
        const inSetup = !!getCurrentInstance();
        const oldConfig = inSetup ? useGlobalConfig() : void 0;
        const provideFn = (_a2 = app == null ? void 0 : app.provide) != null ? _a2 : inSetup ? provide : void 0;
        if (!provideFn) {
          return;
        }
        const context = computed(() => {
          const cfg = unref(config);
          if (!(oldConfig == null ? void 0 : oldConfig.value))
            return cfg;
          return mergeConfig(oldConfig.value, cfg);
        });
        provideFn(configProviderContextKey, context);
        provideFn(localeContextKey, computed(() => context.value.locale));
        provideFn(namespaceContextKey, computed(() => context.value.namespace));
        provideFn(zIndexContextKey, computed(() => context.value.zIndex));
        provideFn(SIZE_INJECTION_KEY, {
          size: computed(() => context.value.size || "")
        });
        if (global2 || !globalConfig.value) {
          globalConfig.value = context.value;
        }
        return context;
      };
      const mergeConfig = (a2, b2) => {
        const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a2), ...keysOf(b2)])];
        const obj = {};
        for (const key of keys2) {
          obj[key] = b2[key] !== void 0 ? b2[key] : a2[key];
        }
        return obj;
      };
      const messageConfig = {};
      var _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$u = /* @__PURE__ */ defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$G = /* @__PURE__ */ defineComponent({
        ...__default__$u,
        props: iconProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("icon");
          const style = computed(() => {
            const { size: size2, color } = props;
            if (!size2 && !color)
              return {};
            return {
              fontSize: isUndefined(size2) ? void 0 : addUnit(size2),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("i", mergeProps({
              class: unref(ns).b(),
              style: unref(style)
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__file", "icon.vue"]]);
      const ElIcon = withInstall(Icon);
      const formContextKey = Symbol("formContextKey");
      const formItemContextKey = Symbol("formItemContextKey");
      const useFormSize = (fallback, ignore = {}) => {
        const emptyRef = ref(void 0);
        const size2 = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
        return computed(() => size2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      };
      const useFormDisabled = (fallback) => {
        const disabled = useProp("disabled");
        const form = inject(formContextKey, void 0);
        return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      };
      const useFormItem = () => {
        const form = inject(formContextKey, void 0);
        const formItem = inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      };
      const useFormItemInputId = (props, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = ref(false);
        }
        const inputId = ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = computed(() => {
          var _a2;
          return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        onMounted(() => {
          idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
            const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      };
      const formMetaProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        },
        disabled: Boolean
      });
      const formProps = buildProps({
        ...formMetaProps,
        model: Object,
        rules: {
          type: definePropType(Object)
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top"],
          default: "right"
        },
        requireAsteriskPosition: {
          type: String,
          values: ["left", "right"],
          default: "left"
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelSuffix: {
          type: String,
          default: ""
        },
        inline: Boolean,
        inlineMessage: Boolean,
        statusIcon: Boolean,
        showMessage: {
          type: Boolean,
          default: true
        },
        validateOnRuleChange: {
          type: Boolean,
          default: true
        },
        hideRequiredAsterisk: Boolean,
        scrollToError: Boolean,
        scrollIntoViewOptions: {
          type: [Object, Boolean]
        }
      });
      const formEmits = {
        validate: (prop, isValid, message2) => (isArray$2(prop) || isString$3(prop)) && isBoolean$1(isValid) && isString$3(message2)
      };
      function useFormLabelWidth() {
        const potentialLabelWidthArr = ref([]);
        const autoLabelWidth = computed(() => {
          if (!potentialLabelWidthArr.value.length)
            return "0";
          const max = Math.max(...potentialLabelWidthArr.value);
          return max ? `${max}px` : "";
        });
        function getLabelWidthIndex(width) {
          const index = potentialLabelWidthArr.value.indexOf(width);
          if (index === -1 && autoLabelWidth.value === "0")
            ;
          return index;
        }
        function registerLabelWidth(val, oldVal) {
          if (val && oldVal) {
            const index = getLabelWidthIndex(oldVal);
            potentialLabelWidthArr.value.splice(index, 1, val);
          } else if (val) {
            potentialLabelWidthArr.value.push(val);
          }
        }
        function deregisterLabelWidth(val) {
          const index = getLabelWidthIndex(val);
          if (index > -1) {
            potentialLabelWidthArr.value.splice(index, 1);
          }
        }
        return {
          autoLabelWidth,
          registerLabelWidth,
          deregisterLabelWidth
        };
      }
      const filterFields = (fields, props) => {
        const normalized = castArray(props);
        return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
      };
      const COMPONENT_NAME$5 = "ElForm";
      const __default__$t = /* @__PURE__ */ defineComponent({
        name: COMPONENT_NAME$5
      });
      const _sfc_main$F = /* @__PURE__ */ defineComponent({
        ...__default__$t,
        props: formProps,
        emits: formEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          const fields = [];
          const formSize = useFormSize();
          const ns = useNamespace("form");
          const formClasses = computed(() => {
            const { labelPosition, inline } = props;
            return [
              ns.b(),
              ns.m(formSize.value || "default"),
              {
                [ns.m(`label-${labelPosition}`)]: labelPosition,
                [ns.m("inline")]: inline
              }
            ];
          });
          const getField = (prop) => {
            return fields.find((field) => field.prop === prop);
          };
          const addField = (field) => {
            fields.push(field);
          };
          const removeField = (field) => {
            if (field.prop) {
              fields.splice(fields.indexOf(field), 1);
            }
          };
          const resetFields = (properties = []) => {
            if (!props.model) {
              return;
            }
            filterFields(fields, properties).forEach((field) => field.resetField());
          };
          const clearValidate = (props2 = []) => {
            filterFields(fields, props2).forEach((field) => field.clearValidate());
          };
          const isValidatable = computed(() => {
            const hasModel = !!props.model;
            return hasModel;
          });
          const obtainValidateFields = (props2) => {
            if (fields.length === 0)
              return [];
            const filteredFields = filterFields(fields, props2);
            if (!filteredFields.length) {
              return [];
            }
            return filteredFields;
          };
          const validate = async (callback) => validateField(void 0, callback);
          const doValidateField = async (props2 = []) => {
            if (!isValidatable.value)
              return false;
            const fields2 = obtainValidateFields(props2);
            if (fields2.length === 0)
              return true;
            let validationErrors = {};
            for (const field of fields2) {
              try {
                await field.validate("");
              } catch (fields3) {
                validationErrors = {
                  ...validationErrors,
                  ...fields3
                };
              }
            }
            if (Object.keys(validationErrors).length === 0)
              return true;
            return Promise.reject(validationErrors);
          };
          const validateField = async (modelProps = [], callback) => {
            const shouldThrow = !isFunction$2(callback);
            try {
              const result = await doValidateField(modelProps);
              if (result === true) {
                callback == null ? void 0 : callback(result);
              }
              return result;
            } catch (e) {
              if (e instanceof Error)
                throw e;
              const invalidFields = e;
              if (props.scrollToError) {
                scrollToField(Object.keys(invalidFields)[0]);
              }
              callback == null ? void 0 : callback(false, invalidFields);
              return shouldThrow && Promise.reject(invalidFields);
            }
          };
          const scrollToField = (prop) => {
            var _a2;
            const field = filterFields(fields, prop)[0];
            if (field) {
              (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView(props.scrollIntoViewOptions);
            }
          };
          watch(() => props.rules, () => {
            if (props.validateOnRuleChange) {
              validate().catch((err) => debugWarn());
            }
          }, { deep: true });
          provide(formContextKey, reactive({
            ...toRefs(props),
            emit: emit2,
            resetFields,
            clearValidate,
            validateField,
            getField,
            addField,
            removeField,
            ...useFormLabelWidth()
          }));
          expose2({
            validate,
            validateField,
            resetFields,
            clearValidate,
            scrollToField
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("form", {
              class: normalizeClass(unref(formClasses))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Form = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__file", "form.vue"]]);
      var define_process_env_default = {};
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o2) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
          return o22.__proto__ || Object.getPrototypeOf(o22);
        };
        return _getPrototypeOf(o2);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
          o22.__proto__ = p22;
          return o22;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn2) {
        return Function.toString.call(fn2).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      if (typeof process !== "undefined" && define_process_env_default && false) {
        warning = function warning3(type4, errors) {
          if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
            if (errors.every(function(e) {
              return typeof e === "string";
            })) {
              console.warn(type4, errors);
            }
          }
        };
      }
      function convertFieldsError(errors) {
        if (!errors || !errors.length)
          return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format$2(template2) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i = 0;
        var len = args.length;
        if (typeof template2 === "function") {
          return template2.apply(null, args);
        }
        if (typeof template2 === "string") {
          var str = template2.replace(formatRegExp, function(x2) {
            if (x2 === "%%") {
              return "%";
            }
            if (i >= len) {
              return x2;
            }
            switch (x2) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_2) {
                  return "[Circular]";
                }
                break;
              default:
                return x2;
            }
          });
          return str;
        }
        return template2;
      }
      function isNativeStringType(type4) {
        return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
      }
      function isEmptyValue(value, type4) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type4 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type4) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total++;
          if (total === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a2) {
          func(a2, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index = 0;
        var arrLength = arr.length;
        function next(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index;
          index = index + 1;
          if (original < arrLength) {
            func(arr[original], next);
          } else {
            callback([]);
          }
        }
        next([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k) {
          ret.push.apply(ret, objArr[k] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve2, reject) {
            var next = function next2(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next);
          });
          _pending["catch"](function(e) {
            return e;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total = 0;
        var results = [];
        var pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            results.push.apply(results, errors);
            total++;
            if (total === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve2(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func, next);
            } else {
              asyncParallelArray(arr, func, next);
            }
          });
        });
        pending["catch"](function(e) {
          return e;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue(value, path) {
        var v2 = value;
        for (var i = 0; i < path.length; i++) {
          if (v2 == void 0) {
            return v2;
          }
          v2 = v2[path[i]];
        }
        return v2;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s2 in source) {
            if (source.hasOwnProperty(s2)) {
              var value = source[s2];
              if (typeof value === "object" && typeof target[s2] === "object") {
                target[s2] = _extends({}, target[s2], value);
              } else {
                target[s2] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required(rule, value, source, errors, options, type4) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
          errors.push(format$2(options.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format$2(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b2 = function b22(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v42 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v42 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v42 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v42 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v42 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v42 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v42 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v42 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v42 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v42 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v42 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b2(options) + v42 + b2(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host2 = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host2 + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        // http://emailregex.com/
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        // url: new RegExp(
        //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
        //   'i',
        // ),
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array(value) {
          return Array.isArray(value);
        },
        regexp: function regexp(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e) {
            return false;
          }
        },
        date: function date(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number3(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format$2(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format$2(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options) {
        var len = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format$2(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format$2(options.messages[key].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format$2(options.messages[key].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format$2(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format$2(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format$2(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format$2(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method2 = function method3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number2 = function number3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp2 = function regexp3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer2 = function integer3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array2 = function array3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object2 = function object3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable2 = function enumerable3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern2 = function pattern3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date2 = function date3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required2 = function required3(rule, value, callback, source, options) {
        var errors = [];
        var type4 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type4);
        callback(errors);
      };
      var type2 = function type3(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators = {
        string,
        method: method2,
        number: number2,
        "boolean": _boolean,
        regexp: regexp2,
        integer: integer2,
        "float": floatFn,
        array: array2,
        object: object2,
        "enum": enumerable2,
        pattern: pattern2,
        date: date2,
        url: type2,
        hex: type2,
        email: type2,
        required: required2,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone2() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o2, oc) {
          var _this2 = this;
          if (o2 === void 0) {
            o2 = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o2;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add2(e) {
              if (Array.isArray(e)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e);
              } else {
                errors.push(e);
              }
            }
            for (var i = 0; i < results.length; i++) {
              add2(results[i]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z) {
            var arr = _this2.rules[z];
            var value = source[z];
            arr.forEach(function(r) {
              var rule = r;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z;
              rule.fullField = rule.fullField || z;
              rule.type = _this2.getType(rule);
              series[z] = series[z] || [];
              series[z].push({
                rule,
                value,
                source,
                field: z
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e) {
              if (e === void 0) {
                e = [];
              }
              var errorList = Array.isArray(e) ? e : [e];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format$2(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e) {
                return cb(e);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType2(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format$2("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type4, validator) {
        if (typeof validator !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type4] = validator;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators;
      const formItemValidateStates = [
        "",
        "error",
        "validating",
        "success"
      ];
      const formItemProps = buildProps({
        label: String,
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        prop: {
          type: definePropType([String, Array])
        },
        required: {
          type: Boolean,
          default: void 0
        },
        rules: {
          type: definePropType([Object, Array])
        },
        error: String,
        validateStatus: {
          type: String,
          values: formItemValidateStates
        },
        for: String,
        inlineMessage: {
          type: [String, Boolean],
          default: ""
        },
        showMessage: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          values: componentSizes
        }
      });
      const COMPONENT_NAME$4 = "ElLabelWrap";
      var FormLabelWrap = /* @__PURE__ */ defineComponent({
        name: COMPONENT_NAME$4,
        props: {
          isAutoWidth: Boolean,
          updateAll: Boolean
        },
        setup(props, {
          slots
        }) {
          const formContext = inject(formContextKey, void 0);
          const formItemContext = inject(formItemContextKey);
          if (!formItemContext)
            throwError(COMPONENT_NAME$4, "usage: <el-form-item><label-wrap /></el-form-item>");
          const ns = useNamespace("form");
          const el = ref();
          const computedWidth = ref(0);
          const getLabelWidth = () => {
            var _a2;
            if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
              const width = window.getComputedStyle(el.value.firstElementChild).width;
              return Math.ceil(Number.parseFloat(width));
            } else {
              return 0;
            }
          };
          const updateLabelWidth = (action = "update") => {
            nextTick(() => {
              if (slots.default && props.isAutoWidth) {
                if (action === "update") {
                  computedWidth.value = getLabelWidth();
                } else if (action === "remove") {
                  formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
                }
              }
            });
          };
          const updateLabelWidthFn = () => updateLabelWidth("update");
          onMounted(() => {
            updateLabelWidthFn();
          });
          onBeforeUnmount(() => {
            updateLabelWidth("remove");
          });
          onUpdated(() => updateLabelWidthFn());
          watch(computedWidth, (val, oldVal) => {
            if (props.updateAll) {
              formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
            }
          });
          useResizeObserver(computed(() => {
            var _a2, _b;
            return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
          }), updateLabelWidthFn);
          return () => {
            var _a2, _b;
            if (!slots)
              return null;
            const {
              isAutoWidth
            } = props;
            if (isAutoWidth) {
              const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
              const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
              const style = {};
              if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
                const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
                const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
                if (marginWidth) {
                  style[marginPosition] = `${marginWidth}px`;
                }
              }
              return createVNode("div", {
                "ref": el,
                "class": [ns.be("item", "label-wrap")],
                "style": style
              }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
            } else {
              return createVNode(Fragment$1, {
                "ref": el
              }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
            }
          };
        }
      });
      const _hoisted_1$j = ["role", "aria-labelledby"];
      const __default__$s = /* @__PURE__ */ defineComponent({
        name: "ElFormItem"
      });
      const _sfc_main$E = /* @__PURE__ */ defineComponent({
        ...__default__$s,
        props: formItemProps,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const slots = useSlots();
          const formContext = inject(formContextKey, void 0);
          const parentFormItemContext = inject(formItemContextKey, void 0);
          const _size = useFormSize(void 0, { formItem: false });
          const ns = useNamespace("form-item");
          const labelId = useId().value;
          const inputIds = ref([]);
          const validateState = ref("");
          const validateStateDebounced = refDebounced(validateState, 100);
          const validateMessage = ref("");
          const formItemRef = ref();
          let initialValue = void 0;
          let isResettingField = false;
          const labelStyle = computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (labelWidth)
              return { width: labelWidth };
            return {};
          });
          const contentStyle = computed(() => {
            if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
              return {};
            }
            if (!props.label && !props.labelWidth && isNested) {
              return {};
            }
            const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (!props.label && !slots.label) {
              return { marginLeft: labelWidth };
            }
            return {};
          });
          const formItemClasses = computed(() => [
            ns.b(),
            ns.m(_size.value),
            ns.is("error", validateState.value === "error"),
            ns.is("validating", validateState.value === "validating"),
            ns.is("success", validateState.value === "success"),
            ns.is("required", isRequired.value || props.required),
            ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
            (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
            { [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
          ]);
          const _inlineMessage = computed(() => isBoolean$1(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
          const validateClasses = computed(() => [
            ns.e("error"),
            { [ns.em("error", "inline")]: _inlineMessage.value }
          ]);
          const propString = computed(() => {
            if (!props.prop)
              return "";
            return isString$3(props.prop) ? props.prop : props.prop.join(".");
          });
          const hasLabel = computed(() => {
            return !!(props.label || slots.label);
          });
          const labelFor = computed(() => {
            return props.for || (inputIds.value.length === 1 ? inputIds.value[0] : void 0);
          });
          const isGroup = computed(() => {
            return !labelFor.value && hasLabel.value;
          });
          const isNested = !!parentFormItemContext;
          const fieldValue = computed(() => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop) {
              return;
            }
            return getProp(model, props.prop).value;
          });
          const normalizedRules = computed(() => {
            const { required } = props;
            const rules2 = [];
            if (props.rules) {
              rules2.push(...castArray(props.rules));
            }
            const formRules = formContext == null ? void 0 : formContext.rules;
            if (formRules && props.prop) {
              const _rules = getProp(formRules, props.prop).value;
              if (_rules) {
                rules2.push(...castArray(_rules));
              }
            }
            if (required !== void 0) {
              const requiredRules = rules2.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes("required"));
              if (requiredRules.length > 0) {
                for (const [rule, i] of requiredRules) {
                  if (rule.required === required)
                    continue;
                  rules2[i] = { ...rule, required };
                }
              } else {
                rules2.push({ required });
              }
            }
            return rules2;
          });
          const validateEnabled = computed(() => normalizedRules.value.length > 0);
          const getFilteredRule = (trigger2) => {
            const rules2 = normalizedRules.value;
            return rules2.filter((rule) => {
              if (!rule.trigger || !trigger2)
                return true;
              if (Array.isArray(rule.trigger)) {
                return rule.trigger.includes(trigger2);
              } else {
                return rule.trigger === trigger2;
              }
            }).map(({ trigger: trigger22, ...rule }) => rule);
          };
          const isRequired = computed(() => normalizedRules.value.some((rule) => rule.required));
          const shouldShowError = computed(() => {
            var _a2;
            return validateStateDebounced.value === "error" && props.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
          });
          const currentLabel = computed(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
          const setValidationState = (state) => {
            validateState.value = state;
          };
          const onValidationFailed = (error) => {
            var _a2, _b;
            const { errors, fields } = error;
            if (!errors || !fields) {
              console.error(error);
            }
            setValidationState("error");
            validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props.prop} is required` : "";
            formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
          };
          const onValidationSucceeded = () => {
            setValidationState("success");
            formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
          };
          const doValidate = async (rules2) => {
            const modelName = propString.value;
            const validator = new Schema({
              [modelName]: rules2
            });
            return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
              onValidationSucceeded();
              return true;
            }).catch((err) => {
              onValidationFailed(err);
              return Promise.reject(err);
            });
          };
          const validate = async (trigger2, callback) => {
            if (isResettingField || !props.prop) {
              return false;
            }
            const hasCallback = isFunction$2(callback);
            if (!validateEnabled.value) {
              callback == null ? void 0 : callback(false);
              return false;
            }
            const rules2 = getFilteredRule(trigger2);
            if (rules2.length === 0) {
              callback == null ? void 0 : callback(true);
              return true;
            }
            setValidationState("validating");
            return doValidate(rules2).then(() => {
              callback == null ? void 0 : callback(true);
              return true;
            }).catch((err) => {
              const { fields } = err;
              callback == null ? void 0 : callback(false, fields);
              return hasCallback ? false : Promise.reject(fields);
            });
          };
          const clearValidate = () => {
            setValidationState("");
            validateMessage.value = "";
            isResettingField = false;
          };
          const resetField = async () => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props.prop)
              return;
            const computedValue = getProp(model, props.prop);
            isResettingField = true;
            computedValue.value = clone(initialValue);
            await nextTick();
            clearValidate();
            isResettingField = false;
          };
          const addInputId = (id) => {
            if (!inputIds.value.includes(id)) {
              inputIds.value.push(id);
            }
          };
          const removeInputId = (id) => {
            inputIds.value = inputIds.value.filter((listId) => listId !== id);
          };
          watch(() => props.error, (val) => {
            validateMessage.value = val || "";
            setValidationState(val ? "error" : "");
          }, { immediate: true });
          watch(() => props.validateStatus, (val) => setValidationState(val || ""));
          const context = reactive({
            ...toRefs(props),
            $el: formItemRef,
            size: _size,
            validateState,
            labelId,
            inputIds,
            isGroup,
            hasLabel,
            fieldValue,
            addInputId,
            removeInputId,
            resetField,
            clearValidate,
            validate
          });
          provide(formItemContextKey, context);
          onMounted(() => {
            if (props.prop) {
              formContext == null ? void 0 : formContext.addField(context);
              initialValue = clone(fieldValue.value);
            }
          });
          onBeforeUnmount(() => {
            formContext == null ? void 0 : formContext.removeField(context);
          });
          expose2({
            size: _size,
            validateMessage,
            validateState,
            validate,
            clearValidate,
            resetField
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createElementBlock("div", {
              ref_key: "formItemRef",
              ref: formItemRef,
              class: normalizeClass(unref(formItemClasses)),
              role: unref(isGroup) ? "group" : void 0,
              "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
            }, [
              createVNode(unref(FormLabelWrap), {
                "is-auto-width": unref(labelStyle).width === "auto",
                "update-all": ((_a2 = unref(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
              }, {
                default: withCtx(() => [
                  unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                    key: 0,
                    id: unref(labelId),
                    for: unref(labelFor),
                    class: normalizeClass(unref(ns).e("label")),
                    style: normalizeStyle(unref(labelStyle))
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                        createTextVNode(toDisplayString$1(unref(currentLabel)), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["is-auto-width", "update-all"]),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("content")),
                style: normalizeStyle(unref(contentStyle))
              }, [
                renderSlot(_ctx.$slots, "default"),
                createVNode(TransitionGroup, {
                  name: `${unref(ns).namespace.value}-zoom-in-top`
                }, {
                  default: withCtx(() => [
                    unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                      key: 0,
                      error: validateMessage.value
                    }, () => [
                      createBaseVNode("div", {
                        class: normalizeClass(unref(validateClasses))
                      }, toDisplayString$1(validateMessage.value), 3)
                    ]) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ], 6)
            ], 10, _hoisted_1$j);
          };
        }
      });
      var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__file", "form-item.vue"]]);
      const ElForm = withInstall(Form, {
        FormItem
      });
      const ElFormItem = withNoopInstall(FormItem);
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style = window.getComputedStyle(targetElement);
        const boxSizing = style.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a2;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber$1(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result.minHeight = `${minHeight}px`;
        }
        if (isNumber$1(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result.height = `${height}px`;
        (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result;
      }
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        maxlength: {
          type: [String, Number]
        },
        minlength: {
          type: [String, Number]
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: {
          type: Boolean,
          default: false
        },
        clearable: {
          type: Boolean,
          default: false
        },
        showPassword: {
          type: Boolean,
          default: false
        },
        showWordLimit: {
          type: Boolean,
          default: false
        },
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        },
        autofocus: {
          type: Boolean,
          default: false
        }
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString$3(value),
        input: (value) => isString$3(value),
        change: (value) => isString$3(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const _hoisted_1$i = ["role"];
      const _hoisted_2$d = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"];
      const _hoisted_3$4 = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"];
      const __default__$r = /* @__PURE__ */ defineComponent({
        name: "ElInput",
        inheritAttrs: false
      });
      const _sfc_main$D = /* @__PURE__ */ defineComponent({
        ...__default__$r,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          const rawAttrs = useAttrs$1();
          const slots = useSlots();
          const containerAttrs = computed(() => {
            const comboBoxAttrs = {};
            if (props.containerRole === "combobox") {
              comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
              comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
              comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
            }
            return comboBoxAttrs;
          });
          const containerKls = computed(() => [
            props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.bm("group", "append")]: slots.append,
              [nsInput.bm("group", "prepend")]: slots.prepend,
              [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value,
              [nsInput.b("hidden")]: props.type === "hidden"
            },
            rawAttrs.class
          ]);
          const wrapperKls = computed(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const attrs = useAttrs({
            excludeKeys: computed(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const { form: elForm, formItem: elFormItem } = useFormItem();
          const { inputId } = useFormItemInputId(props, {
            formItemContext: elFormItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = shallowRef();
          const textarea = shallowRef();
          const hovering = ref(false);
          const isComposing = ref(false);
          const passwordVisible = ref(false);
          const countStyle = ref();
          const textareaCalcStyle = shallowRef(props.inputStyle);
          const _ref = computed(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            afterBlur() {
              var _a2;
              if (props.validateEvent) {
                (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = computed(() => {
            var _a2;
            return (_a2 = elForm == null ? void 0 : elForm.statusIcon) != null ? _a2 : false;
          });
          const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
          const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = computed(() => [
            rawAttrs.style
          ]);
          const textareaStyle = computed(() => [
            props.inputStyle,
            textareaCalcStyle.value,
            { resize: props.resize }
          ]);
          const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
          const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = computed(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
          const textLength = computed(() => nativeInputValue.value.length);
          const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
          const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type, autosize } = props;
            if (!isClient$1 || type !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$5(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$5(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a2;
              if (isInit || !props.autosize)
                return;
              const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props.formatter) {
              value = props.parser ? props.parser(value) : value;
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit2(UPDATE_MODEL_EVENT, value);
            emit2("input", value);
            await nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            emit2("change", event.target.value);
          };
          const handleCompositionStart = (event) => {
            emit2("compositionstart", event);
            isComposing.value = true;
          };
          const handleCompositionUpdate = (event) => {
            var _a2;
            emit2("compositionupdate", event);
            const text = (_a2 = event.target) == null ? void 0 : _a2.value;
            const lastCharacter = text[text.length - 1] || "";
            isComposing.value = !isKorean(lastCharacter);
          };
          const handleCompositionEnd = (event) => {
            emit2("compositionend", event);
            if (isComposing.value) {
              isComposing.value = false;
              handleInput(event);
            }
          };
          const handlePasswordVisible = () => {
            passwordVisible.value = !passwordVisible.value;
            focus();
          };
          const focus = async () => {
            var _a2;
            await nextTick();
            (_a2 = _ref.value) == null ? void 0 : _a2.focus();
          };
          const blur = () => {
            var _a2;
            return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit2("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit2("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit2("keydown", evt);
          };
          const select = () => {
            var _a2;
            (_a2 = _ref.value) == null ? void 0 : _a2.select();
          };
          const clear2 = () => {
            emit2(UPDATE_MODEL_EVENT, "");
            emit2("change", "");
            emit2("clear");
            emit2("input", "");
          };
          watch(() => props.modelValue, () => {
            var _a2;
            nextTick(() => resizeTextarea());
            if (props.validateEvent) {
              (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
            }
          });
          watch(nativeInputValue, () => setNativeInputValue());
          watch(() => props.type, async () => {
            await nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          onMounted(() => {
            if (!props.formatter && props.parser)
              ;
            setNativeInputValue();
            nextTick(resizeTextarea);
          });
          expose2({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: toRef(props, "autosize"),
            focus,
            blur,
            select,
            clear: clear2,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
              class: unref(containerKls),
              style: unref(containerStyle),
              role: _ctx.containerRole,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }), [
              createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
                createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).be("group", "prepend"))
                }, [
                  renderSlot(_ctx.$slots, "prepend")
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: normalizeClass(unref(wrapperKls))
                }, [
                  createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("prefix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("prefix-inner"))
                    }, [
                      renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: unref(nsInput).e("inner")
                  }, unref(attrs), {
                    minlength: _ctx.minlength,
                    maxlength: _ctx.maxlength,
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: unref(inputDisabled),
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.label,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: _ctx.form,
                    autofocus: _ctx.autofocus,
                    onCompositionstart: handleCompositionStart,
                    onCompositionupdate: handleCompositionUpdate,
                    onCompositionend: handleCompositionEnd,
                    onInput: handleInput,
                    onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                    onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, _hoisted_2$d),
                  createCommentVNode(" suffix slot "),
                  unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(nsInput).e("suffix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("suffix-inner"))
                    }, [
                      !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass(unref(nsInput).e("icon"))
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 64)) : createCommentVNode("v-if", true),
                      unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                        onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                        onClick: clear2
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                      unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                        key: 3,
                        class: normalizeClass(unref(nsInput).e("count"))
                      }, [
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsInput).e("count-inner"))
                        }, toDisplayString$1(unref(textLength)) + " / " + toDisplayString$1(_ctx.maxlength), 3)
                      ], 2)) : createCommentVNode("v-if", true),
                      unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 4,
                        class: normalizeClass([
                          unref(nsInput).e("icon"),
                          unref(nsInput).e("validateIcon"),
                          unref(nsInput).is("loading", unref(validateState) === "validating")
                        ])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createCommentVNode(" append slot "),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).be("group", "append"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)) : (openBlock(), createElementBlock(Fragment$1, { key: 1 }, [
                createCommentVNode(" textarea "),
                createBaseVNode("textarea", mergeProps({
                  id: unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: unref(nsTextarea).e("inner")
                }, unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  tabindex: _ctx.tabindex,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: unref(textareaStyle),
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_3$4),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  style: normalizeStyle(countStyle.value),
                  class: normalizeClass(unref(nsInput).e("count"))
                }, toDisplayString$1(unref(textLength)) + " / " + toDisplayString$1(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
              ], 64))
            ], 16, _hoisted_1$i);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__file", "input.vue"]]);
      const ElInput = withInstall(Input);
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle = ({
        move,
        size: size2,
        bar
      }) => ({
        [bar.size]: size2,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$3 = "Thumb";
      const _sfc_main$C = /* @__PURE__ */ defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$3, "can not inject scrollbar context");
          const instance = ref();
          const thumb = ref();
          const thumbState = ref({});
          const visible = ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient$1 ? document.onselectstart : null;
          const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = computed(() => renderThumbStyle({
            size: props.size,
            move: props.move,
            bar: bar.value
          }));
          const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e) => {
            var _a2;
            e.stopPropagation();
            if (e.ctrlKey || [1, 2].includes(e.button))
              return;
            (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
            startDrag(e);
            const el = e.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e) => {
            e.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener$1(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener$1(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                  onMousedown: clickTrackHandler
                }, [
                  createBaseVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(ns).e("thumb")),
                    style: normalizeStyle(unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 34), [
                  [vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__file", "thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        minSize: {
          type: Number,
          required: true
        }
      });
      const _sfc_main$B = /* @__PURE__ */ defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const moveX = ref(0);
          const moveY = ref(0);
          const sizeWidth = ref("");
          const sizeHeight = ref("");
          const ratioY = ref(1);
          const ratioX = ref(1);
          const handleScroll = (wrap2) => {
            if (wrap2) {
              const offsetHeight = wrap2.offsetHeight - GAP;
              const offsetWidth = wrap2.offsetWidth - GAP;
              moveY.value = wrap2.scrollTop * 100 / offsetHeight * ratioY.value;
              moveX.value = wrap2.scrollLeft * 100 / offsetWidth * ratioX.value;
            }
          };
          const update = () => {
            const wrap2 = scrollbar == null ? void 0 : scrollbar.wrapElement;
            if (!wrap2)
              return;
            const offsetHeight = wrap2.offsetHeight - GAP;
            const offsetWidth = wrap2.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrap2.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrap2.scrollWidth;
            const height = Math.max(originalHeight, props.minSize);
            const width = Math.max(originalWidth, props.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          expose2({
            handleScroll,
            update
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment$1, null, [
              createVNode(Thumb, {
                move: moveX.value,
                ratio: ratioX.value,
                size: sizeWidth.value,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              createVNode(Thumb, {
                move: moveY.value,
                ratio: ratioY.value,
                size: sizeHeight.value,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__file", "bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        },
        id: String,
        role: String,
        ariaLabel: String,
        ariaOrientation: {
          type: String,
          values: ["horizontal", "vertical"]
        }
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber$1)
      };
      const COMPONENT_NAME$2 = "ElScrollbar";
      const __default__$q = /* @__PURE__ */ defineComponent({
        name: COMPONENT_NAME$2
      });
      const _sfc_main$A = /* @__PURE__ */ defineComponent({
        ...__default__$q,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          const scrollbarRef = ref();
          const wrapRef = ref();
          const resizeRef = ref();
          const barRef = ref();
          const wrapStyle = computed(() => {
            const style = {};
            if (props.height)
              style.height = addUnit(props.height);
            if (props.maxHeight)
              style.maxHeight = addUnit(props.maxHeight);
            return [props.wrapStyle, style];
          });
          const wrapKls = computed(() => {
            return [
              props.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props.native }
            ];
          });
          const resizeKls = computed(() => {
            return [ns.e("view"), props.viewClass];
          });
          const handleScroll = () => {
            var _a2;
            if (wrapRef.value) {
              (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              emit2("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$5(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber$1(arg1) && isNumber$1(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber$1(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber$1(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            var _a2;
            (_a2 = barRef.value) == null ? void 0 : _a2.update();
          };
          watch(() => props.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
              stopResizeListener = useEventListener$1("resize", update);
            }
          }, { immediate: true });
          watch(() => [props.maxHeight, props.height], () => {
            if (!props.native)
              nextTick(() => {
                var _a2;
                update();
                if (wrapRef.value) {
                  (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
                }
              });
          });
          provide(scrollbarContextKey, reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          onMounted(() => {
            if (!props.native)
              nextTick(() => {
                update();
              });
          });
          onUpdated(() => update());
          expose2({
            wrapRef,
            update,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createBaseVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: normalizeClass(unref(wrapKls)),
                style: normalizeStyle(unref(wrapStyle)),
                onScroll: handleScroll
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                  id: _ctx.id,
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: normalizeClass(unref(resizeKls)),
                  style: normalizeStyle(_ctx.viewStyle),
                  role: _ctx.role,
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": _ctx.ariaOrientation
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
              ], 38),
              !_ctx.native ? (openBlock(), createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                always: _ctx.always,
                "min-size": _ctx.minSize
              }, null, 8, ["always", "min-size"])) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__file", "scrollbar.vue"]]);
      const ElScrollbar = withInstall(Scrollbar);
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$p = /* @__PURE__ */ defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$z = /* @__PURE__ */ defineComponent({
        ...__default__$p,
        props: popperProps,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const triggerRef = ref();
          const popperInstanceRef = ref();
          const contentRef = ref();
          const referenceRef = ref();
          const role = computed(() => props.role);
          const popperProvides = {
            triggerRef,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose2(popperProvides);
          provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__file", "popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$o = /* @__PURE__ */ defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$y = /* @__PURE__ */ defineComponent({
        ...__default__$o,
        props: popperArrowProps,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          watch(() => props.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose2({
            arrowRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: normalizeClass(unref(ns).e("arrow")),
              style: normalizeStyle(unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "arrow.vue"]]);
      const NAME = "ElOnlyChild";
      const OnlyChild = /* @__PURE__ */ defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a2;
          const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
          return () => {
            var _a22;
            const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$5(child)) {
            switch (child.type) {
              case Comment:
                continue;
              case Text:
              case "svg":
                return wrapTextContent(child);
              case Fragment$1:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s2) {
        const ns = useNamespace("only-child");
        return createVNode("span", {
          "class": ns.e("content")
        }, [s2]);
      }
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const __default__$n = /* @__PURE__ */ defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$x = /* @__PURE__ */ defineComponent({
        ...__default__$n,
        props: popperTriggerProps,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const { role, triggerRef } = inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef);
          const ariaControls = computed(() => {
            return ariaHaspopup.value ? props.id : void 0;
          });
          const ariaDescribedby = computed(() => {
            if (role && role.value === "tooltip") {
              return props.open && props.id ? props.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = computed(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = computed(() => {
            return ariaHaspopup.value ? `${props.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          onMounted(() => {
            watch(() => props.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef.value = unrefElement$1(virtualEl);
              }
            }, {
              immediate: true
            });
            watch(triggerRef, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement(el)) {
                [
                  "onMouseenter",
                  "onMouseleave",
                  "onClick",
                  "onKeydown",
                  "onFocus",
                  "onBlur",
                  "onContextmenu"
                ].forEach((eventName) => {
                  var _a2;
                  const handler = props[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                  [
                    "aria-controls",
                    "aria-describedby",
                    "aria-haspopup",
                    "aria-expanded"
                  ].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (isElement(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
          });
          expose2({
            triggerRef
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": unref(ariaControls),
              "aria-describedby": unref(ariaDescribedby),
              "aria-expanded": unref(ariaExpanded),
              "aria-haspopup": unref(ariaHaspopup)
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = ref();
      const lastUserFocusTimestamp = ref(0);
      const lastAutomatedFocusTimestamp = ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last2 = getVisibleElement(focusable.reverse(), container);
        return [first, last2];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack2 = [];
        const push = (layer) => {
          const currentLayer = stack2[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack2 = removeFromStack(stack2, layer);
          stack2.unshift(layer);
        };
        const remove2 = (layer) => {
          var _a2, _b;
          stack2 = removeFromStack(stack2, layer);
          (_b = (_a2 = stack2[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
        };
        return {
          push,
          remove: remove2
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const _sfc_main$w = /* @__PURE__ */ defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props, { emit: emit2 }) {
          const forwardRef = ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props.trapped && !focusLayer.paused) {
              emit2("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e) => {
            if (!props.loop && !props.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
            const { loop } = props;
            const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last2] = getEdges(container);
              const isTabbable = first && last2;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last2) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(last2, true);
                  }
                }
              }
            }
          };
          provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          watch(() => props.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e) => {
            emit2(ON_TRAP_FOCUS_EVT, e);
          };
          const releaseOnFocus = (e) => emit2(ON_RELEASE_FOCUS_EVT, e);
          const onFocusIn = (e) => {
            const trapContainer = unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e.target;
            const relatedTarget = e.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit2("focusin", e);
            if (focusLayer.paused)
              return;
            if (props.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e) => {
            const trapContainer = unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props.trapped) {
              const relatedTarget = e.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit2("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit2("focusout", e);
            }
          };
          async function startTrap() {
            await nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props.focusStartEl;
                    if (!isString$3(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          onMounted(() => {
            if (props.trapped) {
              startTrap();
            }
            watch(() => props.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          onBeforeUnmount(() => {
            if (props.trapped) {
              stopTrap();
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$6], ["__file", "focus-trap.vue"]]);
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: String,
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        virtualTriggering: Boolean,
        zIndex: Number
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const buildPopperOptions = (props, modifiers = []) => {
        const { placement, strategy, popperOptions } = props;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient$1)
          return;
        return unrefElement$1($el);
      };
      function genModifiers(options) {
        const { offset, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props) => {
        const { popperInstanceRef, contentRef, triggerRef, role } = inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = ref();
        const arrowOffset = ref();
        const eventListenerModifier = computed(() => {
          return {
            name: "eventListeners",
            enabled: !!props.visible
          };
        });
        const arrowModifier = computed(() => {
          var _a2;
          const arrowEl = unref(arrowRef);
          const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined$1(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options = computed(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props, [
              unref(arrowModifier),
              unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        watch(instanceRef, (instance) => popperInstanceRef.value = instance);
        onMounted(() => {
          watch(() => {
            var _a2;
            return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = computed(() => unref(attributes).popper);
        const contentZIndex = ref(isNumber$1(props.zIndex) ? props.zIndex : nextZIndex());
        const contentClass = computed(() => [
          ns.b(),
          ns.is("pure", props.pure),
          ns.is(props.effect),
          props.popperClass
        ]);
        const contentStyle = computed(() => {
          return [
            { zIndex: unref(contentZIndex) },
            unref(styles).popper,
            props.popperStyle || {}
          ];
        });
        const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = computed(() => unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = isNumber$1(props.zIndex) ? props.zIndex : nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const usePopperContentFocusTrap = (props, emit2) => {
        const trapped = ref(false);
        const focusStartRef = ref();
        const onFocusAfterTrapped = () => {
          emit2("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit2("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit2("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const __default__$m = /* @__PURE__ */ defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$v = /* @__PURE__ */ defineComponent({
        ...__default__$m,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props, emit2);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props, {
            styles,
            attributes,
            role
          });
          const formItemContext = inject(formItemContextKey, void 0);
          const arrowOffset = ref();
          provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
            provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props.visible && props.focusOnShow) {
              trapped.value = true;
            } else if (props.visible === false) {
              trapped.value = false;
            }
          };
          onMounted(() => {
            watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = unref(triggerTargetEl || contentRef.value);
              const prevEl = unref(prevTriggerTargetEl || contentRef.value);
              if (isElement(el)) {
                triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            watch(() => props.visible, togglePopperAlive, { immediate: true });
          });
          onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose2({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, unref(contentAttrs), {
              style: unref(contentStyle),
              class: unref(contentClass),
              tabindex: "-1",
              onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
              onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
            }), [
              createVNode(unref(ElFocusTrap), {
                trapped: unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": unref(contentRef),
                "focus-start-el": unref(focusStartRef),
                onFocusAfterTrapped: unref(onFocusAfterTrapped),
                onFocusAfterReleased: unref(onFocusAfterReleased),
                onFocusin: unref(onFocusInTrap),
                onFocusoutPrevented: unref(onFocusoutPrevented),
                onReleaseRequested: unref(onReleaseRequested)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "content.vue"]]);
      const ElPopper = withInstall(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      const useTooltipContentProps = buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: definePropType([String, Object])
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: {
          type: Boolean,
          default: false
        },
        persistent: Boolean,
        ariaLabel: String,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean
      });
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.space]
        }
      });
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger2, type) => {
        if (isArray$2(trigger2)) {
          return trigger2.includes(type);
        }
        return trigger2 === type;
      };
      const whenTrigger = (trigger2, type, handler) => {
        return (e) => {
          isTriggerType(unref(trigger2), type) && handler(e);
        };
      };
      const __default__$l = /* @__PURE__ */ defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$u = /* @__PURE__ */ defineComponent({
        ...__default__$l,
        props: useTooltipTriggerProps,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id, open: open2, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef = ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (unref(controlled) || props.disabled) {
              return true;
            }
          };
          const trigger2 = toRef(props, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e) => {
            if (e.button === 0) {
              onToggle(e);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e) => {
            e.preventDefault();
            onToggle(e);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
            const { code: code2 } = e;
            if (props.triggerKeys.includes(code2)) {
              e.preventDefault();
              onToggle(e);
            }
          });
          expose2({
            triggerRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopperTrigger), {
              id: unref(id),
              "virtual-ref": _ctx.virtualRef,
              open: unref(open2),
              "virtual-triggering": _ctx.virtualTriggering,
              class: normalizeClass(unref(ns).e("trigger")),
              onBlur: unref(onBlur),
              onClick: unref(onClick),
              onContextmenu: unref(onContextMenu),
              onFocus: unref(onFocus),
              onMouseenter: unref(onMouseenter),
              onMouseleave: unref(onMouseleave),
              onKeydown: unref(onKeydown)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "trigger.vue"]]);
      const __default__$k = /* @__PURE__ */ defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$t = /* @__PURE__ */ defineComponent({
        ...__default__$k,
        props: useTooltipContentProps,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = ref(null);
          const destroyed = ref(false);
          const {
            controlled,
            id,
            open: open2,
            trigger: trigger2,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = computed(() => {
            return props.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = computed(() => {
            return props.persistent;
          });
          onBeforeUnmount(() => {
            destroyed.value = true;
          });
          const shouldRender = computed(() => {
            return unref(persistentRef) ? true : unref(open2);
          });
          const shouldShow = computed(() => {
            return props.disabled ? false : unref(open2);
          });
          const appendTo = computed(() => {
            return props.appendTo || selector.value;
          });
          const contentStyle = computed(() => {
            var _a2;
            return (_a2 = props.style) != null ? _a2 : {};
          });
          const ariaHidden = computed(() => !unref(open2));
          const onTransitionLeave = () => {
            onHide();
          };
          const stopWhenControlled = () => {
            if (unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props.enterable && unref(trigger2) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (unref(trigger2) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(computed(() => {
              var _a2;
              return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
            }), () => {
              if (unref(controlled))
                return;
              const $trigger = unref(trigger2);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props.virtualTriggering) {
              onClose();
            }
          };
          let stopHandle;
          watch(() => unref(open2), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            }
          }, {
            flush: "post"
          });
          watch(() => props.content, () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          expose2({
            contentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              disabled: !_ctx.teleported,
              to: unref(appendTo)
            }, [
              createVNode(Transition, {
                name: unref(transitionClass),
                onAfterLeave: onTransitionLeave,
                onBeforeEnter,
                onAfterEnter: onAfterShow,
                onBeforeLeave
              }, {
                default: withCtx(() => [
                  unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                    key: 0,
                    id: unref(id),
                    ref_key: "contentRef",
                    ref: contentRef
                  }, _ctx.$attrs, {
                    "aria-label": _ctx.ariaLabel,
                    "aria-hidden": unref(ariaHidden),
                    "boundaries-padding": _ctx.boundariesPadding,
                    "fallback-placements": _ctx.fallbackPlacements,
                    "gpu-acceleration": _ctx.gpuAcceleration,
                    offset: _ctx.offset,
                    placement: _ctx.placement,
                    "popper-options": _ctx.popperOptions,
                    strategy: _ctx.strategy,
                    effect: _ctx.effect,
                    enterable: _ctx.enterable,
                    pure: _ctx.pure,
                    "popper-class": _ctx.popperClass,
                    "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                    "reference-el": _ctx.referenceEl,
                    "trigger-target-el": _ctx.triggerTargetEl,
                    visible: unref(shouldShow),
                    "z-index": _ctx.zIndex,
                    onMouseenter: unref(onContentEnter),
                    onMouseleave: unref(onContentLeave),
                    onBlur,
                    onClose: unref(onClose)
                  }), {
                    default: withCtx(() => [
                      !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                    [vShow, unref(shouldShow)]
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "content.vue"]]);
      const _hoisted_1$h = ["innerHTML"];
      const _hoisted_2$c = { key: 1 };
      const __default__$j = /* @__PURE__ */ defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$s = /* @__PURE__ */ defineComponent({
        ...__default__$j,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          usePopperContainer();
          const id = useId();
          const popperRef = ref();
          const contentRef = ref();
          const updatePopper = () => {
            var _a2;
            const popperComponent = unref(popperRef);
            if (popperComponent) {
              (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
            }
          };
          const open2 = ref(false);
          const toggleReason = ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open2,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef(props, "showAfter"),
            hideAfter: toRef(props, "hideAfter"),
            autoClose: toRef(props, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = computed(() => isBoolean$1(props.visible) && !hasUpdateHandler.value);
          provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id,
            open: readonly(open2),
            trigger: toRef(props, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (unref(open2)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit2("show", toggleReason.value);
            },
            onHide: () => {
              emit2("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit2("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit2("before-hide", toggleReason.value);
            },
            updatePopper
          });
          watch(() => props.disabled, (disabled) => {
            if (disabled && open2.value) {
              open2.value = false;
            }
          });
          const isFocusInsideContent = (event) => {
            var _a2, _b;
            const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
            const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
            return popperContent && popperContent.contains(activeElement);
          };
          onDeactivated(() => open2.value && hide());
          expose2({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: withCtx(() => [
                createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": _ctx.popperClass,
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, _hoisted_1$h)) : (openBlock(), createElementBlock("span", _hoisted_2$c, toDisplayString$1(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "tooltip.vue"]]);
      const ElTooltip = withInstall(Tooltip);
      const badgeProps = buildProps({
        value: {
          type: [String, Number],
          default: ""
        },
        max: {
          type: Number,
          default: 99
        },
        isDot: Boolean,
        hidden: Boolean,
        type: {
          type: String,
          values: ["primary", "success", "warning", "info", "danger"],
          default: "danger"
        },
        showZero: {
          type: Boolean,
          default: true
        },
        color: String,
        dotStyle: {
          type: definePropType([String, Object, Array])
        },
        offset: {
          type: definePropType(Array),
          default: [0, 0]
        },
        dotClass: {
          type: String
        }
      });
      const _hoisted_1$g = ["textContent"];
      const __default__$i = /* @__PURE__ */ defineComponent({
        name: "ElBadge"
      });
      const _sfc_main$r = /* @__PURE__ */ defineComponent({
        ...__default__$i,
        props: badgeProps,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const ns = useNamespace("badge");
          const content = computed(() => {
            if (props.isDot)
              return "";
            if (isNumber$1(props.value) && isNumber$1(props.max)) {
              if (props.max < props.value) {
                return `${props.max}+`;
              }
              return props.value === 0 && !props.showZero ? "" : `${props.value}`;
            }
            return `${props.value}`;
          });
          const style = computed(() => {
            var _a2, _b, _c, _d, _e;
            return [
              {
                backgroundColor: props.color,
                marginRight: addUnit(-((_b = (_a2 = props.offset) == null ? void 0 : _a2[0]) != null ? _b : 0)),
                marginTop: addUnit((_d = (_c = props.offset) == null ? void 0 : _c[1]) != null ? _d : 0)
              },
              (_e = props.dotStyle) != null ? _e : {}
            ];
          });
          expose2({
            content
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(Transition, {
                name: `${unref(ns).namespace.value}-zoom-in-center`,
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createBaseVNode("sup", {
                    class: normalizeClass([
                      unref(ns).e("content"),
                      unref(ns).em("content", _ctx.type),
                      unref(ns).is("fixed", !!_ctx.$slots.default),
                      unref(ns).is("dot", _ctx.isDot),
                      _ctx.dotClass
                    ]),
                    style: normalizeStyle(unref(style)),
                    textContent: toDisplayString$1(unref(content))
                  }, null, 14, _hoisted_1$g), [
                    [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot)]
                  ])
                ]),
                _: 1
              }, 8, ["name"])
            ], 2);
          };
        }
      });
      var Badge = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "badge.vue"]]);
      const ElBadge = withInstall(Badge);
      const buttonGroupContextKey = Symbol("buttonGroupContextKey");
      const useButton = (props, emit2) => {
        useDeprecated({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, computed(() => props.type === "text"));
        const buttonGroupContext = inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const { form } = useFormItem();
        const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useFormDisabled();
        const _ref = ref();
        const slots = useSlots();
        const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
        const autoInsertSpace = computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
        });
        const _props = computed(() => {
          if (props.tag === "button") {
            return {
              ariaDisabled: _disabled.value || props.loading,
              disabled: _disabled.value || props.loading,
              autofocus: props.autofocus,
              type: props.nativeType
            };
          }
          return {};
        });
        const shouldAddSpace = computed(() => {
          var _a2;
          const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === Text) {
              const text = slot.children;
              return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(text.trim());
            }
          }
          return false;
        });
        const handleClick = (evt) => {
          if (props.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit2("click", evt);
        };
        return {
          _disabled,
          _size,
          _type,
          _ref,
          _props,
          shouldAddSpace,
          handleClick
        };
      };
      const buttonTypes = [
        "default",
        "primary",
        "success",
        "warning",
        "info",
        "danger",
        "text",
        ""
      ];
      const buttonNativeTypes = ["button", "submit", "reset"];
      const buttonProps = buildProps({
        size: useSizeProp,
        disabled: Boolean,
        type: {
          type: String,
          values: buttonTypes,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        nativeType: {
          type: String,
          values: buttonNativeTypes,
          default: "button"
        },
        loading: Boolean,
        loadingIcon: {
          type: iconPropType,
          default: () => loading_default
        },
        plain: Boolean,
        text: Boolean,
        link: Boolean,
        bg: Boolean,
        autofocus: Boolean,
        round: Boolean,
        circle: Boolean,
        color: String,
        dark: Boolean,
        autoInsertSpace: {
          type: Boolean,
          default: void 0
        },
        tag: {
          type: definePropType([String, Object]),
          default: "button"
        }
      });
      const buttonEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      function bound01(n, max) {
        if (isOnePointZero(n)) {
          n = "100%";
        }
        var isPercent = isPercentage(n);
        n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
        if (isPercent) {
          n = parseInt(String(n * max), 10) / 100;
        }
        if (Math.abs(n - max) < 1e-6) {
          return 1;
        }
        if (max === 360) {
          n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
        } else {
          n = n % max / parseFloat(String(max));
        }
        return n;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n) {
        return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") !== -1;
      }
      function boundAlpha(a2) {
        a2 = parseFloat(a2);
        if (isNaN(a2) || a2 < 0 || a2 > 1) {
          a2 = 1;
        }
        return a2;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          return "".concat(Number(n) * 100, "%");
        }
        return n;
      }
      function pad2(c2) {
        return c2.length === 1 ? "0" + c2 : String(c2);
      }
      function rgbToRgb(r, g, b2) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b2, 255) * 255
        };
      }
      function rgbToHsl(r, g, b2) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b2 = bound01(b2, 255);
        var max = Math.max(r, g, b2);
        var min = Math.min(r, g, b2);
        var h2 = 0;
        var s2 = 0;
        var l2 = (max + min) / 2;
        if (max === min) {
          s2 = 0;
          h2 = 0;
        } else {
          var d2 = max - min;
          s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
          switch (max) {
            case r:
              h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
              break;
            case g:
              h2 = (b2 - r) / d2 + 2;
              break;
            case b2:
              h2 = (r - g) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, l: l2 };
      }
      function hue2rgb(p2, q2, t2) {
        if (t2 < 0) {
          t2 += 1;
        }
        if (t2 > 1) {
          t2 -= 1;
        }
        if (t2 < 1 / 6) {
          return p2 + (q2 - p2) * (6 * t2);
        }
        if (t2 < 1 / 2) {
          return q2;
        }
        if (t2 < 2 / 3) {
          return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
        }
        return p2;
      }
      function hslToRgb(h2, s2, l2) {
        var r;
        var g;
        var b2;
        h2 = bound01(h2, 360);
        s2 = bound01(s2, 100);
        l2 = bound01(l2, 100);
        if (s2 === 0) {
          g = l2;
          b2 = l2;
          r = l2;
        } else {
          var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
          var p2 = 2 * l2 - q2;
          r = hue2rgb(p2, q2, h2 + 1 / 3);
          g = hue2rgb(p2, q2, h2);
          b2 = hue2rgb(p2, q2, h2 - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b2 * 255 };
      }
      function rgbToHsv(r, g, b2) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b2 = bound01(b2, 255);
        var max = Math.max(r, g, b2);
        var min = Math.min(r, g, b2);
        var h2 = 0;
        var v2 = max;
        var d2 = max - min;
        var s2 = max === 0 ? 0 : d2 / max;
        if (max === min) {
          h2 = 0;
        } else {
          switch (max) {
            case r:
              h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
              break;
            case g:
              h2 = (b2 - r) / d2 + 2;
              break;
            case b2:
              h2 = (r - g) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, v: v2 };
      }
      function hsvToRgb(h2, s2, v2) {
        h2 = bound01(h2, 360) * 6;
        s2 = bound01(s2, 100);
        v2 = bound01(v2, 100);
        var i = Math.floor(h2);
        var f2 = h2 - i;
        var p2 = v2 * (1 - s2);
        var q2 = v2 * (1 - f2 * s2);
        var t2 = v2 * (1 - (1 - f2) * s2);
        var mod = i % 6;
        var r = [v2, q2, p2, p2, t2, v2][mod];
        var g = [t2, v2, v2, q2, p2, p2][mod];
        var b2 = [p2, p2, t2, v2, v2, q2][mod];
        return { r: r * 255, g: g * 255, b: b2 * 255 };
      }
      function rgbToHex(r, g, b2, allow3Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b2).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b2, a2, allow4Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b2).toString(16)),
          pad2(convertDecimalToHex(a2))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d2) {
        return Math.round(parseFloat(d2) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a2 = 1;
        var s2 = null;
        var v2 = null;
        var l2 = null;
        var ok = false;
        var format2 = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s2 = convertToPercentage(color.s);
            v2 = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s2, v2);
            ok = true;
            format2 = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s2 = convertToPercentage(color.s);
            l2 = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s2, l2);
            ok = true;
            format2 = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a2 = color.a;
          }
        }
        a2 = boundAlpha(a2);
        return {
          ok,
          format: color.format || format2,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a: a2
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match2 = matchers.rgb.exec(color);
        if (match2) {
          return { r: match2[1], g: match2[2], b: match2[3] };
        }
        match2 = matchers.rgba.exec(color);
        if (match2) {
          return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
        }
        match2 = matchers.hsl.exec(color);
        if (match2) {
          return { h: match2[1], s: match2[2], l: match2[3] };
        }
        match2 = matchers.hsla.exec(color);
        if (match2) {
          return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
        }
        match2 = matchers.hsv.exec(color);
        if (match2) {
          return { h: match2[1], s: match2[2], v: match2[3] };
        }
        match2 = matchers.hsva.exec(color);
        if (match2) {
          return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
        }
        match2 = matchers.hex8.exec(color);
        if (match2) {
          return {
            r: parseIntFromHex(match2[1]),
            g: parseIntFromHex(match2[2]),
            b: parseIntFromHex(match2[3]),
            a: convertHexToDecimal(match2[4]),
            format: named ? "name" : "hex8"
          };
        }
        match2 = matchers.hex6.exec(color);
        if (match2) {
          return {
            r: parseIntFromHex(match2[1]),
            g: parseIntFromHex(match2[2]),
            b: parseIntFromHex(match2[3]),
            format: named ? "name" : "hex"
          };
        }
        match2 = matchers.hex4.exec(color);
        if (match2) {
          return {
            r: parseIntFromHex(match2[1] + match2[1]),
            g: parseIntFromHex(match2[2] + match2[2]),
            b: parseIntFromHex(match2[3] + match2[3]),
            a: convertHexToDecimal(match2[4] + match2[4]),
            format: named ? "name" : "hex8"
          };
        }
        match2 = matchers.hex3.exec(color);
        if (match2) {
          return {
            r: parseIntFromHex(match2[1] + match2[1]),
            g: parseIntFromHex(match2[2] + match2[2]),
            b: parseIntFromHex(match2[3] + match2[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a2;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R2;
            var G2;
            var B2;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R2 = RsRGB / 12.92;
            } else {
              R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G2 = GsRGB / 12.92;
            } else {
              G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B2 = BsRGB / 12.92;
            } else {
              B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s2 = this.toHsl().s;
            return s2 === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h2 = Math.round(hsv.h * 360);
            var s2 = Math.round(hsv.s * 100);
            var v2 = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h2 = Math.round(hsl.h * 360);
            var s2 = Math.round(hsl.s * 100);
            var l2 = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r = Math.round(this.r);
            var g = Math.round(this.g);
            var b2 = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b2, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b2, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x2) {
              return "".concat(Math.round(bound01(x2, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x2) {
              return Math.round(bound01(x2, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
              var _b = _a2[_i], key = _b[0], value = _b[1];
              if (hex === value) {
                return key;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format2) {
            var formatSet = Boolean(format2);
            format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
            if (needsAlphaFormat) {
              if (format2 === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format2 === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format2 === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format2 === "hex" || format2 === "hex6") {
              formattedString = this.toHexString();
            }
            if (format2 === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format2 === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format2 === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format2 === "name") {
              formattedString = this.toName();
            }
            if (format2 === "hsl") {
              formattedString = this.toHslString();
            }
            if (format2 === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p2 = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
              g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
              b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
              a: (rgb2.a - rgb1.a) * p2 + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h2 = hsv.h;
            var s2 = hsv.s;
            var v2 = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
              v2 = (v2 + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n) {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            var result = [this];
            var increment = 360 / n;
            for (var i = 1; i < n; i++) {
              result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      );
      function darken(color, amount = 20) {
        return color.mix("#141414", amount).toString();
      }
      function useButtonCustomStyle(props) {
        const _disabled = useFormDisabled();
        const ns = useNamespace("button");
        return computed(() => {
          let styles = {};
          const buttonColor = props.color;
          if (buttonColor) {
            const color = new TinyColor(buttonColor);
            const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
            if (props.plain) {
              styles = ns.cssVarBlock({
                "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
                "text-color": buttonColor,
                "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
                "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                "hover-bg-color": buttonColor,
                "hover-border-color": buttonColor,
                "active-bg-color": activeBgColor,
                "active-text-color": `var(${ns.cssVarName("color-white")})`,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
              }
            } else {
              const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
              const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
              styles = ns.cssVarBlock({
                "bg-color": buttonColor,
                "text-color": textColor,
                "border-color": buttonColor,
                "hover-bg-color": hoverBgColor,
                "hover-text-color": textColor,
                "hover-border-color": hoverBgColor,
                "active-bg-color": activeBgColor,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
              }
            }
          }
          return styles;
        });
      }
      const __default__$h = /* @__PURE__ */ defineComponent({
        name: "ElButton"
      });
      const _sfc_main$q = /* @__PURE__ */ defineComponent({
        ...__default__$h,
        props: buttonProps,
        emits: buttonEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          const buttonStyle = useButtonCustomStyle(props);
          const ns = useNamespace("button");
          const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit2);
          const buttonKls = computed(() => [
            ns.b(),
            ns.m(_type.value),
            ns.m(_size.value),
            ns.is("disabled", _disabled.value),
            ns.is("loading", props.loading),
            ns.is("plain", props.plain),
            ns.is("round", props.round),
            ns.is("circle", props.circle),
            ns.is("text", props.text),
            ns.is("link", props.link),
            ns.is("has-bg", props.bg)
          ]);
          expose2({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
              ref_key: "_ref",
              ref: _ref
            }, unref(_props), {
              class: unref(buttonKls),
              style: unref(buttonStyle),
              onClick: unref(handleClick)
            }), {
              default: withCtx(() => [
                _ctx.loading ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
                  _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"]))
                ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ]),
                  _: 3
                })) : createCommentVNode("v-if", true),
                _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                  key: 2,
                  class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["class", "style", "onClick"]);
          };
        }
      });
      var Button = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "button.vue"]]);
      const buttonGroupProps = {
        size: buttonProps.size,
        type: buttonProps.type
      };
      const __default__$g = /* @__PURE__ */ defineComponent({
        name: "ElButtonGroup"
      });
      const _sfc_main$p = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        props: buttonGroupProps,
        setup(__props) {
          const props = __props;
          provide(buttonGroupContextKey, reactive({
            size: toRef(props, "size"),
            type: toRef(props, "type")
          }));
          const ns = useNamespace("button");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(`${unref(ns).b("group")}`)
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "button-group.vue"]]);
      const ElButton = withInstall(Button, {
        ButtonGroup
      });
      withNoopInstall(ButtonGroup);
      const nodeList = /* @__PURE__ */ new Map();
      let startClick;
      if (isClient$1) {
        document.addEventListener("mousedown", (e) => startClick = e);
        document.addEventListener("mouseup", (e) => {
          for (const handlers2 of nodeList.values()) {
            for (const { documentHandler } of handlers2) {
              documentHandler(e, startClick);
            }
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (Array.isArray(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers2 = nodeList.get(el);
          const oldHandlerIndex = handlers2.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers2.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers2.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      };
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction$2(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$2(value) ? value() : value.handler();
          const clear2 = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear2();
            handler();
            document.addEventListener("mouseup", () => clear2(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay);
          });
        }
      };
      var v = false, o, f, s, u, d, N, l, p, m, w, D, x, E, M, F;
      function a() {
        if (!v) {
          v = true;
          var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
          if (x = /\b(iPhone|iP[ao]d)/.exec(e), E = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), M = /FBAN\/\w+;/i.exec(e), F = /Mobile/i.exec(e), D = !!/Win64/.exec(e), n) {
            o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
            var r = /(?:Trident\/(\d+.\d+))/.exec(e);
            N = r ? parseFloat(r[1]) + 4 : o, f = n[2] ? parseFloat(n[2]) : NaN, s = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
          } else
            o = f = s = d = u = NaN;
          if (i) {
            if (i[1]) {
              var t2 = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
              l = t2 ? parseFloat(t2[1].replace("_", ".")) : true;
            } else
              l = false;
            p = !!i[2], m = !!i[3];
          } else
            l = p = m = false;
        }
      }
      var _ = { ie: function() {
        return a() || o;
      }, ieCompatibilityMode: function() {
        return a() || N > o;
      }, ie64: function() {
        return _.ie() && D;
      }, firefox: function() {
        return a() || f;
      }, opera: function() {
        return a() || s;
      }, webkit: function() {
        return a() || u;
      }, safari: function() {
        return _.webkit();
      }, chrome: function() {
        return a() || d;
      }, windows: function() {
        return a() || p;
      }, osx: function() {
        return a() || l;
      }, linux: function() {
        return a() || m;
      }, iphone: function() {
        return a() || x;
      }, mobile: function() {
        return a() || x || E || w || F;
      }, nativeApp: function() {
        return a() || M;
      }, android: function() {
        return a() || w;
      }, ipad: function() {
        return a() || E;
      } }, A = _;
      var c = !!(typeof window < "u" && window.document && window.document.createElement), U = { canUseDOM: c, canUseWorkers: typeof Worker < "u", canUseEventListeners: c && !!(window.addEventListener || window.attachEvent), canUseViewport: c && !!window.screen, isInWorker: !c }, h = U;
      var X;
      h.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
      function S(e, n) {
        if (!h.canUseDOM || n && !("addEventListener" in document))
          return false;
        var i = "on" + e, r = i in document;
        if (!r) {
          var t2 = document.createElement("div");
          t2.setAttribute(i, "return;"), r = typeof t2[i] == "function";
        }
        return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
      }
      var b = S;
      var O = 10, I = 40, P = 800;
      function T(e) {
        var n = 0, i = 0, r = 0, t2 = 0;
        return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t2 = i * O, "deltaY" in e && (t2 = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t2) && e.deltaMode && (e.deltaMode == 1 ? (r *= I, t2 *= I) : (r *= P, t2 *= P)), r && !n && (n = r < 1 ? -1 : 1), t2 && !i && (i = t2 < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t2 };
      }
      T.getEventType = function() {
        return A.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
      };
      var Y = T;
      /**
      * Checks if an event is supported in the current execution environment.
      *
      * NOTE: This will not work correctly for non-generic events such as `change`,
      * `reset`, `load`, `error`, and `select`.
      *
      * Borrows from Modernizr.
      *
      * @param {string} eventNameSuffix Event name, e.g. "click".
      * @param {?boolean} capture Check if the capture phase is supported.
      * @return {boolean} True if the event is supported.
      * @internal
      * @license Modernizr 3.0.0pre (Custom Build) | MIT
      */
      const mousewheel = function(element, callback) {
        if (element && element.addEventListener) {
          const fn2 = function(event) {
            const normalized = Y(event);
            callback && Reflect.apply(callback, this, [event, normalized]);
          };
          element.addEventListener("wheel", fn2, { passive: true });
        }
      };
      const Mousewheel = {
        beforeMount(el, binding) {
          mousewheel(el, binding.value);
        }
      };
      const checkboxProps = {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        value: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueValue: {
          type: [String, Number],
          default: void 0
        },
        falseValue: {
          type: [String, Number],
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        controls: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        }
      };
      const checkboxEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isString$3(val) || isNumber$1(val) || isBoolean$1(val),
        change: (val) => isString$3(val) || isNumber$1(val) || isBoolean$1(val)
      };
      const checkboxGroupContextKey = Symbol("checkboxGroupContextKey");
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = computed(() => {
          var _a2, _b;
          const max = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value;
          const min = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined(max) && model.value.length >= max && !isChecked.value || !isUndefined(min) && model.value.length <= min && isChecked.value;
        });
        const isDisabled = useFormDisabled(computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit: emit2 } = getCurrentInstance();
        function getLabeledValue(value) {
          var _a2, _b, _c, _d;
          return [true, props.trueValue, props.trueLabel].includes(value) ? (_b = (_a2 = props.trueValue) != null ? _a2 : props.trueLabel) != null ? _b : true : (_d = (_c = props.falseValue) != null ? _c : props.falseLabel) != null ? _d : false;
        }
        function emitChangeEvent(checked, e) {
          emit2("change", getLabeledValue(checked), e);
        }
        function handleChange(e) {
          if (isLimitExceeded.value)
            return;
          const target = e.target;
          emit2("change", getLabeledValue(target.checked), e);
        }
        async function onClickRoot(e) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props.falseValue, props.falseLabel].includes(model.value));
              await nextTick();
              emitChangeEvent(model.value, e);
            }
          }
        }
        const validateEvent = computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props.validateEvent);
        watch(() => props.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props) => {
        const selfModel = ref(false);
        const { emit: emit2 } = getCurrentInstance();
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isGroup = computed(() => isUndefined(checkboxGroup) === false);
        const isLimitExceeded = ref(false);
        const model = computed({
          get() {
            var _a2, _b;
            return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a2, _b;
            if (isGroup.value && isArray$2(val)) {
              isLimitExceeded.value = ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a2.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value) && val.length > model.value.length;
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit2(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props, slots, { model }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isFocused = ref(false);
        const actualValue = computed(() => {
          if (!isPropAbsent(props.value)) {
            return props.value;
          }
          return props.label;
        });
        const isChecked = computed(() => {
          const value = model.value;
          if (isBoolean$1(value)) {
            return value;
          } else if (isArray$2(value)) {
            if (isObject$5(actualValue.value)) {
              return value.map(toRaw).some((o2) => isEqual(o2, actualValue.value));
            } else {
              return value.map(toRaw).includes(actualValue.value);
            }
          } else if (value !== null && value !== void 0) {
            return value === props.trueValue || value === props.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(computed(() => {
          var _a2;
          return (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a2.value;
        }));
        const hasOwnLabel = computed(() => {
          return !!slots.default || !isPropAbsent(actualValue.value);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel,
          actualValue
        };
      };
      const useCheckbox = (props, slots) => {
        const { formItem: elFormItem } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          actualValue
        } = useCheckboxStatus(props, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: elFormItem,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        const setStoreValue = () => {
          function addToStore() {
            var _a2, _b;
            if (isArray$2(model.value) && !model.value.includes(actualValue.value)) {
              model.value.push(actualValue.value);
            } else {
              model.value = (_b = (_a2 = props.trueValue) != null ? _a2 : props.trueLabel) != null ? _b : true;
            }
          }
          props.checked && addToStore();
        };
        setStoreValue();
        useDeprecated({
          from: "label act as value",
          replacement: "value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => isGroup.value && isPropAbsent(props.value)));
        useDeprecated({
          from: "true-label",
          replacement: "true-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => !!props.trueLabel));
        useDeprecated({
          from: "false-label",
          replacement: "false-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => !!props.falseLabel));
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          actualValue,
          handleChange,
          onClickRoot
        };
      };
      const _hoisted_1$f = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$b = ["id", "indeterminate", "disabled", "value", "name", "tabindex"];
      const __default__$f = /* @__PURE__ */ defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$o = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            actualValue,
            handleChange,
            onClickRoot
          } = useCheckbox(props, slots);
          const ns = useNamespace("checkbox");
          const compKls = computed(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = computed(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
              class: normalizeClass(unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
              onClick: unref(onClickRoot)
            }, {
              default: withCtx(() => {
                var _a2, _b;
                return [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(spanKls))
                  }, [
                    _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                      key: 0,
                      id: unref(inputId),
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      disabled: unref(isDisabled),
                      "true-value": (_a2 = _ctx.trueValue) != null ? _a2 : _ctx.trueLabel,
                      "false-value": (_b = _ctx.falseValue) != null ? _b : _ctx.falseLabel,
                      onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                      onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                      onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
                      onClick: _cache[4] || (_cache[4] = withModifiers(() => {
                      }, ["stop"]))
                    }, null, 42, _hoisted_1$f)), [
                      [vModelCheckbox, unref(model)]
                    ]) : withDirectives((openBlock(), createElementBlock("input", {
                      key: 1,
                      id: unref(inputId),
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(model) ? model.value = $event : null),
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      disabled: unref(isDisabled),
                      value: unref(actualValue),
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      onChange: _cache[6] || (_cache[6] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                      onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
                      onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
                      onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                      }, ["stop"]))
                    }, null, 42, _hoisted_2$b)), [
                      [vModelCheckbox, unref(model)]
                    ]),
                    createBaseVNode("span", {
                      class: normalizeClass(unref(ns).e("inner"))
                    }, null, 2)
                  ], 2),
                  unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(ns).e("label"))
                  }, [
                    renderSlot(_ctx.$slots, "default"),
                    !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment$1, { key: 0 }, [
                      createTextVNode(toDisplayString$1(_ctx.label), 1)
                    ], 64)) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true)
                ];
              }),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "checkbox.vue"]]);
      const _hoisted_1$e = ["name", "tabindex", "disabled", "true-value", "false-value"];
      const _hoisted_2$a = ["name", "tabindex", "disabled", "value"];
      const __default__$e = /* @__PURE__ */ defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$n = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props = __props;
          const slots = useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            actualValue,
            handleChange
          } = useCheckbox(props, slots);
          const checkboxGroup = inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = computed(() => {
            var _a2, _b, _c, _d;
            const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = computed(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            var _a2, _b;
            return openBlock(), createElementBlock("label", {
              class: normalizeClass(unref(labelKls))
            }, [
              _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                "true-value": (_a2 = _ctx.trueValue) != null ? _a2 : _ctx.trueLabel,
                "false-value": (_b = _ctx.falseValue) != null ? _b : _ctx.falseLabel,
                onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[2] || (_cache[2] = ($event) => isFocused.value = true),
                onBlur: _cache[3] || (_cache[3] = ($event) => isFocused.value = false),
                onClick: _cache[4] || (_cache[4] = withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_1$e)), [
                [vModelCheckbox, unref(model)]
              ]) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(model) ? model.value = $event : null),
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                value: unref(actualValue),
                onChange: _cache[6] || (_cache[6] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                onFocus: _cache[7] || (_cache[7] = ($event) => isFocused.value = true),
                onBlur: _cache[8] || (_cache[8] = ($event) => isFocused.value = false),
                onClick: _cache[9] || (_cache[9] = withModifiers(() => {
                }, ["stop"]))
              }, null, 42, _hoisted_2$a)), [
                [vModelCheckbox, unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString$1(_ctx.label), 1)
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__file", "checkbox-button.vue"]]);
      const checkboxGroupProps = buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        label: String,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const checkboxGroupEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isArray$2(val),
        change: (val) => isArray$2(val)
      };
      const __default__$d = /* @__PURE__ */ defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$m = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit2(UPDATE_MODEL_EVENT, value);
            await nextTick();
            emit2("change", value);
          };
          const modelValue = computed({
            get() {
              return props.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          provide(checkboxGroupContextKey, {
            ...pick(toRefs(props), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          watch(() => props.modelValue, () => {
            if (props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            var _a2;
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              id: unref(groupId),
              class: normalizeClass(unref(ns).b("group")),
              role: "group",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? (_a2 = unref(formItem)) == null ? void 0 : _a2.labelId : void 0
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "checkbox-group.vue"]]);
      const ElCheckbox = withInstall(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      });
      withNoopInstall(CheckboxButton);
      const ElCheckboxGroup$1 = withNoopInstall(CheckboxGroup);
      const tagProps = buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger"],
          default: "primary"
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: String,
        size: {
          type: String,
          values: componentSizes
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      });
      const tagEmits = {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$c = /* @__PURE__ */ defineComponent({
        name: "ElTag"
      });
      const _sfc_main$l = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = computed(() => {
            const { type, hit, effect, closable, round } = props;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type || "primary"),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round)
            ];
          });
          const handleClose = (event) => {
            emit2("close", event);
          };
          const handleClick = (event) => {
            emit2("click", event);
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(containerKls)),
              style: normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              createBaseVNode("span", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns).e("close")),
                onClick: withModifiers(handleClose, ["stop"])
              }, {
                default: withCtx(() => [
                  createVNode(unref(close_default))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ], 6)) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              appear: ""
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  class: normalizeClass(unref(containerKls)),
                  style: normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).e("close")),
                    onClick: withModifiers(handleClose, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(close_default))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "tag.vue"]]);
      const ElTag = withInstall(Tag);
      const emitChangeFn = (value) => isNumber$1(value) || isString$3(value) || isArray$2(value);
      const collapseProps = buildProps({
        accordion: Boolean,
        modelValue: {
          type: definePropType([Array, String, Number]),
          default: () => mutable([])
        }
      });
      const collapseEmits = {
        [UPDATE_MODEL_EVENT]: emitChangeFn,
        [CHANGE_EVENT]: emitChangeFn
      };
      const collapseContextKey = Symbol("collapseContextKey");
      const useCollapse = (props, emit2) => {
        const activeNames = ref(castArray(props.modelValue));
        const setActiveNames = (_activeNames) => {
          activeNames.value = _activeNames;
          const value = props.accordion ? activeNames.value[0] : activeNames.value;
          emit2(UPDATE_MODEL_EVENT, value);
          emit2(CHANGE_EVENT, value);
        };
        const handleItemClick = (name) => {
          if (props.accordion) {
            setActiveNames([activeNames.value[0] === name ? "" : name]);
          } else {
            const _activeNames = [...activeNames.value];
            const index = _activeNames.indexOf(name);
            if (index > -1) {
              _activeNames.splice(index, 1);
            } else {
              _activeNames.push(name);
            }
            setActiveNames(_activeNames);
          }
        };
        watch(() => props.modelValue, () => activeNames.value = castArray(props.modelValue), { deep: true });
        provide(collapseContextKey, {
          activeNames,
          handleItemClick
        });
        return {
          activeNames,
          setActiveNames
        };
      };
      const useCollapseDOM = () => {
        const ns = useNamespace("collapse");
        const rootKls = computed(() => ns.b());
        return {
          rootKls
        };
      };
      const __default__$b = /* @__PURE__ */ defineComponent({
        name: "ElCollapse"
      });
      const _sfc_main$k = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: collapseProps,
        emits: collapseEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          const { activeNames, setActiveNames } = useCollapse(props, emit2);
          const { rootKls } = useCollapseDOM();
          expose2({
            activeNames,
            setActiveNames
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(rootKls))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Collapse = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "collapse.vue"]]);
      const __default__$a = /* @__PURE__ */ defineComponent({
        name: "ElCollapseTransition"
      });
      const _sfc_main$j = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        setup(__props) {
          const ns = useNamespace("collapse-transition");
          const reset = (el) => {
            el.style.maxHeight = "";
            el.style.overflow = el.dataset.oldOverflow;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          };
          const on2 = {
            beforeEnter(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              if (el.style.height)
                el.dataset.elExistsHeight = el.style.height;
              el.style.maxHeight = 0;
              el.style.paddingTop = 0;
              el.style.paddingBottom = 0;
            },
            enter(el) {
              requestAnimationFrame(() => {
                el.dataset.oldOverflow = el.style.overflow;
                if (el.dataset.elExistsHeight) {
                  el.style.maxHeight = el.dataset.elExistsHeight;
                } else if (el.scrollHeight !== 0) {
                  el.style.maxHeight = `${el.scrollHeight}px`;
                } else {
                  el.style.maxHeight = 0;
                }
                el.style.paddingTop = el.dataset.oldPaddingTop;
                el.style.paddingBottom = el.dataset.oldPaddingBottom;
                el.style.overflow = "hidden";
              });
            },
            afterEnter(el) {
              el.style.maxHeight = "";
              el.style.overflow = el.dataset.oldOverflow;
            },
            enterCancelled(el) {
              reset(el);
            },
            beforeLeave(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              el.dataset.oldOverflow = el.style.overflow;
              el.style.maxHeight = `${el.scrollHeight}px`;
              el.style.overflow = "hidden";
            },
            leave(el) {
              if (el.scrollHeight !== 0) {
                el.style.maxHeight = 0;
                el.style.paddingTop = 0;
                el.style.paddingBottom = 0;
              }
            },
            afterLeave(el) {
              reset(el);
            },
            leaveCancelled(el) {
              reset(el);
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, mergeProps({
              name: unref(ns).b()
            }, toHandlers(on2)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["name"]);
          };
        }
      });
      var CollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "collapse-transition.vue"]]);
      CollapseTransition.install = (app) => {
        app.component(CollapseTransition.name, CollapseTransition);
      };
      const _CollapseTransition = CollapseTransition;
      const collapseItemProps = buildProps({
        title: {
          type: String,
          default: ""
        },
        name: {
          type: definePropType([String, Number]),
          default: void 0
        },
        disabled: Boolean
      });
      const useCollapseItem = (props) => {
        const collapse = inject(collapseContextKey);
        const { namespace } = useNamespace("collapse");
        const focusing = ref(false);
        const isClick = ref(false);
        const idInjection = useIdInjection();
        const id = computed(() => idInjection.current++);
        const name = computed(() => {
          var _a2;
          return (_a2 = props.name) != null ? _a2 : `${namespace.value}-id-${idInjection.prefix}-${unref(id)}`;
        });
        const isActive = computed(() => collapse == null ? void 0 : collapse.activeNames.value.includes(unref(name)));
        const handleFocus = () => {
          setTimeout(() => {
            if (!isClick.value) {
              focusing.value = true;
            } else {
              isClick.value = false;
            }
          }, 50);
        };
        const handleHeaderClick = () => {
          if (props.disabled)
            return;
          collapse == null ? void 0 : collapse.handleItemClick(unref(name));
          focusing.value = false;
          isClick.value = true;
        };
        const handleEnterClick = () => {
          collapse == null ? void 0 : collapse.handleItemClick(unref(name));
        };
        return {
          focusing,
          id,
          isActive,
          handleFocus,
          handleHeaderClick,
          handleEnterClick
        };
      };
      const useCollapseItemDOM = (props, { focusing, isActive, id }) => {
        const ns = useNamespace("collapse");
        const rootKls = computed(() => [
          ns.b("item"),
          ns.is("active", unref(isActive)),
          ns.is("disabled", props.disabled)
        ]);
        const headKls = computed(() => [
          ns.be("item", "header"),
          ns.is("active", unref(isActive)),
          { focusing: unref(focusing) && !props.disabled }
        ]);
        const arrowKls = computed(() => [
          ns.be("item", "arrow"),
          ns.is("active", unref(isActive))
        ]);
        const itemWrapperKls = computed(() => ns.be("item", "wrap"));
        const itemContentKls = computed(() => ns.be("item", "content"));
        const scopedContentId = computed(() => ns.b(`content-${unref(id)}`));
        const scopedHeadId = computed(() => ns.b(`head-${unref(id)}`));
        return {
          arrowKls,
          headKls,
          rootKls,
          itemWrapperKls,
          itemContentKls,
          scopedContentId,
          scopedHeadId
        };
      };
      const _hoisted_1$d = ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex"];
      const _hoisted_2$9 = ["id", "aria-hidden", "aria-labelledby"];
      const __default__$9 = /* @__PURE__ */ defineComponent({
        name: "ElCollapseItem"
      });
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: collapseItemProps,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const {
            focusing,
            id,
            isActive,
            handleFocus,
            handleHeaderClick,
            handleEnterClick
          } = useCollapseItem(props);
          const {
            arrowKls,
            headKls,
            rootKls,
            itemWrapperKls,
            itemContentKls,
            scopedContentId,
            scopedHeadId
          } = useCollapseItemDOM(props, { focusing, isActive, id });
          expose2({
            isActive
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(rootKls))
            }, [
              createBaseVNode("button", {
                id: unref(scopedHeadId),
                class: normalizeClass(unref(headKls)),
                "aria-expanded": unref(isActive),
                "aria-controls": unref(scopedContentId),
                "aria-describedby": unref(scopedContentId),
                tabindex: _ctx.disabled ? -1 : 0,
                type: "button",
                onClick: _cache[0] || (_cache[0] = (...args) => unref(handleHeaderClick) && unref(handleHeaderClick)(...args)),
                onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => unref(handleEnterClick) && unref(handleEnterClick)(...args), ["stop", "prevent"]), ["space", "enter"])),
                onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                onBlur: _cache[3] || (_cache[3] = ($event) => focusing.value = false)
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString$1(_ctx.title), 1)
                ]),
                createVNode(unref(ElIcon), {
                  class: normalizeClass(unref(arrowKls))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(arrow_right_default))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 42, _hoisted_1$d),
              createVNode(unref(_CollapseTransition), null, {
                default: withCtx(() => [
                  withDirectives(createBaseVNode("div", {
                    id: unref(scopedContentId),
                    role: "region",
                    class: normalizeClass(unref(itemWrapperKls)),
                    "aria-hidden": !unref(isActive),
                    "aria-labelledby": unref(scopedHeadId)
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(itemContentKls))
                    }, [
                      renderSlot(_ctx.$slots, "default")
                    ], 2)
                  ], 10, _hoisted_2$9), [
                    [vShow, unref(isActive)]
                  ])
                ]),
                _: 3
              })
            ], 2);
          };
        }
      });
      var CollapseItem = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "collapse-item.vue"]]);
      const ElCollapse = withInstall(Collapse, {
        CollapseItem
      });
      const ElCollapseItem = withNoopInstall(CollapseItem);
      const overlayProps = buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: {
          type: Boolean,
          default: false
        },
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      });
      const overlayEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const BLOCK = "overlay";
      var Overlay = /* @__PURE__ */ defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props, { slots, emit: emit2 }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e) => {
            emit2("click", e);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props.mask ? createVNode("div", {
              class: [ns.b(), props.overlayClass],
              style: {
                zIndex: props.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
              class: props.overlayClass,
              style: {
                zIndex: props.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = Overlay;
      const dialogInjectionKey = Symbol("dialogInjectionKey");
      const dialogContentProps = buildProps({
        center: Boolean,
        alignCenter: Boolean,
        closeIcon: {
          type: iconPropType
        },
        draggable: Boolean,
        overflow: Boolean,
        fullscreen: Boolean,
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        ariaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const _hoisted_1$c = ["aria-level"];
      const _hoisted_2$8 = ["aria-label"];
      const _hoisted_3$3 = ["id"];
      const __default__$8 = /* @__PURE__ */ defineComponent({ name: "ElDialogContent" });
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props) {
          const props = __props;
          const { t: t2 } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style } = inject(dialogInjectionKey);
          const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
          const dialogKls = computed(() => [
            ns.b(),
            ns.is("fullscreen", props.fullscreen),
            ns.is("draggable", props.draggable),
            ns.is("align-center", props.alignCenter),
            { [ns.m("center")]: props.center }
          ]);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable = computed(() => props.draggable);
          const overflow = computed(() => props.overflow);
          useDraggable(dialogRef, headerRef, draggable, overflow);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref: unref(composedDialogRef),
              class: normalizeClass(unref(dialogKls)),
              style: normalizeStyle(unref(style)),
              tabindex: "-1"
            }, [
              createBaseVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: normalizeClass([unref(ns).e("header"), { "show-close": _ctx.showClose }])
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createBaseVNode("span", {
                    role: "heading",
                    "aria-level": _ctx.ariaLevel,
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString$1(_ctx.title), 11, _hoisted_1$c)
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": unref(t2)("el.dialog.close"),
                  class: normalizeClass(unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass(unref(ns).e("close"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, _hoisted_2$8)) : createCommentVNode("v-if", true)
              ], 2),
              createBaseVNode("div", {
                id: unref(bodyId),
                class: normalizeClass(unref(ns).e("body"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 10, _hoisted_3$3),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
                key: 0,
                class: normalizeClass(unref(ns).e("footer"))
              }, [
                renderSlot(_ctx.$slots, "footer")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__file", "dialog-content.vue"]]);
      const dialogProps = buildProps({
        ...dialogContentProps,
        appendToBody: Boolean,
        appendTo: {
          type: definePropType(String),
          default: "body"
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: Boolean,
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: Boolean,
        modalClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: {
          type: Boolean,
          default: false
        },
        headerAriaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogEmits = {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean$1(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      };
      const useDialog = (props, targetRef) => {
        var _a2;
        const instance = getCurrentInstance();
        const emit2 = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = ref(false);
        const closed = ref(false);
        const rendered = ref(false);
        const zIndex2 = ref((_a2 = props.zIndex) != null ? _a2 : nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const namespace = useGlobalConfig("namespace", defaultNamespace);
        const style = computed(() => {
          const style2 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props.fullscreen) {
            if (props.top) {
              style2[`${varPrefix}-margin-top`] = props.top;
            }
            if (props.width) {
              style2[`${varPrefix}-width`] = addUnit(props.width);
            }
          }
          return style2;
        });
        const overlayDialogStyle = computed(() => {
          if (props.alignCenter) {
            return { display: "flex" };
          }
          return {};
        });
        function afterEnter() {
          emit2("opened");
        }
        function afterLeave() {
          emit2("closed");
          emit2(UPDATE_MODEL_EVENT, false);
          if (props.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit2("close");
        }
        function open2() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props.openDelay && props.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
          } else {
            doOpen();
          }
        }
        function close() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props.closeDelay && props.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props.beforeClose) {
            props.beforeClose(hide);
          } else {
            close();
          }
        }
        function onModalClick() {
          if (props.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient$1)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit2("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit2("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a22;
          if (((_a22 = event.detail) == null ? void 0 : _a22.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props.closeOnPressEscape) {
            handleClose();
          }
        }
        watch(() => props.modelValue, (val) => {
          if (val) {
            closed.value = false;
            open2();
            rendered.value = true;
            zIndex2.value = isUndefined$1(props.zIndex) ? nextZIndex() : zIndex2.value++;
            nextTick(() => {
              emit2("open");
              if (targetRef.value) {
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close();
            }
          }
        });
        watch(() => props.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        onMounted(() => {
          if (props.modelValue) {
            visible.value = true;
            rendered.value = true;
            open2();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2
        };
      };
      const _hoisted_1$b = ["aria-label", "aria-labelledby", "aria-describedby"];
      const __default__$7 = /* @__PURE__ */ defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const slots = useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, computed(() => !!slots.title));
          const ns = useNamespace("dialog");
          const dialogRef = ref();
          const headerRef = ref();
          const dialogContentRef = ref();
          const {
            visible,
            titleId,
            bodyId,
            style,
            overlayDialogStyle,
            rendered,
            zIndex: zIndex2,
            afterEnter,
            afterLeave,
            beforeLeave,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props, dialogRef);
          provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style
          });
          const overlayEvent = useSameTarget(onModalClick);
          const draggable = computed(() => props.draggable && !props.fullscreen);
          expose2({
            visible,
            dialogContentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: _ctx.appendTo,
              disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
            }, [
              createVNode(Transition, {
                name: "dialog-fade",
                onAfterEnter: unref(afterEnter),
                onAfterLeave: unref(afterLeave),
                onBeforeLeave: unref(beforeLeave),
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createVNode(unref(ElOverlay), {
                    "custom-mask-event": "",
                    mask: _ctx.modal,
                    "overlay-class": _ctx.modalClass,
                    "z-index": unref(zIndex2)
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        role: "dialog",
                        "aria-modal": "true",
                        "aria-label": _ctx.title || void 0,
                        "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                        "aria-describedby": unref(bodyId),
                        class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                        style: normalizeStyle(unref(overlayDialogStyle)),
                        onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                        onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                        onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                      }, [
                        createVNode(unref(ElFocusTrap), {
                          loop: "",
                          trapped: unref(visible),
                          "focus-start-el": "container",
                          onFocusAfterTrapped: unref(onOpenAutoFocus),
                          onFocusAfterReleased: unref(onCloseAutoFocus),
                          onFocusoutPrevented: unref(onFocusoutPrevented),
                          onReleaseRequested: unref(onCloseRequested)
                        }, {
                          default: withCtx(() => [
                            unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                              key: 0,
                              ref_key: "dialogContentRef",
                              ref: dialogContentRef
                            }, _ctx.$attrs, {
                              center: _ctx.center,
                              "align-center": _ctx.alignCenter,
                              "close-icon": _ctx.closeIcon,
                              draggable: unref(draggable),
                              overflow: _ctx.overflow,
                              fullscreen: _ctx.fullscreen,
                              "show-close": _ctx.showClose,
                              title: _ctx.title,
                              "aria-level": _ctx.headerAriaLevel,
                              onClose: unref(handleClose)
                            }), createSlots({
                              header: withCtx(() => [
                                !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                  key: 0,
                                  close: unref(handleClose),
                                  titleId: unref(titleId),
                                  titleClass: unref(ns).e("title")
                                }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                              ]),
                              default: withCtx(() => [
                                renderSlot(_ctx.$slots, "default")
                              ]),
                              _: 2
                            }, [
                              _ctx.$slots.footer ? {
                                name: "footer",
                                fn: withCtx(() => [
                                  renderSlot(_ctx.$slots, "footer")
                                ])
                              } : void 0
                            ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : createCommentVNode("v-if", true)
                          ]),
                          _: 3
                        }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                      ], 46, _hoisted_1$b)
                    ]),
                    _: 3
                  }, 8, ["mask", "overlay-class", "z-index"]), [
                    [vShow, unref(visible)]
                  ])
                ]),
                _: 3
              }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
            ], 8, ["to", "disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__file", "dialog.vue"]]);
      const ElDialog = withInstall(Dialog);
      const dividerProps = buildProps({
        direction: {
          type: String,
          values: ["horizontal", "vertical"],
          default: "horizontal"
        },
        contentPosition: {
          type: String,
          values: ["left", "center", "right"],
          default: "center"
        },
        borderStyle: {
          type: definePropType(String),
          default: "solid"
        }
      });
      const __default__$6 = /* @__PURE__ */ defineComponent({
        name: "ElDivider"
      });
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: dividerProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("divider");
          const dividerStyle = computed(() => {
            return ns.cssVar({
              "border-style": props.borderStyle
            });
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.direction)]),
              style: normalizeStyle(unref(dividerStyle)),
              role: "separator"
            }, [
              _ctx.$slots.default && _ctx.direction !== "vertical" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass([unref(ns).e("text"), unref(ns).is(_ctx.contentPosition)])
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var Divider = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__file", "divider.vue"]]);
      const ElDivider = withInstall(Divider);
      const inputNumberProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        step: {
          type: Number,
          default: 1
        },
        stepStrictly: Boolean,
        max: {
          type: Number,
          default: Number.POSITIVE_INFINITY
        },
        min: {
          type: Number,
          default: Number.NEGATIVE_INFINITY
        },
        modelValue: Number,
        readonly: Boolean,
        disabled: Boolean,
        size: useSizeProp,
        controls: {
          type: Boolean,
          default: true
        },
        controlsPosition: {
          type: String,
          default: "",
          values: ["", "right"]
        },
        valueOnClear: {
          type: [String, Number, null],
          validator: (val) => val === null || isNumber$1(val) || ["min", "max"].includes(val),
          default: null
        },
        name: String,
        label: String,
        placeholder: String,
        precision: {
          type: Number,
          validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const inputNumberEmits = {
        [CHANGE_EVENT]: (cur, prev) => prev !== cur,
        blur: (e) => e instanceof FocusEvent,
        focus: (e) => e instanceof FocusEvent,
        [INPUT_EVENT]: (val) => isNumber$1(val) || isNil(val),
        [UPDATE_MODEL_EVENT]: (val) => isNumber$1(val) || isNil(val)
      };
      const _hoisted_1$a = ["aria-label", "onKeydown"];
      const _hoisted_2$7 = ["aria-label", "onKeydown"];
      const __default__$5 = /* @__PURE__ */ defineComponent({
        name: "ElInputNumber"
      });
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: inputNumberProps,
        emits: inputNumberEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          const { t: t2 } = useLocale();
          const ns = useNamespace("input-number");
          const input = ref();
          const data = reactive({
            currentValue: props.modelValue,
            userInput: null
          });
          const { formItem } = useFormItem();
          const minDisabled = computed(() => isNumber$1(props.modelValue) && props.modelValue <= props.min);
          const maxDisabled = computed(() => isNumber$1(props.modelValue) && props.modelValue >= props.max);
          const numPrecision = computed(() => {
            const stepPrecision = getPrecision(props.step);
            if (!isUndefined(props.precision)) {
              if (stepPrecision > props.precision)
                ;
              return props.precision;
            } else {
              return Math.max(getPrecision(props.modelValue), stepPrecision);
            }
          });
          const controlsAtRight = computed(() => {
            return props.controls && props.controlsPosition === "right";
          });
          const inputNumberSize = useFormSize();
          const inputNumberDisabled = useFormDisabled();
          const displayValue = computed(() => {
            if (data.userInput !== null) {
              return data.userInput;
            }
            let currentValue = data.currentValue;
            if (isNil(currentValue))
              return "";
            if (isNumber$1(currentValue)) {
              if (Number.isNaN(currentValue))
                return "";
              if (!isUndefined(props.precision)) {
                currentValue = currentValue.toFixed(props.precision);
              }
            }
            return currentValue;
          });
          const toPrecision = (num, pre) => {
            if (isUndefined(pre))
              pre = numPrecision.value;
            if (pre === 0)
              return Math.round(num);
            let snum = String(num);
            const pointPos = snum.indexOf(".");
            if (pointPos === -1)
              return num;
            const nums = snum.replace(".", "").split("");
            const datum = nums[pointPos + pre];
            if (!datum)
              return num;
            const length = snum.length;
            if (snum.charAt(length - 1) === "5") {
              snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
            }
            return Number.parseFloat(Number(snum).toFixed(pre));
          };
          const getPrecision = (value) => {
            if (isNil(value))
              return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) {
              precision = valueString.length - dotPosition - 1;
            }
            return precision;
          };
          const ensurePrecision = (val, coefficient = 1) => {
            if (!isNumber$1(val))
              return data.currentValue;
            return toPrecision(val + props.step * coefficient);
          };
          const increase = () => {
            if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value);
            setCurrentValue(newVal);
            emit2(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const decrease = () => {
            if (props.readonly || inputNumberDisabled.value || minDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value, -1);
            setCurrentValue(newVal);
            emit2(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const verifyValue = (value, update) => {
            const { max, min, step, precision, stepStrictly, valueOnClear } = props;
            if (max < min) {
              throwError("InputNumber", "min should not be greater than max.");
            }
            let newVal = Number(value);
            if (isNil(value) || Number.isNaN(newVal)) {
              return null;
            }
            if (value === "") {
              if (valueOnClear === null) {
                return null;
              }
              newVal = isString$3(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
            }
            if (stepStrictly) {
              newVal = toPrecision(Math.round(newVal / step) * step, precision);
            }
            if (!isUndefined(precision)) {
              newVal = toPrecision(newVal, precision);
            }
            if (newVal > max || newVal < min) {
              newVal = newVal > max ? max : min;
              update && emit2(UPDATE_MODEL_EVENT, newVal);
            }
            return newVal;
          };
          const setCurrentValue = (value, emitChange = true) => {
            var _a2;
            const oldVal = data.currentValue;
            const newVal = verifyValue(value);
            if (!emitChange) {
              emit2(UPDATE_MODEL_EVENT, newVal);
              return;
            }
            if (oldVal === newVal && value)
              return;
            data.userInput = null;
            emit2(UPDATE_MODEL_EVENT, newVal);
            if (oldVal !== newVal) {
              emit2(CHANGE_EVENT, newVal, oldVal);
            }
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
            }
            data.currentValue = newVal;
          };
          const handleInput = (value) => {
            data.userInput = value;
            const newVal = value === "" ? null : Number(value);
            emit2(INPUT_EVENT, newVal);
            setCurrentValue(newVal, false);
          };
          const handleInputChange = (value) => {
            const newVal = value !== "" ? Number(value) : "";
            if (isNumber$1(newVal) && !Number.isNaN(newVal) || value === "") {
              setCurrentValue(newVal);
            }
            setCurrentValueToModelValue();
            data.userInput = null;
          };
          const focus = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          };
          const blur = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
          };
          const handleFocus = (event) => {
            emit2("focus", event);
          };
          const handleBlur = (event) => {
            var _a2;
            data.userInput = null;
            emit2("blur", event);
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
            }
          };
          const setCurrentValueToModelValue = () => {
            if (data.currentValue !== props.modelValue) {
              data.currentValue = props.modelValue;
            }
          };
          const handleWheel = (e) => {
            if (document.activeElement === e.target)
              e.preventDefault();
          };
          watch(() => props.modelValue, (value, oldValue) => {
            const newValue = verifyValue(value, true);
            if (data.userInput === null && newValue !== oldValue) {
              data.currentValue = newValue;
            }
          }, { immediate: true });
          onMounted(() => {
            var _a2;
            const { min, max, modelValue } = props;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput.setAttribute("role", "spinbutton");
            if (Number.isFinite(max)) {
              innerInput.setAttribute("aria-valuemax", String(max));
            } else {
              innerInput.removeAttribute("aria-valuemax");
            }
            if (Number.isFinite(min)) {
              innerInput.setAttribute("aria-valuemin", String(min));
            } else {
              innerInput.removeAttribute("aria-valuemin");
            }
            innerInput.setAttribute("aria-valuenow", data.currentValue || data.currentValue === 0 ? String(data.currentValue) : "");
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!isNumber$1(modelValue) && modelValue != null) {
              let val = Number(modelValue);
              if (Number.isNaN(val)) {
                val = null;
              }
              emit2(UPDATE_MODEL_EVENT, val);
            }
          });
          onUpdated(() => {
            var _a2, _b;
            const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
            innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${(_b = data.currentValue) != null ? _b : ""}`);
          });
          expose2({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(unref(inputNumberSize)),
                unref(ns).is("disabled", unref(inputNumberDisabled)),
                unref(ns).is("without-controls", !_ctx.controls),
                unref(ns).is("controls-right", unref(controlsAtRight))
              ]),
              onDragstart: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["prevent"]))
            }, [
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 0,
                role: "button",
                "aria-label": unref(t2)("el.inputNumber.decrease"),
                class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
                onKeydown: withKeys(decrease, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "decrease-icon", {}, () => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, _hoisted_1$a)), [
                [unref(vRepeatClick), decrease]
              ]) : createCommentVNode("v-if", true),
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 1,
                role: "button",
                "aria-label": unref(t2)("el.inputNumber.increase"),
                class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
                onKeydown: withKeys(increase, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "increase-icon", {}, () => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, _hoisted_2$7)), [
                [unref(vRepeatClick), increase]
              ]) : createCommentVNode("v-if", true),
              createVNode(unref(ElInput), {
                id: _ctx.id,
                ref_key: "input",
                ref: input,
                type: "number",
                step: _ctx.step,
                "model-value": unref(displayValue),
                placeholder: _ctx.placeholder,
                readonly: _ctx.readonly,
                disabled: unref(inputNumberDisabled),
                size: unref(inputNumberSize),
                max: _ctx.max,
                min: _ctx.min,
                name: _ctx.name,
                label: _ctx.label,
                "validate-event": false,
                onWheel: handleWheel,
                onKeydown: [
                  withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                  withKeys(withModifiers(decrease, ["prevent"]), ["down"])
                ],
                onBlur: handleBlur,
                onFocus: handleFocus,
                onInput: handleInput,
                onChange: handleInputChange
              }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
            ], 34);
          };
        }
      });
      var InputNumber = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__file", "input-number.vue"]]);
      const ElInputNumber = withInstall(InputNumber);
      const selectGroupKey = Symbol("ElSelectGroup");
      const selectKey = Symbol("ElSelect");
      function useOption(props, states) {
        const select = inject(selectKey);
        const selectGroup = inject(selectGroupKey, { disabled: false });
        const itemSelected = computed(() => {
          if (select.props.multiple) {
            return contains(select.props.modelValue, props.value);
          } else {
            return contains([select.props.modelValue], props.value);
          }
        });
        const limitReached = computed(() => {
          if (select.props.multiple) {
            const modelValue = select.props.modelValue || [];
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
          } else {
            return false;
          }
        });
        const currentLabel = computed(() => {
          return props.label || (isObject$5(props.value) ? "" : props.value);
        });
        const currentValue = computed(() => {
          return props.value || props.label || "";
        });
        const isDisabled = computed(() => {
          return props.disabled || states.groupDisabled || limitReached.value;
        });
        const instance = getCurrentInstance();
        const contains = (arr = [], target) => {
          if (!isObject$5(props.value)) {
            return arr && arr.includes(target);
          } else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item) => {
              return toRaw(get(item, valueKey)) === get(target, valueKey);
            });
          }
        };
        const hoverItem = () => {
          if (!props.disabled && !selectGroup.disabled) {
            select.states.hoveringIndex = select.optionsArray.indexOf(instance.proxy);
          }
        };
        const updateOption = (query) => {
          const regexp = new RegExp(escapeStringRegexp(query), "i");
          states.visible = regexp.test(currentLabel.value) || props.created;
        };
        watch(() => currentLabel.value, () => {
          if (!props.created && !select.props.remote)
            select.setSelected();
        });
        watch(() => props.value, (val, oldVal) => {
          const { remote, valueKey } = select.props;
          if (!isEqual(val, oldVal)) {
            select.onOptionDestroy(oldVal, instance.proxy);
            select.onOptionCreate(instance.proxy);
          }
          if (!props.created && !remote) {
            if (valueKey && isObject$5(val) && isObject$5(oldVal) && val[valueKey] === oldVal[valueKey]) {
              return;
            }
            select.setSelected();
          }
        });
        watch(() => selectGroup.disabled, () => {
          states.groupDisabled = selectGroup.disabled;
        }, { immediate: true });
        return {
          select,
          currentLabel,
          currentValue,
          itemSelected,
          isDisabled,
          hoverItem,
          updateOption
        };
      }
      const _sfc_main$d = /* @__PURE__ */ defineComponent({
        name: "ElOption",
        componentName: "ElOption",
        props: {
          value: {
            required: true,
            type: [String, Number, Boolean, Object]
          },
          label: [String, Number],
          created: Boolean,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const id = useId();
          const containerKls = computed(() => [
            ns.be("dropdown", "item"),
            ns.is("disabled", unref(isDisabled)),
            ns.is("selected", unref(itemSelected)),
            ns.is("hovering", unref(hover))
          ]);
          const states = reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hover: false
          });
          const {
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption
          } = useOption(props, states);
          const { visible, hover } = toRefs(states);
          const vm = getCurrentInstance().proxy;
          select.onOptionCreate(vm);
          onBeforeUnmount(() => {
            const key = vm.value;
            const { selected } = select.states;
            const selectedOptions = select.props.multiple ? selected : [selected];
            const doesSelected = selectedOptions.some((item) => {
              return item.value === vm.value;
            });
            nextTick(() => {
              if (select.states.cachedOptions.get(key) === vm && !doesSelected) {
                select.states.cachedOptions.delete(key);
              }
            });
            select.onOptionDestroy(key, vm);
          });
          function selectOptionClick() {
            if (props.disabled !== true && states.groupDisabled !== true) {
              select.handleOptionSelect(vm);
            }
          }
          return {
            ns,
            id,
            containerKls,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption,
            visible,
            hover,
            selectOptionClick,
            states
          };
        }
      });
      const _hoisted_1$9 = ["id", "aria-disabled", "aria-selected"];
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("li", {
          id: _ctx.id,
          class: normalizeClass(_ctx.containerKls),
          role: "option",
          "aria-disabled": _ctx.isDisabled || void 0,
          "aria-selected": _ctx.itemSelected,
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createBaseVNode("span", null, toDisplayString$1(_ctx.currentLabel), 1)
          ])
        ], 42, _hoisted_1$9)), [
          [vShow, _ctx.visible]
        ]);
      }
      var Option = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$5], ["__file", "option.vue"]]);
      const _sfc_main$c = /* @__PURE__ */ defineComponent({
        name: "ElSelectDropdown",
        componentName: "ElSelectDropdown",
        setup() {
          const select = inject(selectKey);
          const ns = useNamespace("select");
          const popperClass = computed(() => select.props.popperClass);
          const isMultiple = computed(() => select.props.multiple);
          const isFitInputWidth = computed(() => select.props.fitInputWidth);
          const minWidth = ref("");
          function updateMinWidth() {
            var _a2;
            minWidth.value = `${(_a2 = select.selectRef) == null ? void 0 : _a2.offsetWidth}px`;
          }
          onMounted(() => {
            updateMinWidth();
            useResizeObserver(select.selectRef, updateMinWidth);
          });
          return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
          };
        }
      });
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
          style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
        }, [
          _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.ns.be("dropdown", "header"))
          }, [
            renderSlot(_ctx.$slots, "header")
          ], 2)) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default"),
          _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(_ctx.ns.be("dropdown", "footer"))
          }, [
            renderSlot(_ctx.$slots, "footer")
          ], 2)) : createCommentVNode("v-if", true)
        ], 6);
      }
      var ElSelectMenu = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$4], ["__file", "select-dropdown.vue"]]);
      function useInput(handleInput) {
        const isComposing = ref(false);
        const handleCompositionStart = () => {
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          const text = event.target.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          if (isComposing.value) {
            isComposing.value = false;
            if (isFunction$2(handleInput)) {
              handleInput(event);
            }
          }
        };
        return {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      const MINIMUM_INPUT_WIDTH = 11;
      const useSelect = (props, emit2) => {
        const { t: t2 } = useLocale();
        const contentId = useId();
        const nsSelect = useNamespace("select");
        const nsInput = useNamespace("input");
        const states = reactive({
          inputValue: "",
          options: /* @__PURE__ */ new Map(),
          cachedOptions: /* @__PURE__ */ new Map(),
          disabledOptions: /* @__PURE__ */ new Map(),
          optionValues: [],
          selected: props.multiple ? [] : {},
          selectionWidth: 0,
          calculatorWidth: 0,
          collapseItemWidth: 0,
          selectedLabel: "",
          hoveringIndex: -1,
          previousQuery: null,
          inputHovering: false,
          menuVisibleOnFocus: false,
          isBeforeHide: false
        });
        const selectRef = ref(null);
        const selectionRef = ref(null);
        const tooltipRef = ref(null);
        const tagTooltipRef = ref(null);
        const inputRef = ref(null);
        const calculatorRef = ref(null);
        const prefixRef = ref(null);
        const suffixRef = ref(null);
        const menuRef = ref(null);
        const tagMenuRef = ref(null);
        const collapseItemRef = ref(null);
        const scrollbarRef = ref(null);
        const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(inputRef, {
          afterFocus() {
            if (props.automaticDropdown && !expanded.value) {
              expanded.value = true;
              states.menuVisibleOnFocus = true;
            }
          },
          beforeBlur(event) {
            var _a2, _b;
            return ((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
          },
          afterBlur() {
            expanded.value = false;
            states.menuVisibleOnFocus = false;
          }
        });
        const expanded = ref(false);
        const hoverOption = ref();
        const { form, formItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const { valueOnClear, isEmptyValue: isEmptyValue2 } = useEmptyValues(props);
        const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
        const hasModelValue = computed(() => {
          return props.multiple ? isArray$2(props.modelValue) && props.modelValue.length > 0 : !isEmptyValue2(props.modelValue);
        });
        const showClose = computed(() => {
          return props.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
        });
        const iconComponent = computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
        const iconReverse = computed(() => nsSelect.is("reverse", iconComponent.value && expanded.value));
        const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
        const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
        const debounce$1 = computed(() => props.remote ? 300 : 0);
        const emptyText = computed(() => {
          if (props.loading) {
            return props.loadingText || t2("el.select.loading");
          } else {
            if (props.remote && !states.inputValue && states.options.size === 0)
              return false;
            if (props.filterable && states.inputValue && states.options.size > 0 && filteredOptionsCount.value === 0) {
              return props.noMatchText || t2("el.select.noMatch");
            }
            if (states.options.size === 0) {
              return props.noDataText || t2("el.select.noData");
            }
          }
          return null;
        });
        const filteredOptionsCount = computed(() => optionsArray.value.filter((option) => option.visible).length);
        const optionsArray = computed(() => {
          const list = Array.from(states.options.values());
          const newList = [];
          states.optionValues.forEach((item) => {
            const index = list.findIndex((i) => i.value === item);
            if (index > -1) {
              newList.push(list[index]);
            }
          });
          return newList.length >= list.length ? newList : list;
        });
        const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
        const showNewOption = computed(() => {
          const hasExistingOption = optionsArray.value.filter((option) => {
            return !option.created;
          }).some((option) => {
            return option.currentLabel === states.inputValue;
          });
          return props.filterable && props.allowCreate && states.inputValue !== "" && !hasExistingOption;
        });
        const updateOptions = () => {
          if (props.filterable && isFunction$2(props.filterMethod))
            return;
          if (props.filterable && props.remote && isFunction$2(props.remoteMethod))
            return;
          optionsArray.value.forEach((option) => {
            var _a2;
            (_a2 = option.updateOption) == null ? void 0 : _a2.call(option, states.inputValue);
          });
        };
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
        const dropdownMenuVisible = computed({
          get() {
            return expanded.value && emptyText.value !== false;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const shouldShowPlaceholder = computed(() => {
          if (isArray$2(props.modelValue)) {
            return props.modelValue.length === 0 && !states.inputValue;
          }
          return props.filterable ? !states.inputValue : true;
        });
        const currentPlaceholder = computed(() => {
          var _a2;
          const _placeholder = (_a2 = props.placeholder) != null ? _a2 : t2("el.select.placeholder");
          return props.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
        });
        watch(() => props.modelValue, (val, oldVal) => {
          if (props.multiple) {
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
              handleQueryChange("");
            }
          }
          setSelected();
          if (!isEqual(val, oldVal) && props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        }, {
          flush: "post",
          deep: true
        });
        watch(() => expanded.value, (val) => {
          if (val) {
            handleQueryChange(states.inputValue);
          } else {
            states.inputValue = "";
            states.previousQuery = null;
            states.isBeforeHide = true;
          }
          emit2("visible-change", val);
        });
        watch(() => states.options.entries(), () => {
          var _a2;
          if (!isClient$1)
            return;
          const inputs = ((_a2 = selectRef.value) == null ? void 0 : _a2.querySelectorAll("input")) || [];
          if (!props.filterable && !props.defaultFirstOption && !isUndefined(props.modelValue) || !Array.from(inputs).includes(document.activeElement)) {
            setSelected();
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            checkDefaultFirstOption();
          }
        }, {
          flush: "post"
        });
        watch(() => states.hoveringIndex, (val) => {
          if (isNumber$1(val) && val > -1) {
            hoverOption.value = optionsArray.value[val] || {};
          } else {
            hoverOption.value = {};
          }
          optionsArray.value.forEach((option) => {
            option.hover = hoverOption.value === option;
          });
        });
        watchEffect(() => {
          if (states.isBeforeHide)
            return;
          updateOptions();
        });
        const handleQueryChange = (val) => {
          if (states.previousQuery === val) {
            return;
          }
          states.previousQuery = val;
          if (props.filterable && isFunction$2(props.filterMethod)) {
            props.filterMethod(val);
          } else if (props.filterable && props.remote && isFunction$2(props.remoteMethod)) {
            props.remoteMethod(val);
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            nextTick(checkDefaultFirstOption);
          } else {
            nextTick(updateHoveringIndex);
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
          const userCreatedOption = optionsInDropdown.find((n) => n.created);
          const firstOriginOption = optionsInDropdown[0];
          states.hoveringIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
        };
        const setSelected = () => {
          if (!props.multiple) {
            const option = getOption(props.modelValue);
            states.selectedLabel = option.currentLabel;
            states.selected = option;
            return;
          } else {
            states.selectedLabel = "";
          }
          const result = [];
          if (isArray$2(props.modelValue)) {
            props.modelValue.forEach((value) => {
              result.push(getOption(value));
            });
          }
          states.selected = result;
        };
        const getOption = (value) => {
          let option;
          const isObjectValue = toRawType(value).toLowerCase() === "object";
          const isNull = toRawType(value).toLowerCase() === "null";
          const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
          for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
            const cachedOption = cachedOptionsArray.value[i];
            const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
            if (isEqualValue) {
              option = {
                value,
                currentLabel: cachedOption.currentLabel,
                isDisabled: cachedOption.isDisabled
              };
              break;
            }
          }
          if (option)
            return option;
          const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
          const newOption = {
            value,
            currentLabel: label
          };
          return newOption;
        };
        const updateHoveringIndex = () => {
          if (!props.multiple) {
            states.hoveringIndex = optionsArray.value.findIndex((item) => {
              return getValueKey(item) === getValueKey(states.selected);
            });
          } else {
            states.hoveringIndex = optionsArray.value.findIndex((item) => states.selected.some((selected) => getValueKey(selected) === getValueKey(item)));
          }
        };
        const resetSelectionWidth = () => {
          states.selectionWidth = selectionRef.value.getBoundingClientRect().width;
        };
        const resetCalculatorWidth = () => {
          states.calculatorWidth = calculatorRef.value.getBoundingClientRect().width;
        };
        const resetCollapseItemWidth = () => {
          states.collapseItemWidth = collapseItemRef.value.getBoundingClientRect().width;
        };
        const updateTooltip = () => {
          var _a2, _b;
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        const updateTagTooltip = () => {
          var _a2, _b;
          (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        const onInputChange = () => {
          if (states.inputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          handleQueryChange(states.inputValue);
        };
        const onInput = (event) => {
          states.inputValue = event.target.value;
          if (props.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const debouncedOnInputChange = debounce(() => {
          onInputChange();
        }, debounce$1.value);
        const emitChange = (val) => {
          if (!isEqual(props.modelValue, val)) {
            emit2(CHANGE_EVENT, val);
          }
        };
        const getLastNotDisabledIndex = (value) => findLastIndex(value, (it2) => !states.disabledOptions.has(it2));
        const deletePrevTag = (e) => {
          if (!props.multiple)
            return;
          if (e.code === EVENT_CODE.delete)
            return;
          if (e.target.value.length <= 0) {
            const value = props.modelValue.slice();
            const lastNotDisabledIndex = getLastNotDisabledIndex(value);
            if (lastNotDisabledIndex < 0)
              return;
            value.splice(lastNotDisabledIndex, 1);
            emit2(UPDATE_MODEL_EVENT, value);
            emitChange(value);
          }
        };
        const deleteTag = (event, tag) => {
          const index = states.selected.indexOf(tag);
          if (index > -1 && !selectDisabled.value) {
            const value = props.modelValue.slice();
            value.splice(index, 1);
            emit2(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            emit2("remove-tag", tag.value);
          }
          event.stopPropagation();
          focus();
        };
        const deleteSelected = (event) => {
          event.stopPropagation();
          const value = props.multiple ? [] : valueOnClear.value;
          if (props.multiple) {
            for (const item of states.selected) {
              if (item.isDisabled)
                value.push(item.value);
            }
          }
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          states.hoveringIndex = -1;
          expanded.value = false;
          emit2("clear");
          focus();
        };
        const handleOptionSelect = (option) => {
          if (props.multiple) {
            const value = (props.modelValue || []).slice();
            const optionIndex = getValueIndex(value, option.value);
            if (optionIndex > -1) {
              value.splice(optionIndex, 1);
            } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
              value.push(option.value);
            }
            emit2(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
              handleQueryChange("");
            }
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
            }
          } else {
            emit2(UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            expanded.value = false;
          }
          focus();
          if (expanded.value)
            return;
          nextTick(() => {
            scrollToOption(option);
          });
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$5(value))
            return arr.indexOf(value);
          const valueKey = props.valueKey;
          let index = -1;
          arr.some((item, i) => {
            if (toRaw(get(item, valueKey)) === get(value, valueKey)) {
              index = i;
              return true;
            }
            return false;
          });
          return index;
        };
        const scrollToOption = (option) => {
          var _a2, _b, _c, _d, _e;
          const targetOption = isArray$2(option) ? option[0] : option;
          let target = null;
          if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item) => item.value === targetOption.value);
            if (options.length > 0) {
              target = options[0].$el;
            }
          }
          if (tooltipRef.value && target) {
            const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${nsSelect.be("dropdown", "wrap")}`);
            if (menu) {
              scrollIntoView(menu, target);
            }
          }
          (_e = scrollbarRef.value) == null ? void 0 : _e.handleScroll();
        };
        const onOptionCreate = (vm) => {
          states.options.set(vm.value, vm);
          states.cachedOptions.set(vm.value, vm);
          vm.disabled && states.disabledOptions.set(vm.value, vm);
        };
        const onOptionDestroy = (key, vm) => {
          if (states.options.get(key) === vm) {
            states.options.delete(key);
          }
        };
        const {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useInput((e) => onInput(e));
        const popperRef = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        const handleMenuEnter = () => {
          states.isBeforeHide = false;
          nextTick(() => scrollToOption(states.selected));
        };
        const focus = () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        };
        const blur = () => {
          handleClickOutside();
        };
        const handleClearClick = (event) => {
          deleteSelected(event);
        };
        const handleClickOutside = (event) => {
          expanded.value = false;
          if (isFocused.value) {
            const _event2 = new FocusEvent("focus", event);
            nextTick(() => handleBlur(_event2));
          }
        };
        const handleEsc = () => {
          if (states.inputValue.length > 0) {
            states.inputValue = "";
          } else {
            expanded.value = false;
          }
        };
        const toggleMenu = () => {
          if (selectDisabled.value)
            return;
          if (states.menuVisibleOnFocus) {
            states.menuVisibleOnFocus = false;
          } else {
            expanded.value = !expanded.value;
          }
        };
        const selectOption = () => {
          if (!expanded.value) {
            toggleMenu();
          } else {
            if (optionsArray.value[states.hoveringIndex]) {
              handleOptionSelect(optionsArray.value[states.hoveringIndex]);
            }
          }
        };
        const getValueKey = (item) => {
          return isObject$5(item.value) ? get(item.value, props.valueKey) : item.value;
        };
        const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
        const showTagList = computed(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(0, props.maxCollapseTags) : states.selected;
        });
        const collapseTagList = computed(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(props.maxCollapseTags) : [];
        });
        const navigateOptions = (direction) => {
          if (!expanded.value) {
            expanded.value = true;
            return;
          }
          if (states.options.size === 0 || filteredOptionsCount.value === 0)
            return;
          if (!optionsAllDisabled.value) {
            if (direction === "next") {
              states.hoveringIndex++;
              if (states.hoveringIndex === states.options.size) {
                states.hoveringIndex = 0;
              }
            } else if (direction === "prev") {
              states.hoveringIndex--;
              if (states.hoveringIndex < 0) {
                states.hoveringIndex = states.options.size - 1;
              }
            }
            const option = optionsArray.value[states.hoveringIndex];
            if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
              navigateOptions(direction);
            }
            nextTick(() => scrollToOption(hoverOption.value));
          }
        };
        const getGapWidth = () => {
          if (!selectionRef.value)
            return 0;
          const style = window.getComputedStyle(selectionRef.value);
          return Number.parseFloat(style.gap || "6px");
        };
        const tagStyle = computed(() => {
          const gapWidth = getGapWidth();
          const maxWidth = collapseItemRef.value && props.maxCollapseTags === 1 ? states.selectionWidth - states.collapseItemWidth - gapWidth : states.selectionWidth;
          return { maxWidth: `${maxWidth}px` };
        });
        const collapseTagStyle = computed(() => {
          return { maxWidth: `${states.selectionWidth}px` };
        });
        const inputStyle = computed(() => ({
          width: `${Math.max(states.calculatorWidth, MINIMUM_INPUT_WIDTH)}px`
        }));
        if (props.multiple && !isArray$2(props.modelValue)) {
          emit2(UPDATE_MODEL_EVENT, []);
        }
        if (!props.multiple && isArray$2(props.modelValue)) {
          emit2(UPDATE_MODEL_EVENT, "");
        }
        useResizeObserver(selectionRef, resetSelectionWidth);
        useResizeObserver(calculatorRef, resetCalculatorWidth);
        useResizeObserver(menuRef, updateTooltip);
        useResizeObserver(wrapperRef, updateTooltip);
        useResizeObserver(tagMenuRef, updateTagTooltip);
        useResizeObserver(collapseItemRef, resetCollapseItemWidth);
        onMounted(() => {
          setSelected();
        });
        return {
          inputId,
          contentId,
          nsSelect,
          nsInput,
          states,
          isFocused,
          expanded,
          optionsArray,
          hoverOption,
          selectSize,
          filteredOptionsCount,
          resetCalculatorWidth,
          updateTooltip,
          updateTagTooltip,
          debouncedOnInputChange,
          onInput,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          hasModelValue,
          shouldShowPlaceholder,
          currentPlaceholder,
          showClose,
          iconComponent,
          iconReverse,
          validateState,
          validateIcon,
          showNewOption,
          updateOptions,
          collapseTagSize,
          setSelected,
          selectDisabled,
          emptyText,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          handleFocus,
          focus,
          blur,
          handleBlur,
          handleClearClick,
          handleClickOutside,
          handleEsc,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          dropdownMenuVisible,
          showTagList,
          collapseTagList,
          tagStyle,
          collapseTagStyle,
          inputStyle,
          popperRef,
          inputRef,
          tooltipRef,
          tagTooltipRef,
          calculatorRef,
          prefixRef,
          suffixRef,
          selectRef,
          wrapperRef,
          selectionRef,
          scrollbarRef,
          menuRef,
          tagMenuRef,
          collapseItemRef
        };
      };
      var ElOptions = /* @__PURE__ */ defineComponent({
        name: "ElOptions",
        setup(_2, { slots }) {
          const select = inject(selectKey);
          let cachedValueList = [];
          return () => {
            var _a2, _b;
            const children = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
            const valueList = [];
            function filterOptions(children2) {
              if (!isArray$2(children2))
                return;
              children2.forEach((item) => {
                var _a22, _b2, _c, _d;
                const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
                if (name === "ElOptionGroup") {
                  filterOptions(!isString$3(item.children) && !isArray$2(item.children) && isFunction$2((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
                } else if (name === "ElOption") {
                  valueList.push((_d = item.props) == null ? void 0 : _d.value);
                } else if (isArray$2(item.children)) {
                  filterOptions(item.children);
                }
              });
            }
            if (children.length) {
              filterOptions((_b = children[0]) == null ? void 0 : _b.children);
            }
            if (!isEqual(valueList, cachedValueList)) {
              cachedValueList = valueList;
              if (select) {
                select.states.optionValues = valueList;
              }
            }
            return children;
          };
        }
      });
      const SelectProps = buildProps({
        name: String,
        id: String,
        modelValue: {
          type: [Array, String, Number, Boolean, Object],
          default: void 0
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        automaticDropdown: Boolean,
        size: useSizeProp,
        effect: {
          type: definePropType(String),
          default: "light"
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        allowCreate: Boolean,
        loading: Boolean,
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        remote: Boolean,
        loadingText: String,
        noMatchText: String,
        noDataText: String,
        remoteMethod: Function,
        filterMethod: Function,
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        placeholder: {
          type: String
        },
        defaultFirstOption: Boolean,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        valueKey: {
          type: String,
          default: "value"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: Boolean,
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: iconPropType,
          default: circle_close_default
        },
        fitInputWidth: Boolean,
        suffixIcon: {
          type: iconPropType,
          default: arrow_down_default
        },
        tagType: { ...tagProps.type, default: "info" },
        validateEvent: {
          type: Boolean,
          default: true
        },
        remoteShowSuffix: Boolean,
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: ["bottom-start", "top-start", "right", "left"]
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        ...useEmptyValuesProps
      });
      const COMPONENT_NAME$1 = "ElSelect";
      const _sfc_main$b = /* @__PURE__ */ defineComponent({
        name: COMPONENT_NAME$1,
        componentName: COMPONENT_NAME$1,
        components: {
          ElInput,
          ElSelectMenu,
          ElOption: Option,
          ElOptions,
          ElTag,
          ElScrollbar,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: SelectProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props, { emit: emit2 }) {
          const API = useSelect(props, emit2);
          provide(selectKey, reactive({
            props,
            states: API.states,
            optionsArray: API.optionsArray,
            handleOptionSelect: API.handleOptionSelect,
            onOptionCreate: API.onOptionCreate,
            onOptionDestroy: API.onOptionDestroy,
            selectRef: API.selectRef,
            setSelected: API.setSelected
          }));
          return {
            ...API
          };
        }
      });
      const _hoisted_1$8 = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"];
      const _hoisted_2$6 = ["textContent"];
      function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_option = resolveComponent("el-option");
        const _component_el_options = resolveComponent("el-options");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectRef",
          class: normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
          onMouseenter: _cache[16] || (_cache[16] = ($event) => _ctx.states.inputHovering = true),
          onMouseleave: _cache[17] || (_cache[17] = ($event) => _ctx.states.inputHovering = false),
          onClick: _cache[18] || (_cache[18] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["prevent", "stop"]))
        }, [
          createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropdownMenuVisible,
            placement: _ctx.placement,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "popper-options": _ctx.popperOptions,
            "fallback-placements": _ctx.fallbackPlacements,
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: _ctx.persistent,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: _cache[15] || (_cache[15] = ($event) => _ctx.states.isBeforeHide = false)
          }, {
            default: withCtx(() => {
              var _a2;
              return [
                createBaseVNode("div", {
                  ref: "wrapperRef",
                  class: normalizeClass([
                    _ctx.nsSelect.e("wrapper"),
                    _ctx.nsSelect.is("focused", _ctx.isFocused),
                    _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                    _ctx.nsSelect.is("filterable", _ctx.filterable),
                    _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                  ])
                }, [
                  _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "prefixRef",
                    class: normalizeClass(_ctx.nsSelect.e("prefix"))
                  }, [
                    renderSlot(_ctx.$slots, "prefix")
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("div", {
                    ref: "selectionRef",
                    class: normalizeClass([
                      _ctx.nsSelect.e("selection"),
                      _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.states.selected.length)
                    ])
                  }, [
                    _ctx.multiple ? renderSlot(_ctx.$slots, "tag", { key: 0 }, () => [
                      (openBlock(true), createElementBlock(Fragment$1, null, renderList(_ctx.showTagList, (item) => {
                        return openBlock(), createElementBlock("div", {
                          key: _ctx.getValueKey(item),
                          class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          createVNode(_component_el_tag, {
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            style: normalizeStyle(_ctx.tagStyle),
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, toDisplayString$1(item.currentLabel), 3)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "type", "style", "onClose"])
                        ], 2);
                      }), 128)),
                      _ctx.collapseTags && _ctx.states.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tooltip, {
                        key: 0,
                        ref: "tagTooltipRef",
                        disabled: _ctx.dropdownMenuVisible || !_ctx.collapseTagsTooltip,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: _ctx.effect,
                        placement: "bottom",
                        teleported: _ctx.teleported
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", {
                            ref: "collapseItemRef",
                            class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                          }, [
                            createVNode(_component_el_tag, {
                              closable: false,
                              size: _ctx.collapseTagSize,
                              type: _ctx.tagType,
                              "disable-transitions": "",
                              style: normalizeStyle(_ctx.collapseTagStyle)
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("span", {
                                  class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                }, " + " + toDisplayString$1(_ctx.states.selected.length - _ctx.maxCollapseTags), 3)
                              ]),
                              _: 1
                            }, 8, ["size", "type", "style"])
                          ], 2)
                        ]),
                        content: withCtx(() => [
                          createBaseVNode("div", {
                            ref: "tagMenuRef",
                            class: normalizeClass(_ctx.nsSelect.e("selection"))
                          }, [
                            (openBlock(true), createElementBlock(Fragment$1, null, renderList(_ctx.collapseTagList, (item) => {
                              return openBlock(), createElementBlock("div", {
                                key: _ctx.getValueKey(item),
                                class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                              }, [
                                createVNode(_component_el_tag, {
                                  class: "in-tooltip",
                                  closable: !_ctx.selectDisabled && !item.isDisabled,
                                  size: _ctx.collapseTagSize,
                                  type: _ctx.tagType,
                                  "disable-transitions": "",
                                  onClose: ($event) => _ctx.deleteTag($event, item)
                                }, {
                                  default: withCtx(() => [
                                    createBaseVNode("span", {
                                      class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                    }, toDisplayString$1(item.currentLabel), 3)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "type", "onClose"])
                              ], 2);
                            }), 128))
                          ], 2)
                        ]),
                        _: 1
                      }, 8, ["disabled", "effect", "teleported"])) : createCommentVNode("v-if", true)
                    ]) : createCommentVNode("v-if", true),
                    !_ctx.selectDisabled ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("input-wrapper"),
                        _ctx.nsSelect.is("hidden", !_ctx.filterable)
                      ])
                    }, [
                      withDirectives(createBaseVNode("input", {
                        id: _ctx.inputId,
                        ref: "inputRef",
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.states.inputValue = $event),
                        type: "text",
                        class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                        disabled: _ctx.selectDisabled,
                        autocomplete: _ctx.autocomplete,
                        style: normalizeStyle(_ctx.inputStyle),
                        role: "combobox",
                        readonly: !_ctx.filterable,
                        spellcheck: "false",
                        "aria-activedescendant": ((_a2 = _ctx.hoverOption) == null ? void 0 : _a2.id) || "",
                        "aria-controls": _ctx.contentId,
                        "aria-expanded": _ctx.dropdownMenuVisible,
                        "aria-label": _ctx.ariaLabel,
                        "aria-autocomplete": "none",
                        "aria-haspopup": "listbox",
                        onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                        onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                        onKeydown: [
                          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                          _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                          _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                          _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                          _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["stop"]), ["delete"]))
                        ],
                        onCompositionstart: _cache[8] || (_cache[8] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                        onCompositionupdate: _cache[9] || (_cache[9] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                        onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                        onInput: _cache[11] || (_cache[11] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                        onClick: _cache[12] || (_cache[12] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
                      }, null, 46, _hoisted_1$8), [
                        [vModelText, _ctx.states.inputValue]
                      ]),
                      _ctx.filterable ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        ref: "calculatorRef",
                        "aria-hidden": "true",
                        class: normalizeClass(_ctx.nsSelect.e("input-calculator")),
                        textContent: toDisplayString$1(_ctx.states.inputValue)
                      }, null, 10, _hoisted_2$6)) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true),
                    _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("div", {
                      key: 2,
                      class: normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("placeholder"),
                        _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                      ])
                    }, [
                      createBaseVNode("span", null, toDisplayString$1(_ctx.currentPlaceholder), 1)
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 2),
                  createBaseVNode("div", {
                    ref: "suffixRef",
                    class: normalizeClass(_ctx.nsSelect.e("suffix"))
                  }, [
                    _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                      key: 0,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 1,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                      onClick: _ctx.handleClearClick
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                    _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 2,
                      class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)
              ];
            }),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, { ref: "menuRef" }, {
                default: withCtx(() => [
                  _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "header")),
                    onClick: _cache[13] || (_cache[13] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    renderSlot(_ctx.$slots, "header")
                  ], 2)) : createCommentVNode("v-if", true),
                  withDirectives(createVNode(_component_el_scrollbar, {
                    id: _ctx.contentId,
                    ref: "scrollbarRef",
                    tag: "ul",
                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                    class: normalizeClass([_ctx.nsSelect.is("empty", _ctx.filteredOptionsCount === 0)]),
                    role: "listbox",
                    "aria-label": _ctx.ariaLabel,
                    "aria-orientation": "vertical"
                  }, {
                    default: withCtx(() => [
                      _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                        key: 0,
                        value: _ctx.states.inputValue,
                        created: true
                      }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                      createVNode(_component_el_options, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
                    [vShow, _ctx.states.options.size > 0 && !_ctx.loading]
                  ]),
                  _ctx.$slots.loading && _ctx.loading ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "loading"))
                  }, [
                    renderSlot(_ctx.$slots, "loading")
                  ], 2)) : _ctx.loading || _ctx.filteredOptionsCount === 0 ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                  }, [
                    renderSlot(_ctx.$slots, "empty", {}, () => [
                      createBaseVNode("span", null, toDisplayString$1(_ctx.emptyText), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                    key: 3,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "footer")),
                    onClick: _cache[14] || (_cache[14] = withModifiers(() => {
                    }, ["stop"]))
                  }, [
                    renderSlot(_ctx.$slots, "footer")
                  ], 2)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 512)
            ]),
            _: 3
          }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "onBeforeShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$3], ["__file", "select.vue"]]);
      const _sfc_main$a = /* @__PURE__ */ defineComponent({
        name: "ElOptionGroup",
        componentName: "ElOptionGroup",
        props: {
          label: String,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const groupRef = ref(null);
          const instance = getCurrentInstance();
          const children = ref([]);
          provide(selectGroupKey, reactive({
            ...toRefs(props)
          }));
          const visible = computed(() => children.value.some((option) => option.visible === true));
          const flattedChildren = (node) => {
            const children2 = [];
            if (isArray$2(node.children)) {
              node.children.forEach((child) => {
                var _a2, _b;
                if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                  children2.push(child.component.proxy);
                } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                  children2.push(...flattedChildren(child));
                } else if ((_b = child.component) == null ? void 0 : _b.subTree) {
                  children2.push(...flattedChildren(child.component.subTree));
                }
              });
            }
            return children2;
          };
          const updateChildren = () => {
            children.value = flattedChildren(instance.subTree);
          };
          onMounted(() => {
            updateChildren();
          });
          useMutationObserver(groupRef, updateChildren, {
            attributes: true,
            subtree: true,
            childList: true
          });
          return {
            groupRef,
            visible,
            ns
          };
        }
      });
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("ul", {
          ref: "groupRef",
          class: normalizeClass(_ctx.ns.be("group", "wrap"))
        }, [
          createBaseVNode("li", {
            class: normalizeClass(_ctx.ns.be("group", "title"))
          }, toDisplayString$1(_ctx.label), 3),
          createBaseVNode("li", null, [
            createBaseVNode("ul", {
              class: normalizeClass(_ctx.ns.b("group"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ])
        ], 2)), [
          [vShow, _ctx.visible]
        ]);
      }
      var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$2], ["__file", "option-group.vue"]]);
      const ElSelect = withInstall(Select, {
        Option,
        OptionGroup
      });
      const ElOption = withNoopInstall(Option);
      withNoopInstall(OptionGroup);
      const popconfirmProps = buildProps({
        title: String,
        confirmButtonText: String,
        cancelButtonText: String,
        confirmButtonType: {
          type: String,
          values: buttonTypes,
          default: "primary"
        },
        cancelButtonType: {
          type: String,
          values: buttonTypes,
          default: "text"
        },
        icon: {
          type: iconPropType,
          default: () => question_filled_default
        },
        iconColor: {
          type: String,
          default: "#f90"
        },
        hideIcon: {
          type: Boolean,
          default: false
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        teleported: useTooltipContentProps.teleported,
        persistent: useTooltipContentProps.persistent,
        width: {
          type: [String, Number],
          default: 150
        }
      });
      const popconfirmEmits = {
        confirm: (e) => e instanceof MouseEvent,
        cancel: (e) => e instanceof MouseEvent
      };
      const __default__$4 = /* @__PURE__ */ defineComponent({
        name: "ElPopconfirm"
      });
      const _sfc_main$9 = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: popconfirmProps,
        emits: popconfirmEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const { t: t2 } = useLocale();
          const ns = useNamespace("popconfirm");
          const tooltipRef = ref();
          const hidePopper = () => {
            var _a2, _b;
            (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.onClose) == null ? void 0 : _b.call(_a2);
          };
          const style = computed(() => {
            return {
              width: addUnit(props.width)
            };
          });
          const confirm = (e) => {
            emit2("confirm", e);
            hidePopper();
          };
          const cancel = (e) => {
            emit2("cancel", e);
            hidePopper();
          };
          const finalConfirmButtonText = computed(() => props.confirmButtonText || t2("el.popconfirm.confirmButtonText"));
          const finalCancelButtonText = computed(() => props.cancelButtonText || t2("el.popconfirm.cancelButtonText"));
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), mergeProps({
              ref_key: "tooltipRef",
              ref: tooltipRef,
              trigger: "click",
              effect: "light"
            }, _ctx.$attrs, {
              "popper-class": `${unref(ns).namespace.value}-popover`,
              "popper-style": unref(style),
              teleported: _ctx.teleported,
              "fallback-placements": ["bottom", "top", "right", "left"],
              "hide-after": _ctx.hideAfter,
              persistent: _ctx.persistent
            }), {
              content: withCtx(() => [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).b())
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("main"))
                  }, [
                    !_ctx.hideIcon && _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(ns).e("icon")),
                      style: normalizeStyle({ color: _ctx.iconColor })
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                      ]),
                      _: 1
                    }, 8, ["class", "style"])) : createCommentVNode("v-if", true),
                    createTextVNode(" " + toDisplayString$1(_ctx.title), 1)
                  ], 2),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("action"))
                  }, [
                    createVNode(unref(ElButton), {
                      size: "small",
                      type: _ctx.cancelButtonType === "text" ? "" : _ctx.cancelButtonType,
                      text: _ctx.cancelButtonType === "text",
                      onClick: cancel
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString$1(unref(finalCancelButtonText)), 1)
                      ]),
                      _: 1
                    }, 8, ["type", "text"]),
                    createVNode(unref(ElButton), {
                      size: "small",
                      type: _ctx.confirmButtonType === "text" ? "" : _ctx.confirmButtonType,
                      text: _ctx.confirmButtonType === "text",
                      onClick: confirm
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString$1(unref(finalConfirmButtonText)), 1)
                      ]),
                      _: 1
                    }, 8, ["type", "text"])
                  ], 2)
                ], 2)
              ]),
              default: withCtx(() => [
                _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]);
          };
        }
      });
      var Popconfirm = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__file", "popconfirm.vue"]]);
      const ElPopconfirm = withInstall(Popconfirm);
      const sliderContextKey = Symbol("sliderContextKey");
      const sliderProps = buildProps({
        modelValue: {
          type: definePropType([Number, Array]),
          default: 0
        },
        id: {
          type: String,
          default: void 0
        },
        min: {
          type: Number,
          default: 0
        },
        max: {
          type: Number,
          default: 100
        },
        step: {
          type: Number,
          default: 1
        },
        showInput: Boolean,
        showInputControls: {
          type: Boolean,
          default: true
        },
        size: useSizeProp,
        inputSize: useSizeProp,
        showStops: Boolean,
        showTooltip: {
          type: Boolean,
          default: true
        },
        formatTooltip: {
          type: definePropType(Function),
          default: void 0
        },
        disabled: Boolean,
        range: Boolean,
        vertical: Boolean,
        height: String,
        debounce: {
          type: Number,
          default: 300
        },
        label: {
          type: String,
          default: void 0
        },
        rangeStartLabel: {
          type: String,
          default: void 0
        },
        rangeEndLabel: {
          type: String,
          default: void 0
        },
        formatValueText: {
          type: definePropType(Function),
          default: void 0
        },
        tooltipClass: {
          type: String,
          default: void 0
        },
        placement: {
          type: String,
          values: Ee,
          default: "top"
        },
        marks: {
          type: definePropType(Object)
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      });
      const isValidValue = (value) => isNumber$1(value) || isArray$2(value) && value.every(isNumber$1);
      const sliderEmits = {
        [UPDATE_MODEL_EVENT]: isValidValue,
        [INPUT_EVENT]: isValidValue,
        [CHANGE_EVENT]: isValidValue
      };
      const useLifecycle = (props, initData, resetSize) => {
        const sliderWrapper = ref();
        onMounted(async () => {
          if (props.range) {
            if (Array.isArray(props.modelValue)) {
              initData.firstValue = Math.max(props.min, props.modelValue[0]);
              initData.secondValue = Math.min(props.max, props.modelValue[1]);
            } else {
              initData.firstValue = props.min;
              initData.secondValue = props.max;
            }
            initData.oldValue = [initData.firstValue, initData.secondValue];
          } else {
            if (typeof props.modelValue !== "number" || Number.isNaN(props.modelValue)) {
              initData.firstValue = props.min;
            } else {
              initData.firstValue = Math.min(props.max, Math.max(props.min, props.modelValue));
            }
            initData.oldValue = initData.firstValue;
          }
          useEventListener$1(window, "resize", resetSize);
          await nextTick();
          resetSize();
        });
        return {
          sliderWrapper
        };
      };
      const useMarks = (props) => {
        return computed(() => {
          if (!props.marks) {
            return [];
          }
          const marksKeys = Object.keys(props.marks);
          return marksKeys.map(Number.parseFloat).sort((a2, b2) => a2 - b2).filter((point) => point <= props.max && point >= props.min).map((point) => ({
            point,
            position: (point - props.min) * 100 / (props.max - props.min),
            mark: props.marks[point]
          }));
        });
      };
      const useSlide = (props, initData, emit2) => {
        const { form: elForm, formItem: elFormItem } = useFormItem();
        const slider = shallowRef();
        const firstButton = ref();
        const secondButton = ref();
        const buttonRefs = {
          firstButton,
          secondButton
        };
        const sliderDisabled = computed(() => {
          return props.disabled || (elForm == null ? void 0 : elForm.disabled) || false;
        });
        const minValue = computed(() => {
          return Math.min(initData.firstValue, initData.secondValue);
        });
        const maxValue = computed(() => {
          return Math.max(initData.firstValue, initData.secondValue);
        });
        const barSize = computed(() => {
          return props.range ? `${100 * (maxValue.value - minValue.value) / (props.max - props.min)}%` : `${100 * (initData.firstValue - props.min) / (props.max - props.min)}%`;
        });
        const barStart = computed(() => {
          return props.range ? `${100 * (minValue.value - props.min) / (props.max - props.min)}%` : "0%";
        });
        const runwayStyle = computed(() => {
          return props.vertical ? { height: props.height } : {};
        });
        const barStyle = computed(() => {
          return props.vertical ? {
            height: barSize.value,
            bottom: barStart.value
          } : {
            width: barSize.value,
            left: barStart.value
          };
        });
        const resetSize = () => {
          if (slider.value) {
            initData.sliderSize = slider.value[`client${props.vertical ? "Height" : "Width"}`];
          }
        };
        const getButtonRefByPercent = (percent) => {
          const targetValue = props.min + percent * (props.max - props.min) / 100;
          if (!props.range) {
            return firstButton;
          }
          let buttonRefName;
          if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
            buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
          } else {
            buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
          }
          return buttonRefs[buttonRefName];
        };
        const setPosition = (percent) => {
          const buttonRef = getButtonRefByPercent(percent);
          buttonRef.value.setPosition(percent);
          return buttonRef;
        };
        const setFirstValue = (firstValue) => {
          initData.firstValue = firstValue;
          _emit(props.range ? [minValue.value, maxValue.value] : firstValue);
        };
        const setSecondValue = (secondValue) => {
          initData.secondValue = secondValue;
          if (props.range) {
            _emit([minValue.value, maxValue.value]);
          }
        };
        const _emit = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emit2(INPUT_EVENT, val);
        };
        const emitChange = async () => {
          await nextTick();
          emit2(CHANGE_EVENT, props.range ? [minValue.value, maxValue.value] : props.modelValue);
        };
        const handleSliderPointerEvent = (event) => {
          var _a2, _b, _c, _d, _e, _f;
          if (sliderDisabled.value || initData.dragging)
            return;
          resetSize();
          let newPercent = 0;
          if (props.vertical) {
            const clientY = (_c = (_b = (_a2 = event.touches) == null ? void 0 : _a2.item(0)) == null ? void 0 : _b.clientY) != null ? _c : event.clientY;
            const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
            newPercent = (sliderOffsetBottom - clientY) / initData.sliderSize * 100;
          } else {
            const clientX = (_f = (_e = (_d = event.touches) == null ? void 0 : _d.item(0)) == null ? void 0 : _e.clientX) != null ? _f : event.clientX;
            const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
            newPercent = (clientX - sliderOffsetLeft) / initData.sliderSize * 100;
          }
          if (newPercent < 0 || newPercent > 100)
            return;
          return setPosition(newPercent);
        };
        const onSliderWrapperPrevent = (event) => {
          var _a2, _b;
          if (((_a2 = buttonRefs["firstButton"].value) == null ? void 0 : _a2.dragging) || ((_b = buttonRefs["secondButton"].value) == null ? void 0 : _b.dragging)) {
            event.preventDefault();
          }
        };
        const onSliderDown = async (event) => {
          const buttonRef = handleSliderPointerEvent(event);
          if (buttonRef) {
            await nextTick();
            buttonRef.value.onButtonDown(event);
          }
        };
        const onSliderClick = (event) => {
          const buttonRef = handleSliderPointerEvent(event);
          if (buttonRef) {
            emitChange();
          }
        };
        return {
          elFormItem,
          slider,
          firstButton,
          secondButton,
          sliderDisabled,
          minValue,
          maxValue,
          runwayStyle,
          barStyle,
          resetSize,
          setPosition,
          emitChange,
          onSliderWrapperPrevent,
          onSliderClick,
          onSliderDown,
          setFirstValue,
          setSecondValue
        };
      };
      const { left, down, right, up, home, end, pageUp, pageDown } = EVENT_CODE;
      const useTooltip = (props, formatTooltip, showTooltip) => {
        const tooltip = ref();
        const tooltipVisible = ref(false);
        const enableFormat = computed(() => {
          return formatTooltip.value instanceof Function;
        });
        const formatValue = computed(() => {
          return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;
        });
        const displayTooltip = debounce(() => {
          showTooltip.value && (tooltipVisible.value = true);
        }, 50);
        const hideTooltip = debounce(() => {
          showTooltip.value && (tooltipVisible.value = false);
        }, 50);
        return {
          tooltip,
          tooltipVisible,
          formatValue,
          displayTooltip,
          hideTooltip
        };
      };
      const useSliderButton = (props, initData, emit2) => {
        const {
          disabled,
          min,
          max,
          step,
          showTooltip,
          precision,
          sliderSize,
          formatTooltip,
          emitChange,
          resetSize,
          updateDragging
        } = inject(sliderContextKey);
        const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } = useTooltip(props, formatTooltip, showTooltip);
        const button = ref();
        const currentPosition = computed(() => {
          return `${(props.modelValue - min.value) / (max.value - min.value) * 100}%`;
        });
        const wrapperStyle = computed(() => {
          return props.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
        });
        const handleMouseEnter = () => {
          initData.hovering = true;
          displayTooltip();
        };
        const handleMouseLeave = () => {
          initData.hovering = false;
          if (!initData.dragging) {
            hideTooltip();
          }
        };
        const onButtonDown = (event) => {
          if (disabled.value)
            return;
          event.preventDefault();
          onDragStart(event);
          window.addEventListener("mousemove", onDragging);
          window.addEventListener("touchmove", onDragging);
          window.addEventListener("mouseup", onDragEnd);
          window.addEventListener("touchend", onDragEnd);
          window.addEventListener("contextmenu", onDragEnd);
          button.value.focus();
        };
        const incrementPosition = (amount) => {
          if (disabled.value)
            return;
          initData.newPosition = Number.parseFloat(currentPosition.value) + amount / (max.value - min.value) * 100;
          setPosition(initData.newPosition);
          emitChange();
        };
        const onLeftKeyDown = () => {
          incrementPosition(-step.value);
        };
        const onRightKeyDown = () => {
          incrementPosition(step.value);
        };
        const onPageDownKeyDown = () => {
          incrementPosition(-step.value * 4);
        };
        const onPageUpKeyDown = () => {
          incrementPosition(step.value * 4);
        };
        const onHomeKeyDown = () => {
          if (disabled.value)
            return;
          setPosition(0);
          emitChange();
        };
        const onEndKeyDown = () => {
          if (disabled.value)
            return;
          setPosition(100);
          emitChange();
        };
        const onKeyDown = (event) => {
          let isPreventDefault = true;
          if ([left, down].includes(event.key)) {
            onLeftKeyDown();
          } else if ([right, up].includes(event.key)) {
            onRightKeyDown();
          } else if (event.key === home) {
            onHomeKeyDown();
          } else if (event.key === end) {
            onEndKeyDown();
          } else if (event.key === pageDown) {
            onPageDownKeyDown();
          } else if (event.key === pageUp) {
            onPageUpKeyDown();
          } else {
            isPreventDefault = false;
          }
          isPreventDefault && event.preventDefault();
        };
        const getClientXY = (event) => {
          let clientX;
          let clientY;
          if (event.type.startsWith("touch")) {
            clientY = event.touches[0].clientY;
            clientX = event.touches[0].clientX;
          } else {
            clientY = event.clientY;
            clientX = event.clientX;
          }
          return {
            clientX,
            clientY
          };
        };
        const onDragStart = (event) => {
          initData.dragging = true;
          initData.isClick = true;
          const { clientX, clientY } = getClientXY(event);
          if (props.vertical) {
            initData.startY = clientY;
          } else {
            initData.startX = clientX;
          }
          initData.startPosition = Number.parseFloat(currentPosition.value);
          initData.newPosition = initData.startPosition;
        };
        const onDragging = (event) => {
          if (initData.dragging) {
            initData.isClick = false;
            displayTooltip();
            resetSize();
            let diff;
            const { clientX, clientY } = getClientXY(event);
            if (props.vertical) {
              initData.currentY = clientY;
              diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
            } else {
              initData.currentX = clientX;
              diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
            }
            initData.newPosition = initData.startPosition + diff;
            setPosition(initData.newPosition);
          }
        };
        const onDragEnd = () => {
          if (initData.dragging) {
            setTimeout(() => {
              initData.dragging = false;
              if (!initData.hovering) {
                hideTooltip();
              }
              if (!initData.isClick) {
                setPosition(initData.newPosition);
              }
              emitChange();
            }, 0);
            window.removeEventListener("mousemove", onDragging);
            window.removeEventListener("touchmove", onDragging);
            window.removeEventListener("mouseup", onDragEnd);
            window.removeEventListener("touchend", onDragEnd);
            window.removeEventListener("contextmenu", onDragEnd);
          }
        };
        const setPosition = async (newPosition) => {
          if (newPosition === null || Number.isNaN(+newPosition))
            return;
          if (newPosition < 0) {
            newPosition = 0;
          } else if (newPosition > 100) {
            newPosition = 100;
          }
          const lengthPerStep = 100 / ((max.value - min.value) / step.value);
          const steps = Math.round(newPosition / lengthPerStep);
          let value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;
          value = Number.parseFloat(value.toFixed(precision.value));
          if (value !== props.modelValue) {
            emit2(UPDATE_MODEL_EVENT, value);
          }
          if (!initData.dragging && props.modelValue !== initData.oldValue) {
            initData.oldValue = props.modelValue;
          }
          await nextTick();
          initData.dragging && displayTooltip();
          tooltip.value.updatePopper();
        };
        watch(() => initData.dragging, (val) => {
          updateDragging(val);
        });
        return {
          disabled,
          button,
          tooltip,
          tooltipVisible,
          showTooltip,
          wrapperStyle,
          formatValue,
          handleMouseEnter,
          handleMouseLeave,
          onButtonDown,
          onKeyDown,
          setPosition
        };
      };
      const useStops = (props, initData, minValue, maxValue) => {
        const stops = computed(() => {
          if (!props.showStops || props.min > props.max)
            return [];
          if (props.step === 0) {
            return [];
          }
          const stopCount = (props.max - props.min) / props.step;
          const stepWidth = 100 * props.step / (props.max - props.min);
          const result = Array.from({ length: stopCount - 1 }).map((_2, index) => (index + 1) * stepWidth);
          if (props.range) {
            return result.filter((step) => {
              return step < 100 * (minValue.value - props.min) / (props.max - props.min) || step > 100 * (maxValue.value - props.min) / (props.max - props.min);
            });
          } else {
            return result.filter((step) => step > 100 * (initData.firstValue - props.min) / (props.max - props.min));
          }
        });
        const getStopStyle = (position) => {
          return props.vertical ? { bottom: `${position}%` } : { left: `${position}%` };
        };
        return {
          stops,
          getStopStyle
        };
      };
      const useWatch = (props, initData, minValue, maxValue, emit2, elFormItem) => {
        const _emit = (val) => {
          emit2(UPDATE_MODEL_EVENT, val);
          emit2(INPUT_EVENT, val);
        };
        const valueChanged = () => {
          if (props.range) {
            return ![minValue.value, maxValue.value].every((item, index) => item === initData.oldValue[index]);
          } else {
            return props.modelValue !== initData.oldValue;
          }
        };
        const setValues = () => {
          var _a2, _b;
          if (props.min > props.max) {
            throwError("Slider", "min should not be greater than max.");
          }
          const val = props.modelValue;
          if (props.range && Array.isArray(val)) {
            if (val[1] < props.min) {
              _emit([props.min, props.min]);
            } else if (val[0] > props.max) {
              _emit([props.max, props.max]);
            } else if (val[0] < props.min) {
              _emit([props.min, val[1]]);
            } else if (val[1] > props.max) {
              _emit([val[0], props.max]);
            } else {
              initData.firstValue = val[0];
              initData.secondValue = val[1];
              if (valueChanged()) {
                if (props.validateEvent) {
                  (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
                }
                initData.oldValue = val.slice();
              }
            }
          } else if (!props.range && typeof val === "number" && !Number.isNaN(val)) {
            if (val < props.min) {
              _emit(props.min);
            } else if (val > props.max) {
              _emit(props.max);
            } else {
              initData.firstValue = val;
              if (valueChanged()) {
                if (props.validateEvent) {
                  (_b = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _b.call(elFormItem, "change").catch((err) => debugWarn());
                }
                initData.oldValue = val;
              }
            }
          }
        };
        setValues();
        watch(() => initData.dragging, (val) => {
          if (!val) {
            setValues();
          }
        });
        watch(() => props.modelValue, (val, oldVal) => {
          if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index) => item === oldVal[index]) && initData.firstValue === val[0] && initData.secondValue === val[1]) {
            return;
          }
          setValues();
        }, {
          deep: true
        });
        watch(() => [props.min, props.max], () => {
          setValues();
        });
      };
      const sliderButtonProps = buildProps({
        modelValue: {
          type: Number,
          default: 0
        },
        vertical: Boolean,
        tooltipClass: String,
        placement: {
          type: String,
          values: Ee,
          default: "top"
        }
      });
      const sliderButtonEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isNumber$1(value)
      };
      const _hoisted_1$7 = ["tabindex"];
      const __default__$3 = /* @__PURE__ */ defineComponent({
        name: "ElSliderButton"
      });
      const _sfc_main$8 = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: sliderButtonProps,
        emits: sliderButtonEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("slider");
          const initData = reactive({
            hovering: false,
            dragging: false,
            isClick: false,
            startX: 0,
            currentX: 0,
            startY: 0,
            currentY: 0,
            startPosition: 0,
            newPosition: 0,
            oldValue: props.modelValue
          });
          const {
            disabled,
            button,
            tooltip,
            showTooltip,
            tooltipVisible,
            wrapperStyle,
            formatValue,
            handleMouseEnter,
            handleMouseLeave,
            onButtonDown,
            onKeyDown,
            setPosition
          } = useSliderButton(props, initData, emit2);
          const { hovering, dragging } = toRefs(initData);
          expose2({
            onButtonDown,
            onKeyDown,
            setPosition,
            hovering,
            dragging
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "button",
              ref: button,
              class: normalizeClass([unref(ns).e("button-wrapper"), { hover: unref(hovering), dragging: unref(dragging) }]),
              style: normalizeStyle(unref(wrapperStyle)),
              tabindex: unref(disabled) ? -1 : 0,
              onMouseenter: _cache[0] || (_cache[0] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
              onMouseleave: _cache[1] || (_cache[1] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
              onMousedown: _cache[2] || (_cache[2] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
              onTouchstart: _cache[3] || (_cache[3] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
              onFocus: _cache[4] || (_cache[4] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
              onBlur: _cache[5] || (_cache[5] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
              onKeydown: _cache[6] || (_cache[6] = (...args) => unref(onKeyDown) && unref(onKeyDown)(...args))
            }, [
              createVNode(unref(ElTooltip), {
                ref_key: "tooltip",
                ref: tooltip,
                visible: unref(tooltipVisible),
                placement: _ctx.placement,
                "fallback-placements": ["top", "bottom", "right", "left"],
                "stop-popper-mouse-event": false,
                "popper-class": _ctx.tooltipClass,
                disabled: !unref(showTooltip),
                persistent: ""
              }, {
                content: withCtx(() => [
                  createBaseVNode("span", null, toDisplayString$1(unref(formatValue)), 1)
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: normalizeClass([unref(ns).e("button"), { hover: unref(hovering), dragging: unref(dragging) }])
                  }, null, 2)
                ]),
                _: 1
              }, 8, ["visible", "placement", "popper-class", "disabled"])
            ], 46, _hoisted_1$7);
          };
        }
      });
      var SliderButton = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__file", "button.vue"]]);
      const sliderMarkerProps = buildProps({
        mark: {
          type: definePropType([String, Object]),
          default: void 0
        }
      });
      var SliderMarker = /* @__PURE__ */ defineComponent({
        name: "ElSliderMarker",
        props: sliderMarkerProps,
        setup(props) {
          const ns = useNamespace("slider");
          const label = computed(() => {
            return isString$3(props.mark) ? props.mark : props.mark.label;
          });
          const style = computed(() => isString$3(props.mark) ? void 0 : props.mark.style);
          return () => h$1("div", {
            class: ns.e("marks-text"),
            style: style.value
          }, label.value);
        }
      });
      const _hoisted_1$6 = ["id", "role", "aria-label", "aria-labelledby"];
      const _hoisted_2$5 = { key: 1 };
      const __default__$2 = /* @__PURE__ */ defineComponent({
        name: "ElSlider"
      });
      const _sfc_main$7 = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: sliderProps,
        emits: sliderEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("slider");
          const { t: t2 } = useLocale();
          const initData = reactive({
            firstValue: 0,
            secondValue: 0,
            oldValue: 0,
            dragging: false,
            sliderSize: 1
          });
          const {
            elFormItem,
            slider,
            firstButton,
            secondButton,
            sliderDisabled,
            minValue,
            maxValue,
            runwayStyle,
            barStyle,
            resetSize,
            emitChange,
            onSliderWrapperPrevent,
            onSliderClick,
            onSliderDown,
            setFirstValue,
            setSecondValue
          } = useSlide(props, initData, emit2);
          const { stops, getStopStyle } = useStops(props, initData, minValue, maxValue);
          const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
            formItemContext: elFormItem
          });
          const sliderWrapperSize = useFormSize();
          const sliderInputSize = computed(() => props.inputSize || sliderWrapperSize.value);
          const groupLabel = computed(() => {
            return props.label || t2("el.slider.defaultLabel", {
              min: props.min,
              max: props.max
            });
          });
          const firstButtonLabel = computed(() => {
            if (props.range) {
              return props.rangeStartLabel || t2("el.slider.defaultRangeStartLabel");
            } else {
              return groupLabel.value;
            }
          });
          const firstValueText = computed(() => {
            return props.formatValueText ? props.formatValueText(firstValue.value) : `${firstValue.value}`;
          });
          const secondButtonLabel = computed(() => {
            return props.rangeEndLabel || t2("el.slider.defaultRangeEndLabel");
          });
          const secondValueText = computed(() => {
            return props.formatValueText ? props.formatValueText(secondValue.value) : `${secondValue.value}`;
          });
          const sliderKls = computed(() => [
            ns.b(),
            ns.m(sliderWrapperSize.value),
            ns.is("vertical", props.vertical),
            { [ns.m("with-input")]: props.showInput }
          ]);
          const markList = useMarks(props);
          useWatch(props, initData, minValue, maxValue, emit2, elFormItem);
          const precision = computed(() => {
            const precisions = [props.min, props.max, props.step].map((item) => {
              const decimal = `${item}`.split(".")[1];
              return decimal ? decimal.length : 0;
            });
            return Math.max.apply(null, precisions);
          });
          const { sliderWrapper } = useLifecycle(props, initData, resetSize);
          const { firstValue, secondValue, sliderSize } = toRefs(initData);
          const updateDragging = (val) => {
            initData.dragging = val;
          };
          provide(sliderContextKey, {
            ...toRefs(props),
            sliderSize,
            disabled: sliderDisabled,
            precision,
            emitChange,
            resetSize,
            updateDragging
          });
          expose2({
            onSliderClick
          });
          return (_ctx, _cache) => {
            var _a2, _b;
            return openBlock(), createElementBlock("div", {
              id: _ctx.range ? unref(inputId) : void 0,
              ref_key: "sliderWrapper",
              ref: sliderWrapper,
              class: normalizeClass(unref(sliderKls)),
              role: _ctx.range ? "group" : void 0,
              "aria-label": _ctx.range && !unref(isLabeledByFormItem) ? unref(groupLabel) : void 0,
              "aria-labelledby": _ctx.range && unref(isLabeledByFormItem) ? (_a2 = unref(elFormItem)) == null ? void 0 : _a2.labelId : void 0,
              onTouchstart: _cache[2] || (_cache[2] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args)),
              onTouchmove: _cache[3] || (_cache[3] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args))
            }, [
              createBaseVNode("div", {
                ref_key: "slider",
                ref: slider,
                class: normalizeClass([
                  unref(ns).e("runway"),
                  { "show-input": _ctx.showInput && !_ctx.range },
                  unref(ns).is("disabled", unref(sliderDisabled))
                ]),
                style: normalizeStyle(unref(runwayStyle)),
                onMousedown: _cache[0] || (_cache[0] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args)),
                onTouchstart: _cache[1] || (_cache[1] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).e("bar")),
                  style: normalizeStyle(unref(barStyle))
                }, null, 6),
                createVNode(SliderButton, {
                  id: !_ctx.range ? unref(inputId) : void 0,
                  ref_key: "firstButton",
                  ref: firstButton,
                  "model-value": unref(firstValue),
                  vertical: _ctx.vertical,
                  "tooltip-class": _ctx.tooltipClass,
                  placement: _ctx.placement,
                  role: "slider",
                  "aria-label": _ctx.range || !unref(isLabeledByFormItem) ? unref(firstButtonLabel) : void 0,
                  "aria-labelledby": !_ctx.range && unref(isLabeledByFormItem) ? (_b = unref(elFormItem)) == null ? void 0 : _b.labelId : void 0,
                  "aria-valuemin": _ctx.min,
                  "aria-valuemax": _ctx.range ? unref(secondValue) : _ctx.max,
                  "aria-valuenow": unref(firstValue),
                  "aria-valuetext": unref(firstValueText),
                  "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                  "aria-disabled": unref(sliderDisabled),
                  "onUpdate:modelValue": unref(setFirstValue)
                }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
                _ctx.range ? (openBlock(), createBlock(SliderButton, {
                  key: 0,
                  ref_key: "secondButton",
                  ref: secondButton,
                  "model-value": unref(secondValue),
                  vertical: _ctx.vertical,
                  "tooltip-class": _ctx.tooltipClass,
                  placement: _ctx.placement,
                  role: "slider",
                  "aria-label": unref(secondButtonLabel),
                  "aria-valuemin": unref(firstValue),
                  "aria-valuemax": _ctx.max,
                  "aria-valuenow": unref(secondValue),
                  "aria-valuetext": unref(secondValueText),
                  "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                  "aria-disabled": unref(sliderDisabled),
                  "onUpdate:modelValue": unref(setSecondValue)
                }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : createCommentVNode("v-if", true),
                _ctx.showStops ? (openBlock(), createElementBlock("div", _hoisted_2$5, [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList(unref(stops), (item, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      class: normalizeClass(unref(ns).e("stop")),
                      style: normalizeStyle(unref(getStopStyle)(item))
                    }, null, 6);
                  }), 128))
                ])) : createCommentVNode("v-if", true),
                unref(markList).length > 0 ? (openBlock(), createElementBlock(Fragment$1, { key: 2 }, [
                  createBaseVNode("div", null, [
                    (openBlock(true), createElementBlock(Fragment$1, null, renderList(unref(markList), (item, key) => {
                      return openBlock(), createElementBlock("div", {
                        key,
                        style: normalizeStyle(unref(getStopStyle)(item.position)),
                        class: normalizeClass([unref(ns).e("stop"), unref(ns).e("marks-stop")])
                      }, null, 6);
                    }), 128))
                  ]),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("marks"))
                  }, [
                    (openBlock(true), createElementBlock(Fragment$1, null, renderList(unref(markList), (item, key) => {
                      return openBlock(), createBlock(unref(SliderMarker), {
                        key,
                        mark: item.mark,
                        style: normalizeStyle(unref(getStopStyle)(item.position))
                      }, null, 8, ["mark", "style"]);
                    }), 128))
                  ], 2)
                ], 64)) : createCommentVNode("v-if", true)
              ], 38),
              _ctx.showInput && !_ctx.range ? (openBlock(), createBlock(unref(ElInputNumber), {
                key: 0,
                ref: "input",
                "model-value": unref(firstValue),
                class: normalizeClass(unref(ns).e("input")),
                step: _ctx.step,
                disabled: unref(sliderDisabled),
                controls: _ctx.showInputControls,
                min: _ctx.min,
                max: _ctx.max,
                debounce: _ctx.debounce,
                size: unref(sliderInputSize),
                "onUpdate:modelValue": unref(setFirstValue),
                onChange: unref(emitChange)
              }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : createCommentVNode("v-if", true)
            ], 42, _hoisted_1$6);
          };
        }
      });
      var Slider = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__file", "slider.vue"]]);
      const ElSlider = withInstall(Slider);
      const switchProps = buildProps({
        modelValue: {
          type: [Boolean, String, Number],
          default: false
        },
        disabled: {
          type: Boolean,
          default: false
        },
        loading: {
          type: Boolean,
          default: false
        },
        size: {
          type: String,
          validator: isValidComponentSize
        },
        width: {
          type: [String, Number],
          default: ""
        },
        inlinePrompt: {
          type: Boolean,
          default: false
        },
        inactiveActionIcon: {
          type: iconPropType
        },
        activeActionIcon: {
          type: iconPropType
        },
        activeIcon: {
          type: iconPropType
        },
        inactiveIcon: {
          type: iconPropType
        },
        activeText: {
          type: String,
          default: ""
        },
        inactiveText: {
          type: String,
          default: ""
        },
        activeValue: {
          type: [Boolean, String, Number],
          default: true
        },
        inactiveValue: {
          type: [Boolean, String, Number],
          default: false
        },
        name: {
          type: String,
          default: ""
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        beforeChange: {
          type: definePropType(Function)
        },
        id: String,
        tabindex: {
          type: [String, Number]
        },
        label: {
          type: String,
          default: void 0
        }
      });
      const switchEmits = {
        [UPDATE_MODEL_EVENT]: (val) => isBoolean$1(val) || isString$3(val) || isNumber$1(val),
        [CHANGE_EVENT]: (val) => isBoolean$1(val) || isString$3(val) || isNumber$1(val),
        [INPUT_EVENT]: (val) => isBoolean$1(val) || isString$3(val) || isNumber$1(val)
      };
      const _hoisted_1$5 = ["onClick"];
      const _hoisted_2$4 = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"];
      const _hoisted_3$2 = ["aria-hidden"];
      const _hoisted_4$1 = ["aria-hidden"];
      const _hoisted_5$1 = ["aria-hidden"];
      const COMPONENT_NAME = "ElSwitch";
      const __default__$1 = /* @__PURE__ */ defineComponent({
        name: COMPONENT_NAME
      });
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: switchProps,
        emits: switchEmits,
        setup(__props, { expose: expose2, emit: emit2 }) {
          const props = __props;
          const { formItem } = useFormItem();
          const switchSize = useFormSize();
          const ns = useNamespace("switch");
          const { inputId } = useFormItemInputId(props, {
            formItemContext: formItem
          });
          const switchDisabled = useFormDisabled(computed(() => props.loading));
          const isControlled = ref(props.modelValue !== false);
          const input = ref();
          const core = ref();
          const switchKls = computed(() => [
            ns.b(),
            ns.m(switchSize.value),
            ns.is("disabled", switchDisabled.value),
            ns.is("checked", checked.value)
          ]);
          const labelLeftKls = computed(() => [
            ns.e("label"),
            ns.em("label", "left"),
            ns.is("active", !checked.value)
          ]);
          const labelRightKls = computed(() => [
            ns.e("label"),
            ns.em("label", "right"),
            ns.is("active", checked.value)
          ]);
          const coreStyle = computed(() => ({
            width: addUnit(props.width)
          }));
          watch(() => props.modelValue, () => {
            isControlled.value = true;
          });
          const actualValue = computed(() => {
            return isControlled.value ? props.modelValue : false;
          });
          const checked = computed(() => actualValue.value === props.activeValue);
          if (![props.activeValue, props.inactiveValue].includes(actualValue.value)) {
            emit2(UPDATE_MODEL_EVENT, props.inactiveValue);
            emit2(CHANGE_EVENT, props.inactiveValue);
            emit2(INPUT_EVENT, props.inactiveValue);
          }
          watch(checked, (val) => {
            var _a2;
            input.value.checked = val;
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
            }
          });
          const handleChange = () => {
            const val = checked.value ? props.inactiveValue : props.activeValue;
            emit2(UPDATE_MODEL_EVENT, val);
            emit2(CHANGE_EVENT, val);
            emit2(INPUT_EVENT, val);
            nextTick(() => {
              input.value.checked = checked.value;
            });
          };
          const switchValue = () => {
            if (switchDisabled.value)
              return;
            const { beforeChange } = props;
            if (!beforeChange) {
              handleChange();
              return;
            }
            const shouldChange = beforeChange();
            const isPromiseOrBool = [
              isPromise$1(shouldChange),
              isBoolean$1(shouldChange)
            ].includes(true);
            if (!isPromiseOrBool) {
              throwError(COMPONENT_NAME, "beforeChange must return type `Promise<boolean>` or `boolean`");
            }
            if (isPromise$1(shouldChange)) {
              shouldChange.then((result) => {
                if (result) {
                  handleChange();
                }
              }).catch((e) => {
              });
            } else if (shouldChange) {
              handleChange();
            }
          };
          const focus = () => {
            var _a2, _b;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          };
          onMounted(() => {
            input.value.checked = checked.value;
          });
          expose2({
            focus,
            checked
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(switchKls)),
              onClick: withModifiers(switchValue, ["prevent"])
            }, [
              createBaseVNode("input", {
                id: unref(inputId),
                ref_key: "input",
                ref: input,
                class: normalizeClass(unref(ns).e("input")),
                type: "checkbox",
                role: "switch",
                "aria-checked": unref(checked),
                "aria-disabled": unref(switchDisabled),
                "aria-label": _ctx.label,
                name: _ctx.name,
                "true-value": _ctx.activeValue,
                "false-value": _ctx.inactiveValue,
                disabled: unref(switchDisabled),
                tabindex: _ctx.tabindex,
                onChange: handleChange,
                onKeydown: withKeys(switchValue, ["enter"])
              }, null, 42, _hoisted_2$4),
              !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(unref(labelLeftKls))
              }, [
                _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  "aria-hidden": unref(checked)
                }, toDisplayString$1(_ctx.inactiveText), 9, _hoisted_3$2)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("span", {
                ref_key: "core",
                ref: core,
                class: normalizeClass(unref(ns).e("core")),
                style: normalizeStyle(unref(coreStyle))
              }, [
                _ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("inner"))
                }, [
                  _ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).is("icon"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(checked) ? _ctx.activeIcon : _ctx.inactiveIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : _ctx.activeText || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(ns).is("text")),
                    "aria-hidden": !unref(checked)
                  }, toDisplayString$1(unref(checked) ? _ctx.activeText : _ctx.inactiveText), 11, _hoisted_4$1)) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).e("action"))
                }, [
                  _ctx.loading ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(loading_default))
                    ]),
                    _: 1
                  }, 8, ["class"])) : unref(checked) ? renderSlot(_ctx.$slots, "active-action", { key: 1 }, () => [
                    _ctx.activeActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeActionIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]) : !unref(checked) ? renderSlot(_ctx.$slots, "inactive-action", { key: 2 }, () => [
                    _ctx.inactiveActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveActionIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]) : createCommentVNode("v-if", true)
                ], 2)
              ], 6),
              !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
                key: 1,
                class: normalizeClass(unref(labelRightKls))
              }, [
                _ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  "aria-hidden": !unref(checked)
                }, toDisplayString$1(_ctx.activeText), 9, _hoisted_5$1)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true)
            ], 10, _hoisted_1$5);
          };
        }
      });
      var Switch = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__file", "switch.vue"]]);
      const ElSwitch = withInstall(Switch);
      const getCell = function(event) {
        var _a2;
        return (_a2 = event.target) == null ? void 0 : _a2.closest("td");
      };
      const orderBy = function(array, sortKey, reverse, sortMethod, sortBy) {
        if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
          return array;
        }
        if (typeof reverse === "string") {
          reverse = reverse === "descending" ? -1 : 1;
        } else {
          reverse = reverse && reverse < 0 ? -1 : 1;
        }
        const getKey = sortMethod ? null : function(value, index) {
          if (sortBy) {
            if (!Array.isArray(sortBy)) {
              sortBy = [sortBy];
            }
            return sortBy.map((by) => {
              if (typeof by === "string") {
                return get(value, by);
              } else {
                return by(value, index, array);
              }
            });
          }
          if (sortKey !== "$key") {
            if (isObject$5(value) && "$value" in value)
              value = value.$value;
          }
          return [isObject$5(value) ? get(value, sortKey) : value];
        };
        const compare = function(a2, b2) {
          if (sortMethod) {
            return sortMethod(a2.value, b2.value);
          }
          for (let i = 0, len = a2.key.length; i < len; i++) {
            if (a2.key[i] < b2.key[i]) {
              return -1;
            }
            if (a2.key[i] > b2.key[i]) {
              return 1;
            }
          }
          return 0;
        };
        return array.map((value, index) => {
          return {
            value,
            index,
            key: getKey ? getKey(value, index) : null
          };
        }).sort((a2, b2) => {
          let order = compare(a2, b2);
          if (!order) {
            order = a2.index - b2.index;
          }
          return order * +reverse;
        }).map((item) => item.value);
      };
      const getColumnById = function(table, columnId) {
        let column = null;
        table.columns.forEach((item) => {
          if (item.id === columnId) {
            column = item;
          }
        });
        return column;
      };
      const getColumnByKey = function(table, columnKey) {
        let column = null;
        for (let i = 0; i < table.columns.length; i++) {
          const item = table.columns[i];
          if (item.columnKey === columnKey) {
            column = item;
            break;
          }
        }
        if (!column)
          throwError("ElTable", `No column matching with column-key: ${columnKey}`);
        return column;
      };
      const getColumnByCell = function(table, cell, namespace) {
        const matches = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
        if (matches) {
          return getColumnById(table, matches[0]);
        }
        return null;
      };
      const getRowIdentity = (row, rowKey) => {
        if (!row)
          throw new Error("Row is required when get row identity");
        if (typeof rowKey === "string") {
          if (!rowKey.includes(".")) {
            return `${row[rowKey]}`;
          }
          const key = rowKey.split(".");
          let current = row;
          for (const element of key) {
            current = current[element];
          }
          return `${current}`;
        } else if (typeof rowKey === "function") {
          return rowKey.call(null, row);
        }
      };
      const getKeysMap = function(array, rowKey) {
        const arrayMap2 = {};
        (array || []).forEach((row, index) => {
          arrayMap2[getRowIdentity(row, rowKey)] = { row, index };
        });
        return arrayMap2;
      };
      function mergeOptions(defaults, config) {
        const options = {};
        let key;
        for (key in defaults) {
          options[key] = defaults[key];
        }
        for (key in config) {
          if (hasOwn$1(config, key)) {
            const value = config[key];
            if (typeof value !== "undefined") {
              options[key] = value;
            }
          }
        }
        return options;
      }
      function parseWidth(width) {
        if (width === "")
          return width;
        if (width !== void 0) {
          width = Number.parseInt(width, 10);
          if (Number.isNaN(width)) {
            width = "";
          }
        }
        return width;
      }
      function parseMinWidth(minWidth) {
        if (minWidth === "")
          return minWidth;
        if (minWidth !== void 0) {
          minWidth = parseWidth(minWidth);
          if (Number.isNaN(minWidth)) {
            minWidth = 80;
          }
        }
        return minWidth;
      }
      function parseHeight(height) {
        if (typeof height === "number") {
          return height;
        }
        if (typeof height === "string") {
          if (/^\d+(?:px)?$/.test(height)) {
            return Number.parseInt(height, 10);
          } else {
            return height;
          }
        }
        return null;
      }
      function compose(...funcs) {
        if (funcs.length === 0) {
          return (arg) => arg;
        }
        if (funcs.length === 1) {
          return funcs[0];
        }
        return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
      }
      function toggleRowStatus(statusArr, row, newVal) {
        let changed = false;
        const index = statusArr.indexOf(row);
        const included = index !== -1;
        const toggleStatus = (type) => {
          if (type === "add") {
            statusArr.push(row);
          } else {
            statusArr.splice(index, 1);
          }
          changed = true;
          if (isArray$2(row.children)) {
            row.children.forEach((item) => {
              toggleRowStatus(statusArr, item, newVal != null ? newVal : !included);
            });
          }
        };
        if (isBoolean$1(newVal)) {
          if (newVal && !included) {
            toggleStatus("add");
          } else if (!newVal && included) {
            toggleStatus("remove");
          }
        } else {
          included ? toggleStatus("remove") : toggleStatus("add");
        }
        return changed;
      }
      function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
        const isNil2 = (array) => !(Array.isArray(array) && array.length);
        function _walker(parent, children, level) {
          cb(parent, children, level);
          children.forEach((item) => {
            if (item[lazyKey]) {
              cb(item, null, level + 1);
              return;
            }
            const children2 = item[childrenKey];
            if (!isNil2(children2)) {
              _walker(item, children2, level + 1);
            }
          });
        }
        root2.forEach((item) => {
          if (item[lazyKey]) {
            cb(item, null, 0);
            return;
          }
          const children = item[childrenKey];
          if (!isNil2(children)) {
            _walker(item, children, 0);
          }
        });
      }
      let removePopper = null;
      function createTablePopper(props, popperContent, trigger2, table) {
        if ((removePopper == null ? void 0 : removePopper.trigger) === trigger2) {
          return;
        }
        removePopper == null ? void 0 : removePopper();
        const parentNode = table == null ? void 0 : table.refs.tableWrapper;
        const ns = parentNode == null ? void 0 : parentNode.dataset.prefix;
        const popperOptions = {
          strategy: "fixed",
          ...props.popperOptions
        };
        const vm = createVNode(ElTooltip, {
          content: popperContent,
          virtualTriggering: true,
          virtualRef: trigger2,
          appendTo: parentNode,
          placement: "top",
          transition: "none",
          offset: 0,
          hideAfter: 0,
          ...props,
          popperOptions,
          onHide: () => {
            removePopper == null ? void 0 : removePopper();
          }
        });
        vm.appContext = { ...table.appContext, ...table };
        const container = document.createElement("div");
        render(vm, container);
        vm.component.exposed.onOpen();
        const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns}-scrollbar__wrap`);
        removePopper = () => {
          render(null, container);
          scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", removePopper);
          removePopper = null;
        };
        removePopper.trigger = trigger2;
        scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", removePopper);
      }
      function getCurrentColumns(column) {
        if (column.children) {
          return flatMap(column.children, getCurrentColumns);
        } else {
          return [column];
        }
      }
      function getColSpan(colSpan, column) {
        return colSpan + column.colSpan;
      }
      const isFixedColumn = (index, fixed, store, realColumns) => {
        let start = 0;
        let after = index;
        const columns = store.states.columns.value;
        if (realColumns) {
          const curColumns = getCurrentColumns(realColumns[index]);
          const preColumns = columns.slice(0, columns.indexOf(curColumns[0]));
          start = preColumns.reduce(getColSpan, 0);
          after = start + curColumns.reduce(getColSpan, 0) - 1;
        } else {
          start = index;
        }
        let fixedLayout;
        switch (fixed) {
          case "left":
            if (after < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            }
            break;
          case "right":
            if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
            break;
          default:
            if (after < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            } else if (start >= columns.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
        }
        return fixedLayout ? {
          direction: fixedLayout,
          start,
          after
        } : {};
      };
      const getFixedColumnsClass = (namespace, index, fixed, store, realColumns, offset = 0) => {
        const classes = [];
        const { direction, start, after } = isFixedColumn(index, fixed, store, realColumns);
        if (direction) {
          const isLeft = direction === "left";
          classes.push(`${namespace}-fixed-column--${direction}`);
          if (isLeft && after + offset === store.states.fixedLeafColumnsLength.value - 1) {
            classes.push("is-last-column");
          } else if (!isLeft && start - offset === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
            classes.push("is-first-column");
          }
        }
        return classes;
      };
      function getOffset(offset, column) {
        return offset + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
      }
      const getFixedColumnOffset = (index, fixed, store, realColumns) => {
        const {
          direction,
          start = 0,
          after = 0
        } = isFixedColumn(index, fixed, store, realColumns);
        if (!direction) {
          return;
        }
        const styles = {};
        const isLeft = direction === "left";
        const columns = store.states.columns.value;
        if (isLeft) {
          styles.left = columns.slice(0, start).reduce(getOffset, 0);
        } else {
          styles.right = columns.slice(after + 1).reverse().reduce(getOffset, 0);
        }
        return styles;
      };
      const ensurePosition = (style, key) => {
        if (!style)
          return;
        if (!Number.isNaN(style[key])) {
          style[key] = `${style[key]}px`;
        }
      };
      function useExpand(watcherData) {
        const instance = getCurrentInstance();
        const defaultExpandAll = ref(false);
        const expandRows = ref([]);
        const updateExpandRows = () => {
          const data = watcherData.data.value || [];
          const rowKey = watcherData.rowKey.value;
          if (defaultExpandAll.value) {
            expandRows.value = data.slice();
          } else if (rowKey) {
            const expandRowsMap = getKeysMap(expandRows.value, rowKey);
            expandRows.value = data.reduce((prev, row) => {
              const rowId = getRowIdentity(row, rowKey);
              const rowInfo = expandRowsMap[rowId];
              if (rowInfo) {
                prev.push(row);
              }
              return prev;
            }, []);
          } else {
            expandRows.value = [];
          }
        };
        const toggleRowExpansion = (row, expanded) => {
          const changed = toggleRowStatus(expandRows.value, row, expanded);
          if (changed) {
            instance.emit("expand-change", row, expandRows.value.slice());
          }
        };
        const setExpandRowKeys = (rowKeys) => {
          instance.store.assertRowKey();
          const data = watcherData.data.value || [];
          const rowKey = watcherData.rowKey.value;
          const keysMap = getKeysMap(data, rowKey);
          expandRows.value = rowKeys.reduce((prev, cur) => {
            const info = keysMap[cur];
            if (info) {
              prev.push(info.row);
            }
            return prev;
          }, []);
        };
        const isRowExpanded = (row) => {
          const rowKey = watcherData.rowKey.value;
          if (rowKey) {
            const expandMap = getKeysMap(expandRows.value, rowKey);
            return !!expandMap[getRowIdentity(row, rowKey)];
          }
          return expandRows.value.includes(row);
        };
        return {
          updateExpandRows,
          toggleRowExpansion,
          setExpandRowKeys,
          isRowExpanded,
          states: {
            expandRows,
            defaultExpandAll
          }
        };
      }
      function useCurrent(watcherData) {
        const instance = getCurrentInstance();
        const _currentRowKey = ref(null);
        const currentRow = ref(null);
        const setCurrentRowKey = (key) => {
          instance.store.assertRowKey();
          _currentRowKey.value = key;
          setCurrentRowByKey(key);
        };
        const restoreCurrentRowKey = () => {
          _currentRowKey.value = null;
        };
        const setCurrentRowByKey = (key) => {
          const { data, rowKey } = watcherData;
          let _currentRow = null;
          if (rowKey.value) {
            _currentRow = (unref(data) || []).find((item) => getRowIdentity(item, rowKey.value) === key);
          }
          currentRow.value = _currentRow;
          instance.emit("current-change", currentRow.value, null);
        };
        const updateCurrentRow = (_currentRow) => {
          const oldCurrentRow = currentRow.value;
          if (_currentRow && _currentRow !== oldCurrentRow) {
            currentRow.value = _currentRow;
            instance.emit("current-change", currentRow.value, oldCurrentRow);
            return;
          }
          if (!_currentRow && oldCurrentRow) {
            currentRow.value = null;
            instance.emit("current-change", null, oldCurrentRow);
          }
        };
        const updateCurrentRowData = () => {
          const rowKey = watcherData.rowKey.value;
          const data = watcherData.data.value || [];
          const oldCurrentRow = currentRow.value;
          if (!data.includes(oldCurrentRow) && oldCurrentRow) {
            if (rowKey) {
              const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
              setCurrentRowByKey(currentRowKey);
            } else {
              currentRow.value = null;
            }
            if (currentRow.value === null) {
              instance.emit("current-change", null, oldCurrentRow);
            }
          } else if (_currentRowKey.value) {
            setCurrentRowByKey(_currentRowKey.value);
            restoreCurrentRowKey();
          }
        };
        return {
          setCurrentRowKey,
          restoreCurrentRowKey,
          setCurrentRowByKey,
          updateCurrentRow,
          updateCurrentRowData,
          states: {
            _currentRowKey,
            currentRow
          }
        };
      }
      function useTree(watcherData) {
        const expandRowKeys = ref([]);
        const treeData = ref({});
        const indent = ref(16);
        const lazy = ref(false);
        const lazyTreeNodeMap = ref({});
        const lazyColumnIdentifier = ref("hasChildren");
        const childrenColumnName = ref("children");
        const instance = getCurrentInstance();
        const normalizedData = computed(() => {
          if (!watcherData.rowKey.value)
            return {};
          const data = watcherData.data.value || [];
          return normalize(data);
        });
        const normalizedLazyNode = computed(() => {
          const rowKey = watcherData.rowKey.value;
          const keys2 = Object.keys(lazyTreeNodeMap.value);
          const res = {};
          if (!keys2.length)
            return res;
          keys2.forEach((key) => {
            if (lazyTreeNodeMap.value[key].length) {
              const item = { children: [] };
              lazyTreeNodeMap.value[key].forEach((row) => {
                const currentRowKey = getRowIdentity(row, rowKey);
                item.children.push(currentRowKey);
                if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
                  res[currentRowKey] = { children: [] };
                }
              });
              res[key] = item;
            }
          });
          return res;
        });
        const normalize = (data) => {
          const rowKey = watcherData.rowKey.value;
          const res = {};
          walkTreeNode(data, (parent, children, level) => {
            const parentId = getRowIdentity(parent, rowKey);
            if (Array.isArray(children)) {
              res[parentId] = {
                children: children.map((row) => getRowIdentity(row, rowKey)),
                level
              };
            } else if (lazy.value) {
              res[parentId] = {
                children: [],
                lazy: true,
                level
              };
            }
          }, childrenColumnName.value, lazyColumnIdentifier.value);
          return res;
        };
        const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a2) => (_a2 = instance.store) == null ? void 0 : _a2.states.defaultExpandAll.value)()) => {
          var _a2;
          const nested = normalizedData.value;
          const normalizedLazyNode_ = normalizedLazyNode.value;
          const keys2 = Object.keys(nested);
          const newTreeData = {};
          if (keys2.length) {
            const oldTreeData = unref(treeData);
            const rootLazyRowKeys = [];
            const getExpanded = (oldValue, key) => {
              if (ifChangeExpandRowKeys) {
                if (expandRowKeys.value) {
                  return ifExpandAll || expandRowKeys.value.includes(key);
                } else {
                  return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
                }
              } else {
                const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
                return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
              }
            };
            keys2.forEach((key) => {
              const oldValue = oldTreeData[key];
              const newValue = { ...nested[key] };
              newValue.expanded = getExpanded(oldValue, key);
              if (newValue.lazy) {
                const { loaded = false, loading = false } = oldValue || {};
                newValue.loaded = !!loaded;
                newValue.loading = !!loading;
                rootLazyRowKeys.push(key);
              }
              newTreeData[key] = newValue;
            });
            const lazyKeys = Object.keys(normalizedLazyNode_);
            if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
              lazyKeys.forEach((key) => {
                const oldValue = oldTreeData[key];
                const lazyNodeChildren = normalizedLazyNode_[key].children;
                if (rootLazyRowKeys.includes(key)) {
                  if (newTreeData[key].children.length !== 0) {
                    throw new Error("[ElTable]children must be an empty array.");
                  }
                  newTreeData[key].children = lazyNodeChildren;
                } else {
                  const { loaded = false, loading = false } = oldValue || {};
                  newTreeData[key] = {
                    lazy: true,
                    loaded: !!loaded,
                    loading: !!loading,
                    expanded: getExpanded(oldValue, key),
                    children: lazyNodeChildren,
                    level: ""
                  };
                }
              });
            }
          }
          treeData.value = newTreeData;
          (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
        };
        watch(() => expandRowKeys.value, () => {
          updateTreeData(true);
        });
        watch(() => normalizedData.value, () => {
          updateTreeData();
        });
        watch(() => normalizedLazyNode.value, () => {
          updateTreeData();
        });
        const updateTreeExpandKeys = (value) => {
          expandRowKeys.value = value;
          updateTreeData();
        };
        const toggleTreeExpansion = (row, expanded) => {
          instance.store.assertRowKey();
          const rowKey = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey);
          const data = id && treeData.value[id];
          if (id && data && "expanded" in data) {
            const oldExpanded = data.expanded;
            expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
            treeData.value[id].expanded = expanded;
            if (oldExpanded !== expanded) {
              instance.emit("expand-change", row, expanded);
            }
            instance.store.updateTableScrollY();
          }
        };
        const loadOrToggle = (row) => {
          instance.store.assertRowKey();
          const rowKey = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey);
          const data = treeData.value[id];
          if (lazy.value && data && "loaded" in data && !data.loaded) {
            loadData(row, id, data);
          } else {
            toggleTreeExpansion(row, void 0);
          }
        };
        const loadData = (row, key, treeNode) => {
          const { load } = instance.props;
          if (load && !treeData.value[key].loaded) {
            treeData.value[key].loading = true;
            load(row, treeNode, (data) => {
              if (!Array.isArray(data)) {
                throw new TypeError("[ElTable] data must be an array");
              }
              treeData.value[key].loading = false;
              treeData.value[key].loaded = true;
              treeData.value[key].expanded = true;
              if (data.length) {
                lazyTreeNodeMap.value[key] = data;
              }
              instance.emit("expand-change", row, true);
            });
          }
        };
        return {
          loadData,
          loadOrToggle,
          toggleTreeExpansion,
          updateTreeExpandKeys,
          updateTreeData,
          normalize,
          states: {
            expandRowKeys,
            treeData,
            indent,
            lazy,
            lazyTreeNodeMap,
            lazyColumnIdentifier,
            childrenColumnName
          }
        };
      }
      const sortData = (data, states) => {
        const sortingColumn = states.sortingColumn;
        if (!sortingColumn || typeof sortingColumn.sortable === "string") {
          return data;
        }
        return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
      };
      const doFlattenColumns = (columns) => {
        const result = [];
        columns.forEach((column) => {
          if (column.children && column.children.length > 0) {
            result.push.apply(result, doFlattenColumns(column.children));
          } else {
            result.push(column);
          }
        });
        return result;
      };
      function useWatcher$1() {
        var _a2;
        const instance = getCurrentInstance();
        const { size: tableSize } = toRefs((_a2 = instance.proxy) == null ? void 0 : _a2.$props);
        const rowKey = ref(null);
        const data = ref([]);
        const _data = ref([]);
        const isComplex = ref(false);
        const _columns = ref([]);
        const originColumns = ref([]);
        const columns = ref([]);
        const fixedColumns = ref([]);
        const rightFixedColumns = ref([]);
        const leafColumns = ref([]);
        const fixedLeafColumns = ref([]);
        const rightFixedLeafColumns = ref([]);
        const updateOrderFns = [];
        const leafColumnsLength = ref(0);
        const fixedLeafColumnsLength = ref(0);
        const rightFixedLeafColumnsLength = ref(0);
        const isAllSelected = ref(false);
        const selection = ref([]);
        const reserveSelection = ref(false);
        const selectOnIndeterminate = ref(false);
        const selectable = ref(null);
        const filters = ref({});
        const filteredData = ref(null);
        const sortingColumn = ref(null);
        const sortProp = ref(null);
        const sortOrder = ref(null);
        const hoverRow = ref(null);
        watch(data, () => instance.state && scheduleLayout(false), {
          deep: true
        });
        const assertRowKey = () => {
          if (!rowKey.value)
            throw new Error("[ElTable] prop row-key is required");
        };
        const updateChildFixed = (column) => {
          var _a22;
          (_a22 = column.children) == null ? void 0 : _a22.forEach((childColumn) => {
            childColumn.fixed = column.fixed;
            updateChildFixed(childColumn);
          });
        };
        const updateColumns = () => {
          _columns.value.forEach((column) => {
            updateChildFixed(column);
          });
          fixedColumns.value = _columns.value.filter((column) => column.fixed === true || column.fixed === "left");
          rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
          if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
            _columns.value[0].fixed = true;
            fixedColumns.value.unshift(_columns.value[0]);
          }
          const notFixedColumns = _columns.value.filter((column) => !column.fixed);
          originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
          const leafColumns2 = doFlattenColumns(notFixedColumns);
          const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
          const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
          leafColumnsLength.value = leafColumns2.length;
          fixedLeafColumnsLength.value = fixedLeafColumns2.length;
          rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
          columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
          isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
        };
        const scheduleLayout = (needUpdateColumns, immediate = false) => {
          if (needUpdateColumns) {
            updateColumns();
          }
          if (immediate) {
            instance.state.doLayout();
          } else {
            instance.state.debouncedUpdateLayout();
          }
        };
        const isSelected = (row) => {
          return selection.value.includes(row);
        };
        const clearSelection = () => {
          isAllSelected.value = false;
          const oldSelection = selection.value;
          if (oldSelection.length) {
            selection.value = [];
            instance.emit("selection-change", []);
          }
        };
        const cleanSelection = () => {
          let deleted;
          if (rowKey.value) {
            deleted = [];
            const selectedMap = getKeysMap(selection.value, rowKey.value);
            const dataMap = getKeysMap(data.value, rowKey.value);
            for (const key in selectedMap) {
              if (hasOwn$1(selectedMap, key) && !dataMap[key]) {
                deleted.push(selectedMap[key].row);
              }
            }
          } else {
            deleted = selection.value.filter((item) => !data.value.includes(item));
          }
          if (deleted.length) {
            const newSelection = selection.value.filter((item) => !deleted.includes(item));
            selection.value = newSelection;
            instance.emit("selection-change", newSelection.slice());
          }
        };
        const getSelectionRows = () => {
          return (selection.value || []).slice();
        };
        const toggleRowSelection = (row, selected = void 0, emitChange = true) => {
          const changed = toggleRowStatus(selection.value, row, selected);
          if (changed) {
            const newSelection = (selection.value || []).slice();
            if (emitChange) {
              instance.emit("select", newSelection, row);
            }
            instance.emit("selection-change", newSelection);
          }
        };
        const _toggleAllSelection = () => {
          var _a22, _b;
          const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
          isAllSelected.value = value;
          let selectionChanged = false;
          let childrenCount = 0;
          const rowKey2 = (_b = (_a22 = instance == null ? void 0 : instance.store) == null ? void 0 : _a22.states) == null ? void 0 : _b.rowKey.value;
          data.value.forEach((row, index) => {
            const rowIndex = index + childrenCount;
            if (selectable.value) {
              if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value)) {
                selectionChanged = true;
              }
            } else {
              if (toggleRowStatus(selection.value, row, value)) {
                selectionChanged = true;
              }
            }
            childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));
          });
          if (selectionChanged) {
            instance.emit("selection-change", selection.value ? selection.value.slice() : []);
          }
          instance.emit("select-all", selection.value);
        };
        const updateSelectionByRowKey = () => {
          const selectedMap = getKeysMap(selection.value, rowKey.value);
          data.value.forEach((row) => {
            const rowId = getRowIdentity(row, rowKey.value);
            const rowInfo = selectedMap[rowId];
            if (rowInfo) {
              selection.value[rowInfo.index] = row;
            }
          });
        };
        const updateAllSelected = () => {
          var _a22, _b, _c;
          if (((_a22 = data.value) == null ? void 0 : _a22.length) === 0) {
            isAllSelected.value = false;
            return;
          }
          let selectedMap;
          if (rowKey.value) {
            selectedMap = getKeysMap(selection.value, rowKey.value);
          }
          const isSelected2 = function(row) {
            if (selectedMap) {
              return !!selectedMap[getRowIdentity(row, rowKey.value)];
            } else {
              return selection.value.includes(row);
            }
          };
          let isAllSelected_ = true;
          let selectedCount = 0;
          let childrenCount = 0;
          for (let i = 0, j = (data.value || []).length; i < j; i++) {
            const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
            const rowIndex = i + childrenCount;
            const item = data.value[i];
            const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);
            if (!isSelected2(item)) {
              if (!selectable.value || isRowSelectable) {
                isAllSelected_ = false;
                break;
              }
            } else {
              selectedCount++;
            }
            childrenCount += getChildrenCount(getRowIdentity(item, keyProp));
          }
          if (selectedCount === 0)
            isAllSelected_ = false;
          isAllSelected.value = isAllSelected_;
        };
        const getChildrenCount = (rowKey2) => {
          var _a22;
          if (!instance || !instance.store)
            return 0;
          const { treeData } = instance.store.states;
          let count = 0;
          const children = (_a22 = treeData.value[rowKey2]) == null ? void 0 : _a22.children;
          if (children) {
            count += children.length;
            children.forEach((childKey) => {
              count += getChildrenCount(childKey);
            });
          }
          return count;
        };
        const updateFilters = (columns2, values2) => {
          if (!Array.isArray(columns2)) {
            columns2 = [columns2];
          }
          const filters_ = {};
          columns2.forEach((col) => {
            filters.value[col.id] = values2;
            filters_[col.columnKey || col.id] = values2;
          });
          return filters_;
        };
        const updateSort = (column, prop, order) => {
          if (sortingColumn.value && sortingColumn.value !== column) {
            sortingColumn.value.order = null;
          }
          sortingColumn.value = column;
          sortProp.value = prop;
          sortOrder.value = order;
        };
        const execFilter = () => {
          let sourceData = unref(_data);
          Object.keys(filters.value).forEach((columnId) => {
            const values2 = filters.value[columnId];
            if (!values2 || values2.length === 0)
              return;
            const column = getColumnById({
              columns: columns.value
            }, columnId);
            if (column && column.filterMethod) {
              sourceData = sourceData.filter((row) => {
                return values2.some((value) => column.filterMethod.call(null, value, row, column));
              });
            }
          });
          filteredData.value = sourceData;
        };
        const execSort = () => {
          data.value = sortData(filteredData.value, {
            sortingColumn: sortingColumn.value,
            sortProp: sortProp.value,
            sortOrder: sortOrder.value
          });
        };
        const execQuery = (ignore = void 0) => {
          if (!(ignore && ignore.filter)) {
            execFilter();
          }
          execSort();
        };
        const clearFilter = (columnKeys) => {
          const { tableHeaderRef } = instance.refs;
          if (!tableHeaderRef)
            return;
          const panels = Object.assign({}, tableHeaderRef.filterPanels);
          const keys2 = Object.keys(panels);
          if (!keys2.length)
            return;
          if (typeof columnKeys === "string") {
            columnKeys = [columnKeys];
          }
          if (Array.isArray(columnKeys)) {
            const columns_ = columnKeys.map((key) => getColumnByKey({
              columns: columns.value
            }, key));
            keys2.forEach((key) => {
              const column = columns_.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            instance.store.commit("filterChange", {
              column: columns_,
              values: [],
              silent: true,
              multi: true
            });
          } else {
            keys2.forEach((key) => {
              const column = columns.value.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            filters.value = {};
            instance.store.commit("filterChange", {
              column: {},
              values: [],
              silent: true
            });
          }
        };
        const clearSort = () => {
          if (!sortingColumn.value)
            return;
          updateSort(null, null, null);
          instance.store.commit("changeSortCondition", {
            silent: true
          });
        };
        const {
          setExpandRowKeys,
          toggleRowExpansion,
          updateExpandRows,
          states: expandStates,
          isRowExpanded
        } = useExpand({
          data,
          rowKey
        });
        const {
          updateTreeExpandKeys,
          toggleTreeExpansion,
          updateTreeData,
          loadOrToggle,
          states: treeStates
        } = useTree({
          data,
          rowKey
        });
        const {
          updateCurrentRowData,
          updateCurrentRow,
          setCurrentRowKey,
          states: currentData
        } = useCurrent({
          data,
          rowKey
        });
        const setExpandRowKeysAdapter = (val) => {
          setExpandRowKeys(val);
          updateTreeExpandKeys(val);
        };
        const toggleRowExpansionAdapter = (row, expanded) => {
          const hasExpandColumn = columns.value.some(({ type }) => type === "expand");
          if (hasExpandColumn) {
            toggleRowExpansion(row, expanded);
          } else {
            toggleTreeExpansion(row, expanded);
          }
        };
        return {
          assertRowKey,
          updateColumns,
          scheduleLayout,
          isSelected,
          clearSelection,
          cleanSelection,
          getSelectionRows,
          toggleRowSelection,
          _toggleAllSelection,
          toggleAllSelection: null,
          updateSelectionByRowKey,
          updateAllSelected,
          updateFilters,
          updateCurrentRow,
          updateSort,
          execFilter,
          execSort,
          execQuery,
          clearFilter,
          clearSort,
          toggleRowExpansion,
          setExpandRowKeysAdapter,
          setCurrentRowKey,
          toggleRowExpansionAdapter,
          isRowExpanded,
          updateExpandRows,
          updateCurrentRowData,
          loadOrToggle,
          updateTreeData,
          states: {
            tableSize,
            rowKey,
            data,
            _data,
            isComplex,
            _columns,
            originColumns,
            columns,
            fixedColumns,
            rightFixedColumns,
            leafColumns,
            fixedLeafColumns,
            rightFixedLeafColumns,
            updateOrderFns,
            leafColumnsLength,
            fixedLeafColumnsLength,
            rightFixedLeafColumnsLength,
            isAllSelected,
            selection,
            reserveSelection,
            selectOnIndeterminate,
            selectable,
            filters,
            filteredData,
            sortingColumn,
            sortProp,
            sortOrder,
            hoverRow,
            ...expandStates,
            ...treeStates,
            ...currentData
          }
        };
      }
      function replaceColumn(array, column) {
        return array.map((item) => {
          var _a2;
          if (item.id === column.id) {
            return column;
          } else if ((_a2 = item.children) == null ? void 0 : _a2.length) {
            item.children = replaceColumn(item.children, column);
          }
          return item;
        });
      }
      function sortColumn(array) {
        array.forEach((item) => {
          var _a2, _b;
          item.no = (_a2 = item.getColumnIndex) == null ? void 0 : _a2.call(item);
          if ((_b = item.children) == null ? void 0 : _b.length) {
            sortColumn(item.children);
          }
        });
        array.sort((cur, pre) => cur.no - pre.no);
      }
      function useStore() {
        const instance = getCurrentInstance();
        const watcher = useWatcher$1();
        const ns = useNamespace("table");
        const mutations = {
          setData(states, data) {
            const dataInstanceChanged = unref(states._data) !== data;
            states.data.value = data;
            states._data.value = data;
            instance.store.execQuery();
            instance.store.updateCurrentRowData();
            instance.store.updateExpandRows();
            instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
            if (unref(states.reserveSelection)) {
              instance.store.assertRowKey();
              instance.store.updateSelectionByRowKey();
            } else {
              if (dataInstanceChanged) {
                instance.store.clearSelection();
              } else {
                instance.store.cleanSelection();
              }
            }
            instance.store.updateAllSelected();
            if (instance.$ready) {
              instance.store.scheduleLayout();
            }
          },
          insertColumn(states, column, parent, updateColumnOrder) {
            const array = unref(states._columns);
            let newColumns = [];
            if (!parent) {
              array.push(column);
              newColumns = array;
            } else {
              if (parent && !parent.children) {
                parent.children = [];
              }
              parent.children.push(column);
              newColumns = replaceColumn(array, parent);
            }
            sortColumn(newColumns);
            states._columns.value = newColumns;
            states.updateOrderFns.push(updateColumnOrder);
            if (column.type === "selection") {
              states.selectable.value = column.selectable;
              states.reserveSelection.value = column.reserveSelection;
            }
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          updateColumnOrder(states, column) {
            var _a2;
            const newColumnIndex = (_a2 = column.getColumnIndex) == null ? void 0 : _a2.call(column);
            if (newColumnIndex === column.no)
              return;
            sortColumn(states._columns.value);
            if (instance.$ready) {
              instance.store.updateColumns();
            }
          },
          removeColumn(states, column, parent, updateColumnOrder) {
            const array = unref(states._columns) || [];
            if (parent) {
              parent.children.splice(parent.children.findIndex((item) => item.id === column.id), 1);
              nextTick(() => {
                var _a2;
                if (((_a2 = parent.children) == null ? void 0 : _a2.length) === 0) {
                  delete parent.children;
                }
              });
              states._columns.value = replaceColumn(array, parent);
            } else {
              const index = array.indexOf(column);
              if (index > -1) {
                array.splice(index, 1);
                states._columns.value = array;
              }
            }
            const updateFnIndex = states.updateOrderFns.indexOf(updateColumnOrder);
            updateFnIndex > -1 && states.updateOrderFns.splice(updateFnIndex, 1);
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          sort(states, options) {
            const { prop, order, init } = options;
            if (prop) {
              const column = unref(states.columns).find((column2) => column2.property === prop);
              if (column) {
                column.order = order;
                instance.store.updateSort(column, prop, order);
                instance.store.commit("changeSortCondition", { init });
              }
            }
          },
          changeSortCondition(states, options) {
            const { sortingColumn, sortProp, sortOrder } = states;
            const columnValue = unref(sortingColumn), propValue = unref(sortProp), orderValue = unref(sortOrder);
            if (orderValue === null) {
              states.sortingColumn.value = null;
              states.sortProp.value = null;
            }
            const ignore = { filter: true };
            instance.store.execQuery(ignore);
            if (!options || !(options.silent || options.init)) {
              instance.emit("sort-change", {
                column: columnValue,
                prop: propValue,
                order: orderValue
              });
            }
            instance.store.updateTableScrollY();
          },
          filterChange(_states, options) {
            const { column, values: values2, silent } = options;
            const newFilters = instance.store.updateFilters(column, values2);
            instance.store.execQuery();
            if (!silent) {
              instance.emit("filter-change", newFilters);
            }
            instance.store.updateTableScrollY();
          },
          toggleAllSelection() {
            instance.store.toggleAllSelection();
          },
          rowSelectedChanged(_states, row) {
            instance.store.toggleRowSelection(row);
            instance.store.updateAllSelected();
          },
          setHoverRow(states, row) {
            states.hoverRow.value = row;
          },
          setCurrentRow(_states, row) {
            instance.store.updateCurrentRow(row);
          }
        };
        const commit = function(name, ...args) {
          const mutations2 = instance.store.mutations;
          if (mutations2[name]) {
            mutations2[name].apply(instance, [instance.store.states].concat(args));
          } else {
            throw new Error(`Action not found: ${name}`);
          }
        };
        const updateTableScrollY = function() {
          nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
        };
        return {
          ns,
          ...watcher,
          mutations,
          commit,
          updateTableScrollY
        };
      }
      const InitialStateMap = {
        rowKey: "rowKey",
        defaultExpandAll: "defaultExpandAll",
        selectOnIndeterminate: "selectOnIndeterminate",
        indent: "indent",
        lazy: "lazy",
        data: "data",
        ["treeProps.hasChildren"]: {
          key: "lazyColumnIdentifier",
          default: "hasChildren"
        },
        ["treeProps.children"]: {
          key: "childrenColumnName",
          default: "children"
        }
      };
      function createStore(table, props) {
        if (!table) {
          throw new Error("Table is required.");
        }
        const store = useStore();
        store.toggleAllSelection = debounce(store._toggleAllSelection, 10);
        Object.keys(InitialStateMap).forEach((key) => {
          handleValue(getArrKeysValue(props, key), key, store);
        });
        proxyTableProps(store, props);
        return store;
      }
      function proxyTableProps(store, props) {
        Object.keys(InitialStateMap).forEach((key) => {
          watch(() => getArrKeysValue(props, key), (value) => {
            handleValue(value, key, store);
          });
        });
      }
      function handleValue(value, propsKey, store) {
        let newVal = value;
        let storeKey = InitialStateMap[propsKey];
        if (typeof InitialStateMap[propsKey] === "object") {
          storeKey = storeKey.key;
          newVal = newVal || InitialStateMap[propsKey].default;
        }
        store.states[storeKey].value = newVal;
      }
      function getArrKeysValue(props, keys2) {
        if (keys2.includes(".")) {
          const keyList = keys2.split(".");
          let value = props;
          keyList.forEach((key) => {
            value = value[key];
          });
          return value;
        } else {
          return props[keys2];
        }
      }
      class TableLayout {
        constructor(options) {
          this.observers = [];
          this.table = null;
          this.store = null;
          this.columns = [];
          this.fit = true;
          this.showHeader = true;
          this.height = ref(null);
          this.scrollX = ref(false);
          this.scrollY = ref(false);
          this.bodyWidth = ref(null);
          this.fixedWidth = ref(null);
          this.rightFixedWidth = ref(null);
          this.gutterWidth = 0;
          for (const name in options) {
            if (hasOwn$1(options, name)) {
              if (isRef(this[name])) {
                this[name].value = options[name];
              } else {
                this[name] = options[name];
              }
            }
          }
          if (!this.table) {
            throw new Error("Table is required for Table Layout");
          }
          if (!this.store) {
            throw new Error("Store is required for Table Layout");
          }
        }
        updateScrollY() {
          const height = this.height.value;
          if (height === null)
            return false;
          const scrollBarRef = this.table.refs.scrollBarRef;
          if (this.table.vnode.el && (scrollBarRef == null ? void 0 : scrollBarRef.wrapRef)) {
            let scrollY = true;
            const prevScrollY = this.scrollY.value;
            scrollY = scrollBarRef.wrapRef.scrollHeight > scrollBarRef.wrapRef.clientHeight;
            this.scrollY.value = scrollY;
            return prevScrollY !== scrollY;
          }
          return false;
        }
        setHeight(value, prop = "height") {
          if (!isClient$1)
            return;
          const el = this.table.vnode.el;
          value = parseHeight(value);
          this.height.value = Number(value);
          if (!el && (value || value === 0))
            return nextTick(() => this.setHeight(value, prop));
          if (typeof value === "number") {
            el.style[prop] = `${value}px`;
            this.updateElsHeight();
          } else if (typeof value === "string") {
            el.style[prop] = value;
            this.updateElsHeight();
          }
        }
        setMaxHeight(value) {
          this.setHeight(value, "max-height");
        }
        getFlattenColumns() {
          const flattenColumns = [];
          const columns = this.table.store.states.columns.value;
          columns.forEach((column) => {
            if (column.isColumnGroup) {
              flattenColumns.push.apply(flattenColumns, column.columns);
            } else {
              flattenColumns.push(column);
            }
          });
          return flattenColumns;
        }
        updateElsHeight() {
          this.updateScrollY();
          this.notifyObservers("scrollable");
        }
        headerDisplayNone(elm) {
          if (!elm)
            return true;
          let headerChild = elm;
          while (headerChild.tagName !== "DIV") {
            if (getComputedStyle(headerChild).display === "none") {
              return true;
            }
            headerChild = headerChild.parentElement;
          }
          return false;
        }
        updateColumnsWidth() {
          if (!isClient$1)
            return;
          const fit = this.fit;
          const bodyWidth = this.table.vnode.el.clientWidth;
          let bodyMinWidth = 0;
          const flattenColumns = this.getFlattenColumns();
          const flexColumns = flattenColumns.filter((column) => typeof column.width !== "number");
          flattenColumns.forEach((column) => {
            if (typeof column.width === "number" && column.realWidth)
              column.realWidth = null;
          });
          if (flexColumns.length > 0 && fit) {
            flattenColumns.forEach((column) => {
              bodyMinWidth += Number(column.width || column.minWidth || 80);
            });
            if (bodyMinWidth <= bodyWidth) {
              this.scrollX.value = false;
              const totalFlexWidth = bodyWidth - bodyMinWidth;
              if (flexColumns.length === 1) {
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
              } else {
                const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);
                const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
                let noneFirstWidth = 0;
                flexColumns.forEach((column, index) => {
                  if (index === 0)
                    return;
                  const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
                  noneFirstWidth += flexWidth;
                  column.realWidth = Number(column.minWidth || 80) + flexWidth;
                });
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
              }
            } else {
              this.scrollX.value = true;
              flexColumns.forEach((column) => {
                column.realWidth = Number(column.minWidth);
              });
            }
            this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
            this.table.state.resizeState.value.width = this.bodyWidth.value;
          } else {
            flattenColumns.forEach((column) => {
              if (!column.width && !column.minWidth) {
                column.realWidth = 80;
              } else {
                column.realWidth = Number(column.width || column.minWidth);
              }
              bodyMinWidth += column.realWidth;
            });
            this.scrollX.value = bodyMinWidth > bodyWidth;
            this.bodyWidth.value = bodyMinWidth;
          }
          const fixedColumns = this.store.states.fixedColumns.value;
          if (fixedColumns.length > 0) {
            let fixedWidth = 0;
            fixedColumns.forEach((column) => {
              fixedWidth += Number(column.realWidth || column.width);
            });
            this.fixedWidth.value = fixedWidth;
          }
          const rightFixedColumns = this.store.states.rightFixedColumns.value;
          if (rightFixedColumns.length > 0) {
            let rightFixedWidth = 0;
            rightFixedColumns.forEach((column) => {
              rightFixedWidth += Number(column.realWidth || column.width);
            });
            this.rightFixedWidth.value = rightFixedWidth;
          }
          this.notifyObservers("columns");
        }
        addObserver(observer) {
          this.observers.push(observer);
        }
        removeObserver(observer) {
          const index = this.observers.indexOf(observer);
          if (index !== -1) {
            this.observers.splice(index, 1);
          }
        }
        notifyObservers(event) {
          const observers = this.observers;
          observers.forEach((observer) => {
            var _a2, _b;
            switch (event) {
              case "columns":
                (_a2 = observer.state) == null ? void 0 : _a2.onColumnsChange(this);
                break;
              case "scrollable":
                (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
                break;
              default:
                throw new Error(`Table Layout don't have event ${event}.`);
            }
          });
        }
      }
      const { CheckboxGroup: ElCheckboxGroup } = ElCheckbox;
      const _sfc_main$5 = /* @__PURE__ */ defineComponent({
        name: "ElTableFilterPanel",
        components: {
          ElCheckbox,
          ElCheckboxGroup,
          ElScrollbar,
          ElTooltip,
          ElIcon,
          ArrowDown: arrow_down_default,
          ArrowUp: arrow_up_default
        },
        directives: { ClickOutside },
        props: {
          placement: {
            type: String,
            default: "bottom-start"
          },
          store: {
            type: Object
          },
          column: {
            type: Object
          },
          upDataColumn: {
            type: Function
          }
        },
        setup(props) {
          const instance = getCurrentInstance();
          const { t: t2 } = useLocale();
          const ns = useNamespace("table-filter");
          const parent = instance == null ? void 0 : instance.parent;
          if (!parent.filterPanels.value[props.column.id]) {
            parent.filterPanels.value[props.column.id] = instance;
          }
          const tooltipVisible = ref(false);
          const tooltip = ref(null);
          const filters = computed(() => {
            return props.column && props.column.filters;
          });
          const filterClassName = computed(() => {
            if (props.column.filterClassName) {
              return `${ns.b()} ${props.column.filterClassName}`;
            }
            return ns.b();
          });
          const filterValue = computed({
            get: () => {
              var _a2;
              return (((_a2 = props.column) == null ? void 0 : _a2.filteredValue) || [])[0];
            },
            set: (value) => {
              if (filteredValue.value) {
                if (typeof value !== "undefined" && value !== null) {
                  filteredValue.value.splice(0, 1, value);
                } else {
                  filteredValue.value.splice(0, 1);
                }
              }
            }
          });
          const filteredValue = computed({
            get() {
              if (props.column) {
                return props.column.filteredValue || [];
              }
              return [];
            },
            set(value) {
              if (props.column) {
                props.upDataColumn("filteredValue", value);
              }
            }
          });
          const multiple = computed(() => {
            if (props.column) {
              return props.column.filterMultiple;
            }
            return true;
          });
          const isActive = (filter2) => {
            return filter2.value === filterValue.value;
          };
          const hidden = () => {
            tooltipVisible.value = false;
          };
          const showFilterPanel = (e) => {
            e.stopPropagation();
            tooltipVisible.value = !tooltipVisible.value;
          };
          const hideFilterPanel = () => {
            tooltipVisible.value = false;
          };
          const handleConfirm = () => {
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleReset = () => {
            filteredValue.value = [];
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleSelect = (_filterValue) => {
            filterValue.value = _filterValue;
            if (typeof _filterValue !== "undefined" && _filterValue !== null) {
              confirmFilter(filteredValue.value);
            } else {
              confirmFilter([]);
            }
            hidden();
          };
          const confirmFilter = (filteredValue2) => {
            props.store.commit("filterChange", {
              column: props.column,
              values: filteredValue2
            });
            props.store.updateAllSelected();
          };
          watch(tooltipVisible, (value) => {
            if (props.column) {
              props.upDataColumn("filterOpened", value);
            }
          }, {
            immediate: true
          });
          const popperPaneRef = computed(() => {
            var _a2, _b;
            return (_b = (_a2 = tooltip.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
          });
          return {
            tooltipVisible,
            multiple,
            filterClassName,
            filteredValue,
            filterValue,
            filters,
            handleConfirm,
            handleReset,
            handleSelect,
            isActive,
            t: t2,
            ns,
            showFilterPanel,
            hideFilterPanel,
            popperPaneRef,
            tooltip
          };
        }
      });
      const _hoisted_1$4 = { key: 0 };
      const _hoisted_2$3 = ["disabled"];
      const _hoisted_3$1 = ["label", "onClick"];
      function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_checkbox = resolveComponent("el-checkbox");
        const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_arrow_up = resolveComponent("arrow-up");
        const _component_arrow_down = resolveComponent("arrow-down");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _directive_click_outside = resolveDirective("click-outside");
        return openBlock(), createBlock(_component_el_tooltip, {
          ref: "tooltip",
          visible: _ctx.tooltipVisible,
          offset: 0,
          placement: _ctx.placement,
          "show-arrow": false,
          "stop-popper-mouse-event": false,
          teleported: "",
          effect: "light",
          pure: "",
          "popper-class": _ctx.filterClassName,
          persistent: ""
        }, {
          content: withCtx(() => [
            _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_1$4, [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.ns.e("content"))
              }, [
                createVNode(_component_el_scrollbar, {
                  "wrap-class": _ctx.ns.e("wrap")
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_checkbox_group, {
                      modelValue: _ctx.filteredValue,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filteredValue = $event),
                      class: normalizeClass(_ctx.ns.e("checkbox-group"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment$1, null, renderList(_ctx.filters, (filter2) => {
                          return openBlock(), createBlock(_component_el_checkbox, {
                            key: filter2.value,
                            value: filter2.value
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString$1(filter2.text), 1)
                            ]),
                            _: 2
                          }, 1032, ["value"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue", "class"])
                  ]),
                  _: 1
                }, 8, ["wrap-class"])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.ns.e("bottom"))
              }, [
                createBaseVNode("button", {
                  class: normalizeClass({ [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0 }),
                  disabled: _ctx.filteredValue.length === 0,
                  type: "button",
                  onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
                }, toDisplayString$1(_ctx.t("el.table.confirmFilter")), 11, _hoisted_2$3),
                createBaseVNode("button", {
                  type: "button",
                  onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
                }, toDisplayString$1(_ctx.t("el.table.resetFilter")), 1)
              ], 2)
            ])) : (openBlock(), createElementBlock("ul", {
              key: 1,
              class: normalizeClass(_ctx.ns.e("list"))
            }, [
              createBaseVNode("li", {
                class: normalizeClass([
                  _ctx.ns.e("list-item"),
                  {
                    [_ctx.ns.is("active")]: _ctx.filterValue === void 0 || _ctx.filterValue === null
                  }
                ]),
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleSelect(null))
              }, toDisplayString$1(_ctx.t("el.table.clearFilter")), 3),
              (openBlock(true), createElementBlock(Fragment$1, null, renderList(_ctx.filters, (filter2) => {
                return openBlock(), createElementBlock("li", {
                  key: filter2.value,
                  class: normalizeClass([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter2))]),
                  label: filter2.value,
                  onClick: ($event) => _ctx.handleSelect(filter2.value)
                }, toDisplayString$1(filter2.text), 11, _hoisted_3$1);
              }), 128))
            ], 2))
          ]),
          default: withCtx(() => [
            withDirectives((openBlock(), createElementBlock("span", {
              class: normalizeClass([
                `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
                `${_ctx.ns.namespace.value}-none-outline`
              ]),
              onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
            }, [
              createVNode(_component_el_icon, null, {
                default: withCtx(() => [
                  _ctx.column.filterOpened ? (openBlock(), createBlock(_component_arrow_up, { key: 0 })) : (openBlock(), createBlock(_component_arrow_down, { key: 1 }))
                ]),
                _: 1
              })
            ], 2)), [
              [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
            ])
          ]),
          _: 1
        }, 8, ["visible", "placement", "popper-class"]);
      }
      var FilterPanel = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$1], ["__file", "filter-panel.vue"]]);
      function useLayoutObserver(root2) {
        const instance = getCurrentInstance();
        onBeforeMount(() => {
          tableLayout.value.addObserver(instance);
        });
        onMounted(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUpdated(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUnmounted(() => {
          tableLayout.value.removeObserver(instance);
        });
        const tableLayout = computed(() => {
          const layout = root2.layout;
          if (!layout) {
            throw new Error("Can not find table layout.");
          }
          return layout;
        });
        const onColumnsChange = (layout) => {
          var _a2;
          const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col")) || [];
          if (!cols.length)
            return;
          const flattenColumns = layout.getFlattenColumns();
          const columnsMap = {};
          flattenColumns.forEach((column) => {
            columnsMap[column.id] = column;
          });
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            const name = col.getAttribute("name");
            const column = columnsMap[name];
            if (column) {
              col.setAttribute("width", column.realWidth || column.width);
            }
          }
        };
        const onScrollableChange = (layout) => {
          var _a2, _b;
          const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col[name=gutter]")) || [];
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            col.setAttribute("width", layout.scrollY.value ? layout.gutterWidth : "0");
          }
          const ths = ((_b = root2.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];
          for (let i = 0, j = ths.length; i < j; i++) {
            const th = ths[i];
            th.style.width = layout.scrollY.value ? `${layout.gutterWidth}px` : "0";
            th.style.display = layout.scrollY.value ? "" : "none";
          }
        };
        return {
          tableLayout: tableLayout.value,
          onColumnsChange,
          onScrollableChange
        };
      }
      const TABLE_INJECTION_KEY = Symbol("ElTable");
      function useEvent(props, emit2) {
        const instance = getCurrentInstance();
        const parent = inject(TABLE_INJECTION_KEY);
        const handleFilterClick = (event) => {
          event.stopPropagation();
          return;
        };
        const handleHeaderClick = (event, column) => {
          if (!column.filters && column.sortable) {
            handleSortClick(event, column, false);
          } else if (column.filterable && !column.sortable) {
            handleFilterClick(event);
          }
          parent == null ? void 0 : parent.emit("header-click", column, event);
        };
        const handleHeaderContextMenu = (event, column) => {
          parent == null ? void 0 : parent.emit("header-contextmenu", column, event);
        };
        const draggingColumn = ref(null);
        const dragging = ref(false);
        const dragState = ref({});
        const handleMouseDown = (event, column) => {
          if (!isClient$1)
            return;
          if (column.children && column.children.length > 0)
            return;
          if (draggingColumn.value && props.border) {
            dragging.value = true;
            const table = parent;
            emit2("set-drag-visible", true);
            const tableEl = table == null ? void 0 : table.vnode.el;
            const tableLeft = tableEl.getBoundingClientRect().left;
            const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
            const columnRect = columnEl.getBoundingClientRect();
            const minLeft = columnRect.left - tableLeft + 30;
            addClass(columnEl, "noclick");
            dragState.value = {
              startMouseLeft: event.clientX,
              startLeft: columnRect.right - tableLeft,
              startColumnLeft: columnRect.left - tableLeft,
              tableLeft
            };
            const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
            resizeProxy.style.left = `${dragState.value.startLeft}px`;
            document.onselectstart = function() {
              return false;
            };
            document.ondragstart = function() {
              return false;
            };
            const handleMouseMove2 = (event2) => {
              const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
              const proxyLeft = dragState.value.startLeft + deltaLeft;
              resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
            };
            const handleMouseUp = () => {
              if (dragging.value) {
                const { startColumnLeft, startLeft } = dragState.value;
                const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
                const columnWidth = finalLeft - startColumnLeft;
                column.width = column.realWidth = columnWidth;
                table == null ? void 0 : table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
                requestAnimationFrame(() => {
                  props.store.scheduleLayout(false, true);
                });
                document.body.style.cursor = "";
                dragging.value = false;
                draggingColumn.value = null;
                dragState.value = {};
                emit2("set-drag-visible", false);
              }
              document.removeEventListener("mousemove", handleMouseMove2);
              document.removeEventListener("mouseup", handleMouseUp);
              document.onselectstart = null;
              document.ondragstart = null;
              setTimeout(() => {
                removeClass(columnEl, "noclick");
              }, 0);
            };
            document.addEventListener("mousemove", handleMouseMove2);
            document.addEventListener("mouseup", handleMouseUp);
          }
        };
        const handleMouseMove = (event, column) => {
          if (column.children && column.children.length > 0)
            return;
          const el = event.target;
          if (!isElement(el)) {
            return;
          }
          const target = el == null ? void 0 : el.closest("th");
          if (!column || !column.resizable)
            return;
          if (!dragging.value && props.border) {
            const rect = target.getBoundingClientRect();
            const bodyStyle = document.body.style;
            if (rect.width > 12 && rect.right - event.pageX < 8) {
              bodyStyle.cursor = "col-resize";
              if (hasClass(target, "is-sortable")) {
                target.style.cursor = "col-resize";
              }
              draggingColumn.value = column;
            } else if (!dragging.value) {
              bodyStyle.cursor = "";
              if (hasClass(target, "is-sortable")) {
                target.style.cursor = "pointer";
              }
              draggingColumn.value = null;
            }
          }
        };
        const handleMouseOut = () => {
          if (!isClient$1)
            return;
          document.body.style.cursor = "";
        };
        const toggleOrder = ({ order, sortOrders }) => {
          if (order === "")
            return sortOrders[0];
          const index = sortOrders.indexOf(order || null);
          return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
        };
        const handleSortClick = (event, column, givenOrder) => {
          var _a2;
          event.stopPropagation();
          const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
          const target = (_a2 = event.target) == null ? void 0 : _a2.closest("th");
          if (target) {
            if (hasClass(target, "noclick")) {
              removeClass(target, "noclick");
              return;
            }
          }
          if (!column.sortable)
            return;
          const states = props.store.states;
          let sortProp = states.sortProp.value;
          let sortOrder;
          const sortingColumn = states.sortingColumn.value;
          if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
            if (sortingColumn) {
              sortingColumn.order = null;
            }
            states.sortingColumn.value = column;
            sortProp = column.property;
          }
          if (!order) {
            sortOrder = column.order = null;
          } else {
            sortOrder = column.order = order;
          }
          states.sortProp.value = sortProp;
          states.sortOrder.value = sortOrder;
          parent == null ? void 0 : parent.store.commit("changeSortCondition");
        };
        return {
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleMouseOut,
          handleSortClick,
          handleFilterClick
        };
      }
      function useStyle$2(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getHeaderRowStyle = (rowIndex) => {
          const headerRowStyle = parent == null ? void 0 : parent.props.headerRowStyle;
          if (typeof headerRowStyle === "function") {
            return headerRowStyle.call(null, { rowIndex });
          }
          return headerRowStyle;
        };
        const getHeaderRowClass = (rowIndex) => {
          const classes = [];
          const headerRowClassName = parent == null ? void 0 : parent.props.headerRowClassName;
          if (typeof headerRowClassName === "string") {
            classes.push(headerRowClassName);
          } else if (typeof headerRowClassName === "function") {
            classes.push(headerRowClassName.call(null, { rowIndex }));
          }
          return classes.join(" ");
        };
        const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
          var _a2;
          let headerCellStyles = (_a2 = parent == null ? void 0 : parent.props.headerCellStyle) != null ? _a2 : {};
          if (typeof headerCellStyles === "function") {
            headerCellStyles = headerCellStyles.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, column.fixed, props.store, row);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, headerCellStyles, fixedStyle);
        };
        const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, column.fixed, props.store, row);
          const classes = [
            column.id,
            column.order,
            column.headerAlign,
            column.className,
            column.labelClassName,
            ...fixedClasses
          ];
          if (!column.children) {
            classes.push("is-leaf");
          }
          if (column.sortable) {
            classes.push("is-sortable");
          }
          const headerCellClassName = parent == null ? void 0 : parent.props.headerCellClassName;
          if (typeof headerCellClassName === "string") {
            classes.push(headerCellClassName);
          } else if (typeof headerCellClassName === "function") {
            classes.push(headerCellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        return {
          getHeaderRowStyle,
          getHeaderRowClass,
          getHeaderCellStyle,
          getHeaderCellClass
        };
      }
      const getAllColumns = (columns) => {
        const result = [];
        columns.forEach((column) => {
          if (column.children) {
            result.push(column);
            result.push.apply(result, getAllColumns(column.children));
          } else {
            result.push(column);
          }
        });
        return result;
      };
      const convertToRows = (originColumns) => {
        let maxLevel = 1;
        const traverse2 = (column, parent) => {
          if (parent) {
            column.level = parent.level + 1;
            if (maxLevel < column.level) {
              maxLevel = column.level;
            }
          }
          if (column.children) {
            let colSpan = 0;
            column.children.forEach((subColumn) => {
              traverse2(subColumn, column);
              colSpan += subColumn.colSpan;
            });
            column.colSpan = colSpan;
          } else {
            column.colSpan = 1;
          }
        };
        originColumns.forEach((column) => {
          column.level = 1;
          traverse2(column, void 0);
        });
        const rows = [];
        for (let i = 0; i < maxLevel; i++) {
          rows.push([]);
        }
        const allColumns = getAllColumns(originColumns);
        allColumns.forEach((column) => {
          if (!column.children) {
            column.rowSpan = maxLevel - column.level + 1;
          } else {
            column.rowSpan = 1;
            column.children.forEach((col) => col.isSubColumn = true);
          }
          rows[column.level - 1].push(column);
        });
        return rows;
      };
      function useUtils$1(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const columnRows = computed(() => {
          return convertToRows(props.store.states.originColumns.value);
        });
        const isGroup = computed(() => {
          const result = columnRows.value.length > 1;
          if (result && parent) {
            parent.state.isGroup.value = true;
          }
          return result;
        });
        const toggleAllSelection = (event) => {
          event.stopPropagation();
          parent == null ? void 0 : parent.store.commit("toggleAllSelection");
        };
        return {
          isGroup,
          toggleAllSelection,
          columnRows
        };
      }
      var TableHeader = /* @__PURE__ */ defineComponent({
        name: "ElTableHeader",
        components: {
          ElCheckbox
        },
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          }
        },
        setup(props, { emit: emit2 }) {
          const instance = getCurrentInstance();
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const filterPanels = ref({});
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
          onMounted(async () => {
            await nextTick();
            await nextTick();
            const { prop, order } = props.defaultSort;
            parent == null ? void 0 : parent.store.commit("sort", { prop, order, init: true });
          });
          const {
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick
          } = useEvent(props, emit2);
          const {
            getHeaderRowStyle,
            getHeaderRowClass,
            getHeaderCellStyle,
            getHeaderCellClass
          } = useStyle$2(props);
          const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props);
          instance.state = {
            onColumnsChange,
            onScrollableChange
          };
          instance.filterPanels = filterPanels;
          return {
            ns,
            filterPanels,
            onColumnsChange,
            onScrollableChange,
            columnRows,
            getHeaderRowClass,
            getHeaderRowStyle,
            getHeaderCellClass,
            getHeaderCellStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick,
            isGroup,
            toggleAllSelection
          };
        },
        render() {
          const {
            ns,
            isGroup,
            columnRows,
            getHeaderCellStyle,
            getHeaderCellClass,
            getHeaderRowClass,
            getHeaderRowStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleSortClick,
            handleMouseOut,
            store,
            $parent
          } = this;
          let rowSpan = 1;
          return h$1("thead", {
            class: { [ns.is("group")]: isGroup }
          }, columnRows.map((subColumns, rowIndex) => h$1("tr", {
            class: getHeaderRowClass(rowIndex),
            key: rowIndex,
            style: getHeaderRowStyle(rowIndex)
          }, subColumns.map((column, cellIndex) => {
            if (column.rowSpan > rowSpan) {
              rowSpan = column.rowSpan;
            }
            return h$1("th", {
              class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
              colspan: column.colSpan,
              key: `${column.id}-thead`,
              rowspan: column.rowSpan,
              style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
              onClick: ($event) => handleHeaderClick($event, column),
              onContextmenu: ($event) => handleHeaderContextMenu($event, column),
              onMousedown: ($event) => handleMouseDown($event, column),
              onMousemove: ($event) => handleMouseMove($event, column),
              onMouseout: handleMouseOut
            }, [
              h$1("div", {
                class: [
                  "cell",
                  column.filteredValue && column.filteredValue.length > 0 ? "highlight" : ""
                ]
              }, [
                column.renderHeader ? column.renderHeader({
                  column,
                  $index: cellIndex,
                  store,
                  _self: $parent
                }) : column.label,
                column.sortable && h$1("span", {
                  onClick: ($event) => handleSortClick($event, column),
                  class: "caret-wrapper"
                }, [
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "ascending"),
                    class: "sort-caret ascending"
                  }),
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "descending"),
                    class: "sort-caret descending"
                  })
                ]),
                column.filterable && h$1(FilterPanel, {
                  store,
                  placement: column.filterPlacement || "bottom-start",
                  column,
                  upDataColumn: (key, value) => {
                    column[key] = value;
                  }
                })
              ])
            ]);
          }))));
        }
      });
      function useEvents(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const tooltipContent = ref("");
        const tooltipTrigger = ref(h$1("div"));
        const handleEvent = (event, row, name) => {
          var _a2;
          const table = parent;
          const cell = getCell(event);
          let column;
          const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
          if (cell) {
            column = getColumnByCell({
              columns: props.store.states.columns.value
            }, cell, namespace);
            if (column) {
              table == null ? void 0 : table.emit(`cell-${name}`, row, column, cell, event);
            }
          }
          table == null ? void 0 : table.emit(`row-${name}`, row, column, event);
        };
        const handleDoubleClick = (event, row) => {
          handleEvent(event, row, "dblclick");
        };
        const handleClick = (event, row) => {
          props.store.commit("setCurrentRow", row);
          handleEvent(event, row, "click");
        };
        const handleContextMenu = (event, row) => {
          handleEvent(event, row, "contextmenu");
        };
        const handleMouseEnter = debounce((index) => {
          props.store.commit("setHoverRow", index);
        }, 30);
        const handleMouseLeave = debounce(() => {
          props.store.commit("setHoverRow", null);
        }, 30);
        const getPadding = (el) => {
          const style = window.getComputedStyle(el, null);
          const paddingLeft = Number.parseInt(style.paddingLeft, 10) || 0;
          const paddingRight = Number.parseInt(style.paddingRight, 10) || 0;
          const paddingTop = Number.parseInt(style.paddingTop, 10) || 0;
          const paddingBottom = Number.parseInt(style.paddingBottom, 10) || 0;
          return {
            left: paddingLeft,
            right: paddingRight,
            top: paddingTop,
            bottom: paddingBottom
          };
        };
        const toggleRowClassByCell = (rowSpan, event, toggle) => {
          let node = event.target.parentNode;
          while (rowSpan > 1) {
            node = node == null ? void 0 : node.nextSibling;
            if (!node || node.nodeName !== "TR")
              break;
            toggle(node, "hover-row hover-fixed-row");
            rowSpan--;
          }
        };
        const handleCellMouseEnter = (event, row, tooltipOptions) => {
          var _a2;
          const table = parent;
          const cell = getCell(event);
          const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
          if (cell) {
            const column = getColumnByCell({
              columns: props.store.states.columns.value
            }, cell, namespace);
            if (cell.rowSpan > 1) {
              toggleRowClassByCell(cell.rowSpan, event, addClass);
            }
            const hoverState = table.hoverState = { cell, column, row };
            table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
          }
          if (!tooltipOptions) {
            return;
          }
          const cellChild = event.target.querySelector(".cell");
          if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
            return;
          }
          const range2 = document.createRange();
          range2.setStart(cellChild, 0);
          range2.setEnd(cellChild, cellChild.childNodes.length);
          let rangeWidth = range2.getBoundingClientRect().width;
          let rangeHeight = range2.getBoundingClientRect().height;
          const offsetWidth = rangeWidth - Math.floor(rangeWidth);
          if (offsetWidth < 1e-3) {
            rangeWidth = Math.floor(rangeWidth);
          }
          const offsetHeight = rangeHeight - Math.floor(rangeHeight);
          if (offsetHeight < 1e-3) {
            rangeHeight = Math.floor(rangeHeight);
          }
          const { top, left: left2, right: right2, bottom } = getPadding(cellChild);
          const horizontalPadding = left2 + right2;
          const verticalPadding = top + bottom;
          if (rangeWidth + horizontalPadding > cellChild.offsetWidth || rangeHeight + verticalPadding > cellChild.offsetHeight || cellChild.scrollWidth > cellChild.offsetWidth) {
            createTablePopper(tooltipOptions, cell.innerText || cell.textContent, cell, table);
          }
        };
        const handleCellMouseLeave = (event) => {
          const cell = getCell(event);
          if (!cell)
            return;
          if (cell.rowSpan > 1) {
            toggleRowClassByCell(cell.rowSpan, event, removeClass);
          }
          const oldHoverState = parent == null ? void 0 : parent.hoverState;
          parent == null ? void 0 : parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
        };
        return {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        };
      }
      function useStyles(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getRowStyle = (row, rowIndex) => {
          const rowStyle = parent == null ? void 0 : parent.props.rowStyle;
          if (typeof rowStyle === "function") {
            return rowStyle.call(null, {
              row,
              rowIndex
            });
          }
          return rowStyle || null;
        };
        const getRowClass = (row, rowIndex) => {
          const classes = [ns.e("row")];
          if ((parent == null ? void 0 : parent.props.highlightCurrentRow) && row === props.store.states.currentRow.value) {
            classes.push("current-row");
          }
          if (props.stripe && rowIndex % 2 === 1) {
            classes.push(ns.em("row", "striped"));
          }
          const rowClassName = parent == null ? void 0 : parent.props.rowClassName;
          if (typeof rowClassName === "string") {
            classes.push(rowClassName);
          } else if (typeof rowClassName === "function") {
            classes.push(rowClassName.call(null, {
              row,
              rowIndex
            }));
          }
          return classes;
        };
        const getCellStyle = (rowIndex, columnIndex, row, column) => {
          const cellStyle = parent == null ? void 0 : parent.props.cellStyle;
          let cellStyles = cellStyle != null ? cellStyle : {};
          if (typeof cellStyle === "function") {
            cellStyles = cellStyle.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, props == null ? void 0 : props.fixed, props.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, cellStyles, fixedStyle);
        };
        const getCellClass = (rowIndex, columnIndex, row, column, offset) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, props == null ? void 0 : props.fixed, props.store, void 0, offset);
          const classes = [column.id, column.align, column.className, ...fixedClasses];
          const cellClassName = parent == null ? void 0 : parent.props.cellClassName;
          if (typeof cellClassName === "string") {
            classes.push(cellClassName);
          } else if (typeof cellClassName === "function") {
            classes.push(cellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        const getSpan = (row, column, rowIndex, columnIndex) => {
          let rowspan = 1;
          let colspan = 1;
          const fn2 = parent == null ? void 0 : parent.props.spanMethod;
          if (typeof fn2 === "function") {
            const result = fn2({
              row,
              column,
              rowIndex,
              columnIndex
            });
            if (Array.isArray(result)) {
              rowspan = result[0];
              colspan = result[1];
            } else if (typeof result === "object") {
              rowspan = result.rowspan;
              colspan = result.colspan;
            }
          }
          return { rowspan, colspan };
        };
        const getColspanRealWidth = (columns, colspan, index) => {
          if (colspan < 1) {
            return columns[index].realWidth;
          }
          const widthArr = columns.map(({ realWidth, width }) => realWidth || width).slice(index, index + colspan);
          return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
        };
        return {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        };
      }
      function useRender$1(props) {
        const parent = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        } = useEvents(props);
        const {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        } = useStyles(props);
        const firstDefaultColumnIndex = computed(() => {
          return props.store.states.columns.value.findIndex(({ type }) => type === "default");
        });
        const getKeyOfRow = (row, index) => {
          const rowKey = parent.props.rowKey;
          if (rowKey) {
            return getRowIdentity(row, rowKey);
          }
          return index;
        };
        const rowRender = (row, $index, treeRowData, expanded = false) => {
          const { tooltipEffect, tooltipOptions, store } = props;
          const { indent, columns } = store.states;
          const rowClasses = getRowClass(row, $index);
          let display = true;
          if (treeRowData) {
            rowClasses.push(ns.em("row", `level-${treeRowData.level}`));
            display = treeRowData.display;
          }
          const displayStyle = display ? null : {
            display: "none"
          };
          return h$1("tr", {
            style: [displayStyle, getRowStyle(row, $index)],
            class: rowClasses,
            key: getKeyOfRow(row, $index),
            onDblclick: ($event) => handleDoubleClick($event, row),
            onClick: ($event) => handleClick($event, row),
            onContextmenu: ($event) => handleContextMenu($event, row),
            onMouseenter: () => handleMouseEnter($index),
            onMouseleave: handleMouseLeave
          }, columns.value.map((column, cellIndex) => {
            const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
            if (!rowspan || !colspan) {
              return null;
            }
            const columnData = Object.assign({}, column);
            columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
            const data = {
              store: props.store,
              _self: props.context || parent,
              column: columnData,
              row,
              $index,
              cellIndex,
              expanded
            };
            if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
              data.treeNode = {
                indent: treeRowData.level * indent.value,
                level: treeRowData.level
              };
              if (typeof treeRowData.expanded === "boolean") {
                data.treeNode.expanded = treeRowData.expanded;
                if ("loading" in treeRowData) {
                  data.treeNode.loading = treeRowData.loading;
                }
                if ("noLazyChildren" in treeRowData) {
                  data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
                }
              }
            }
            const baseKey = `${$index},${cellIndex}`;
            const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
            const tdChildren = cellChildren(cellIndex, column, data);
            const mergedTooltipOptions = column.showOverflowTooltip && merge$1({
              effect: tooltipEffect
            }, tooltipOptions, column.showOverflowTooltip);
            return h$1("td", {
              style: getCellStyle($index, cellIndex, row, column),
              class: getCellClass($index, cellIndex, row, column, colspan - 1),
              key: `${patchKey}${baseKey}`,
              rowspan,
              colspan,
              onMouseenter: ($event) => handleCellMouseEnter($event, row, mergedTooltipOptions),
              onMouseleave: handleCellMouseLeave
            }, [tdChildren]);
          }));
        };
        const cellChildren = (cellIndex, column, data) => {
          return column.renderCell(data);
        };
        const wrappedRowRender = (row, $index) => {
          const store = props.store;
          const { isRowExpanded, assertRowKey } = store;
          const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey } = store.states;
          const columns = store.states.columns.value;
          const hasExpandColumn = columns.some(({ type }) => type === "expand");
          if (hasExpandColumn) {
            const expanded = isRowExpanded(row);
            const tr = rowRender(row, $index, void 0, expanded);
            const renderExpanded = parent.renderExpanded;
            if (expanded) {
              if (!renderExpanded) {
                console.error("[Element Error]renderExpanded is required.");
                return tr;
              }
              return [
                [
                  tr,
                  h$1("tr", {
                    key: `expanded-row__${tr.key}`
                  }, [
                    h$1("td", {
                      colspan: columns.length,
                      class: `${ns.e("cell")} ${ns.e("expanded-cell")}`
                    }, [renderExpanded({ row, $index, store, expanded })])
                  ])
                ]
              ];
            } else {
              return [[tr]];
            }
          } else if (Object.keys(treeData.value).length) {
            assertRowKey();
            const key = getRowIdentity(row, rowKey.value);
            let cur = treeData.value[key];
            let treeRowData = null;
            if (cur) {
              treeRowData = {
                expanded: cur.expanded,
                level: cur.level,
                display: true
              };
              if (typeof cur.lazy === "boolean") {
                if (typeof cur.loaded === "boolean" && cur.loaded) {
                  treeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }
                treeRowData.loading = cur.loading;
              }
            }
            const tmp = [rowRender(row, $index, treeRowData)];
            if (cur) {
              let i = 0;
              const traverse2 = (children, parent2) => {
                if (!(children && children.length && parent2))
                  return;
                children.forEach((node) => {
                  const innerTreeRowData = {
                    display: parent2.display && parent2.expanded,
                    level: parent2.level + 1,
                    expanded: false,
                    noLazyChildren: false,
                    loading: false
                  };
                  const childKey = getRowIdentity(node, rowKey.value);
                  if (childKey === void 0 || childKey === null) {
                    throw new Error("For nested data item, row-key is required.");
                  }
                  cur = { ...treeData.value[childKey] };
                  if (cur) {
                    innerTreeRowData.expanded = cur.expanded;
                    cur.level = cur.level || innerTreeRowData.level;
                    cur.display = !!(cur.expanded && innerTreeRowData.display);
                    if (typeof cur.lazy === "boolean") {
                      if (typeof cur.loaded === "boolean" && cur.loaded) {
                        innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                      }
                      innerTreeRowData.loading = cur.loading;
                    }
                  }
                  i++;
                  tmp.push(rowRender(node, $index + i, innerTreeRowData));
                  if (cur) {
                    const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
                    traverse2(nodes2, cur);
                  }
                });
              };
              cur.display = true;
              const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
              traverse2(nodes, cur);
            }
            return tmp;
          } else {
            return rowRender(row, $index, void 0);
          }
        };
        return {
          wrappedRowRender,
          tooltipContent,
          tooltipTrigger
        };
      }
      const defaultProps$2 = {
        store: {
          required: true,
          type: Object
        },
        stripe: Boolean,
        tooltipEffect: String,
        tooltipOptions: {
          type: Object
        },
        context: {
          default: () => ({}),
          type: Object
        },
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        fixed: {
          type: String,
          default: ""
        },
        highlight: Boolean
      };
      var TableBody = /* @__PURE__ */ defineComponent({
        name: "ElTableBody",
        props: defaultProps$2,
        setup(props) {
          const instance = getCurrentInstance();
          const parent = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender$1(props);
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
          const hoveredCellList = [];
          watch(props.store.states.hoverRow, (newVal, oldVal) => {
            var _a2;
            const el = instance == null ? void 0 : instance.vnode.el;
            const rows = Array.from((el == null ? void 0 : el.children) || []).filter((e) => e == null ? void 0 : e.classList.contains(`${ns.e("row")}`));
            let rowNum = newVal;
            const childNodes = (_a2 = rows[rowNum]) == null ? void 0 : _a2.childNodes;
            if (childNodes == null ? void 0 : childNodes.length) {
              let control = 0;
              const indexes = Array.from(childNodes).reduce((acc, item, index) => {
                var _a22, _b;
                if (((_a22 = childNodes[index]) == null ? void 0 : _a22.colSpan) > 1) {
                  control = (_b = childNodes[index]) == null ? void 0 : _b.colSpan;
                }
                if (item.nodeName !== "TD" && control === 0) {
                  acc.push(index);
                }
                control > 0 && control--;
                return acc;
              }, []);
              indexes.forEach((rowIndex) => {
                var _a22;
                while (rowNum > 0) {
                  const preChildNodes = (_a22 = rows[rowNum - 1]) == null ? void 0 : _a22.childNodes;
                  if (preChildNodes[rowIndex] && preChildNodes[rowIndex].nodeName === "TD" && preChildNodes[rowIndex].rowSpan > 1) {
                    addClass(preChildNodes[rowIndex], "hover-cell");
                    hoveredCellList.push(preChildNodes[rowIndex]);
                    break;
                  }
                  rowNum--;
                }
              });
            } else {
              hoveredCellList.forEach((item) => removeClass(item, "hover-cell"));
              hoveredCellList.length = 0;
            }
            if (!props.store.states.isComplex.value || !isClient$1)
              return;
            rAF(() => {
              const oldRow = rows[oldVal];
              const newRow = rows[newVal];
              if (oldRow && !oldRow.classList.contains("hover-fixed-row")) {
                removeClass(oldRow, "hover-row");
              }
              if (newRow) {
                addClass(newRow, "hover-row");
              }
            });
          });
          onUnmounted(() => {
            var _a2;
            (_a2 = removePopper) == null ? void 0 : _a2();
          });
          return {
            ns,
            onColumnsChange,
            onScrollableChange,
            wrappedRowRender,
            tooltipContent,
            tooltipTrigger
          };
        },
        render() {
          const { wrappedRowRender, store } = this;
          const data = store.states.data.value || [];
          return h$1("tbody", { tabIndex: -1 }, [
            data.reduce((acc, row) => {
              return acc.concat(wrappedRowRender(row, acc.length));
            }, [])
          ]);
        }
      });
      function useMapState() {
        const table = inject(TABLE_INJECTION_KEY);
        const store = table == null ? void 0 : table.store;
        const leftFixedLeafCount = computed(() => {
          return store.states.fixedLeafColumnsLength.value;
        });
        const rightFixedLeafCount = computed(() => {
          return store.states.rightFixedColumns.value.length;
        });
        const columnsCount = computed(() => {
          return store.states.columns.value.length;
        });
        const leftFixedCount = computed(() => {
          return store.states.fixedColumns.value.length;
        });
        const rightFixedCount = computed(() => {
          return store.states.rightFixedColumns.value.length;
        });
        return {
          leftFixedLeafCount,
          rightFixedLeafCount,
          columnsCount,
          leftFixedCount,
          rightFixedCount,
          columns: store.states.columns
        };
      }
      function useStyle$1(props) {
        const { columns } = useMapState();
        const ns = useNamespace("table");
        const getCellClasses = (columns2, cellIndex) => {
          const column = columns2[cellIndex];
          const classes = [
            ns.e("cell"),
            column.id,
            column.align,
            column.labelClassName,
            ...getFixedColumnsClass(ns.b(), cellIndex, column.fixed, props.store)
          ];
          if (column.className) {
            classes.push(column.className);
          }
          if (!column.children) {
            classes.push(ns.is("leaf"));
          }
          return classes;
        };
        const getCellStyles = (column, cellIndex) => {
          const fixedStyle = getFixedColumnOffset(cellIndex, column.fixed, props.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return fixedStyle;
        };
        return {
          getCellClasses,
          getCellStyles,
          columns
        };
      }
      var TableFooter = /* @__PURE__ */ defineComponent({
        name: "ElTableFooter",
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          summaryMethod: Function,
          sumText: String,
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          }
        },
        setup(props) {
          const { getCellClasses, getCellStyles, columns } = useStyle$1(props);
          const ns = useNamespace("table");
          return {
            ns,
            getCellClasses,
            getCellStyles,
            columns
          };
        },
        render() {
          const { columns, getCellStyles, getCellClasses, summaryMethod, sumText } = this;
          const data = this.store.states.data.value;
          let sums = [];
          if (summaryMethod) {
            sums = summaryMethod({
              columns,
              data
            });
          } else {
            columns.forEach((column, index) => {
              if (index === 0) {
                sums[index] = sumText;
                return;
              }
              const values2 = data.map((item) => Number(item[column.property]));
              const precisions = [];
              let notNumber = true;
              values2.forEach((value) => {
                if (!Number.isNaN(+value)) {
                  notNumber = false;
                  const decimal = `${value}`.split(".")[1];
                  precisions.push(decimal ? decimal.length : 0);
                }
              });
              const precision = Math.max.apply(null, precisions);
              if (!notNumber) {
                sums[index] = values2.reduce((prev, curr) => {
                  const value = Number(curr);
                  if (!Number.isNaN(+value)) {
                    return Number.parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
                  } else {
                    return prev;
                  }
                }, 0);
              } else {
                sums[index] = "";
              }
            });
          }
          return h$1(h$1("tfoot", [
            h$1("tr", {}, [
              ...columns.map((column, cellIndex) => h$1("td", {
                key: cellIndex,
                colspan: column.colSpan,
                rowspan: column.rowSpan,
                class: getCellClasses(columns, cellIndex),
                style: getCellStyles(column, cellIndex)
              }, [
                h$1("div", {
                  class: ["cell", column.labelClassName]
                }, [sums[cellIndex]])
              ]))
            ])
          ]));
        }
      });
      function useUtils(store) {
        const setCurrentRow = (row) => {
          store.commit("setCurrentRow", row);
        };
        const getSelectionRows = () => {
          return store.getSelectionRows();
        };
        const toggleRowSelection = (row, selected) => {
          store.toggleRowSelection(row, selected, false);
          store.updateAllSelected();
        };
        const clearSelection = () => {
          store.clearSelection();
        };
        const clearFilter = (columnKeys) => {
          store.clearFilter(columnKeys);
        };
        const toggleAllSelection = () => {
          store.commit("toggleAllSelection");
        };
        const toggleRowExpansion = (row, expanded) => {
          store.toggleRowExpansionAdapter(row, expanded);
        };
        const clearSort = () => {
          store.clearSort();
        };
        const sort = (prop, order) => {
          store.commit("sort", { prop, order });
        };
        return {
          setCurrentRow,
          getSelectionRows,
          toggleRowSelection,
          clearSelection,
          clearFilter,
          toggleAllSelection,
          toggleRowExpansion,
          clearSort,
          sort
        };
      }
      function useStyle(props, layout, store, table) {
        const isHidden2 = ref(false);
        const renderExpanded = ref(null);
        const resizeProxyVisible = ref(false);
        const setDragVisible = (visible) => {
          resizeProxyVisible.value = visible;
        };
        const resizeState = ref({
          width: null,
          height: null,
          headerHeight: null
        });
        const isGroup = ref(false);
        const scrollbarViewStyle = {
          display: "inline-block",
          verticalAlign: "middle"
        };
        const tableWidth = ref();
        const tableScrollHeight = ref(0);
        const bodyScrollHeight = ref(0);
        const headerScrollHeight = ref(0);
        const footerScrollHeight = ref(0);
        const appendScrollHeight = ref(0);
        watchEffect(() => {
          layout.setHeight(props.height);
        });
        watchEffect(() => {
          layout.setMaxHeight(props.maxHeight);
        });
        watch(() => [props.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey]) => {
          if (!unref(rowKey) || !unref(currentRowKey))
            return;
          store.setCurrentRowKey(`${currentRowKey}`);
        }, {
          immediate: true
        });
        watch(() => props.data, (data) => {
          table.store.commit("setData", data);
        }, {
          immediate: true,
          deep: true
        });
        watchEffect(() => {
          if (props.expandRowKeys) {
            store.setExpandRowKeysAdapter(props.expandRowKeys);
          }
        });
        const handleMouseLeave = () => {
          table.store.commit("setHoverRow", null);
          if (table.hoverState)
            table.hoverState = null;
        };
        const handleHeaderFooterMousewheel = (event, data) => {
          const { pixelX, pixelY } = data;
          if (Math.abs(pixelX) >= Math.abs(pixelY)) {
            table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
          }
        };
        const shouldUpdateHeight = computed(() => {
          return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
        });
        const tableBodyStyles = computed(() => {
          return {
            width: layout.bodyWidth.value ? `${layout.bodyWidth.value}px` : ""
          };
        });
        const doLayout = () => {
          if (shouldUpdateHeight.value) {
            layout.updateElsHeight();
          }
          layout.updateColumnsWidth();
          requestAnimationFrame(syncPosition);
        };
        onMounted(async () => {
          await nextTick();
          store.updateColumns();
          bindEvents();
          requestAnimationFrame(doLayout);
          const el = table.vnode.el;
          const tableHeader = table.refs.headerWrapper;
          if (props.flexible && el && el.parentElement) {
            el.parentElement.style.minWidth = "0";
          }
          resizeState.value = {
            width: tableWidth.value = el.offsetWidth,
            height: el.offsetHeight,
            headerHeight: props.showHeader && tableHeader ? tableHeader.offsetHeight : null
          };
          store.states.columns.value.forEach((column) => {
            if (column.filteredValue && column.filteredValue.length) {
              table.store.commit("filterChange", {
                column,
                values: column.filteredValue,
                silent: true
              });
            }
          });
          table.$ready = true;
        });
        const setScrollClassByEl = (el, className) => {
          if (!el)
            return;
          const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
          classList.push(layout.scrollX.value ? className : "is-scrolling-none");
          el.className = classList.join(" ");
        };
        const setScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          setScrollClassByEl(tableWrapper, className);
        };
        const hasScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          return !!(tableWrapper && tableWrapper.classList.contains(className));
        };
        const syncPosition = function() {
          if (!table.refs.scrollBarRef)
            return;
          if (!layout.scrollX.value) {
            const scrollingNoneClass = "is-scrolling-none";
            if (!hasScrollClass(scrollingNoneClass)) {
              setScrollClass(scrollingNoneClass);
            }
            return;
          }
          const scrollContainer = table.refs.scrollBarRef.wrapRef;
          if (!scrollContainer)
            return;
          const { scrollLeft, offsetWidth, scrollWidth } = scrollContainer;
          const { headerWrapper, footerWrapper } = table.refs;
          if (headerWrapper)
            headerWrapper.scrollLeft = scrollLeft;
          if (footerWrapper)
            footerWrapper.scrollLeft = scrollLeft;
          const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
          if (scrollLeft >= maxScrollLeftPosition) {
            setScrollClass("is-scrolling-right");
          } else if (scrollLeft === 0) {
            setScrollClass("is-scrolling-left");
          } else {
            setScrollClass("is-scrolling-middle");
          }
        };
        const bindEvents = () => {
          if (!table.refs.scrollBarRef)
            return;
          if (table.refs.scrollBarRef.wrapRef) {
            useEventListener$1(table.refs.scrollBarRef.wrapRef, "scroll", syncPosition, {
              passive: true
            });
          }
          if (props.fit) {
            useResizeObserver(table.vnode.el, resizeListener);
          } else {
            useEventListener$1(window, "resize", resizeListener);
          }
          useResizeObserver(table.refs.bodyWrapper, () => {
            var _a2, _b;
            resizeListener();
            (_b = (_a2 = table.refs) == null ? void 0 : _a2.scrollBarRef) == null ? void 0 : _b.update();
          });
        };
        const resizeListener = () => {
          var _a2, _b, _c, _d;
          const el = table.vnode.el;
          if (!table.$ready || !el)
            return;
          let shouldUpdateLayout = false;
          const {
            width: oldWidth,
            height: oldHeight,
            headerHeight: oldHeaderHeight
          } = resizeState.value;
          const width = tableWidth.value = el.offsetWidth;
          if (oldWidth !== width) {
            shouldUpdateLayout = true;
          }
          const height = el.offsetHeight;
          if ((props.height || shouldUpdateHeight.value) && oldHeight !== height) {
            shouldUpdateLayout = true;
          }
          const tableHeader = props.tableLayout === "fixed" ? table.refs.headerWrapper : (_a2 = table.refs.tableHeaderRef) == null ? void 0 : _a2.$el;
          if (props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) !== oldHeaderHeight) {
            shouldUpdateLayout = true;
          }
          tableScrollHeight.value = ((_b = table.refs.tableWrapper) == null ? void 0 : _b.scrollHeight) || 0;
          headerScrollHeight.value = (tableHeader == null ? void 0 : tableHeader.scrollHeight) || 0;
          footerScrollHeight.value = ((_c = table.refs.footerWrapper) == null ? void 0 : _c.offsetHeight) || 0;
          appendScrollHeight.value = ((_d = table.refs.appendWrapper) == null ? void 0 : _d.offsetHeight) || 0;
          bodyScrollHeight.value = tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value - appendScrollHeight.value;
          if (shouldUpdateLayout) {
            resizeState.value = {
              width,
              height,
              headerHeight: props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) || 0
            };
            doLayout();
          }
        };
        const tableSize = useFormSize();
        const bodyWidth = computed(() => {
          const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout;
          return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
        });
        const tableLayout = computed(() => {
          if (props.maxHeight)
            return "fixed";
          return props.tableLayout;
        });
        const emptyBlockStyle = computed(() => {
          if (props.data && props.data.length)
            return null;
          let height = "100%";
          if (props.height && bodyScrollHeight.value) {
            height = `${bodyScrollHeight.value}px`;
          }
          const width = tableWidth.value;
          return {
            width: width ? `${width}px` : "",
            height
          };
        });
        const tableInnerStyle = computed(() => {
          if (props.height) {
            return {
              height: !Number.isNaN(Number(props.height)) ? `${props.height}px` : props.height
            };
          }
          if (props.maxHeight) {
            return {
              maxHeight: !Number.isNaN(Number(props.maxHeight)) ? `${props.maxHeight}px` : props.maxHeight
            };
          }
          return {};
        });
        const scrollbarStyle = computed(() => {
          if (props.height) {
            return {
              height: "100%"
            };
          }
          if (props.maxHeight) {
            if (!Number.isNaN(Number(props.maxHeight))) {
              return {
                maxHeight: `${props.maxHeight - headerScrollHeight.value - footerScrollHeight.value}px`
              };
            } else {
              return {
                maxHeight: `calc(${props.maxHeight} - ${headerScrollHeight.value + footerScrollHeight.value}px)`
              };
            }
          }
          return {};
        });
        const handleFixedMousewheel = (event, data) => {
          const bodyWrapper = table.refs.bodyWrapper;
          if (Math.abs(data.spinY) > 0) {
            const currentScrollTop = bodyWrapper.scrollTop;
            if (data.pixelY < 0 && currentScrollTop !== 0) {
              event.preventDefault();
            }
            if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
              event.preventDefault();
            }
            bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
          } else {
            bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
          }
        };
        return {
          isHidden: isHidden2,
          renderExpanded,
          setDragVisible,
          isGroup,
          handleMouseLeave,
          handleHeaderFooterMousewheel,
          tableSize,
          emptyBlockStyle,
          handleFixedMousewheel,
          resizeProxyVisible,
          bodyWidth,
          resizeState,
          doLayout,
          tableBodyStyles,
          tableLayout,
          scrollbarViewStyle,
          tableInnerStyle,
          scrollbarStyle
        };
      }
      function useKeyRender(table) {
        const observer = ref();
        const initWatchDom = () => {
          const el = table.vnode.el;
          const columnsWrapper = el.querySelector(".hidden-columns");
          const config = { childList: true, subtree: true };
          const updateOrderFns = table.store.states.updateOrderFns;
          observer.value = new MutationObserver(() => {
            updateOrderFns.forEach((fn2) => fn2());
          });
          observer.value.observe(columnsWrapper, config);
        };
        onMounted(() => {
          initWatchDom();
        });
        onUnmounted(() => {
          var _a2;
          (_a2 = observer.value) == null ? void 0 : _a2.disconnect();
        });
      }
      var defaultProps$1 = {
        data: {
          type: Array,
          default: () => []
        },
        size: useSizeProp,
        width: [String, Number],
        height: [String, Number],
        maxHeight: [String, Number],
        fit: {
          type: Boolean,
          default: true
        },
        stripe: Boolean,
        border: Boolean,
        rowKey: [String, Function],
        showHeader: {
          type: Boolean,
          default: true
        },
        showSummary: Boolean,
        sumText: String,
        summaryMethod: Function,
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        cellClassName: [String, Function],
        cellStyle: [Object, Function],
        headerRowClassName: [String, Function],
        headerRowStyle: [Object, Function],
        headerCellClassName: [String, Function],
        headerCellStyle: [Object, Function],
        highlightCurrentRow: Boolean,
        currentRowKey: [String, Number],
        emptyText: String,
        expandRowKeys: Array,
        defaultExpandAll: Boolean,
        defaultSort: Object,
        tooltipEffect: String,
        tooltipOptions: Object,
        spanMethod: Function,
        selectOnIndeterminate: {
          type: Boolean,
          default: true
        },
        indent: {
          type: Number,
          default: 16
        },
        treeProps: {
          type: Object,
          default: () => {
            return {
              hasChildren: "hasChildren",
              children: "children"
            };
          }
        },
        lazy: Boolean,
        load: Function,
        style: {
          type: Object,
          default: () => ({})
        },
        className: {
          type: String,
          default: ""
        },
        tableLayout: {
          type: String,
          default: "fixed"
        },
        scrollbarAlwaysOn: Boolean,
        flexible: Boolean,
        showOverflowTooltip: [Boolean, Object]
      };
      function hColgroup(props) {
        const isAuto = props.tableLayout === "auto";
        let columns = props.columns || [];
        if (isAuto) {
          if (columns.every((column) => column.width === void 0)) {
            columns = [];
          }
        }
        const getPropsData = (column) => {
          const propsData = {
            key: `${props.tableLayout}_${column.id}`,
            style: {},
            name: void 0
          };
          if (isAuto) {
            propsData.style = {
              width: `${column.width}px`
            };
          } else {
            propsData.name = column.id;
          }
          return propsData;
        };
        return h$1("colgroup", {}, columns.map((column) => h$1("col", getPropsData(column))));
      }
      hColgroup.props = ["columns", "tableLayout"];
      const useScrollbar = () => {
        const scrollBarRef = ref();
        const scrollTo = (options, yCoord) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar) {
            scrollbar.scrollTo(options, yCoord);
          }
        };
        const setScrollPosition = (position, offset) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar && isNumber$1(offset) && ["Top", "Left"].includes(position)) {
            scrollbar[`setScroll${position}`](offset);
          }
        };
        const setScrollTop = (top) => setScrollPosition("Top", top);
        const setScrollLeft = (left2) => setScrollPosition("Left", left2);
        return {
          scrollBarRef,
          scrollTo,
          setScrollTop,
          setScrollLeft
        };
      };
      let tableIdSeed = 1;
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        name: "ElTable",
        directives: {
          Mousewheel
        },
        components: {
          TableHeader,
          TableBody,
          TableFooter,
          ElScrollbar,
          hColgroup
        },
        props: defaultProps$1,
        emits: [
          "select",
          "select-all",
          "selection-change",
          "cell-mouse-enter",
          "cell-mouse-leave",
          "cell-contextmenu",
          "cell-click",
          "cell-dblclick",
          "row-click",
          "row-contextmenu",
          "row-dblclick",
          "header-click",
          "header-contextmenu",
          "sort-change",
          "filter-change",
          "current-change",
          "header-dragend",
          "expand-change"
        ],
        setup(props) {
          const { t: t2 } = useLocale();
          const ns = useNamespace("table");
          const table = getCurrentInstance();
          provide(TABLE_INJECTION_KEY, table);
          const store = createStore(table, props);
          table.store = store;
          const layout = new TableLayout({
            store: table.store,
            table,
            fit: props.fit,
            showHeader: props.showHeader
          });
          table.layout = layout;
          const isEmpty = computed(() => (store.states.data.value || []).length === 0);
          const {
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            sort
          } = useUtils(store);
          const {
            isHidden: isHidden2,
            renderExpanded,
            setDragVisible,
            isGroup,
            handleMouseLeave,
            handleHeaderFooterMousewheel,
            tableSize,
            emptyBlockStyle,
            handleFixedMousewheel,
            resizeProxyVisible,
            bodyWidth,
            resizeState,
            doLayout,
            tableBodyStyles,
            tableLayout,
            scrollbarViewStyle,
            tableInnerStyle,
            scrollbarStyle
          } = useStyle(props, layout, store, table);
          const { scrollBarRef, scrollTo, setScrollLeft, setScrollTop } = useScrollbar();
          const debouncedUpdateLayout = debounce(doLayout, 50);
          const tableId = `${ns.namespace.value}-table_${tableIdSeed++}`;
          table.tableId = tableId;
          table.state = {
            isGroup,
            resizeState,
            doLayout,
            debouncedUpdateLayout
          };
          const computedSumText = computed(() => props.sumText || t2("el.table.sumText"));
          const computedEmptyText = computed(() => {
            return props.emptyText || t2("el.table.emptyText");
          });
          useKeyRender(table);
          return {
            ns,
            layout,
            store,
            handleHeaderFooterMousewheel,
            handleMouseLeave,
            tableId,
            tableSize,
            isHidden: isHidden2,
            isEmpty,
            renderExpanded,
            resizeProxyVisible,
            resizeState,
            isGroup,
            bodyWidth,
            tableBodyStyles,
            emptyBlockStyle,
            debouncedUpdateLayout,
            handleFixedMousewheel,
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            doLayout,
            sort,
            t: t2,
            setDragVisible,
            context: table,
            computedSumText,
            computedEmptyText,
            tableLayout,
            scrollbarViewStyle,
            tableInnerStyle,
            scrollbarStyle,
            scrollBarRef,
            scrollTo,
            setScrollLeft,
            setScrollTop
          };
        }
      });
      const _hoisted_1$3 = ["data-prefix"];
      const _hoisted_2$2 = {
        ref: "hiddenColumns",
        class: "hidden-columns"
      };
      function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_hColgroup = resolveComponent("hColgroup");
        const _component_table_header = resolveComponent("table-header");
        const _component_table_body = resolveComponent("table-body");
        const _component_table_footer = resolveComponent("table-footer");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _directive_mousewheel = resolveDirective("mousewheel");
        return openBlock(), createElementBlock("div", {
          ref: "tableWrapper",
          class: normalizeClass([
            {
              [_ctx.ns.m("fit")]: _ctx.fit,
              [_ctx.ns.m("striped")]: _ctx.stripe,
              [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
              [_ctx.ns.m("hidden")]: _ctx.isHidden,
              [_ctx.ns.m("group")]: _ctx.isGroup,
              [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
              [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
              [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
              [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
              [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
              "has-footer": _ctx.showSummary
            },
            _ctx.ns.m(_ctx.tableSize),
            _ctx.className,
            _ctx.ns.b(),
            _ctx.ns.m(`layout-${_ctx.tableLayout}`)
          ]),
          style: normalizeStyle(_ctx.style),
          "data-prefix": _ctx.ns.namespace.value,
          onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.ns.e("inner-wrapper")),
            style: normalizeStyle(_ctx.tableInnerStyle)
          }, [
            createBaseVNode("div", _hoisted_2$2, [
              renderSlot(_ctx.$slots, "default")
            ], 512),
            _ctx.showHeader && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              ref: "headerWrapper",
              class: normalizeClass(_ctx.ns.e("header-wrapper"))
            }, [
              createBaseVNode("table", {
                ref: "tableHeader",
                class: normalizeClass(_ctx.ns.e("header")),
                style: normalizeStyle(_ctx.tableBodyStyles),
                border: "0",
                cellpadding: "0",
                cellspacing: "0"
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_header, {
                  ref: "tableHeaderRef",
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  onSetDragVisible: _ctx.setDragVisible
                }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
              ], 6)
            ], 2)), [
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              ref: "bodyWrapper",
              class: normalizeClass(_ctx.ns.e("body-wrapper"))
            }, [
              createVNode(_component_el_scrollbar, {
                ref: "scrollBarRef",
                "view-style": _ctx.scrollbarViewStyle,
                "wrap-style": _ctx.scrollbarStyle,
                always: _ctx.scrollbarAlwaysOn
              }, {
                default: withCtx(() => [
                  createBaseVNode("table", {
                    ref: "tableBody",
                    class: normalizeClass(_ctx.ns.e("body")),
                    cellspacing: "0",
                    cellpadding: "0",
                    border: "0",
                    style: normalizeStyle({
                      width: _ctx.bodyWidth,
                      tableLayout: _ctx.tableLayout
                    })
                  }, [
                    createVNode(_component_hColgroup, {
                      columns: _ctx.store.states.columns.value,
                      "table-layout": _ctx.tableLayout
                    }, null, 8, ["columns", "table-layout"]),
                    _ctx.showHeader && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_header, {
                      key: 0,
                      ref: "tableHeaderRef",
                      class: normalizeClass(_ctx.ns.e("body-header")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      onSetDragVisible: _ctx.setDragVisible
                    }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : createCommentVNode("v-if", true),
                    createVNode(_component_table_body, {
                      context: _ctx.context,
                      highlight: _ctx.highlightCurrentRow,
                      "row-class-name": _ctx.rowClassName,
                      "tooltip-effect": _ctx.tooltipEffect,
                      "tooltip-options": _ctx.tooltipOptions,
                      "row-style": _ctx.rowStyle,
                      store: _ctx.store,
                      stripe: _ctx.stripe
                    }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
                    _ctx.showSummary && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_footer, {
                      key: 1,
                      class: normalizeClass(_ctx.ns.e("body-footer")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      "sum-text": _ctx.computedSumText,
                      "summary-method": _ctx.summaryMethod
                    }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : createCommentVNode("v-if", true)
                  ], 6),
                  _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "emptyBlock",
                    style: normalizeStyle(_ctx.emptyBlockStyle),
                    class: normalizeClass(_ctx.ns.e("empty-block"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(_ctx.ns.e("empty-text"))
                    }, [
                      renderSlot(_ctx.$slots, "empty", {}, () => [
                        createTextVNode(toDisplayString$1(_ctx.computedEmptyText), 1)
                      ])
                    ], 2)
                  ], 6)) : createCommentVNode("v-if", true),
                  _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    ref: "appendWrapper",
                    class: normalizeClass(_ctx.ns.e("append-wrapper"))
                  }, [
                    renderSlot(_ctx.$slots, "append")
                  ], 2)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["view-style", "wrap-style", "always"])
            ], 2),
            _ctx.showSummary && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 1,
              ref: "footerWrapper",
              class: normalizeClass(_ctx.ns.e("footer-wrapper"))
            }, [
              createBaseVNode("table", {
                class: normalizeClass(_ctx.ns.e("footer")),
                cellspacing: "0",
                cellpadding: "0",
                border: "0",
                style: normalizeStyle(_ctx.tableBodyStyles)
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_footer, {
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  "sum-text": _ctx.computedSumText,
                  "summary-method": _ctx.summaryMethod
                }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
              ], 6)
            ], 2)), [
              [vShow, !_ctx.isEmpty],
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            _ctx.border || _ctx.isGroup ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(_ctx.ns.e("border-left-patch"))
            }, null, 2)) : createCommentVNode("v-if", true)
          ], 6),
          withDirectives(createBaseVNode("div", {
            ref: "resizeProxy",
            class: normalizeClass(_ctx.ns.e("column-resize-proxy"))
          }, null, 2), [
            [vShow, _ctx.resizeProxyVisible]
          ])
        ], 46, _hoisted_1$3);
      }
      var Table = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render], ["__file", "table.vue"]]);
      const defaultClassNames = {
        selection: "table-column--selection",
        expand: "table__expand-column"
      };
      const cellStarts = {
        default: {
          order: ""
        },
        selection: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        expand: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        index: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        }
      };
      const getDefaultClassName = (type) => {
        return defaultClassNames[type] || "";
      };
      const cellForced = {
        selection: {
          renderHeader({ store, column }) {
            function isDisabled() {
              return store.states.data.value && store.states.data.value.length === 0;
            }
            return h$1(ElCheckbox, {
              disabled: isDisabled(),
              size: store.states.tableSize.value,
              indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
              "onUpdate:modelValue": store.toggleAllSelection,
              modelValue: store.states.isAllSelected.value,
              ariaLabel: column.label
            });
          },
          renderCell({
            row,
            column,
            store,
            $index
          }) {
            return h$1(ElCheckbox, {
              disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
              size: store.states.tableSize.value,
              onChange: () => {
                store.commit("rowSelectedChanged", row);
              },
              onClick: (event) => event.stopPropagation(),
              modelValue: store.isSelected(row),
              ariaLabel: column.label
            });
          },
          sortable: false,
          resizable: false
        },
        index: {
          renderHeader({ column }) {
            return column.label || "#";
          },
          renderCell({
            column,
            $index
          }) {
            let i = $index + 1;
            const index = column.index;
            if (typeof index === "number") {
              i = $index + index;
            } else if (typeof index === "function") {
              i = index($index);
            }
            return h$1("div", {}, [i]);
          },
          sortable: false
        },
        expand: {
          renderHeader({ column }) {
            return column.label || "";
          },
          renderCell({
            row,
            store,
            expanded
          }) {
            const { ns } = store;
            const classes = [ns.e("expand-icon")];
            if (expanded) {
              classes.push(ns.em("expand-icon", "expanded"));
            }
            const callback = function(e) {
              e.stopPropagation();
              store.toggleRowExpansion(row);
            };
            return h$1("div", {
              class: classes,
              onClick: callback
            }, {
              default: () => {
                return [
                  h$1(ElIcon, null, {
                    default: () => {
                      return [h$1(arrow_right_default)];
                    }
                  })
                ];
              }
            });
          },
          sortable: false,
          resizable: false
        }
      };
      function defaultRenderCell({
        row,
        column,
        $index
      }) {
        var _a2;
        const property2 = column.property;
        const value = property2 && getProp(row, property2).value;
        if (column && column.formatter) {
          return column.formatter(row, column, value, $index);
        }
        return ((_a2 = value == null ? void 0 : value.toString) == null ? void 0 : _a2.call(value)) || "";
      }
      function treeCellPrefix({
        row,
        treeNode,
        store
      }, createPlaceholder = false) {
        const { ns } = store;
        if (!treeNode) {
          if (createPlaceholder) {
            return [
              h$1("span", {
                class: ns.e("placeholder")
              })
            ];
          }
          return null;
        }
        const ele = [];
        const callback = function(e) {
          e.stopPropagation();
          if (treeNode.loading) {
            return;
          }
          store.loadOrToggle(row);
        };
        if (treeNode.indent) {
          ele.push(h$1("span", {
            class: ns.e("indent"),
            style: { "padding-left": `${treeNode.indent}px` }
          }));
        }
        if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
          const expandClasses = [
            ns.e("expand-icon"),
            treeNode.expanded ? ns.em("expand-icon", "expanded") : ""
          ];
          let icon = arrow_right_default;
          if (treeNode.loading) {
            icon = loading_default;
          }
          ele.push(h$1("div", {
            class: expandClasses,
            onClick: callback
          }, {
            default: () => {
              return [
                h$1(ElIcon, { class: { [ns.is("loading")]: treeNode.loading } }, {
                  default: () => [h$1(icon)]
                })
              ];
            }
          }));
        } else {
          ele.push(h$1("span", {
            class: ns.e("placeholder")
          }));
        }
        return ele;
      }
      function getAllAliases(props, aliases) {
        return props.reduce((prev, cur) => {
          prev[cur] = cur;
          return prev;
        }, aliases);
      }
      function useWatcher(owner, props_) {
        const instance = getCurrentInstance();
        const registerComplexWatchers = () => {
          const props = ["fixed"];
          const aliases = {
            realWidth: "width",
            realMinWidth: "minWidth"
          };
          const allAliases = getAllAliases(props, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn$1(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                let value = newVal;
                if (columnKey === "width" && key === "realWidth") {
                  value = parseWidth(newVal);
                }
                if (columnKey === "minWidth" && key === "realMinWidth") {
                  value = parseMinWidth(newVal);
                }
                instance.columnConfig.value[columnKey] = value;
                instance.columnConfig.value[key] = value;
                const updateColumns = columnKey === "fixed";
                owner.value.store.scheduleLayout(updateColumns);
              });
            }
          });
        };
        const registerNormalWatchers = () => {
          const props = [
            "label",
            "filters",
            "filterMultiple",
            "filteredValue",
            "sortable",
            "index",
            "formatter",
            "className",
            "labelClassName",
            "filterClassName",
            "showOverflowTooltip"
          ];
          const aliases = {
            property: "prop",
            align: "realAlign",
            headerAlign: "realHeaderAlign"
          };
          const allAliases = getAllAliases(props, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn$1(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                instance.columnConfig.value[key] = newVal;
              });
            }
          });
        };
        return {
          registerComplexWatchers,
          registerNormalWatchers
        };
      }
      function useRender(props, slots, owner) {
        const instance = getCurrentInstance();
        const columnId = ref("");
        const isSubColumn = ref(false);
        const realAlign = ref();
        const realHeaderAlign = ref();
        const ns = useNamespace("table");
        watchEffect(() => {
          realAlign.value = props.align ? `is-${props.align}` : null;
          realAlign.value;
        });
        watchEffect(() => {
          realHeaderAlign.value = props.headerAlign ? `is-${props.headerAlign}` : realAlign.value;
          realHeaderAlign.value;
        });
        const columnOrTableParent = computed(() => {
          let parent = instance.vnode.vParent || instance.parent;
          while (parent && !parent.tableId && !parent.columnId) {
            parent = parent.vnode.vParent || parent.parent;
          }
          return parent;
        });
        const hasTreeColumn = computed(() => {
          const { store } = instance.parent;
          if (!store)
            return false;
          const { treeData } = store.states;
          const treeDataValue = treeData.value;
          return treeDataValue && Object.keys(treeDataValue).length > 0;
        });
        const realWidth = ref(parseWidth(props.width));
        const realMinWidth = ref(parseMinWidth(props.minWidth));
        const setColumnWidth = (column) => {
          if (realWidth.value)
            column.width = realWidth.value;
          if (realMinWidth.value) {
            column.minWidth = realMinWidth.value;
          }
          if (!realWidth.value && realMinWidth.value) {
            column.width = void 0;
          }
          if (!column.minWidth) {
            column.minWidth = 80;
          }
          column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
          return column;
        };
        const setColumnForcedProps = (column) => {
          const type = column.type;
          const source = cellForced[type] || {};
          Object.keys(source).forEach((prop) => {
            const value = source[prop];
            if (prop !== "className" && value !== void 0) {
              column[prop] = value;
            }
          });
          const className = getDefaultClassName(type);
          if (className) {
            const forceClass = `${unref(ns.namespace)}-${className}`;
            column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
          }
          return column;
        };
        const checkSubColumn = (children) => {
          if (Array.isArray(children)) {
            children.forEach((child) => check(child));
          } else {
            check(children);
          }
          function check(item) {
            var _a2;
            if (((_a2 = item == null ? void 0 : item.type) == null ? void 0 : _a2.name) === "ElTableColumn") {
              item.vParent = instance;
            }
          }
        };
        const setColumnRenders = (column) => {
          if (props.renderHeader)
            ;
          else if (column.type !== "selection") {
            column.renderHeader = (scope) => {
              instance.columnConfig.value["label"];
              return renderSlot(slots, "header", scope, () => [column.label]);
            };
          }
          let originRenderCell = column.renderCell;
          if (column.type === "expand") {
            column.renderCell = (data) => h$1("div", {
              class: "cell"
            }, [originRenderCell(data)]);
            owner.value.renderExpanded = (data) => {
              return slots.default ? slots.default(data) : slots.default;
            };
          } else {
            originRenderCell = originRenderCell || defaultRenderCell;
            column.renderCell = (data) => {
              let children = null;
              if (slots.default) {
                const vnodes = slots.default(data);
                children = vnodes.some((v2) => v2.type !== Comment) ? vnodes : originRenderCell(data);
              } else {
                children = originRenderCell(data);
              }
              const { columns } = owner.value.store.states;
              const firstUserColumnIndex = columns.value.findIndex((item) => item.type === "default");
              const shouldCreatePlaceholder = hasTreeColumn.value && data.cellIndex === firstUserColumnIndex;
              const prefix = treeCellPrefix(data, shouldCreatePlaceholder);
              const props2 = {
                class: "cell",
                style: {}
              };
              if (column.showOverflowTooltip) {
                props2.class = `${props2.class} ${unref(ns.namespace)}-tooltip`;
                props2.style = {
                  width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
                };
              }
              checkSubColumn(children);
              return h$1("div", props2, [prefix, children]);
            };
          }
          return column;
        };
        const getPropsData = (...propsKey) => {
          return propsKey.reduce((prev, cur) => {
            if (Array.isArray(cur)) {
              cur.forEach((key) => {
                prev[key] = props[key];
              });
            }
            return prev;
          }, {});
        };
        const getColumnElIndex = (children, child) => {
          return Array.prototype.indexOf.call(children, child);
        };
        const updateColumnOrder = () => {
          owner.value.store.commit("updateColumnOrder", instance.columnConfig.value);
        };
        return {
          columnId,
          realAlign,
          isSubColumn,
          realHeaderAlign,
          columnOrTableParent,
          setColumnWidth,
          setColumnForcedProps,
          setColumnRenders,
          getPropsData,
          getColumnElIndex,
          updateColumnOrder
        };
      }
      var defaultProps = {
        type: {
          type: String,
          default: "default"
        },
        label: String,
        className: String,
        labelClassName: String,
        property: String,
        prop: String,
        width: {
          type: [String, Number],
          default: ""
        },
        minWidth: {
          type: [String, Number],
          default: ""
        },
        renderHeader: Function,
        sortable: {
          type: [Boolean, String],
          default: false
        },
        sortMethod: Function,
        sortBy: [String, Function, Array],
        resizable: {
          type: Boolean,
          default: true
        },
        columnKey: String,
        align: String,
        headerAlign: String,
        showOverflowTooltip: {
          type: [Boolean, Object],
          default: void 0
        },
        fixed: [Boolean, String],
        formatter: Function,
        selectable: Function,
        reserveSelection: Boolean,
        filterMethod: Function,
        filteredValue: Array,
        filters: Array,
        filterPlacement: String,
        filterMultiple: {
          type: Boolean,
          default: true
        },
        filterClassName: String,
        index: [Number, Function],
        sortOrders: {
          type: Array,
          default: () => {
            return ["ascending", "descending", null];
          },
          validator: (val) => {
            return val.every((order) => ["ascending", "descending", null].includes(order));
          }
        }
      };
      let columnIdSeed = 1;
      var ElTableColumn$1 = /* @__PURE__ */ defineComponent({
        name: "ElTableColumn",
        components: {
          ElCheckbox
        },
        props: defaultProps,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const columnConfig = ref({});
          const owner = computed(() => {
            let parent2 = instance.parent;
            while (parent2 && !parent2.tableId) {
              parent2 = parent2.parent;
            }
            return parent2;
          });
          const { registerNormalWatchers, registerComplexWatchers } = useWatcher(owner, props);
          const {
            columnId,
            isSubColumn,
            realHeaderAlign,
            columnOrTableParent,
            setColumnWidth,
            setColumnForcedProps,
            setColumnRenders,
            getPropsData,
            getColumnElIndex,
            realAlign,
            updateColumnOrder
          } = useRender(props, slots, owner);
          const parent = columnOrTableParent.value;
          columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
          onBeforeMount(() => {
            isSubColumn.value = owner.value !== parent;
            const type = props.type || "default";
            const sortable = props.sortable === "" ? true : props.sortable;
            const showOverflowTooltip = isUndefined(props.showOverflowTooltip) ? parent.props.showOverflowTooltip : props.showOverflowTooltip;
            const defaults = {
              ...cellStarts[type],
              id: columnId.value,
              type,
              property: props.prop || props.property,
              align: realAlign,
              headerAlign: realHeaderAlign,
              showOverflowTooltip,
              filterable: props.filters || props.filterMethod,
              filteredValue: [],
              filterPlacement: "",
              filterClassName: "",
              isColumnGroup: false,
              isSubColumn: false,
              filterOpened: false,
              sortable,
              index: props.index,
              rawColumnKey: instance.vnode.key
            };
            const basicProps = [
              "columnKey",
              "label",
              "className",
              "labelClassName",
              "type",
              "renderHeader",
              "formatter",
              "fixed",
              "resizable"
            ];
            const sortProps = ["sortMethod", "sortBy", "sortOrders"];
            const selectProps = ["selectable", "reserveSelection"];
            const filterProps = [
              "filterMethod",
              "filters",
              "filterMultiple",
              "filterOpened",
              "filteredValue",
              "filterPlacement",
              "filterClassName"
            ];
            let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
            column = mergeOptions(defaults, column);
            const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
            column = chains(column);
            columnConfig.value = column;
            registerNormalWatchers();
            registerComplexWatchers();
          });
          onMounted(() => {
            var _a2;
            const parent2 = columnOrTableParent.value;
            const children = isSubColumn.value ? parent2.vnode.el.children : (_a2 = parent2.refs.hiddenColumns) == null ? void 0 : _a2.children;
            const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
            columnConfig.value.getColumnIndex = getColumnIndex;
            const columnIndex = getColumnIndex();
            columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null, updateColumnOrder);
          });
          onBeforeUnmount(() => {
            owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null, updateColumnOrder);
          });
          instance.columnId = columnId.value;
          instance.columnConfig = columnConfig;
          return;
        },
        render() {
          var _a2, _b, _c;
          try {
            const renderDefault = (_b = (_a2 = this.$slots).default) == null ? void 0 : _b.call(_a2, {
              row: {},
              column: {},
              $index: -1
            });
            const children = [];
            if (Array.isArray(renderDefault)) {
              for (const childNode of renderDefault) {
                if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
                  children.push(childNode);
                } else if (childNode.type === Fragment$1 && Array.isArray(childNode.children)) {
                  childNode.children.forEach((vnode2) => {
                    if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !isString$3(vnode2 == null ? void 0 : vnode2.children)) {
                      children.push(vnode2);
                    }
                  });
                }
              }
            }
            const vnode = h$1("div", children);
            return vnode;
          } catch (e) {
            return h$1("div", []);
          }
        }
      });
      const ElTable = withInstall(Table, {
        TableColumn: ElTableColumn$1
      });
      const ElTableColumn = withNoopInstall(ElTableColumn$1);
      const messageTypes = ["success", "info", "warning", "error"];
      const messageDefaults = mutable({
        customClass: "",
        center: false,
        dangerouslyUseHTMLString: false,
        duration: 3e3,
        icon: void 0,
        id: "",
        message: "",
        onClose: void 0,
        showClose: false,
        type: "info",
        plain: false,
        offset: 16,
        zIndex: 0,
        grouping: false,
        repeatNum: 1,
        appendTo: isClient$1 ? document.body : void 0
      });
      const messageProps = buildProps({
        customClass: {
          type: String,
          default: messageDefaults.customClass
        },
        center: {
          type: Boolean,
          default: messageDefaults.center
        },
        dangerouslyUseHTMLString: {
          type: Boolean,
          default: messageDefaults.dangerouslyUseHTMLString
        },
        duration: {
          type: Number,
          default: messageDefaults.duration
        },
        icon: {
          type: iconPropType,
          default: messageDefaults.icon
        },
        id: {
          type: String,
          default: messageDefaults.id
        },
        message: {
          type: definePropType([
            String,
            Object,
            Function
          ]),
          default: messageDefaults.message
        },
        onClose: {
          type: definePropType(Function),
          default: messageDefaults.onClose
        },
        showClose: {
          type: Boolean,
          default: messageDefaults.showClose
        },
        type: {
          type: String,
          values: messageTypes,
          default: messageDefaults.type
        },
        plain: {
          type: Boolean,
          default: messageDefaults.plain
        },
        offset: {
          type: Number,
          default: messageDefaults.offset
        },
        zIndex: {
          type: Number,
          default: messageDefaults.zIndex
        },
        grouping: {
          type: Boolean,
          default: messageDefaults.grouping
        },
        repeatNum: {
          type: Number,
          default: messageDefaults.repeatNum
        }
      });
      const messageEmits = {
        destroy: () => true
      };
      const instances = shallowReactive([]);
      const getInstance = (id) => {
        const idx = instances.findIndex((instance) => instance.id === id);
        const current = instances[idx];
        let prev;
        if (idx > 0) {
          prev = instances[idx - 1];
        }
        return { current, prev };
      };
      const getLastOffset = (id) => {
        const { prev } = getInstance(id);
        if (!prev)
          return 0;
        return prev.vm.exposed.bottom.value;
      };
      const getOffsetOrSpace = (id, offset) => {
        const idx = instances.findIndex((instance) => instance.id === id);
        return idx > 0 ? 16 : offset;
      };
      const _hoisted_1$2 = ["id"];
      const _hoisted_2$1 = ["innerHTML"];
      const __default__ = /* @__PURE__ */ defineComponent({
        name: "ElMessage"
      });
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: messageProps,
        emits: messageEmits,
        setup(__props, { expose: expose2 }) {
          const props = __props;
          const { Close } = TypeComponents;
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("message");
          const { currentZIndex, nextZIndex } = zIndex2;
          const messageRef = ref();
          const visible = ref(false);
          const height = ref(0);
          let stopTimer = void 0;
          const badgeType = computed(() => props.type ? props.type === "error" ? "danger" : props.type : "info");
          const typeClass = computed(() => {
            const type = props.type;
            return { [ns.bm("icon", type)]: type && TypeComponentsMap[type] };
          });
          const iconComponent = computed(() => props.icon || TypeComponentsMap[props.type] || "");
          const lastOffset = computed(() => getLastOffset(props.id));
          const offset = computed(() => getOffsetOrSpace(props.id, props.offset) + lastOffset.value);
          const bottom = computed(() => height.value + offset.value);
          const customStyle = computed(() => ({
            top: `${offset.value}px`,
            zIndex: currentZIndex.value
          }));
          function startTimer() {
            if (props.duration === 0)
              return;
            ({ stop: stopTimer } = useTimeoutFn(() => {
              close();
            }, props.duration));
          }
          function clearTimer() {
            stopTimer == null ? void 0 : stopTimer();
          }
          function close() {
            visible.value = false;
          }
          function keydown({ code: code2 }) {
            if (code2 === EVENT_CODE.esc) {
              close();
            }
          }
          onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          watch(() => props.repeatNum, () => {
            clearTimer();
            startTimer();
          });
          useEventListener$1(document, "keydown", keydown);
          useResizeObserver(messageRef, () => {
            height.value = messageRef.value.getBoundingClientRect().height;
          });
          expose2({
            visible,
            bottom,
            close
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("destroy")),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  id: _ctx.id,
                  ref_key: "messageRef",
                  ref: messageRef,
                  class: normalizeClass([
                    unref(ns).b(),
                    { [unref(ns).m(_ctx.type)]: _ctx.type },
                    unref(ns).is("center", _ctx.center),
                    unref(ns).is("closable", _ctx.showClose),
                    unref(ns).is("plain", _ctx.plain),
                    _ctx.customClass
                  ]),
                  style: normalizeStyle(unref(customStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer
                }, [
                  _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref(ElBadge), {
                    key: 0,
                    value: _ctx.repeatNum,
                    type: unref(badgeType),
                    class: normalizeClass(unref(ns).e("badge"))
                  }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
                  unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  renderSlot(_ctx.$slots, "default", {}, () => [
                    !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                      key: 0,
                      class: normalizeClass(unref(ns).e("content"))
                    }, toDisplayString$1(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment$1, { key: 1 }, [
                      createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                      createBaseVNode("p", {
                        class: normalizeClass(unref(ns).e("content")),
                        innerHTML: _ctx.message
                      }, null, 10, _hoisted_2$1)
                    ], 2112))
                  ]),
                  _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 2,
                    class: normalizeClass(unref(ns).e("closeBtn")),
                    onClick: withModifiers(close, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(Close))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 46, _hoisted_1$2), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeLeave"]);
          };
        }
      });
      var MessageConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__file", "message.vue"]]);
      let seed = 1;
      const normalizeOptions = (params) => {
        const options = !params || isString$3(params) || isVNode$1(params) || isFunction$2(params) ? { message: params } : params;
        const normalized = {
          ...messageDefaults,
          ...options
        };
        if (!normalized.appendTo) {
          normalized.appendTo = document.body;
        } else if (isString$3(normalized.appendTo)) {
          let appendTo = document.querySelector(normalized.appendTo);
          if (!isElement(appendTo)) {
            appendTo = document.body;
          }
          normalized.appendTo = appendTo;
        }
        return normalized;
      };
      const closeMessage = (instance) => {
        const idx = instances.indexOf(instance);
        if (idx === -1)
          return;
        instances.splice(idx, 1);
        const { handler } = instance;
        handler.close();
      };
      const createMessage = ({ appendTo, ...options }, context) => {
        const id = `message_${seed++}`;
        const userOnClose = options.onClose;
        const container = document.createElement("div");
        const props = {
          ...options,
          id,
          onClose: () => {
            userOnClose == null ? void 0 : userOnClose();
            closeMessage(instance);
          },
          onDestroy: () => {
            render(null, container);
          }
        };
        const vnode = createVNode(MessageConstructor, props, isFunction$2(props.message) || isVNode$1(props.message) ? {
          default: isFunction$2(props.message) ? props.message : () => props.message
        } : null);
        vnode.appContext = context || message._context;
        render(vnode, container);
        appendTo.appendChild(container.firstElementChild);
        const vm = vnode.component;
        const handler = {
          close: () => {
            vm.exposed.visible.value = false;
          }
        };
        const instance = {
          id,
          vnode,
          vm,
          handler,
          props: vnode.component.props
        };
        return instance;
      };
      const message = (options = {}, context) => {
        if (!isClient$1)
          return { close: () => void 0 };
        if (isNumber$1(messageConfig.max) && instances.length >= messageConfig.max) {
          return { close: () => void 0 };
        }
        const normalized = normalizeOptions(options);
        if (normalized.grouping && instances.length) {
          const instance2 = instances.find(({ vnode: vm }) => {
            var _a2;
            return ((_a2 = vm.props) == null ? void 0 : _a2.message) === normalized.message;
          });
          if (instance2) {
            instance2.props.repeatNum += 1;
            instance2.props.type = normalized.type;
            return instance2.handler;
          }
        }
        const instance = createMessage(normalized, context);
        instances.push(instance);
        return instance.handler;
      };
      messageTypes.forEach((type) => {
        message[type] = (options = {}, appContext) => {
          const normalized = normalizeOptions(options);
          return message({ ...normalized, type }, appContext);
        };
      });
      function closeAll(type) {
        for (const instance of instances) {
          if (!type || type === instance.props.type) {
            instance.handler.close();
          }
        }
      }
      message.closeAll = closeAll;
      message._context = null;
      const ElMessage = withInstallFunction(message, "$message");
      /*!
        * shared v9.12.1
        * (c) 2024 kazuya kawaguchi
        * Released under the MIT License.
        */
      const inBrowser = typeof window !== "undefined";
      const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
      const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
      const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
      const isNumber = (val) => typeof val === "number" && isFinite(val);
      const isDate = (val) => toTypeString(val) === "[object Date]";
      const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
      const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
      const assign$1 = Object.assign;
      let _globalThis;
      const getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      function escapeHtml(rawText) {
        return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
      }
      const hasOwnProperty = Object.prototype.hasOwnProperty;
      function hasOwn(obj, key) {
        return hasOwnProperty.call(obj, key);
      }
      const isArray = Array.isArray;
      const isFunction = (val) => typeof val === "function";
      const isString$1 = (val) => typeof val === "string";
      const isBoolean = (val) => typeof val === "boolean";
      const isObject$3 = (val) => val !== null && typeof val === "object";
      const isPromise = (val) => {
        return isObject$3(val) && isFunction(val.then) && isFunction(val.catch);
      };
      const objectToString = Object.prototype.toString;
      const toTypeString = (value) => objectToString.call(value);
      const isPlainObject = (val) => {
        if (!isObject$3(val))
          return false;
        const proto = Object.getPrototypeOf(val);
        return proto === null || proto.constructor === Object;
      };
      const toDisplayString = (val) => {
        return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
      };
      function join$1(items, separator = "") {
        return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
      }
      function incrementer(code2) {
        let current = code2;
        return () => ++current;
      }
      function warn(msg, err) {
        if (typeof console !== "undefined") {
          console.warn(`[intlify] ` + msg);
          if (err) {
            console.warn(err.stack);
          }
        }
      }
      const isNotObjectOrIsArray = (val) => !isObject$3(val) || isArray(val);
      function deepCopy(src, des) {
        if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
          throw new Error("Invalid value");
        }
        const stack2 = [{ src, des }];
        while (stack2.length) {
          const { src: src2, des: des2 } = stack2.pop();
          Object.keys(src2).forEach((key) => {
            if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des2[key])) {
              des2[key] = src2[key];
            } else {
              stack2.push({ src: src2[key], des: des2[key] });
            }
          });
        }
      }
      /*!
        * message-compiler v9.12.1
        * (c) 2024 kazuya kawaguchi
        * Released under the MIT License.
        */
      function createPosition(line, column, offset) {
        return { line, column, offset };
      }
      function createLocation(start, end2, source) {
        const loc = { start, end: end2 };
        if (source != null) {
          loc.source = source;
        }
        return loc;
      }
      const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
      function format$1(message2, ...args) {
        if (args.length === 1 && isObject$2(args[0])) {
          args = args[0];
        }
        if (!args || !args.hasOwnProperty) {
          args = {};
        }
        return message2.replace(RE_ARGS, (match2, identifier) => {
          return args.hasOwnProperty(identifier) ? args[identifier] : "";
        });
      }
      const assign = Object.assign;
      const isString = (val) => typeof val === "string";
      const isObject$2 = (val) => val !== null && typeof val === "object";
      function join(items, separator = "") {
        return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
      }
      const CompileWarnCodes = {
        USE_MODULO_SYNTAX: 1,
        __EXTEND_POINT__: 2
      };
      const warnMessages = {
        [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
      };
      function createCompileWarn(code2, loc, ...args) {
        const msg = format$1(warnMessages[code2] || "", ...args || []);
        const message2 = { message: String(msg), code: code2 };
        if (loc) {
          message2.location = loc;
        }
        return message2;
      }
      const CompileErrorCodes = {
        // tokenizer error codes
        EXPECTED_TOKEN: 1,
        INVALID_TOKEN_IN_PLACEHOLDER: 2,
        UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
        UNKNOWN_ESCAPE_SEQUENCE: 4,
        INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
        UNBALANCED_CLOSING_BRACE: 6,
        UNTERMINATED_CLOSING_BRACE: 7,
        EMPTY_PLACEHOLDER: 8,
        NOT_ALLOW_NEST_PLACEHOLDER: 9,
        INVALID_LINKED_FORMAT: 10,
        // parser error codes
        MUST_HAVE_MESSAGES_IN_PLURAL: 11,
        UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
        UNEXPECTED_EMPTY_LINKED_KEY: 13,
        UNEXPECTED_LEXICAL_ANALYSIS: 14,
        // generator error codes
        UNHANDLED_CODEGEN_NODE_TYPE: 15,
        // minifier error codes
        UNHANDLED_MINIFIER_NODE_TYPE: 16,
        // Special value for higher-order compilers to pick up the last code
        // to avoid collision of error codes. This should always be kept as the last
        // item.
        __EXTEND_POINT__: 17
      };
      const errorMessages = {
        // tokenizer error messages
        [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
        [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
        [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
        [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
        [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
        [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
        [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
        [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
        [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
        [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
        // parser error messages
        [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
        [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
        [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
        [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
        // generator error messages
        [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
        // minimizer error messages
        [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
      };
      function createCompileError(code2, loc, options = {}) {
        const { domain, messages: messages2, args } = options;
        const msg = format$1((messages2 || errorMessages)[code2] || "", ...args || []);
        const error = new SyntaxError(String(msg));
        error.code = code2;
        if (loc) {
          error.location = loc;
        }
        error.domain = domain;
        return error;
      }
      function defaultOnError(error) {
        throw error;
      }
      const CHAR_SP = " ";
      const CHAR_CR = "\r";
      const CHAR_LF = "\n";
      const CHAR_LS = String.fromCharCode(8232);
      const CHAR_PS = String.fromCharCode(8233);
      function createScanner(str) {
        const _buf = str;
        let _index = 0;
        let _line = 1;
        let _column = 1;
        let _peekOffset = 0;
        const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
        const isLF = (index2) => _buf[index2] === CHAR_LF;
        const isPS = (index2) => _buf[index2] === CHAR_PS;
        const isLS = (index2) => _buf[index2] === CHAR_LS;
        const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
        const index = () => _index;
        const line = () => _line;
        const column = () => _column;
        const peekOffset = () => _peekOffset;
        const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
        const currentChar = () => charAt(_index);
        const currentPeek = () => charAt(_index + _peekOffset);
        function next() {
          _peekOffset = 0;
          if (isLineEnd(_index)) {
            _line++;
            _column = 0;
          }
          if (isCRLF(_index)) {
            _index++;
          }
          _index++;
          _column++;
          return _buf[_index];
        }
        function peek() {
          if (isCRLF(_index + _peekOffset)) {
            _peekOffset++;
          }
          _peekOffset++;
          return _buf[_index + _peekOffset];
        }
        function reset() {
          _index = 0;
          _line = 1;
          _column = 1;
          _peekOffset = 0;
        }
        function resetPeek(offset = 0) {
          _peekOffset = offset;
        }
        function skipToPeek() {
          const target = _index + _peekOffset;
          while (target !== _index) {
            next();
          }
          _peekOffset = 0;
        }
        return {
          index,
          line,
          column,
          peekOffset,
          charAt,
          currentChar,
          currentPeek,
          next,
          peek,
          reset,
          resetPeek,
          skipToPeek
        };
      }
      const EOF = void 0;
      const DOT = ".";
      const LITERAL_DELIMITER = "'";
      const ERROR_DOMAIN$3 = "tokenizer";
      function createTokenizer(source, options = {}) {
        const location2 = options.location !== false;
        const _scnr = createScanner(source);
        const currentOffset = () => _scnr.index();
        const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
        const _initLoc = currentPosition();
        const _initOffset = currentOffset();
        const _context = {
          currentType: 14,
          offset: _initOffset,
          startLoc: _initLoc,
          endLoc: _initLoc,
          lastType: 14,
          lastOffset: _initOffset,
          lastStartLoc: _initLoc,
          lastEndLoc: _initLoc,
          braceNest: 0,
          inLinked: false,
          text: ""
        };
        const context = () => _context;
        const { onError } = options;
        function emitError(code2, pos, offset, ...args) {
          const ctx = context();
          pos.column += offset;
          pos.offset += offset;
          if (onError) {
            const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
            const err = createCompileError(code2, loc, {
              domain: ERROR_DOMAIN$3,
              args
            });
            onError(err);
          }
        }
        function getToken(context2, type, value) {
          context2.endLoc = currentPosition();
          context2.currentType = type;
          const token = { type };
          if (location2) {
            token.loc = createLocation(context2.startLoc, context2.endLoc);
          }
          if (value != null) {
            token.value = value;
          }
          return token;
        }
        const getEndToken = (context2) => getToken(
          context2,
          14
          /* TokenTypes.EOF */
        );
        function eat(scnr, ch) {
          if (scnr.currentChar() === ch) {
            scnr.next();
            return ch;
          } else {
            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
            return "";
          }
        }
        function peekSpaces(scnr) {
          let buf = "";
          while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
            buf += scnr.currentPeek();
            scnr.peek();
          }
          return buf;
        }
        function skipSpaces(scnr) {
          const buf = peekSpaces(scnr);
          scnr.skipToPeek();
          return buf;
        }
        function isIdentifierStart(ch) {
          if (ch === EOF) {
            return false;
          }
          const cc = ch.charCodeAt(0);
          return cc >= 97 && cc <= 122 || // a-z
          cc >= 65 && cc <= 90 || // A-Z
          cc === 95;
        }
        function isNumberStart(ch) {
          if (ch === EOF) {
            return false;
          }
          const cc = ch.charCodeAt(0);
          return cc >= 48 && cc <= 57;
        }
        function isNamedIdentifierStart(scnr, context2) {
          const { currentType } = context2;
          if (currentType !== 2) {
            return false;
          }
          peekSpaces(scnr);
          const ret = isIdentifierStart(scnr.currentPeek());
          scnr.resetPeek();
          return ret;
        }
        function isListIdentifierStart(scnr, context2) {
          const { currentType } = context2;
          if (currentType !== 2) {
            return false;
          }
          peekSpaces(scnr);
          const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
          const ret = isNumberStart(ch);
          scnr.resetPeek();
          return ret;
        }
        function isLiteralStart(scnr, context2) {
          const { currentType } = context2;
          if (currentType !== 2) {
            return false;
          }
          peekSpaces(scnr);
          const ret = scnr.currentPeek() === LITERAL_DELIMITER;
          scnr.resetPeek();
          return ret;
        }
        function isLinkedDotStart(scnr, context2) {
          const { currentType } = context2;
          if (currentType !== 8) {
            return false;
          }
          peekSpaces(scnr);
          const ret = scnr.currentPeek() === ".";
          scnr.resetPeek();
          return ret;
        }
        function isLinkedModifierStart(scnr, context2) {
          const { currentType } = context2;
          if (currentType !== 9) {
            return false;
          }
          peekSpaces(scnr);
          const ret = isIdentifierStart(scnr.currentPeek());
          scnr.resetPeek();
          return ret;
        }
        function isLinkedDelimiterStart(scnr, context2) {
          const { currentType } = context2;
          if (!(currentType === 8 || currentType === 12)) {
            return false;
          }
          peekSpaces(scnr);
          const ret = scnr.currentPeek() === ":";
          scnr.resetPeek();
          return ret;
        }
        function isLinkedReferStart(scnr, context2) {
          const { currentType } = context2;
          if (currentType !== 10) {
            return false;
          }
          const fn2 = () => {
            const ch = scnr.currentPeek();
            if (ch === "{") {
              return isIdentifierStart(scnr.peek());
            } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
              return false;
            } else if (ch === CHAR_LF) {
              scnr.peek();
              return fn2();
            } else {
              return isIdentifierStart(ch);
            }
          };
          const ret = fn2();
          scnr.resetPeek();
          return ret;
        }
        function isPluralStart(scnr) {
          peekSpaces(scnr);
          const ret = scnr.currentPeek() === "|";
          scnr.resetPeek();
          return ret;
        }
        function detectModuloStart(scnr) {
          const spaces = peekSpaces(scnr);
          const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
          scnr.resetPeek();
          return {
            isModulo: ret,
            hasSpace: spaces.length > 0
          };
        }
        function isTextStart(scnr, reset = true) {
          const fn2 = (hasSpace = false, prev = "", detectModulo = false) => {
            const ch = scnr.currentPeek();
            if (ch === "{") {
              return prev === "%" ? false : hasSpace;
            } else if (ch === "@" || !ch) {
              return prev === "%" ? true : hasSpace;
            } else if (ch === "%") {
              scnr.peek();
              return fn2(hasSpace, "%", true);
            } else if (ch === "|") {
              return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
            } else if (ch === CHAR_SP) {
              scnr.peek();
              return fn2(true, CHAR_SP, detectModulo);
            } else if (ch === CHAR_LF) {
              scnr.peek();
              return fn2(true, CHAR_LF, detectModulo);
            } else {
              return true;
            }
          };
          const ret = fn2();
          reset && scnr.resetPeek();
          return ret;
        }
        function takeChar(scnr, fn2) {
          const ch = scnr.currentChar();
          if (ch === EOF) {
            return EOF;
          }
          if (fn2(ch)) {
            scnr.next();
            return ch;
          }
          return null;
        }
        function isIdentifier(ch) {
          const cc = ch.charCodeAt(0);
          return cc >= 97 && cc <= 122 || // a-z
          cc >= 65 && cc <= 90 || // A-Z
          cc >= 48 && cc <= 57 || // 0-9
          cc === 95 || // _
          cc === 36;
        }
        function takeIdentifierChar(scnr) {
          return takeChar(scnr, isIdentifier);
        }
        function isNamedIdentifier(ch) {
          const cc = ch.charCodeAt(0);
          return cc >= 97 && cc <= 122 || // a-z
          cc >= 65 && cc <= 90 || // A-Z
          cc >= 48 && cc <= 57 || // 0-9
          cc === 95 || // _
          cc === 36 || // $
          cc === 45;
        }
        function takeNamedIdentifierChar(scnr) {
          return takeChar(scnr, isNamedIdentifier);
        }
        function isDigit(ch) {
          const cc = ch.charCodeAt(0);
          return cc >= 48 && cc <= 57;
        }
        function takeDigit(scnr) {
          return takeChar(scnr, isDigit);
        }
        function isHexDigit(ch) {
          const cc = ch.charCodeAt(0);
          return cc >= 48 && cc <= 57 || // 0-9
          cc >= 65 && cc <= 70 || // A-F
          cc >= 97 && cc <= 102;
        }
        function takeHexDigit(scnr) {
          return takeChar(scnr, isHexDigit);
        }
        function getDigits(scnr) {
          let ch = "";
          let num = "";
          while (ch = takeDigit(scnr)) {
            num += ch;
          }
          return num;
        }
        function readModulo(scnr) {
          skipSpaces(scnr);
          const ch = scnr.currentChar();
          if (ch !== "%") {
            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
          }
          scnr.next();
          return "%";
        }
        function readText(scnr) {
          let buf = "";
          while (true) {
            const ch = scnr.currentChar();
            if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
              break;
            } else if (ch === "%") {
              if (isTextStart(scnr)) {
                buf += ch;
                scnr.next();
              } else {
                break;
              }
            } else if (ch === CHAR_SP || ch === CHAR_LF) {
              if (isTextStart(scnr)) {
                buf += ch;
                scnr.next();
              } else if (isPluralStart(scnr)) {
                break;
              } else {
                buf += ch;
                scnr.next();
              }
            } else {
              buf += ch;
              scnr.next();
            }
          }
          return buf;
        }
        function readNamedIdentifier(scnr) {
          skipSpaces(scnr);
          let ch = "";
          let name = "";
          while (ch = takeNamedIdentifierChar(scnr)) {
            name += ch;
          }
          if (scnr.currentChar() === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          return name;
        }
        function readListIdentifier(scnr) {
          skipSpaces(scnr);
          let value = "";
          if (scnr.currentChar() === "-") {
            scnr.next();
            value += `-${getDigits(scnr)}`;
          } else {
            value += getDigits(scnr);
          }
          if (scnr.currentChar() === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          return value;
        }
        function isLiteral2(ch) {
          return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
        }
        function readLiteral(scnr) {
          skipSpaces(scnr);
          eat(scnr, `'`);
          let ch = "";
          let literal = "";
          while (ch = takeChar(scnr, isLiteral2)) {
            if (ch === "\\") {
              literal += readEscapeSequence(scnr);
            } else {
              literal += ch;
            }
          }
          const current = scnr.currentChar();
          if (current === CHAR_LF || current === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
            if (current === CHAR_LF) {
              scnr.next();
              eat(scnr, `'`);
            }
            return literal;
          }
          eat(scnr, `'`);
          return literal;
        }
        function readEscapeSequence(scnr) {
          const ch = scnr.currentChar();
          switch (ch) {
            case "\\":
            case `'`:
              scnr.next();
              return `\\${ch}`;
            case "u":
              return readUnicodeEscapeSequence(scnr, ch, 4);
            case "U":
              return readUnicodeEscapeSequence(scnr, ch, 6);
            default:
              emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
              return "";
          }
        }
        function readUnicodeEscapeSequence(scnr, unicode, digits) {
          eat(scnr, unicode);
          let sequence = "";
          for (let i = 0; i < digits; i++) {
            const ch = takeHexDigit(scnr);
            if (!ch) {
              emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
              break;
            }
            sequence += ch;
          }
          return `\\${unicode}${sequence}`;
        }
        function isInvalidIdentifier(ch) {
          return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
        }
        function readInvalidIdentifier(scnr) {
          skipSpaces(scnr);
          let ch = "";
          let identifiers = "";
          while (ch = takeChar(scnr, isInvalidIdentifier)) {
            identifiers += ch;
          }
          return identifiers;
        }
        function readLinkedModifier(scnr) {
          let ch = "";
          let name = "";
          while (ch = takeIdentifierChar(scnr)) {
            name += ch;
          }
          return name;
        }
        function readLinkedRefer(scnr) {
          const fn2 = (detect2 = false, buf) => {
            const ch = scnr.currentChar();
            if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
              return buf;
            } else if (ch === CHAR_SP) {
              return buf;
            } else if (ch === CHAR_LF || ch === DOT) {
              buf += ch;
              scnr.next();
              return fn2(detect2, buf);
            } else {
              buf += ch;
              scnr.next();
              return fn2(true, buf);
            }
          };
          return fn2(false, "");
        }
        function readPlural(scnr) {
          skipSpaces(scnr);
          const plural = eat(
            scnr,
            "|"
            /* TokenChars.Pipe */
          );
          skipSpaces(scnr);
          return plural;
        }
        function readTokenInPlaceholder(scnr, context2) {
          let token = null;
          const ch = scnr.currentChar();
          switch (ch) {
            case "{":
              if (context2.braceNest >= 1) {
                emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
              }
              scnr.next();
              token = getToken(
                context2,
                2,
                "{"
                /* TokenChars.BraceLeft */
              );
              skipSpaces(scnr);
              context2.braceNest++;
              return token;
            case "}":
              if (context2.braceNest > 0 && context2.currentType === 2) {
                emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
              }
              scnr.next();
              token = getToken(
                context2,
                3,
                "}"
                /* TokenChars.BraceRight */
              );
              context2.braceNest--;
              context2.braceNest > 0 && skipSpaces(scnr);
              if (context2.inLinked && context2.braceNest === 0) {
                context2.inLinked = false;
              }
              return token;
            case "@":
              if (context2.braceNest > 0) {
                emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
              }
              token = readTokenInLinked(scnr, context2) || getEndToken(context2);
              context2.braceNest = 0;
              return token;
            default: {
              let validNamedIdentifier = true;
              let validListIdentifier = true;
              let validLiteral = true;
              if (isPluralStart(scnr)) {
                if (context2.braceNest > 0) {
                  emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                }
                token = getToken(context2, 1, readPlural(scnr));
                context2.braceNest = 0;
                context2.inLinked = false;
                return token;
              }
              if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
                emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                context2.braceNest = 0;
                return readToken(scnr, context2);
              }
              if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
                token = getToken(context2, 5, readNamedIdentifier(scnr));
                skipSpaces(scnr);
                return token;
              }
              if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
                token = getToken(context2, 6, readListIdentifier(scnr));
                skipSpaces(scnr);
                return token;
              }
              if (validLiteral = isLiteralStart(scnr, context2)) {
                token = getToken(context2, 7, readLiteral(scnr));
                skipSpaces(scnr);
                return token;
              }
              if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
                token = getToken(context2, 13, readInvalidIdentifier(scnr));
                emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
                skipSpaces(scnr);
                return token;
              }
              break;
            }
          }
          return token;
        }
        function readTokenInLinked(scnr, context2) {
          const { currentType } = context2;
          let token = null;
          const ch = scnr.currentChar();
          if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
          }
          switch (ch) {
            case "@":
              scnr.next();
              token = getToken(
                context2,
                8,
                "@"
                /* TokenChars.LinkedAlias */
              );
              context2.inLinked = true;
              return token;
            case ".":
              skipSpaces(scnr);
              scnr.next();
              return getToken(
                context2,
                9,
                "."
                /* TokenChars.LinkedDot */
              );
            case ":":
              skipSpaces(scnr);
              scnr.next();
              return getToken(
                context2,
                10,
                ":"
                /* TokenChars.LinkedDelimiter */
              );
            default:
              if (isPluralStart(scnr)) {
                token = getToken(context2, 1, readPlural(scnr));
                context2.braceNest = 0;
                context2.inLinked = false;
                return token;
              }
              if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
                skipSpaces(scnr);
                return readTokenInLinked(scnr, context2);
              }
              if (isLinkedModifierStart(scnr, context2)) {
                skipSpaces(scnr);
                return getToken(context2, 12, readLinkedModifier(scnr));
              }
              if (isLinkedReferStart(scnr, context2)) {
                skipSpaces(scnr);
                if (ch === "{") {
                  return readTokenInPlaceholder(scnr, context2) || token;
                } else {
                  return getToken(context2, 11, readLinkedRefer(scnr));
                }
              }
              if (currentType === 8) {
                emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
              }
              context2.braceNest = 0;
              context2.inLinked = false;
              return readToken(scnr, context2);
          }
        }
        function readToken(scnr, context2) {
          let token = {
            type: 14
            /* TokenTypes.EOF */
          };
          if (context2.braceNest > 0) {
            return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
          }
          if (context2.inLinked) {
            return readTokenInLinked(scnr, context2) || getEndToken(context2);
          }
          const ch = scnr.currentChar();
          switch (ch) {
            case "{":
              return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
            case "}":
              emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
              scnr.next();
              return getToken(
                context2,
                3,
                "}"
                /* TokenChars.BraceRight */
              );
            case "@":
              return readTokenInLinked(scnr, context2) || getEndToken(context2);
            default: {
              if (isPluralStart(scnr)) {
                token = getToken(context2, 1, readPlural(scnr));
                context2.braceNest = 0;
                context2.inLinked = false;
                return token;
              }
              const { isModulo, hasSpace } = detectModuloStart(scnr);
              if (isModulo) {
                return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
              }
              if (isTextStart(scnr)) {
                return getToken(context2, 0, readText(scnr));
              }
              break;
            }
          }
          return token;
        }
        function nextToken() {
          const { currentType, offset, startLoc, endLoc } = _context;
          _context.lastType = currentType;
          _context.lastOffset = offset;
          _context.lastStartLoc = startLoc;
          _context.lastEndLoc = endLoc;
          _context.offset = currentOffset();
          _context.startLoc = currentPosition();
          if (_scnr.currentChar() === EOF) {
            return getToken(
              _context,
              14
              /* TokenTypes.EOF */
            );
          }
          return readToken(_scnr, _context);
        }
        return {
          nextToken,
          currentOffset,
          currentPosition,
          context
        };
      }
      const ERROR_DOMAIN$2 = "parser";
      const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
      function fromEscapeSequence(match2, codePoint4, codePoint6) {
        switch (match2) {
          case `\\\\`:
            return `\\`;
          case `\\'`:
            return `'`;
          default: {
            const codePoint = parseInt(codePoint4 || codePoint6, 16);
            if (codePoint <= 55295 || codePoint >= 57344) {
              return String.fromCodePoint(codePoint);
            }
            return "�";
          }
        }
      }
      function createParser(options = {}) {
        const location2 = options.location !== false;
        const { onError, onWarn } = options;
        function emitError(tokenzer, code2, start, offset, ...args) {
          const end2 = tokenzer.currentPosition();
          end2.offset += offset;
          end2.column += offset;
          if (onError) {
            const loc = location2 ? createLocation(start, end2) : null;
            const err = createCompileError(code2, loc, {
              domain: ERROR_DOMAIN$2,
              args
            });
            onError(err);
          }
        }
        function emitWarn(tokenzer, code2, start, offset, ...args) {
          const end2 = tokenzer.currentPosition();
          end2.offset += offset;
          end2.column += offset;
          if (onWarn) {
            const loc = location2 ? createLocation(start, end2) : null;
            onWarn(createCompileWarn(code2, loc, args));
          }
        }
        function startNode(type, offset, loc) {
          const node = { type };
          if (location2) {
            node.start = offset;
            node.end = offset;
            node.loc = { start: loc, end: loc };
          }
          return node;
        }
        function endNode(node, offset, pos, type) {
          if (type) {
            node.type = type;
          }
          if (location2) {
            node.end = offset;
            if (node.loc) {
              node.loc.end = pos;
            }
          }
        }
        function parseText(tokenizer, value) {
          const context = tokenizer.context();
          const node = startNode(3, context.offset, context.startLoc);
          node.value = value;
          endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
          return node;
        }
        function parseList(tokenizer, index) {
          const context = tokenizer.context();
          const { lastOffset: offset, lastStartLoc: loc } = context;
          const node = startNode(5, offset, loc);
          node.index = parseInt(index, 10);
          tokenizer.nextToken();
          endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
          return node;
        }
        function parseNamed(tokenizer, key, modulo) {
          const context = tokenizer.context();
          const { lastOffset: offset, lastStartLoc: loc } = context;
          const node = startNode(4, offset, loc);
          node.key = key;
          if (modulo === true) {
            node.modulo = true;
          }
          tokenizer.nextToken();
          endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
          return node;
        }
        function parseLiteral(tokenizer, value) {
          const context = tokenizer.context();
          const { lastOffset: offset, lastStartLoc: loc } = context;
          const node = startNode(9, offset, loc);
          node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
          tokenizer.nextToken();
          endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
          return node;
        }
        function parseLinkedModifier(tokenizer) {
          const token = tokenizer.nextToken();
          const context = tokenizer.context();
          const { lastOffset: offset, lastStartLoc: loc } = context;
          const node = startNode(8, offset, loc);
          if (token.type !== 12) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
            node.value = "";
            endNode(node, offset, loc);
            return {
              nextConsumeToken: token,
              node
            };
          }
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.value = token.value || "";
          endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
          return {
            node
          };
        }
        function parseLinkedKey(tokenizer, value) {
          const context = tokenizer.context();
          const node = startNode(7, context.offset, context.startLoc);
          node.value = value;
          endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
          return node;
        }
        function parseLinked(tokenizer) {
          const context = tokenizer.context();
          const linkedNode = startNode(6, context.offset, context.startLoc);
          let token = tokenizer.nextToken();
          if (token.type === 9) {
            const parsed = parseLinkedModifier(tokenizer);
            linkedNode.modifier = parsed.node;
            token = parsed.nextConsumeToken || tokenizer.nextToken();
          }
          if (token.type !== 10) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          token = tokenizer.nextToken();
          if (token.type === 2) {
            token = tokenizer.nextToken();
          }
          switch (token.type) {
            case 11:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
              break;
            case 5:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              linkedNode.key = parseNamed(tokenizer, token.value || "");
              break;
            case 6:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              linkedNode.key = parseList(tokenizer, token.value || "");
              break;
            case 7:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              linkedNode.key = parseLiteral(tokenizer, token.value || "");
              break;
            default: {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
              const nextContext = tokenizer.context();
              const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
              emptyLinkedKeyNode.value = "";
              endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
              linkedNode.key = emptyLinkedKeyNode;
              endNode(linkedNode, nextContext.offset, nextContext.startLoc);
              return {
                nextConsumeToken: token,
                node: linkedNode
              };
            }
          }
          endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
          return {
            node: linkedNode
          };
        }
        function parseMessage(tokenizer) {
          const context = tokenizer.context();
          const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
          const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
          const node = startNode(2, startOffset, startLoc);
          node.items = [];
          let nextToken = null;
          let modulo = null;
          do {
            const token = nextToken || tokenizer.nextToken();
            nextToken = null;
            switch (token.type) {
              case 0:
                if (token.value == null) {
                  emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                node.items.push(parseText(tokenizer, token.value || ""));
                break;
              case 6:
                if (token.value == null) {
                  emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                node.items.push(parseList(tokenizer, token.value || ""));
                break;
              case 4:
                modulo = true;
                break;
              case 5:
                if (token.value == null) {
                  emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                node.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
                if (modulo) {
                  emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
                  modulo = null;
                }
                break;
              case 7:
                if (token.value == null) {
                  emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                node.items.push(parseLiteral(tokenizer, token.value || ""));
                break;
              case 8: {
                const parsed = parseLinked(tokenizer);
                node.items.push(parsed.node);
                nextToken = parsed.nextConsumeToken || null;
                break;
              }
            }
          } while (context.currentType !== 14 && context.currentType !== 1);
          const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
          const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
          endNode(node, endOffset, endLoc);
          return node;
        }
        function parsePlural(tokenizer, offset, loc, msgNode) {
          const context = tokenizer.context();
          let hasEmptyMessage = msgNode.items.length === 0;
          const node = startNode(1, offset, loc);
          node.cases = [];
          node.cases.push(msgNode);
          do {
            const msg = parseMessage(tokenizer);
            if (!hasEmptyMessage) {
              hasEmptyMessage = msg.items.length === 0;
            }
            node.cases.push(msg);
          } while (context.currentType !== 14);
          if (hasEmptyMessage) {
            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
          }
          endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
          return node;
        }
        function parseResource(tokenizer) {
          const context = tokenizer.context();
          const { offset, startLoc } = context;
          const msgNode = parseMessage(tokenizer);
          if (context.currentType === 14) {
            return msgNode;
          } else {
            return parsePlural(tokenizer, offset, startLoc, msgNode);
          }
        }
        function parse2(source) {
          const tokenizer = createTokenizer(source, assign({}, options));
          const context = tokenizer.context();
          const node = startNode(0, context.offset, context.startLoc);
          if (location2 && node.loc) {
            node.loc.source = source;
          }
          node.body = parseResource(tokenizer);
          if (options.onCacheKey) {
            node.cacheKey = options.onCacheKey(source);
          }
          if (context.currentType !== 14) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
          }
          endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
          return node;
        }
        return { parse: parse2 };
      }
      function getTokenCaption(token) {
        if (token.type === 14) {
          return "EOF";
        }
        const name = (token.value || "").replace(/\r?\n/gu, "\\n");
        return name.length > 10 ? name.slice(0, 9) + "…" : name;
      }
      function createTransformer(ast, options = {}) {
        const _context = {
          ast,
          helpers: /* @__PURE__ */ new Set()
        };
        const context = () => _context;
        const helper = (name) => {
          _context.helpers.add(name);
          return name;
        };
        return { context, helper };
      }
      function traverseNodes(nodes, transformer) {
        for (let i = 0; i < nodes.length; i++) {
          traverseNode(nodes[i], transformer);
        }
      }
      function traverseNode(node, transformer) {
        switch (node.type) {
          case 1:
            traverseNodes(node.cases, transformer);
            transformer.helper(
              "plural"
              /* HelperNameMap.PLURAL */
            );
            break;
          case 2:
            traverseNodes(node.items, transformer);
            break;
          case 6: {
            const linked = node;
            traverseNode(linked.key, transformer);
            transformer.helper(
              "linked"
              /* HelperNameMap.LINKED */
            );
            transformer.helper(
              "type"
              /* HelperNameMap.TYPE */
            );
            break;
          }
          case 5:
            transformer.helper(
              "interpolate"
              /* HelperNameMap.INTERPOLATE */
            );
            transformer.helper(
              "list"
              /* HelperNameMap.LIST */
            );
            break;
          case 4:
            transformer.helper(
              "interpolate"
              /* HelperNameMap.INTERPOLATE */
            );
            transformer.helper(
              "named"
              /* HelperNameMap.NAMED */
            );
            break;
        }
      }
      function transform(ast, options = {}) {
        const transformer = createTransformer(ast);
        transformer.helper(
          "normalize"
          /* HelperNameMap.NORMALIZE */
        );
        ast.body && traverseNode(ast.body, transformer);
        const context = transformer.context();
        ast.helpers = Array.from(context.helpers);
      }
      function optimize(ast) {
        const body = ast.body;
        if (body.type === 2) {
          optimizeMessageNode(body);
        } else {
          body.cases.forEach((c2) => optimizeMessageNode(c2));
        }
        return ast;
      }
      function optimizeMessageNode(message2) {
        if (message2.items.length === 1) {
          const item = message2.items[0];
          if (item.type === 3 || item.type === 9) {
            message2.static = item.value;
            delete item.value;
          }
        } else {
          const values2 = [];
          for (let i = 0; i < message2.items.length; i++) {
            const item = message2.items[i];
            if (!(item.type === 3 || item.type === 9)) {
              break;
            }
            if (item.value == null) {
              break;
            }
            values2.push(item.value);
          }
          if (values2.length === message2.items.length) {
            message2.static = join(values2);
            for (let i = 0; i < message2.items.length; i++) {
              const item = message2.items[i];
              if (item.type === 3 || item.type === 9) {
                delete item.value;
              }
            }
          }
        }
      }
      const ERROR_DOMAIN$1 = "minifier";
      function minify(node) {
        node.t = node.type;
        switch (node.type) {
          case 0: {
            const resource2 = node;
            minify(resource2.body);
            resource2.b = resource2.body;
            delete resource2.body;
            break;
          }
          case 1: {
            const plural = node;
            const cases = plural.cases;
            for (let i = 0; i < cases.length; i++) {
              minify(cases[i]);
            }
            plural.c = cases;
            delete plural.cases;
            break;
          }
          case 2: {
            const message2 = node;
            const items = message2.items;
            for (let i = 0; i < items.length; i++) {
              minify(items[i]);
            }
            message2.i = items;
            delete message2.items;
            if (message2.static) {
              message2.s = message2.static;
              delete message2.static;
            }
            break;
          }
          case 3:
          case 9:
          case 8:
          case 7: {
            const valueNode = node;
            if (valueNode.value) {
              valueNode.v = valueNode.value;
              delete valueNode.value;
            }
            break;
          }
          case 6: {
            const linked = node;
            minify(linked.key);
            linked.k = linked.key;
            delete linked.key;
            if (linked.modifier) {
              minify(linked.modifier);
              linked.m = linked.modifier;
              delete linked.modifier;
            }
            break;
          }
          case 5: {
            const list = node;
            list.i = list.index;
            delete list.index;
            break;
          }
          case 4: {
            const named = node;
            named.k = named.key;
            delete named.key;
            break;
          }
          default: {
            throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
              domain: ERROR_DOMAIN$1,
              args: [node.type]
            });
          }
        }
        delete node.type;
      }
      const ERROR_DOMAIN = "parser";
      function createCodeGenerator(ast, options) {
        const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
        const location2 = options.location !== false;
        const _context = {
          filename,
          code: "",
          column: 1,
          line: 1,
          offset: 0,
          map: void 0,
          breakLineCode,
          needIndent: _needIndent,
          indentLevel: 0
        };
        if (location2 && ast.loc) {
          _context.source = ast.loc.source;
        }
        const context = () => _context;
        function push(code2, node) {
          _context.code += code2;
        }
        function _newline(n, withBreakLine = true) {
          const _breakLineCode = withBreakLine ? breakLineCode : "";
          push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
        }
        function indent(withNewLine = true) {
          const level = ++_context.indentLevel;
          withNewLine && _newline(level);
        }
        function deindent(withNewLine = true) {
          const level = --_context.indentLevel;
          withNewLine && _newline(level);
        }
        function newline() {
          _newline(_context.indentLevel);
        }
        const helper = (key) => `_${key}`;
        const needIndent = () => _context.needIndent;
        return {
          context,
          push,
          indent,
          deindent,
          newline,
          helper,
          needIndent
        };
      }
      function generateLinkedNode(generator, node) {
        const { helper } = generator;
        generator.push(`${helper(
        "linked"
        /* HelperNameMap.LINKED */
      )}(`);
        generateNode(generator, node.key);
        if (node.modifier) {
          generator.push(`, `);
          generateNode(generator, node.modifier);
          generator.push(`, _type`);
        } else {
          generator.push(`, undefined, _type`);
        }
        generator.push(`)`);
      }
      function generateMessageNode(generator, node) {
        const { helper, needIndent } = generator;
        generator.push(`${helper(
        "normalize"
        /* HelperNameMap.NORMALIZE */
      )}([`);
        generator.indent(needIndent());
        const length = node.items.length;
        for (let i = 0; i < length; i++) {
          generateNode(generator, node.items[i]);
          if (i === length - 1) {
            break;
          }
          generator.push(", ");
        }
        generator.deindent(needIndent());
        generator.push("])");
      }
      function generatePluralNode(generator, node) {
        const { helper, needIndent } = generator;
        if (node.cases.length > 1) {
          generator.push(`${helper(
          "plural"
          /* HelperNameMap.PLURAL */
        )}([`);
          generator.indent(needIndent());
          const length = node.cases.length;
          for (let i = 0; i < length; i++) {
            generateNode(generator, node.cases[i]);
            if (i === length - 1) {
              break;
            }
            generator.push(", ");
          }
          generator.deindent(needIndent());
          generator.push(`])`);
        }
      }
      function generateResource(generator, node) {
        if (node.body) {
          generateNode(generator, node.body);
        } else {
          generator.push("null");
        }
      }
      function generateNode(generator, node) {
        const { helper } = generator;
        switch (node.type) {
          case 0:
            generateResource(generator, node);
            break;
          case 1:
            generatePluralNode(generator, node);
            break;
          case 2:
            generateMessageNode(generator, node);
            break;
          case 6:
            generateLinkedNode(generator, node);
            break;
          case 8:
            generator.push(JSON.stringify(node.value), node);
            break;
          case 7:
            generator.push(JSON.stringify(node.value), node);
            break;
          case 5:
            generator.push(`${helper(
            "interpolate"
            /* HelperNameMap.INTERPOLATE */
          )}(${helper(
            "list"
            /* HelperNameMap.LIST */
          )}(${node.index}))`, node);
            break;
          case 4:
            generator.push(`${helper(
            "interpolate"
            /* HelperNameMap.INTERPOLATE */
          )}(${helper(
            "named"
            /* HelperNameMap.NAMED */
          )}(${JSON.stringify(node.key)}))`, node);
            break;
          case 9:
            generator.push(JSON.stringify(node.value), node);
            break;
          case 3:
            generator.push(JSON.stringify(node.value), node);
            break;
          default: {
            throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
              domain: ERROR_DOMAIN,
              args: [node.type]
            });
          }
        }
      }
      const generate = (ast, options = {}) => {
        const mode = isString(options.mode) ? options.mode : "normal";
        const filename = isString(options.filename) ? options.filename : "message.intl";
        const sourceMap = !!options.sourceMap;
        const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
        const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
        const helpers = ast.helpers || [];
        const generator = createCodeGenerator(ast, {
          mode,
          filename,
          sourceMap,
          breakLineCode,
          needIndent
        });
        generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
        generator.indent(needIndent);
        if (helpers.length > 0) {
          generator.push(`const { ${join(helpers.map((s2) => `${s2}: _${s2}`), ", ")} } = ctx`);
          generator.newline();
        }
        generator.push(`return `);
        generateNode(generator, ast);
        generator.deindent(needIndent);
        generator.push(`}`);
        delete ast.helpers;
        const { code: code2, map: map2 } = generator.context();
        return {
          ast,
          code: code2,
          map: map2 ? map2.toJSON() : void 0
          // eslint-disable-line @typescript-eslint/no-explicit-any
        };
      };
      function baseCompile$1(source, options = {}) {
        const assignedOptions = assign({}, options);
        const jit = !!assignedOptions.jit;
        const enalbeMinify = !!assignedOptions.minify;
        const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
        const parser2 = createParser(assignedOptions);
        const ast = parser2.parse(source);
        if (!jit) {
          transform(ast, assignedOptions);
          return generate(ast, assignedOptions);
        } else {
          enambeOptimize && optimize(ast);
          enalbeMinify && minify(ast);
          return { ast, code: "" };
        }
      }
      /*!
        * core-base v9.12.1
        * (c) 2024 kazuya kawaguchi
        * Released under the MIT License.
        */
      function initFeatureFlags$1() {
        if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
          getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
        }
      }
      const pathStateMachine = [];
      pathStateMachine[
        0
        /* States.BEFORE_PATH */
      ] = {
        [
          "w"
          /* PathCharTypes.WORKSPACE */
        ]: [
          0
          /* States.BEFORE_PATH */
        ],
        [
          "i"
          /* PathCharTypes.IDENT */
        ]: [
          3,
          0
          /* Actions.APPEND */
        ],
        [
          "["
          /* PathCharTypes.LEFT_BRACKET */
        ]: [
          4
          /* States.IN_SUB_PATH */
        ],
        [
          "o"
          /* PathCharTypes.END_OF_FAIL */
        ]: [
          7
          /* States.AFTER_PATH */
        ]
      };
      pathStateMachine[
        1
        /* States.IN_PATH */
      ] = {
        [
          "w"
          /* PathCharTypes.WORKSPACE */
        ]: [
          1
          /* States.IN_PATH */
        ],
        [
          "."
          /* PathCharTypes.DOT */
        ]: [
          2
          /* States.BEFORE_IDENT */
        ],
        [
          "["
          /* PathCharTypes.LEFT_BRACKET */
        ]: [
          4
          /* States.IN_SUB_PATH */
        ],
        [
          "o"
          /* PathCharTypes.END_OF_FAIL */
        ]: [
          7
          /* States.AFTER_PATH */
        ]
      };
      pathStateMachine[
        2
        /* States.BEFORE_IDENT */
      ] = {
        [
          "w"
          /* PathCharTypes.WORKSPACE */
        ]: [
          2
          /* States.BEFORE_IDENT */
        ],
        [
          "i"
          /* PathCharTypes.IDENT */
        ]: [
          3,
          0
          /* Actions.APPEND */
        ],
        [
          "0"
          /* PathCharTypes.ZERO */
        ]: [
          3,
          0
          /* Actions.APPEND */
        ]
      };
      pathStateMachine[
        3
        /* States.IN_IDENT */
      ] = {
        [
          "i"
          /* PathCharTypes.IDENT */
        ]: [
          3,
          0
          /* Actions.APPEND */
        ],
        [
          "0"
          /* PathCharTypes.ZERO */
        ]: [
          3,
          0
          /* Actions.APPEND */
        ],
        [
          "w"
          /* PathCharTypes.WORKSPACE */
        ]: [
          1,
          1
          /* Actions.PUSH */
        ],
        [
          "."
          /* PathCharTypes.DOT */
        ]: [
          2,
          1
          /* Actions.PUSH */
        ],
        [
          "["
          /* PathCharTypes.LEFT_BRACKET */
        ]: [
          4,
          1
          /* Actions.PUSH */
        ],
        [
          "o"
          /* PathCharTypes.END_OF_FAIL */
        ]: [
          7,
          1
          /* Actions.PUSH */
        ]
      };
      pathStateMachine[
        4
        /* States.IN_SUB_PATH */
      ] = {
        [
          "'"
          /* PathCharTypes.SINGLE_QUOTE */
        ]: [
          5,
          0
          /* Actions.APPEND */
        ],
        [
          '"'
          /* PathCharTypes.DOUBLE_QUOTE */
        ]: [
          6,
          0
          /* Actions.APPEND */
        ],
        [
          "["
          /* PathCharTypes.LEFT_BRACKET */
        ]: [
          4,
          2
          /* Actions.INC_SUB_PATH_DEPTH */
        ],
        [
          "]"
          /* PathCharTypes.RIGHT_BRACKET */
        ]: [
          1,
          3
          /* Actions.PUSH_SUB_PATH */
        ],
        [
          "o"
          /* PathCharTypes.END_OF_FAIL */
        ]: 8,
        [
          "l"
          /* PathCharTypes.ELSE */
        ]: [
          4,
          0
          /* Actions.APPEND */
        ]
      };
      pathStateMachine[
        5
        /* States.IN_SINGLE_QUOTE */
      ] = {
        [
          "'"
          /* PathCharTypes.SINGLE_QUOTE */
        ]: [
          4,
          0
          /* Actions.APPEND */
        ],
        [
          "o"
          /* PathCharTypes.END_OF_FAIL */
        ]: 8,
        [
          "l"
          /* PathCharTypes.ELSE */
        ]: [
          5,
          0
          /* Actions.APPEND */
        ]
      };
      pathStateMachine[
        6
        /* States.IN_DOUBLE_QUOTE */
      ] = {
        [
          '"'
          /* PathCharTypes.DOUBLE_QUOTE */
        ]: [
          4,
          0
          /* Actions.APPEND */
        ],
        [
          "o"
          /* PathCharTypes.END_OF_FAIL */
        ]: 8,
        [
          "l"
          /* PathCharTypes.ELSE */
        ]: [
          6,
          0
          /* Actions.APPEND */
        ]
      };
      const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
      function isLiteral(exp) {
        return literalValueRE.test(exp);
      }
      function stripQuotes(str) {
        const a2 = str.charCodeAt(0);
        const b2 = str.charCodeAt(str.length - 1);
        return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
      }
      function getPathCharType(ch) {
        if (ch === void 0 || ch === null) {
          return "o";
        }
        const code2 = ch.charCodeAt(0);
        switch (code2) {
          case 91:
          case 93:
          case 46:
          case 34:
          case 39:
            return ch;
          case 95:
          case 36:
          case 45:
            return "i";
          case 9:
          case 10:
          case 13:
          case 160:
          case 65279:
          case 8232:
          case 8233:
            return "w";
        }
        return "i";
      }
      function formatSubPath(path) {
        const trimmed = path.trim();
        if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
          return false;
        }
        return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
      }
      function parse(path) {
        const keys2 = [];
        let index = -1;
        let mode = 0;
        let subPathDepth = 0;
        let c2;
        let key;
        let newChar;
        let type;
        let transition;
        let action;
        let typeMap;
        const actions = [];
        actions[
          0
          /* Actions.APPEND */
        ] = () => {
          if (key === void 0) {
            key = newChar;
          } else {
            key += newChar;
          }
        };
        actions[
          1
          /* Actions.PUSH */
        ] = () => {
          if (key !== void 0) {
            keys2.push(key);
            key = void 0;
          }
        };
        actions[
          2
          /* Actions.INC_SUB_PATH_DEPTH */
        ] = () => {
          actions[
            0
            /* Actions.APPEND */
          ]();
          subPathDepth++;
        };
        actions[
          3
          /* Actions.PUSH_SUB_PATH */
        ] = () => {
          if (subPathDepth > 0) {
            subPathDepth--;
            mode = 4;
            actions[
              0
              /* Actions.APPEND */
            ]();
          } else {
            subPathDepth = 0;
            if (key === void 0) {
              return false;
            }
            key = formatSubPath(key);
            if (key === false) {
              return false;
            } else {
              actions[
                1
                /* Actions.PUSH */
              ]();
            }
          }
        };
        function maybeUnescapeQuote() {
          const nextChar = path[index + 1];
          if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
            index++;
            newChar = "\\" + nextChar;
            actions[
              0
              /* Actions.APPEND */
            ]();
            return true;
          }
        }
        while (mode !== null) {
          index++;
          c2 = path[index];
          if (c2 === "\\" && maybeUnescapeQuote()) {
            continue;
          }
          type = getPathCharType(c2);
          typeMap = pathStateMachine[mode];
          transition = typeMap[type] || typeMap[
            "l"
            /* PathCharTypes.ELSE */
          ] || 8;
          if (transition === 8) {
            return;
          }
          mode = transition[0];
          if (transition[1] !== void 0) {
            action = actions[transition[1]];
            if (action) {
              newChar = c2;
              if (action() === false) {
                return;
              }
            }
          }
          if (mode === 7) {
            return keys2;
          }
        }
      }
      const cache = /* @__PURE__ */ new Map();
      function resolveWithKeyValue(obj, path) {
        return isObject$3(obj) ? obj[path] : null;
      }
      function resolveValue(obj, path) {
        if (!isObject$3(obj)) {
          return null;
        }
        let hit = cache.get(path);
        if (!hit) {
          hit = parse(path);
          if (hit) {
            cache.set(path, hit);
          }
        }
        if (!hit) {
          return null;
        }
        const len = hit.length;
        let last2 = obj;
        let i = 0;
        while (i < len) {
          const val = last2[hit[i]];
          if (val === void 0) {
            return null;
          }
          if (isFunction(last2)) {
            return null;
          }
          last2 = val;
          i++;
        }
        return last2;
      }
      const DEFAULT_MODIFIER = (str) => str;
      const DEFAULT_MESSAGE = (ctx) => "";
      const DEFAULT_MESSAGE_DATA_TYPE = "text";
      const DEFAULT_NORMALIZE = (values2) => values2.length === 0 ? "" : join$1(values2);
      const DEFAULT_INTERPOLATE = toDisplayString;
      function pluralDefault(choice, choicesLength) {
        choice = Math.abs(choice);
        if (choicesLength === 2) {
          return choice ? choice > 1 ? 1 : 0 : 1;
        }
        return choice ? Math.min(choice, 2) : 0;
      }
      function getPluralIndex(options) {
        const index = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
        return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index : index;
      }
      function normalizeNamed(pluralIndex, props) {
        if (!props.count) {
          props.count = pluralIndex;
        }
        if (!props.n) {
          props.n = pluralIndex;
        }
      }
      function createMessageContext(options = {}) {
        const locale = options.locale;
        const pluralIndex = getPluralIndex(options);
        const pluralRule = isObject$3(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
        const orgPluralRule = isObject$3(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
        const plural = (messages2) => {
          return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
        };
        const _list = options.list || [];
        const list = (index) => _list[index];
        const _named = options.named || {};
        isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
        const named = (key) => _named[key];
        function message2(key) {
          const msg = isFunction(options.messages) ? options.messages(key) : isObject$3(options.messages) ? options.messages[key] : false;
          return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
        }
        const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
        const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
        const interpolate = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
        const type = isPlainObject(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
        const linked = (key, ...args) => {
          const [arg1, arg2] = args;
          let type22 = "text";
          let modifier = "";
          if (args.length === 1) {
            if (isObject$3(arg1)) {
              modifier = arg1.modifier || modifier;
              type22 = arg1.type || type22;
            } else if (isString$1(arg1)) {
              modifier = arg1 || modifier;
            }
          } else if (args.length === 2) {
            if (isString$1(arg1)) {
              modifier = arg1 || modifier;
            }
            if (isString$1(arg2)) {
              type22 = arg2 || type22;
            }
          }
          const ret = message2(key)(ctx);
          const msg = (
            // The message in vnode resolved with linked are returned as an array by processor.nomalize
            type22 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
          );
          return modifier ? _modifier(modifier)(msg, type22) : msg;
        };
        const ctx = {
          [
            "list"
            /* HelperNameMap.LIST */
          ]: list,
          [
            "named"
            /* HelperNameMap.NAMED */
          ]: named,
          [
            "plural"
            /* HelperNameMap.PLURAL */
          ]: plural,
          [
            "linked"
            /* HelperNameMap.LINKED */
          ]: linked,
          [
            "message"
            /* HelperNameMap.MESSAGE */
          ]: message2,
          [
            "type"
            /* HelperNameMap.TYPE */
          ]: type,
          [
            "interpolate"
            /* HelperNameMap.INTERPOLATE */
          ]: interpolate,
          [
            "normalize"
            /* HelperNameMap.NORMALIZE */
          ]: normalize,
          [
            "values"
            /* HelperNameMap.VALUES */
          ]: assign$1({}, _list, _named)
        };
        return ctx;
      }
      let devtools = null;
      function setDevToolsHook(hook) {
        devtools = hook;
      }
      function initI18nDevTools(i18n2, version2, meta) {
        devtools && devtools.emit("i18n:init", {
          timestamp: Date.now(),
          i18n: i18n2,
          version: version2,
          meta
        });
      }
      const translateDevTools = /* @__PURE__ */ createDevToolsHook(
        "function:translate"
        /* IntlifyDevToolsHooks.FunctionTranslate */
      );
      function createDevToolsHook(hook) {
        return (payloads) => devtools && devtools.emit(hook, payloads);
      }
      const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
      const inc$1$1 = incrementer(code$1$1);
      const CoreWarnCodes = {
        NOT_FOUND_KEY: code$1$1,
        // 2
        FALLBACK_TO_TRANSLATE: inc$1$1(),
        // 3
        CANNOT_FORMAT_NUMBER: inc$1$1(),
        // 4
        FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
        // 5
        CANNOT_FORMAT_DATE: inc$1$1(),
        // 6
        FALLBACK_TO_DATE_FORMAT: inc$1$1(),
        // 7
        EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
        // 8
        __EXTEND_POINT__: inc$1$1()
        // 9
      };
      const code$2 = CompileErrorCodes.__EXTEND_POINT__;
      const inc$2 = incrementer(code$2);
      const CoreErrorCodes = {
        INVALID_ARGUMENT: code$2,
        // 17
        INVALID_DATE_ARGUMENT: inc$2(),
        // 18
        INVALID_ISO_DATE_ARGUMENT: inc$2(),
        // 19
        NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
        // 20
        NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
        // 21
        NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
        // 22
        NOT_SUPPORT_LOCALE_TYPE: inc$2(),
        // 23
        __EXTEND_POINT__: inc$2()
        // 24
      };
      function createCoreError(code2) {
        return createCompileError(code2, null, void 0);
      }
      function getLocale(context, options) {
        return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
      }
      let _resolveLocale;
      function resolveLocale(locale) {
        if (isString$1(locale)) {
          return locale;
        } else {
          if (isFunction(locale)) {
            if (locale.resolvedOnce && _resolveLocale != null) {
              return _resolveLocale;
            } else if (locale.constructor.name === "Function") {
              const resolve2 = locale();
              if (isPromise(resolve2)) {
                throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
              }
              return _resolveLocale = resolve2;
            } else {
              throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
            }
          } else {
            throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
          }
        }
      }
      function fallbackWithSimple(ctx, fallback, start) {
        return [.../* @__PURE__ */ new Set([
          start,
          ...isArray(fallback) ? fallback : isObject$3(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start]
        ])];
      }
      function fallbackWithLocaleChain(ctx, fallback, start) {
        const startLocale = isString$1(start) ? start : DEFAULT_LOCALE;
        const context = ctx;
        if (!context.__localeChainCache) {
          context.__localeChainCache = /* @__PURE__ */ new Map();
        }
        let chain = context.__localeChainCache.get(startLocale);
        if (!chain) {
          chain = [];
          let block = [start];
          while (isArray(block)) {
            block = appendBlockToChain(chain, block, fallback);
          }
          const defaults = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
          block = isString$1(defaults) ? [defaults] : defaults;
          if (isArray(block)) {
            appendBlockToChain(chain, block, false);
          }
          context.__localeChainCache.set(startLocale, chain);
        }
        return chain;
      }
      function appendBlockToChain(chain, block, blocks) {
        let follow = true;
        for (let i = 0; i < block.length && isBoolean(follow); i++) {
          const locale = block[i];
          if (isString$1(locale)) {
            follow = appendLocaleToChain(chain, block[i], blocks);
          }
        }
        return follow;
      }
      function appendLocaleToChain(chain, locale, blocks) {
        let follow;
        const tokens = locale.split("-");
        do {
          const target = tokens.join("-");
          follow = appendItemToChain(chain, target, blocks);
          tokens.splice(-1, 1);
        } while (tokens.length && follow === true);
        return follow;
      }
      function appendItemToChain(chain, target, blocks) {
        let follow = false;
        if (!chain.includes(target)) {
          follow = true;
          if (target) {
            follow = target[target.length - 1] !== "!";
            const locale = target.replace(/!/g, "");
            chain.push(locale);
            if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
              follow = blocks[locale];
            }
          }
        }
        return follow;
      }
      const VERSION$1 = "9.12.1";
      const NOT_REOSLVED = -1;
      const DEFAULT_LOCALE = "en-US";
      const MISSING_RESOLVE_VALUE = "";
      const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
      function getDefaultLinkedModifiers() {
        return {
          upper: (val, type) => {
            return type === "text" && isString$1(val) ? val.toUpperCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
          },
          lower: (val, type) => {
            return type === "text" && isString$1(val) ? val.toLowerCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
          },
          capitalize: (val, type) => {
            return type === "text" && isString$1(val) ? capitalize(val) : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
          }
        };
      }
      let _compiler;
      function registerMessageCompiler(compiler) {
        _compiler = compiler;
      }
      let _resolver;
      function registerMessageResolver(resolver) {
        _resolver = resolver;
      }
      let _fallbacker;
      function registerLocaleFallbacker(fallbacker) {
        _fallbacker = fallbacker;
      }
      let _additionalMeta = null;
      const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
        _additionalMeta = meta;
      };
      const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
      let _fallbackContext = null;
      const setFallbackContext = (context) => {
        _fallbackContext = context;
      };
      const getFallbackContext = () => _fallbackContext;
      let _cid = 0;
      function createCoreContext(options = {}) {
        const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
        const version2 = isString$1(options.version) ? options.version : VERSION$1;
        const locale = isString$1(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
        const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
        const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
        const messages2 = isPlainObject(options.messages) ? options.messages : { [_locale]: {} };
        const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale]: {} };
        const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale]: {} };
        const modifiers = assign$1({}, options.modifiers || {}, getDefaultLinkedModifiers());
        const pluralRules = options.pluralRules || {};
        const missing = isFunction(options.missing) ? options.missing : null;
        const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
        const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
        const fallbackFormat = !!options.fallbackFormat;
        const unresolving = !!options.unresolving;
        const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
        const processor = isPlainObject(options.processor) ? options.processor : null;
        const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
        const escapeParameter = !!options.escapeParameter;
        const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
        const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
        const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
        const fallbackContext = isObject$3(options.fallbackContext) ? options.fallbackContext : void 0;
        const internalOptions = options;
        const __datetimeFormatters = isObject$3(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
        const __numberFormatters = isObject$3(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
        const __meta = isObject$3(internalOptions.__meta) ? internalOptions.__meta : {};
        _cid++;
        const context = {
          version: version2,
          cid: _cid,
          locale,
          fallbackLocale,
          messages: messages2,
          modifiers,
          pluralRules,
          missing,
          missingWarn,
          fallbackWarn,
          fallbackFormat,
          unresolving,
          postTranslation,
          processor,
          warnHtmlMessage,
          escapeParameter,
          messageCompiler,
          messageResolver,
          localeFallbacker,
          fallbackContext,
          onWarn,
          __meta
        };
        {
          context.datetimeFormats = datetimeFormats;
          context.numberFormats = numberFormats;
          context.__datetimeFormatters = __datetimeFormatters;
          context.__numberFormatters = __numberFormatters;
        }
        if (__INTLIFY_PROD_DEVTOOLS__) {
          initI18nDevTools(context, version2, __meta);
        }
        return context;
      }
      function handleMissing(context, key, locale, missingWarn, type) {
        const { missing, onWarn } = context;
        if (missing !== null) {
          const ret = missing(context, locale, key, type);
          return isString$1(ret) ? ret : key;
        } else {
          return key;
        }
      }
      function updateFallbackLocale(ctx, locale, fallback) {
        const context = ctx;
        context.__localeChainCache = /* @__PURE__ */ new Map();
        ctx.localeFallbacker(ctx, fallback, locale);
      }
      function format(ast) {
        const msg = (ctx) => formatParts(ctx, ast);
        return msg;
      }
      function formatParts(ctx, ast) {
        const body = ast.b || ast.body;
        if ((body.t || body.type) === 1) {
          const plural = body;
          const cases = plural.c || plural.cases;
          return ctx.plural(cases.reduce((messages2, c2) => [
            ...messages2,
            formatMessageParts(ctx, c2)
          ], []));
        } else {
          return formatMessageParts(ctx, body);
        }
      }
      function formatMessageParts(ctx, node) {
        const _static = node.s || node.static;
        if (_static) {
          return ctx.type === "text" ? _static : ctx.normalize([_static]);
        } else {
          const messages2 = (node.i || node.items).reduce((acm, c2) => [...acm, formatMessagePart(ctx, c2)], []);
          return ctx.normalize(messages2);
        }
      }
      function formatMessagePart(ctx, node) {
        const type = node.t || node.type;
        switch (type) {
          case 3: {
            const text = node;
            return text.v || text.value;
          }
          case 9: {
            const literal = node;
            return literal.v || literal.value;
          }
          case 4: {
            const named = node;
            return ctx.interpolate(ctx.named(named.k || named.key));
          }
          case 5: {
            const list = node;
            return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
          }
          case 6: {
            const linked = node;
            const modifier = linked.m || linked.modifier;
            return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
          }
          case 7: {
            const linkedKey = node;
            return linkedKey.v || linkedKey.value;
          }
          case 8: {
            const linkedModifier = node;
            return linkedModifier.v || linkedModifier.value;
          }
          default:
            throw new Error(`unhandled node type on format message part: ${type}`);
        }
      }
      const defaultOnCacheKey = (message2) => message2;
      let compileCache = /* @__PURE__ */ Object.create(null);
      const isMessageAST = (val) => isObject$3(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
      function baseCompile(message2, options = {}) {
        let detectError = false;
        const onError = options.onError || defaultOnError;
        options.onError = (err) => {
          detectError = true;
          onError(err);
        };
        return { ...baseCompile$1(message2, options), detectError };
      }
      function compile(message2, context) {
        if (isString$1(message2)) {
          isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
          const onCacheKey = context.onCacheKey || defaultOnCacheKey;
          const cacheKey = onCacheKey(message2);
          const cached = compileCache[cacheKey];
          if (cached) {
            return cached;
          }
          const { ast, detectError } = baseCompile(message2, {
            ...context,
            location: false,
            jit: true
          });
          const msg = format(ast);
          return !detectError ? compileCache[cacheKey] = msg : msg;
        } else {
          const cacheKey = message2.cacheKey;
          if (cacheKey) {
            const cached = compileCache[cacheKey];
            if (cached) {
              return cached;
            }
            return compileCache[cacheKey] = format(message2);
          } else {
            return format(message2);
          }
        }
      }
      const NOOP_MESSAGE_FUNCTION = () => "";
      const isMessageFunction = (val) => isFunction(val);
      function translate(context, ...args) {
        const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
        const [key, options] = parseTranslateArgs(...args);
        const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
        const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
        const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
        const resolvedMessage = !!options.resolvedMessage;
        const defaultMsgOrKey = isString$1(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
        const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
        const locale = getLocale(context, options);
        escapeParameter && escapeParams(options);
        let [formatScope, targetLocale, message2] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
          key,
          locale,
          messages2[locale] || {}
        ];
        let format2 = formatScope;
        let cacheBaseKey = key;
        if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
          if (enableDefaultMsg) {
            format2 = defaultMsgOrKey;
            cacheBaseKey = format2;
          }
        }
        if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
          return unresolving ? NOT_REOSLVED : key;
        }
        let occurred = false;
        const onError = () => {
          occurred = true;
        };
        const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
        if (occurred) {
          return format2;
        }
        const ctxOptions = getMessageContextOptions(context, targetLocale, message2, options);
        const msgContext = createMessageContext(ctxOptions);
        const messaged = evaluateMessage(context, msg, msgContext);
        const ret = postTranslation ? postTranslation(messaged, key) : messaged;
        if (__INTLIFY_PROD_DEVTOOLS__) {
          const payloads = {
            timestamp: Date.now(),
            key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
            locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
            format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
            message: ret
          };
          payloads.meta = assign$1({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
          translateDevTools(payloads);
        }
        return ret;
      }
      function escapeParams(options) {
        if (isArray(options.list)) {
          options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
        } else if (isObject$3(options.named)) {
          Object.keys(options.named).forEach((key) => {
            if (isString$1(options.named[key])) {
              options.named[key] = escapeHtml(options.named[key]);
            }
          });
        }
      }
      function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
        const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
        const locales = localeFallbacker(context, fallbackLocale, locale);
        let message2 = {};
        let targetLocale;
        let format2 = null;
        const type = "translate";
        for (let i = 0; i < locales.length; i++) {
          targetLocale = locales[i];
          message2 = messages2[targetLocale] || {};
          if ((format2 = resolveValue2(message2, key)) === null) {
            format2 = message2[key];
          }
          if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
            break;
          }
          const missingRet = handleMissing(
            context,
            // eslint-disable-line @typescript-eslint/no-explicit-any
            key,
            targetLocale,
            missingWarn,
            type
          );
          if (missingRet !== key) {
            format2 = missingRet;
          }
        }
        return [format2, targetLocale, message2];
      }
      function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
        const { messageCompiler, warnHtmlMessage } = context;
        if (isMessageFunction(format2)) {
          const msg2 = format2;
          msg2.locale = msg2.locale || targetLocale;
          msg2.key = msg2.key || key;
          return msg2;
        }
        if (messageCompiler == null) {
          const msg2 = () => format2;
          msg2.locale = targetLocale;
          msg2.key = key;
          return msg2;
        }
        const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
        msg.locale = targetLocale;
        msg.key = key;
        msg.source = format2;
        return msg;
      }
      function evaluateMessage(context, msg, msgCtx) {
        const messaged = msg(msgCtx);
        return messaged;
      }
      function parseTranslateArgs(...args) {
        const [arg1, arg2, arg3] = args;
        const options = {};
        if (!isString$1(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
          throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
        }
        const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
        if (isNumber(arg2)) {
          options.plural = arg2;
        } else if (isString$1(arg2)) {
          options.default = arg2;
        } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
          options.named = arg2;
        } else if (isArray(arg2)) {
          options.list = arg2;
        }
        if (isNumber(arg3)) {
          options.plural = arg3;
        } else if (isString$1(arg3)) {
          options.default = arg3;
        } else if (isPlainObject(arg3)) {
          assign$1(options, arg3);
        }
        return [key, options];
      }
      function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
        return {
          locale,
          key,
          warnHtmlMessage,
          onError: (err) => {
            onError && onError(err);
            {
              throw err;
            }
          },
          onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
        };
      }
      function getMessageContextOptions(context, locale, message2, options) {
        const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
        const resolveMessage = (key) => {
          let val = resolveValue2(message2, key);
          if (val == null && fallbackContext) {
            const [, , message22] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
            val = resolveValue2(message22, key);
          }
          if (isString$1(val) || isMessageAST(val)) {
            let occurred = false;
            const onError = () => {
              occurred = true;
            };
            const msg = compileMessageFormat(context, key, locale, val, key, onError);
            return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
          } else if (isMessageFunction(val)) {
            return val;
          } else {
            return NOOP_MESSAGE_FUNCTION;
          }
        };
        const ctxOptions = {
          locale,
          modifiers,
          pluralRules,
          messages: resolveMessage
        };
        if (context.processor) {
          ctxOptions.processor = context.processor;
        }
        if (options.list) {
          ctxOptions.list = options.list;
        }
        if (options.named) {
          ctxOptions.named = options.named;
        }
        if (isNumber(options.plural)) {
          ctxOptions.pluralIndex = options.plural;
        }
        return ctxOptions;
      }
      function datetime(context, ...args) {
        const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
        const { __datetimeFormatters } = context;
        const [key, value, options, overrides] = parseDateTimeArgs(...args);
        const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
        isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
        const part = !!options.part;
        const locale = getLocale(context, options);
        const locales = localeFallbacker(
          context,
          // eslint-disable-line @typescript-eslint/no-explicit-any
          fallbackLocale,
          locale
        );
        if (!isString$1(key) || key === "") {
          return new Intl.DateTimeFormat(locale, overrides).format(value);
        }
        let datetimeFormat = {};
        let targetLocale;
        let format2 = null;
        const type = "datetime format";
        for (let i = 0; i < locales.length; i++) {
          targetLocale = locales[i];
          datetimeFormat = datetimeFormats[targetLocale] || {};
          format2 = datetimeFormat[key];
          if (isPlainObject(format2))
            break;
          handleMissing(context, key, targetLocale, missingWarn, type);
        }
        if (!isPlainObject(format2) || !isString$1(targetLocale)) {
          return unresolving ? NOT_REOSLVED : key;
        }
        let id = `${targetLocale}__${key}`;
        if (!isEmptyObject(overrides)) {
          id = `${id}__${JSON.stringify(overrides)}`;
        }
        let formatter = __datetimeFormatters.get(id);
        if (!formatter) {
          formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
          __datetimeFormatters.set(id, formatter);
        }
        return !part ? formatter.format(value) : formatter.formatToParts(value);
      }
      const DATETIME_FORMAT_OPTIONS_KEYS = [
        "localeMatcher",
        "weekday",
        "era",
        "year",
        "month",
        "day",
        "hour",
        "minute",
        "second",
        "timeZoneName",
        "formatMatcher",
        "hour12",
        "timeZone",
        "dateStyle",
        "timeStyle",
        "calendar",
        "dayPeriod",
        "numberingSystem",
        "hourCycle",
        "fractionalSecondDigits"
      ];
      function parseDateTimeArgs(...args) {
        const [arg1, arg2, arg3, arg4] = args;
        const options = {};
        let overrides = {};
        let value;
        if (isString$1(arg1)) {
          const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
          if (!matches) {
            throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
          }
          const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
          value = new Date(dateTime);
          try {
            value.toISOString();
          } catch (e) {
            throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
          }
        } else if (isDate(arg1)) {
          if (isNaN(arg1.getTime())) {
            throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
          }
          value = arg1;
        } else if (isNumber(arg1)) {
          value = arg1;
        } else {
          throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
        }
        if (isString$1(arg2)) {
          options.key = arg2;
        } else if (isPlainObject(arg2)) {
          Object.keys(arg2).forEach((key) => {
            if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
              overrides[key] = arg2[key];
            } else {
              options[key] = arg2[key];
            }
          });
        }
        if (isString$1(arg3)) {
          options.locale = arg3;
        } else if (isPlainObject(arg3)) {
          overrides = arg3;
        }
        if (isPlainObject(arg4)) {
          overrides = arg4;
        }
        return [options.key || "", value, options, overrides];
      }
      function clearDateTimeFormat(ctx, locale, format2) {
        const context = ctx;
        for (const key in format2) {
          const id = `${locale}__${key}`;
          if (!context.__datetimeFormatters.has(id)) {
            continue;
          }
          context.__datetimeFormatters.delete(id);
        }
      }
      function number(context, ...args) {
        const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
        const { __numberFormatters } = context;
        const [key, value, options, overrides] = parseNumberArgs(...args);
        const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
        isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
        const part = !!options.part;
        const locale = getLocale(context, options);
        const locales = localeFallbacker(
          context,
          // eslint-disable-line @typescript-eslint/no-explicit-any
          fallbackLocale,
          locale
        );
        if (!isString$1(key) || key === "") {
          return new Intl.NumberFormat(locale, overrides).format(value);
        }
        let numberFormat = {};
        let targetLocale;
        let format2 = null;
        const type = "number format";
        for (let i = 0; i < locales.length; i++) {
          targetLocale = locales[i];
          numberFormat = numberFormats[targetLocale] || {};
          format2 = numberFormat[key];
          if (isPlainObject(format2))
            break;
          handleMissing(context, key, targetLocale, missingWarn, type);
        }
        if (!isPlainObject(format2) || !isString$1(targetLocale)) {
          return unresolving ? NOT_REOSLVED : key;
        }
        let id = `${targetLocale}__${key}`;
        if (!isEmptyObject(overrides)) {
          id = `${id}__${JSON.stringify(overrides)}`;
        }
        let formatter = __numberFormatters.get(id);
        if (!formatter) {
          formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
          __numberFormatters.set(id, formatter);
        }
        return !part ? formatter.format(value) : formatter.formatToParts(value);
      }
      const NUMBER_FORMAT_OPTIONS_KEYS = [
        "localeMatcher",
        "style",
        "currency",
        "currencyDisplay",
        "currencySign",
        "useGrouping",
        "minimumIntegerDigits",
        "minimumFractionDigits",
        "maximumFractionDigits",
        "minimumSignificantDigits",
        "maximumSignificantDigits",
        "compactDisplay",
        "notation",
        "signDisplay",
        "unit",
        "unitDisplay",
        "roundingMode",
        "roundingPriority",
        "roundingIncrement",
        "trailingZeroDisplay"
      ];
      function parseNumberArgs(...args) {
        const [arg1, arg2, arg3, arg4] = args;
        const options = {};
        let overrides = {};
        if (!isNumber(arg1)) {
          throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
        }
        const value = arg1;
        if (isString$1(arg2)) {
          options.key = arg2;
        } else if (isPlainObject(arg2)) {
          Object.keys(arg2).forEach((key) => {
            if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
              overrides[key] = arg2[key];
            } else {
              options[key] = arg2[key];
            }
          });
        }
        if (isString$1(arg3)) {
          options.locale = arg3;
        } else if (isPlainObject(arg3)) {
          overrides = arg3;
        }
        if (isPlainObject(arg4)) {
          overrides = arg4;
        }
        return [options.key || "", value, options, overrides];
      }
      function clearNumberFormat(ctx, locale, format2) {
        const context = ctx;
        for (const key in format2) {
          const id = `${locale}__${key}`;
          if (!context.__numberFormatters.has(id)) {
            continue;
          }
          context.__numberFormatters.delete(id);
        }
      }
      {
        initFeatureFlags$1();
      }
      /*!
        * vue-i18n v9.12.1
        * (c) 2024 kazuya kawaguchi
        * Released under the MIT License.
        */
      const VERSION = "9.12.1";
      function initFeatureFlags() {
        if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
          getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
        }
      }
      const code$1 = CoreWarnCodes.__EXTEND_POINT__;
      const inc$1 = incrementer(code$1);
      ({
        FALLBACK_TO_ROOT: code$1,
        // 9
        NOT_SUPPORTED_PRESERVE: inc$1(),
        // 10
        NOT_SUPPORTED_FORMATTER: inc$1(),
        // 11
        NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
        // 12
        NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
        // 13
        COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
        // 14
        NOT_FOUND_PARENT_SCOPE: inc$1(),
        // 15
        IGNORE_OBJ_FLATTEN: inc$1(),
        // 16
        NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
        // 17
        NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
        // 18
      });
      const code = CoreErrorCodes.__EXTEND_POINT__;
      const inc = incrementer(code);
      const I18nErrorCodes = {
        // composer module errors
        UNEXPECTED_RETURN_TYPE: code,
        // 24
        // legacy module errors
        INVALID_ARGUMENT: inc(),
        // 25
        // i18n module errors
        MUST_BE_CALL_SETUP_TOP: inc(),
        // 26
        NOT_INSTALLED: inc(),
        // 27
        NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
        // 28
        // directive module errors
        REQUIRED_VALUE: inc(),
        // 29
        INVALID_VALUE: inc(),
        // 30
        // vue-devtools errors
        CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
        // 31
        NOT_INSTALLED_WITH_PROVIDE: inc(),
        // 32
        // unexpected error
        UNEXPECTED_ERROR: inc(),
        // 33
        // not compatible legacy vue-i18n constructor
        NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
        // 34
        // bridge support vue 2.x only
        BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
        // 35
        // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
        MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
        // 36
        // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
        NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
        // 37
        // for enhancement
        __EXTEND_POINT__: inc()
        // 38
      };
      function createI18nError(code2, ...args) {
        return createCompileError(code2, null, void 0);
      }
      const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
      const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
      const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
      const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
      const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
      const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
      function handleFlatJson(obj) {
        if (!isObject$3(obj)) {
          return obj;
        }
        for (const key in obj) {
          if (!hasOwn(obj, key)) {
            continue;
          }
          if (!key.includes(".")) {
            if (isObject$3(obj[key])) {
              handleFlatJson(obj[key]);
            }
          } else {
            const subKeys = key.split(".");
            const lastIndex = subKeys.length - 1;
            let currentObj = obj;
            let hasStringValue = false;
            for (let i = 0; i < lastIndex; i++) {
              if (!(subKeys[i] in currentObj)) {
                currentObj[subKeys[i]] = {};
              }
              if (!isObject$3(currentObj[subKeys[i]])) {
                hasStringValue = true;
                break;
              }
              currentObj = currentObj[subKeys[i]];
            }
            if (!hasStringValue) {
              currentObj[subKeys[lastIndex]] = obj[key];
              delete obj[key];
            }
            if (isObject$3(currentObj[subKeys[lastIndex]])) {
              handleFlatJson(currentObj[subKeys[lastIndex]]);
            }
          }
        }
        return obj;
      }
      function getLocaleMessages(locale, options) {
        const { messages: messages2, __i18n, messageResolver, flatJson } = options;
        const ret = isPlainObject(messages2) ? messages2 : isArray(__i18n) ? {} : { [locale]: {} };
        if (isArray(__i18n)) {
          __i18n.forEach((custom) => {
            if ("locale" in custom && "resource" in custom) {
              const { locale: locale2, resource: resource2 } = custom;
              if (locale2) {
                ret[locale2] = ret[locale2] || {};
                deepCopy(resource2, ret[locale2]);
              } else {
                deepCopy(resource2, ret);
              }
            } else {
              isString$1(custom) && deepCopy(JSON.parse(custom), ret);
            }
          });
        }
        if (messageResolver == null && flatJson) {
          for (const key in ret) {
            if (hasOwn(ret, key)) {
              handleFlatJson(ret[key]);
            }
          }
        }
        return ret;
      }
      function getComponentOptions(instance) {
        return instance.type;
      }
      function adjustI18nResources(gl, options, componentOptions) {
        let messages2 = isObject$3(options.messages) ? options.messages : {};
        if ("__i18nGlobal" in componentOptions) {
          messages2 = getLocaleMessages(gl.locale.value, {
            messages: messages2,
            __i18n: componentOptions.__i18nGlobal
          });
        }
        const locales = Object.keys(messages2);
        if (locales.length) {
          locales.forEach((locale) => {
            gl.mergeLocaleMessage(locale, messages2[locale]);
          });
        }
        {
          if (isObject$3(options.datetimeFormats)) {
            const locales2 = Object.keys(options.datetimeFormats);
            if (locales2.length) {
              locales2.forEach((locale) => {
                gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
              });
            }
          }
          if (isObject$3(options.numberFormats)) {
            const locales2 = Object.keys(options.numberFormats);
            if (locales2.length) {
              locales2.forEach((locale) => {
                gl.mergeNumberFormat(locale, options.numberFormats[locale]);
              });
            }
          }
        }
      }
      function createTextNode(key) {
        return createVNode(Text, null, key, 0);
      }
      const DEVTOOLS_META = "__INTLIFY_META__";
      const NOOP_RETURN_ARRAY = () => [];
      const NOOP_RETURN_FALSE = () => false;
      let composerID = 0;
      function defineCoreMissingHandler(missing) {
        return (ctx, locale, key, type) => {
          return missing(locale, key, getCurrentInstance() || void 0, type);
        };
      }
      const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
        const instance = getCurrentInstance();
        let meta = null;
        return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
      };
      function createComposer(options = {}, VueI18nLegacy) {
        const { __root, __injectWithOption } = options;
        const _isGlobal = __root === void 0;
        const flatJson = options.flatJson;
        const _ref = inBrowser ? ref : shallowRef;
        const translateExistCompatible = !!options.translateExistCompatible;
        let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
        const _locale = _ref(
          // prettier-ignore
          __root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
        );
        const _fallbackLocale = _ref(
          // prettier-ignore
          __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
        );
        const _messages = _ref(getLocaleMessages(_locale.value, options));
        const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
        const _numberFormats = _ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
        let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
        let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
        let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
        let _fallbackFormat = !!options.fallbackFormat;
        let _missing = isFunction(options.missing) ? options.missing : null;
        let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
        let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
        let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
        let _escapeParameter = !!options.escapeParameter;
        const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
        let _pluralRules = options.pluralRules || __root && __root.pluralRules;
        let _context;
        const getCoreContext = () => {
          _isGlobal && setFallbackContext(null);
          const ctxOptions = {
            version: VERSION,
            locale: _locale.value,
            fallbackLocale: _fallbackLocale.value,
            messages: _messages.value,
            modifiers: _modifiers,
            pluralRules: _pluralRules,
            missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
            missingWarn: _missingWarn,
            fallbackWarn: _fallbackWarn,
            fallbackFormat: _fallbackFormat,
            unresolving: true,
            postTranslation: _postTranslation === null ? void 0 : _postTranslation,
            warnHtmlMessage: _warnHtmlMessage,
            escapeParameter: _escapeParameter,
            messageResolver: options.messageResolver,
            messageCompiler: options.messageCompiler,
            __meta: { framework: "vue" }
          };
          {
            ctxOptions.datetimeFormats = _datetimeFormats.value;
            ctxOptions.numberFormats = _numberFormats.value;
            ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
            ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
          }
          const ctx = createCoreContext(ctxOptions);
          _isGlobal && setFallbackContext(ctx);
          return ctx;
        };
        _context = getCoreContext();
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
        function trackReactivityValues() {
          return [
            _locale.value,
            _fallbackLocale.value,
            _messages.value,
            _datetimeFormats.value,
            _numberFormats.value
          ];
        }
        const locale = computed({
          get: () => _locale.value,
          set: (val) => {
            _locale.value = val;
            _context.locale = _locale.value;
          }
        });
        const fallbackLocale = computed({
          get: () => _fallbackLocale.value,
          set: (val) => {
            _fallbackLocale.value = val;
            _context.fallbackLocale = _fallbackLocale.value;
            updateFallbackLocale(_context, _locale.value, val);
          }
        });
        const messages2 = computed(() => _messages.value);
        const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
        const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
        function getPostTranslationHandler() {
          return isFunction(_postTranslation) ? _postTranslation : null;
        }
        function setPostTranslationHandler(handler) {
          _postTranslation = handler;
          _context.postTranslation = handler;
        }
        function getMissingHandler() {
          return _missing;
        }
        function setMissingHandler(handler) {
          if (handler !== null) {
            _runtimeMissing = defineCoreMissingHandler(handler);
          }
          _missing = handler;
          _context.missing = _runtimeMissing;
        }
        const wrapWithDeps = (fn2, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
          trackReactivityValues();
          let ret;
          try {
            if (__INTLIFY_PROD_DEVTOOLS__) {
              /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
            }
            if (!_isGlobal) {
              _context.fallbackContext = __root ? getFallbackContext() : void 0;
            }
            ret = fn2(_context);
          } finally {
            if (__INTLIFY_PROD_DEVTOOLS__)
              ;
            if (!_isGlobal) {
              _context.fallbackContext = void 0;
            }
          }
          if (warnType !== "translate exists" && // for not `te` (e.g `t`)
          isNumber(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
            const [key, arg2] = argumentParser();
            return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
          } else if (successCondition(ret)) {
            return ret;
          } else {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
          }
        };
        function t2(...args) {
          return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root2) => Reflect.apply(root2.t, root2, [...args]), (key) => key, (val) => isString$1(val));
        }
        function rt2(...args) {
          const [arg1, arg2, arg3] = args;
          if (arg3 && !isObject$3(arg3)) {
            throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
          }
          return t2(...[arg1, arg2, assign$1({ resolvedMessage: true }, arg3 || {})]);
        }
        function d2(...args) {
          return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => Reflect.apply(root2.d, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
        }
        function n(...args) {
          return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => Reflect.apply(root2.n, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
        }
        function normalize(values2) {
          return values2.map((val) => isString$1(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
        }
        const interpolate = (val) => val;
        const processor = {
          normalize,
          interpolate,
          type: "vnode"
        };
        function translateVNode(...args) {
          return wrapWithDeps(
            (context) => {
              let ret;
              const _context2 = context;
              try {
                _context2.processor = processor;
                ret = Reflect.apply(translate, null, [_context2, ...args]);
              } finally {
                _context2.processor = null;
              }
              return ret;
            },
            () => parseTranslateArgs(...args),
            "translate",
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (root2) => root2[TranslateVNodeSymbol](...args),
            (key) => [createTextNode(key)],
            (val) => isArray(val)
          );
        }
        function numberParts(...args) {
          return wrapWithDeps(
            (context) => Reflect.apply(number, null, [context, ...args]),
            () => parseNumberArgs(...args),
            "number format",
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (root2) => root2[NumberPartsSymbol](...args),
            NOOP_RETURN_ARRAY,
            (val) => isString$1(val) || isArray(val)
          );
        }
        function datetimeParts(...args) {
          return wrapWithDeps(
            (context) => Reflect.apply(datetime, null, [context, ...args]),
            () => parseDateTimeArgs(...args),
            "datetime format",
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (root2) => root2[DatetimePartsSymbol](...args),
            NOOP_RETURN_ARRAY,
            (val) => isString$1(val) || isArray(val)
          );
        }
        function setPluralRules(rules2) {
          _pluralRules = rules2;
          _context.pluralRules = _pluralRules;
        }
        function te2(key, locale2) {
          return wrapWithDeps(() => {
            if (!key) {
              return false;
            }
            const targetLocale = isString$1(locale2) ? locale2 : _locale.value;
            const message2 = getLocaleMessage(targetLocale);
            const resolved = _context.messageResolver(message2, key);
            return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$1(resolved) : resolved != null;
          }, () => [key], "translate exists", (root2) => {
            return Reflect.apply(root2.te, root2, [key, locale2]);
          }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
        }
        function resolveMessages(key) {
          let messages22 = null;
          const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
          for (let i = 0; i < locales.length; i++) {
            const targetLocaleMessages = _messages.value[locales[i]] || {};
            const messageValue = _context.messageResolver(targetLocaleMessages, key);
            if (messageValue != null) {
              messages22 = messageValue;
              break;
            }
          }
          return messages22;
        }
        function tm(key) {
          const messages22 = resolveMessages(key);
          return messages22 != null ? messages22 : __root ? __root.tm(key) || {} : {};
        }
        function getLocaleMessage(locale2) {
          return _messages.value[locale2] || {};
        }
        function setLocaleMessage(locale2, message2) {
          if (flatJson) {
            const _message = { [locale2]: message2 };
            for (const key in _message) {
              if (hasOwn(_message, key)) {
                handleFlatJson(_message[key]);
              }
            }
            message2 = _message[locale2];
          }
          _messages.value[locale2] = message2;
          _context.messages = _messages.value;
        }
        function mergeLocaleMessage(locale2, message2) {
          _messages.value[locale2] = _messages.value[locale2] || {};
          const _message = { [locale2]: message2 };
          if (flatJson) {
            for (const key in _message) {
              if (hasOwn(_message, key)) {
                handleFlatJson(_message[key]);
              }
            }
          }
          message2 = _message[locale2];
          deepCopy(message2, _messages.value[locale2]);
          _context.messages = _messages.value;
        }
        function getDateTimeFormat(locale2) {
          return _datetimeFormats.value[locale2] || {};
        }
        function setDateTimeFormat(locale2, format2) {
          _datetimeFormats.value[locale2] = format2;
          _context.datetimeFormats = _datetimeFormats.value;
          clearDateTimeFormat(_context, locale2, format2);
        }
        function mergeDateTimeFormat(locale2, format2) {
          _datetimeFormats.value[locale2] = assign$1(_datetimeFormats.value[locale2] || {}, format2);
          _context.datetimeFormats = _datetimeFormats.value;
          clearDateTimeFormat(_context, locale2, format2);
        }
        function getNumberFormat(locale2) {
          return _numberFormats.value[locale2] || {};
        }
        function setNumberFormat(locale2, format2) {
          _numberFormats.value[locale2] = format2;
          _context.numberFormats = _numberFormats.value;
          clearNumberFormat(_context, locale2, format2);
        }
        function mergeNumberFormat(locale2, format2) {
          _numberFormats.value[locale2] = assign$1(_numberFormats.value[locale2] || {}, format2);
          _context.numberFormats = _numberFormats.value;
          clearNumberFormat(_context, locale2, format2);
        }
        composerID++;
        if (__root && inBrowser) {
          watch(__root.locale, (val) => {
            if (_inheritLocale) {
              _locale.value = val;
              _context.locale = val;
              updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
            }
          });
          watch(__root.fallbackLocale, (val) => {
            if (_inheritLocale) {
              _fallbackLocale.value = val;
              _context.fallbackLocale = val;
              updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
            }
          });
        }
        const composer = {
          id: composerID,
          locale,
          fallbackLocale,
          get inheritLocale() {
            return _inheritLocale;
          },
          set inheritLocale(val) {
            _inheritLocale = val;
            if (val && __root) {
              _locale.value = __root.locale.value;
              _fallbackLocale.value = __root.fallbackLocale.value;
              updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
            }
          },
          get availableLocales() {
            return Object.keys(_messages.value).sort();
          },
          messages: messages2,
          get modifiers() {
            return _modifiers;
          },
          get pluralRules() {
            return _pluralRules || {};
          },
          get isGlobal() {
            return _isGlobal;
          },
          get missingWarn() {
            return _missingWarn;
          },
          set missingWarn(val) {
            _missingWarn = val;
            _context.missingWarn = _missingWarn;
          },
          get fallbackWarn() {
            return _fallbackWarn;
          },
          set fallbackWarn(val) {
            _fallbackWarn = val;
            _context.fallbackWarn = _fallbackWarn;
          },
          get fallbackRoot() {
            return _fallbackRoot;
          },
          set fallbackRoot(val) {
            _fallbackRoot = val;
          },
          get fallbackFormat() {
            return _fallbackFormat;
          },
          set fallbackFormat(val) {
            _fallbackFormat = val;
            _context.fallbackFormat = _fallbackFormat;
          },
          get warnHtmlMessage() {
            return _warnHtmlMessage;
          },
          set warnHtmlMessage(val) {
            _warnHtmlMessage = val;
            _context.warnHtmlMessage = val;
          },
          get escapeParameter() {
            return _escapeParameter;
          },
          set escapeParameter(val) {
            _escapeParameter = val;
            _context.escapeParameter = val;
          },
          t: t2,
          getLocaleMessage,
          setLocaleMessage,
          mergeLocaleMessage,
          getPostTranslationHandler,
          setPostTranslationHandler,
          getMissingHandler,
          setMissingHandler,
          [SetPluralRulesSymbol]: setPluralRules
        };
        {
          composer.datetimeFormats = datetimeFormats;
          composer.numberFormats = numberFormats;
          composer.rt = rt2;
          composer.te = te2;
          composer.tm = tm;
          composer.d = d2;
          composer.n = n;
          composer.getDateTimeFormat = getDateTimeFormat;
          composer.setDateTimeFormat = setDateTimeFormat;
          composer.mergeDateTimeFormat = mergeDateTimeFormat;
          composer.getNumberFormat = getNumberFormat;
          composer.setNumberFormat = setNumberFormat;
          composer.mergeNumberFormat = mergeNumberFormat;
          composer[InejctWithOptionSymbol] = __injectWithOption;
          composer[TranslateVNodeSymbol] = translateVNode;
          composer[DatetimePartsSymbol] = datetimeParts;
          composer[NumberPartsSymbol] = numberParts;
        }
        return composer;
      }
      const baseFormatProps = {
        tag: {
          type: [String, Object]
        },
        locale: {
          type: String
        },
        scope: {
          type: String,
          // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
          validator: (val) => val === "parent" || val === "global",
          default: "parent"
          /* ComponentI18nScope */
        },
        i18n: {
          type: Object
        }
      };
      function getInterpolateArg({ slots }, keys2) {
        if (keys2.length === 1 && keys2[0] === "default") {
          const ret = slots.default ? slots.default() : [];
          return ret.reduce((slot, current) => {
            return [
              ...slot,
              // prettier-ignore
              ...current.type === Fragment$1 ? current.children : [current]
            ];
          }, []);
        } else {
          return keys2.reduce((arg, key) => {
            const slot = slots[key];
            if (slot) {
              arg[key] = slot();
            }
            return arg;
          }, {});
        }
      }
      function getFragmentableTag(tag) {
        return Fragment$1;
      }
      const TranslationImpl = /* @__PURE__ */ defineComponent({
        /* eslint-disable */
        name: "i18n-t",
        props: assign$1({
          keypath: {
            type: String,
            required: true
          },
          plural: {
            type: [Number, String],
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            validator: (val) => isNumber(val) || !isNaN(val)
          }
        }, baseFormatProps),
        /* eslint-enable */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        setup(props, context) {
          const { slots, attrs } = context;
          const i18n2 = props.i18n || useI18n({
            useScope: props.scope,
            __useComponent: true
          });
          return () => {
            const keys2 = Object.keys(slots).filter((key) => key !== "_");
            const options = {};
            if (props.locale) {
              options.locale = props.locale;
            }
            if (props.plural !== void 0) {
              options.plural = isString$1(props.plural) ? +props.plural : props.plural;
            }
            const arg = getInterpolateArg(context, keys2);
            const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
            const assignedAttrs = assign$1({}, attrs);
            const tag = isString$1(props.tag) || isObject$3(props.tag) ? props.tag : getFragmentableTag();
            return h$1(tag, assignedAttrs, children);
          };
        }
      });
      const Translation = TranslationImpl;
      function isVNode(target) {
        return isArray(target) && !isString$1(target[0]);
      }
      function renderFormatter(props, context, slotKeys, partFormatter) {
        const { slots, attrs } = context;
        return () => {
          const options = { part: true };
          let overrides = {};
          if (props.locale) {
            options.locale = props.locale;
          }
          if (isString$1(props.format)) {
            options.key = props.format;
          } else if (isObject$3(props.format)) {
            if (isString$1(props.format.key)) {
              options.key = props.format.key;
            }
            overrides = Object.keys(props.format).reduce((options2, prop) => {
              return slotKeys.includes(prop) ? assign$1({}, options2, { [prop]: props.format[prop] }) : options2;
            }, {});
          }
          const parts = partFormatter(...[props.value, options, overrides]);
          let children = [options.key];
          if (isArray(parts)) {
            children = parts.map((part, index) => {
              const slot = slots[part.type];
              const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
              if (isVNode(node)) {
                node[0].key = `${part.type}-${index}`;
              }
              return node;
            });
          } else if (isString$1(parts)) {
            children = [parts];
          }
          const assignedAttrs = assign$1({}, attrs);
          const tag = isString$1(props.tag) || isObject$3(props.tag) ? props.tag : getFragmentableTag();
          return h$1(tag, assignedAttrs, children);
        };
      }
      const NumberFormatImpl = /* @__PURE__ */ defineComponent({
        /* eslint-disable */
        name: "i18n-n",
        props: assign$1({
          value: {
            type: Number,
            required: true
          },
          format: {
            type: [String, Object]
          }
        }, baseFormatProps),
        /* eslint-enable */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        setup(props, context) {
          const i18n2 = props.i18n || useI18n({
            useScope: props.scope,
            __useComponent: true
          });
          return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            i18n2[NumberPartsSymbol](...args)
          ));
        }
      });
      const NumberFormat = NumberFormatImpl;
      const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
        /* eslint-disable */
        name: "i18n-d",
        props: assign$1({
          value: {
            type: [Number, Date],
            required: true
          },
          format: {
            type: [String, Object]
          }
        }, baseFormatProps),
        /* eslint-enable */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        setup(props, context) {
          const i18n2 = props.i18n || useI18n({
            useScope: props.scope,
            __useComponent: true
          });
          return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            i18n2[DatetimePartsSymbol](...args)
          ));
        }
      });
      const DatetimeFormat = DatetimeFormatImpl;
      function getComposer$2(i18n2, instance) {
        const i18nInternal = i18n2;
        if (i18n2.mode === "composition") {
          return i18nInternal.__getInstance(instance) || i18n2.global;
        } else {
          const vueI18n = i18nInternal.__getInstance(instance);
          return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
        }
      }
      function vTDirective(i18n2) {
        const _process = (binding) => {
          const { instance, modifiers, value } = binding;
          if (!instance || !instance.$) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          const composer = getComposer$2(i18n2, instance.$);
          const parsedValue = parseValue(value);
          return [
            Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
            composer
          ];
        };
        const register = (el, binding) => {
          const [textContent, composer] = _process(binding);
          if (inBrowser && i18n2.global === composer) {
            el.__i18nWatcher = watch(composer.locale, () => {
              binding.instance && binding.instance.$forceUpdate();
            });
          }
          el.__composer = composer;
          el.textContent = textContent;
        };
        const unregister = (el) => {
          if (inBrowser && el.__i18nWatcher) {
            el.__i18nWatcher();
            el.__i18nWatcher = void 0;
            delete el.__i18nWatcher;
          }
          if (el.__composer) {
            el.__composer = void 0;
            delete el.__composer;
          }
        };
        const update = (el, { value }) => {
          if (el.__composer) {
            const composer = el.__composer;
            const parsedValue = parseValue(value);
            el.textContent = Reflect.apply(composer.t, composer, [
              ...makeParams(parsedValue)
            ]);
          }
        };
        const getSSRProps = (binding) => {
          const [textContent] = _process(binding);
          return { textContent };
        };
        return {
          created: register,
          unmounted: unregister,
          beforeUpdate: update,
          getSSRProps
        };
      }
      function parseValue(value) {
        if (isString$1(value)) {
          return { path: value };
        } else if (isPlainObject(value)) {
          if (!("path" in value)) {
            throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
          }
          return value;
        } else {
          throw createI18nError(I18nErrorCodes.INVALID_VALUE);
        }
      }
      function makeParams(value) {
        const { path, locale, args, choice, plural } = value;
        const options = {};
        const named = args || {};
        if (isString$1(locale)) {
          options.locale = locale;
        }
        if (isNumber(choice)) {
          options.plural = choice;
        }
        if (isNumber(plural)) {
          options.plural = plural;
        }
        return [path, named, options];
      }
      function apply(app, i18n2, ...options) {
        const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
        const useI18nComponentName = !!pluginOptions.useI18nComponentName;
        const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
        if (globalInstall) {
          [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app.component(name, Translation));
          [NumberFormat.name, "I18nN"].forEach((name) => app.component(name, NumberFormat));
          [DatetimeFormat.name, "I18nD"].forEach((name) => app.component(name, DatetimeFormat));
        }
        {
          app.directive("t", vTDirective(i18n2));
        }
      }
      const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
      function createI18n(options = {}, VueI18nLegacy) {
        const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
        const __allowComposition = true;
        const __instances = /* @__PURE__ */ new Map();
        const [globalScope, __global] = createGlobal(options);
        const symbol = /* @__PURE__ */ makeSymbol("");
        function __getInstance(component) {
          return __instances.get(component) || null;
        }
        function __setInstance(component, instance) {
          __instances.set(component, instance);
        }
        function __deleteInstance(component) {
          __instances.delete(component);
        }
        {
          const i18n2 = {
            // mode
            get mode() {
              return "composition";
            },
            // allowComposition
            get allowComposition() {
              return __allowComposition;
            },
            // install plugin
            async install(app, ...options2) {
              app.__VUE_I18N_SYMBOL__ = symbol;
              app.provide(app.__VUE_I18N_SYMBOL__, i18n2);
              if (isPlainObject(options2[0])) {
                const opts = options2[0];
                i18n2.__composerExtend = opts.__composerExtend;
                i18n2.__vueI18nExtend = opts.__vueI18nExtend;
              }
              let globalReleaseHandler = null;
              if (__globalInjection) {
                globalReleaseHandler = injectGlobalFields(app, i18n2.global);
              }
              {
                apply(app, i18n2, ...options2);
              }
              const unmountApp = app.unmount;
              app.unmount = () => {
                globalReleaseHandler && globalReleaseHandler();
                i18n2.dispose();
                unmountApp();
              };
            },
            // global accessor
            get global() {
              return __global;
            },
            dispose() {
              globalScope.stop();
            },
            // @internal
            __instances,
            // @internal
            __getInstance,
            // @internal
            __setInstance,
            // @internal
            __deleteInstance
          };
          return i18n2;
        }
      }
      function useI18n(options = {}) {
        const instance = getCurrentInstance();
        if (instance == null) {
          throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
        }
        if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
          throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
        }
        const i18n2 = getI18nInstance(instance);
        const gl = getGlobalComposer(i18n2);
        const componentOptions = getComponentOptions(instance);
        const scope = getScope(options, componentOptions);
        if (scope === "global") {
          adjustI18nResources(gl, options, componentOptions);
          return gl;
        }
        if (scope === "parent") {
          let composer2 = getComposer(i18n2, instance, options.__useComponent);
          if (composer2 == null) {
            composer2 = gl;
          }
          return composer2;
        }
        const i18nInternal = i18n2;
        let composer = i18nInternal.__getInstance(instance);
        if (composer == null) {
          const composerOptions = assign$1({}, options);
          if ("__i18n" in componentOptions) {
            composerOptions.__i18n = componentOptions.__i18n;
          }
          if (gl) {
            composerOptions.__root = gl;
          }
          composer = createComposer(composerOptions);
          if (i18nInternal.__composerExtend) {
            composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
          }
          setupLifeCycle(i18nInternal, instance, composer);
          i18nInternal.__setInstance(instance, composer);
        }
        return composer;
      }
      function createGlobal(options, legacyMode, VueI18nLegacy) {
        const scope = effectScope();
        {
          const obj = scope.run(() => createComposer(options));
          if (obj == null) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          return [scope, obj];
        }
      }
      function getI18nInstance(instance) {
        {
          const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
          if (!i18n2) {
            throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
          }
          return i18n2;
        }
      }
      function getScope(options, componentOptions) {
        return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
      }
      function getGlobalComposer(i18n2) {
        return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
      }
      function getComposer(i18n2, target, useComponent = false) {
        let composer = null;
        const root2 = target.root;
        let current = getParentComponentInstance(target, useComponent);
        while (current != null) {
          const i18nInternal = i18n2;
          if (i18n2.mode === "composition") {
            composer = i18nInternal.__getInstance(current);
          }
          if (composer != null) {
            break;
          }
          if (root2 === current) {
            break;
          }
          current = current.parent;
        }
        return composer;
      }
      function getParentComponentInstance(target, useComponent = false) {
        if (target == null) {
          return null;
        }
        {
          return !useComponent ? target.parent : target.vnode.ctx || target.parent;
        }
      }
      function setupLifeCycle(i18n2, target, composer) {
        {
          onMounted(() => {
          }, target);
          onUnmounted(() => {
            const _composer = composer;
            i18n2.__deleteInstance(target);
            const dispose = _composer[DisposeSymbol];
            if (dispose) {
              dispose();
              delete _composer[DisposeSymbol];
            }
          }, target);
        }
      }
      const globalExportProps = [
        "locale",
        "fallbackLocale",
        "availableLocales"
      ];
      const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
      function injectGlobalFields(app, composer) {
        const i18n2 = /* @__PURE__ */ Object.create(null);
        globalExportProps.forEach((prop) => {
          const desc = Object.getOwnPropertyDescriptor(composer, prop);
          if (!desc) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          const wrap2 = isRef(desc.value) ? {
            get() {
              return desc.value.value;
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            set(val) {
              desc.value.value = val;
            }
          } : {
            get() {
              return desc.get && desc.get();
            }
          };
          Object.defineProperty(i18n2, prop, wrap2);
        });
        app.config.globalProperties.$i18n = i18n2;
        globalExportMethods.forEach((method) => {
          const desc = Object.getOwnPropertyDescriptor(composer, method);
          if (!desc || !desc.value) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
        });
        const dispose = () => {
          delete app.config.globalProperties.$i18n;
          globalExportMethods.forEach((method) => {
            delete app.config.globalProperties[`$${method}`];
          });
        };
        return dispose;
      }
      {
        initFeatureFlags();
      }
      {
        registerMessageCompiler(compile);
      }
      registerMessageResolver(resolveValue);
      registerLocaleFallbacker(fallbackWithLocaleChain);
      if (__INTLIFY_PROD_DEVTOOLS__) {
        const target = getGlobalThis();
        target.__INTLIFY__ = true;
        setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
      }
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        __name: "ConfirmPopup",
        emits: ["confirm"],
        setup(__props, { emit: __emit }) {
          const emit2 = __emit;
          const { t: t2 } = useI18n();
          return (_ctx, _cache) => {
            const _component_el_popconfirm = ElPopconfirm;
            return openBlock(), createBlock(_component_el_popconfirm, {
              title: unref(t2)("confirmPopup.title"),
              "confirm-button-text": unref(t2)("confirmPopup.yes"),
              "cancel-button-text": unref(t2)("confirmPopup.no"),
              placement: "top",
              onConfirm: _cache[0] || (_cache[0] = (...args) => emit2("confirm", ...args))
            }, {
              reference: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["title", "confirm-button-text", "cancel-button-text"]);
          };
        }
      });
      var FileSaver_min = { exports: {} };
      (function(module2, exports2) {
        (function(a2, b2) {
          b2();
        })(commonjsGlobal, function() {
          function b2(a3, b3) {
            return "undefined" == typeof b3 ? b3 = { autoBom: false } : "object" != typeof b3 && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], { type: a3.type }) : a3;
          }
          function c2(a3, b3, c3) {
            var d3 = new XMLHttpRequest();
            d3.open("GET", a3), d3.responseType = "blob", d3.onload = function() {
              g(d3.response, b3, c3);
            }, d3.onerror = function() {
              console.error("could not download file");
            }, d3.send();
          }
          function d2(a3) {
            var b3 = new XMLHttpRequest();
            b3.open("HEAD", a3, false);
            try {
              b3.send();
            } catch (a4) {
            }
            return 200 <= b3.status && 299 >= b3.status;
          }
          function e(a3) {
            try {
              a3.dispatchEvent(new MouseEvent("click"));
            } catch (c3) {
              var b3 = document.createEvent("MouseEvents");
              b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
            }
          }
          var f2 = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f2.saveAs || ("object" != typeof window || window !== f2 ? function() {
          } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g2, h2) {
            var i = f2.URL || f2.webkitURL, j = document.createElement("a");
            g2 = g2 || b3.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b3 ? (j.href = b3, j.origin === location.origin ? e(j) : d2(j.href) ? c2(b3, g2, h2) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b3), setTimeout(function() {
              i.revokeObjectURL(j.href);
            }, 4e4), setTimeout(function() {
              e(j);
            }, 0));
          } : "msSaveOrOpenBlob" in navigator ? function(f3, g2, h2) {
            if (g2 = g2 || f3.name || "download", "string" != typeof f3)
              navigator.msSaveOrOpenBlob(b2(f3, h2), g2);
            else if (d2(f3))
              c2(f3, g2, h2);
            else {
              var i = document.createElement("a");
              i.href = f3, i.target = "_blank", setTimeout(function() {
                e(i);
              });
            }
          } : function(b3, d3, e2, g2) {
            if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b3)
              return c2(b3, d3, e2);
            var h2 = "application/octet-stream" === b3.type, i = /constructor/i.test(f2.HTMLElement) || f2.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
            if ((j || h2 && i || a2) && "undefined" != typeof FileReader) {
              var k = new FileReader();
              k.onloadend = function() {
                var a3 = k.result;
                a3 = j ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a3 : location = a3, g2 = null;
              }, k.readAsDataURL(b3);
            } else {
              var l2 = f2.URL || f2.webkitURL, m2 = l2.createObjectURL(b3);
              g2 ? g2.location = m2 : location.href = m2, g2 = null, setTimeout(function() {
                l2.revokeObjectURL(m2);
              }, 4e4);
            }
          });
          f2.saveAs = g.saveAs = g, module2.exports = g;
        });
      })(FileSaver_min);
      var FileSaver_minExports = FileSaver_min.exports;
      function commonjsRequire(path) {
        throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
      }
      var localforage$1 = { exports: {} };
      /*!
          localForage -- Offline Storage, Improved
          Version 1.10.0
          https://localforage.github.io/localForage
          (c) 2013-2017 Mozilla, Apache License 2.0
      */
      (function(module2, exports2) {
        (function(f2) {
          {
            module2.exports = f2();
          }
        })(function() {
          return function e(t2, n, r) {
            function s2(o3, u2) {
              if (!n[o3]) {
                if (!t2[o3]) {
                  var a2 = typeof commonjsRequire == "function" && commonjsRequire;
                  if (!u2 && a2)
                    return a2(o3, true);
                  if (i)
                    return i(o3, true);
                  var f2 = new Error("Cannot find module '" + o3 + "'");
                  throw f2.code = "MODULE_NOT_FOUND", f2;
                }
                var l2 = n[o3] = { exports: {} };
                t2[o3][0].call(l2.exports, function(e2) {
                  var n2 = t2[o3][1][e2];
                  return s2(n2 ? n2 : e2);
                }, l2, l2.exports, e, t2, n, r);
              }
              return n[o3].exports;
            }
            var i = typeof commonjsRequire == "function" && commonjsRequire;
            for (var o2 = 0; o2 < r.length; o2++)
              s2(r[o2]);
            return s2;
          }({ 1: [function(_dereq_, module3, exports3) {
            (function(global2) {
              var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
              var scheduleDrain;
              {
                if (Mutation) {
                  var called = 0;
                  var observer = new Mutation(nextTick2);
                  var element = global2.document.createTextNode("");
                  observer.observe(element, {
                    characterData: true
                  });
                  scheduleDrain = function() {
                    element.data = called = ++called % 2;
                  };
                } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
                  var channel = new global2.MessageChannel();
                  channel.port1.onmessage = nextTick2;
                  scheduleDrain = function() {
                    channel.port2.postMessage(0);
                  };
                } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
                  scheduleDrain = function() {
                    var scriptEl = global2.document.createElement("script");
                    scriptEl.onreadystatechange = function() {
                      nextTick2();
                      scriptEl.onreadystatechange = null;
                      scriptEl.parentNode.removeChild(scriptEl);
                      scriptEl = null;
                    };
                    global2.document.documentElement.appendChild(scriptEl);
                  };
                } else {
                  scheduleDrain = function() {
                    setTimeout(nextTick2, 0);
                  };
                }
              }
              var draining;
              var queue2 = [];
              function nextTick2() {
                draining = true;
                var i, oldQueue;
                var len = queue2.length;
                while (len) {
                  oldQueue = queue2;
                  queue2 = [];
                  i = -1;
                  while (++i < len) {
                    oldQueue[i]();
                  }
                  len = queue2.length;
                }
                draining = false;
              }
              module3.exports = immediate;
              function immediate(task) {
                if (queue2.push(task) === 1 && !draining) {
                  scheduleDrain();
                }
              }
            }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
          }, {}], 2: [function(_dereq_, module3, exports3) {
            var immediate = _dereq_(1);
            function INTERNAL() {
            }
            var handlers2 = {};
            var REJECTED = ["REJECTED"];
            var FULFILLED = ["FULFILLED"];
            var PENDING = ["PENDING"];
            module3.exports = Promise2;
            function Promise2(resolver) {
              if (typeof resolver !== "function") {
                throw new TypeError("resolver must be a function");
              }
              this.state = PENDING;
              this.queue = [];
              this.outcome = void 0;
              if (resolver !== INTERNAL) {
                safelyResolveThenable(this, resolver);
              }
            }
            Promise2.prototype["catch"] = function(onRejected) {
              return this.then(null, onRejected);
            };
            Promise2.prototype.then = function(onFulfilled, onRejected) {
              if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
                return this;
              }
              var promise = new this.constructor(INTERNAL);
              if (this.state !== PENDING) {
                var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
                unwrap(promise, resolver, this.outcome);
              } else {
                this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
              }
              return promise;
            };
            function QueueItem(promise, onFulfilled, onRejected) {
              this.promise = promise;
              if (typeof onFulfilled === "function") {
                this.onFulfilled = onFulfilled;
                this.callFulfilled = this.otherCallFulfilled;
              }
              if (typeof onRejected === "function") {
                this.onRejected = onRejected;
                this.callRejected = this.otherCallRejected;
              }
            }
            QueueItem.prototype.callFulfilled = function(value) {
              handlers2.resolve(this.promise, value);
            };
            QueueItem.prototype.otherCallFulfilled = function(value) {
              unwrap(this.promise, this.onFulfilled, value);
            };
            QueueItem.prototype.callRejected = function(value) {
              handlers2.reject(this.promise, value);
            };
            QueueItem.prototype.otherCallRejected = function(value) {
              unwrap(this.promise, this.onRejected, value);
            };
            function unwrap(promise, func, value) {
              immediate(function() {
                var returnValue;
                try {
                  returnValue = func(value);
                } catch (e) {
                  return handlers2.reject(promise, e);
                }
                if (returnValue === promise) {
                  handlers2.reject(promise, new TypeError("Cannot resolve promise with itself"));
                } else {
                  handlers2.resolve(promise, returnValue);
                }
              });
            }
            handlers2.resolve = function(self2, value) {
              var result = tryCatch(getThen, value);
              if (result.status === "error") {
                return handlers2.reject(self2, result.value);
              }
              var thenable = result.value;
              if (thenable) {
                safelyResolveThenable(self2, thenable);
              } else {
                self2.state = FULFILLED;
                self2.outcome = value;
                var i = -1;
                var len = self2.queue.length;
                while (++i < len) {
                  self2.queue[i].callFulfilled(value);
                }
              }
              return self2;
            };
            handlers2.reject = function(self2, error) {
              self2.state = REJECTED;
              self2.outcome = error;
              var i = -1;
              var len = self2.queue.length;
              while (++i < len) {
                self2.queue[i].callRejected(error);
              }
              return self2;
            };
            function getThen(obj) {
              var then = obj && obj.then;
              if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
                return function appyThen() {
                  then.apply(obj, arguments);
                };
              }
            }
            function safelyResolveThenable(self2, thenable) {
              var called = false;
              function onError(value) {
                if (called) {
                  return;
                }
                called = true;
                handlers2.reject(self2, value);
              }
              function onSuccess(value) {
                if (called) {
                  return;
                }
                called = true;
                handlers2.resolve(self2, value);
              }
              function tryToUnwrap() {
                thenable(onSuccess, onError);
              }
              var result = tryCatch(tryToUnwrap);
              if (result.status === "error") {
                onError(result.value);
              }
            }
            function tryCatch(func, value) {
              var out = {};
              try {
                out.value = func(value);
                out.status = "success";
              } catch (e) {
                out.status = "error";
                out.value = e;
              }
              return out;
            }
            Promise2.resolve = resolve2;
            function resolve2(value) {
              if (value instanceof this) {
                return value;
              }
              return handlers2.resolve(new this(INTERNAL), value);
            }
            Promise2.reject = reject;
            function reject(reason) {
              var promise = new this(INTERNAL);
              return handlers2.reject(promise, reason);
            }
            Promise2.all = all;
            function all(iterable) {
              var self2 = this;
              if (Object.prototype.toString.call(iterable) !== "[object Array]") {
                return this.reject(new TypeError("must be an array"));
              }
              var len = iterable.length;
              var called = false;
              if (!len) {
                return this.resolve([]);
              }
              var values2 = new Array(len);
              var resolved = 0;
              var i = -1;
              var promise = new this(INTERNAL);
              while (++i < len) {
                allResolver(iterable[i], i);
              }
              return promise;
              function allResolver(value, i2) {
                self2.resolve(value).then(resolveFromAll, function(error) {
                  if (!called) {
                    called = true;
                    handlers2.reject(promise, error);
                  }
                });
                function resolveFromAll(outValue) {
                  values2[i2] = outValue;
                  if (++resolved === len && !called) {
                    called = true;
                    handlers2.resolve(promise, values2);
                  }
                }
              }
            }
            Promise2.race = race;
            function race(iterable) {
              var self2 = this;
              if (Object.prototype.toString.call(iterable) !== "[object Array]") {
                return this.reject(new TypeError("must be an array"));
              }
              var len = iterable.length;
              var called = false;
              if (!len) {
                return this.resolve([]);
              }
              var i = -1;
              var promise = new this(INTERNAL);
              while (++i < len) {
                resolver(iterable[i]);
              }
              return promise;
              function resolver(value) {
                self2.resolve(value).then(function(response) {
                  if (!called) {
                    called = true;
                    handlers2.resolve(promise, response);
                  }
                }, function(error) {
                  if (!called) {
                    called = true;
                    handlers2.reject(promise, error);
                  }
                });
              }
            }
          }, { "1": 1 }], 3: [function(_dereq_, module3, exports3) {
            (function(global2) {
              if (typeof global2.Promise !== "function") {
                global2.Promise = _dereq_(2);
              }
            }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
          }, { "2": 2 }], 4: [function(_dereq_, module3, exports3) {
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function getIDB() {
              try {
                if (typeof indexedDB !== "undefined") {
                  return indexedDB;
                }
                if (typeof webkitIndexedDB !== "undefined") {
                  return webkitIndexedDB;
                }
                if (typeof mozIndexedDB !== "undefined") {
                  return mozIndexedDB;
                }
                if (typeof OIndexedDB !== "undefined") {
                  return OIndexedDB;
                }
                if (typeof msIndexedDB !== "undefined") {
                  return msIndexedDB;
                }
              } catch (e) {
                return;
              }
            }
            var idb = getIDB();
            function isIndexedDBValid() {
              try {
                if (!idb || !idb.open) {
                  return false;
                }
                var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
                var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
                return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
                // and HTC Android devices <4.4 are missing IDBKeyRange
                // See: https://github.com/mozilla/localForage/issues/128
                // See: https://github.com/mozilla/localForage/issues/272
                typeof IDBKeyRange !== "undefined";
              } catch (e) {
                return false;
              }
            }
            function createBlob(parts, properties) {
              parts = parts || [];
              properties = properties || {};
              try {
                return new Blob(parts, properties);
              } catch (e) {
                if (e.name !== "TypeError") {
                  throw e;
                }
                var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
                var builder = new Builder();
                for (var i = 0; i < parts.length; i += 1) {
                  builder.append(parts[i]);
                }
                return builder.getBlob(properties.type);
              }
            }
            if (typeof Promise === "undefined") {
              _dereq_(3);
            }
            var Promise$12 = Promise;
            function executeCallback2(promise, callback) {
              if (callback) {
                promise.then(function(result) {
                  callback(null, result);
                }, function(error) {
                  callback(error);
                });
              }
            }
            function executeTwoCallbacks(promise, callback, errorCallback) {
              if (typeof callback === "function") {
                promise.then(callback);
              }
              if (typeof errorCallback === "function") {
                promise["catch"](errorCallback);
              }
            }
            function normalizeKey2(key2) {
              if (typeof key2 !== "string") {
                console.warn(key2 + " used as a key, but it is not a string.");
                key2 = String(key2);
              }
              return key2;
            }
            function getCallback() {
              if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
                return arguments[arguments.length - 1];
              }
            }
            var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
            var supportsBlobs = void 0;
            var dbContexts = {};
            var toString2 = Object.prototype.toString;
            var READ_ONLY = "readonly";
            var READ_WRITE = "readwrite";
            function _binStringToArrayBuffer(bin) {
              var length2 = bin.length;
              var buf = new ArrayBuffer(length2);
              var arr = new Uint8Array(buf);
              for (var i = 0; i < length2; i++) {
                arr[i] = bin.charCodeAt(i);
              }
              return buf;
            }
            function _checkBlobSupportWithoutCaching(idb2) {
              return new Promise$12(function(resolve2) {
                var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
                var blob2 = createBlob([""]);
                txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob2, "key");
                txn.onabort = function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  resolve2(false);
                };
                txn.oncomplete = function() {
                  var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
                  var matchedEdge = navigator.userAgent.match(/Edge\//);
                  resolve2(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
                };
              })["catch"](function() {
                return false;
              });
            }
            function _checkBlobSupport(idb2) {
              if (typeof supportsBlobs === "boolean") {
                return Promise$12.resolve(supportsBlobs);
              }
              return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
                supportsBlobs = value;
                return supportsBlobs;
              });
            }
            function _deferReadiness(dbInfo) {
              var dbContext = dbContexts[dbInfo.name];
              var deferredOperation = {};
              deferredOperation.promise = new Promise$12(function(resolve2, reject) {
                deferredOperation.resolve = resolve2;
                deferredOperation.reject = reject;
              });
              dbContext.deferredOperations.push(deferredOperation);
              if (!dbContext.dbReady) {
                dbContext.dbReady = deferredOperation.promise;
              } else {
                dbContext.dbReady = dbContext.dbReady.then(function() {
                  return deferredOperation.promise;
                });
              }
            }
            function _advanceReadiness(dbInfo) {
              var dbContext = dbContexts[dbInfo.name];
              var deferredOperation = dbContext.deferredOperations.pop();
              if (deferredOperation) {
                deferredOperation.resolve();
                return deferredOperation.promise;
              }
            }
            function _rejectReadiness(dbInfo, err) {
              var dbContext = dbContexts[dbInfo.name];
              var deferredOperation = dbContext.deferredOperations.pop();
              if (deferredOperation) {
                deferredOperation.reject(err);
                return deferredOperation.promise;
              }
            }
            function _getConnection(dbInfo, upgradeNeeded) {
              return new Promise$12(function(resolve2, reject) {
                dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
                if (dbInfo.db) {
                  if (upgradeNeeded) {
                    _deferReadiness(dbInfo);
                    dbInfo.db.close();
                  } else {
                    return resolve2(dbInfo.db);
                  }
                }
                var dbArgs = [dbInfo.name];
                if (upgradeNeeded) {
                  dbArgs.push(dbInfo.version);
                }
                var openreq = idb.open.apply(idb, dbArgs);
                if (upgradeNeeded) {
                  openreq.onupgradeneeded = function(e) {
                    var db = openreq.result;
                    try {
                      db.createObjectStore(dbInfo.storeName);
                      if (e.oldVersion <= 1) {
                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                      }
                    } catch (ex) {
                      if (ex.name === "ConstraintError") {
                        console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                      } else {
                        throw ex;
                      }
                    }
                  };
                }
                openreq.onerror = function(e) {
                  e.preventDefault();
                  reject(openreq.error);
                };
                openreq.onsuccess = function() {
                  var db = openreq.result;
                  db.onversionchange = function(e) {
                    e.target.close();
                  };
                  resolve2(db);
                  _advanceReadiness(dbInfo);
                };
              });
            }
            function _getOriginalConnection(dbInfo) {
              return _getConnection(dbInfo, false);
            }
            function _getUpgradedConnection(dbInfo) {
              return _getConnection(dbInfo, true);
            }
            function _isUpgradeNeeded(dbInfo, defaultVersion) {
              if (!dbInfo.db) {
                return true;
              }
              var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
              var isDowngrade = dbInfo.version < dbInfo.db.version;
              var isUpgrade = dbInfo.version > dbInfo.db.version;
              if (isDowngrade) {
                if (dbInfo.version !== defaultVersion) {
                  console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
                }
                dbInfo.version = dbInfo.db.version;
              }
              if (isUpgrade || isNewStore) {
                if (isNewStore) {
                  var incVersion = dbInfo.db.version + 1;
                  if (incVersion > dbInfo.version) {
                    dbInfo.version = incVersion;
                  }
                }
                return true;
              }
              return false;
            }
            function _encodeBlob(blob2) {
              return new Promise$12(function(resolve2, reject) {
                var reader = new FileReader();
                reader.onerror = reject;
                reader.onloadend = function(e) {
                  var base64 = btoa(e.target.result || "");
                  resolve2({
                    __local_forage_encoded_blob: true,
                    data: base64,
                    type: blob2.type
                  });
                };
                reader.readAsBinaryString(blob2);
              });
            }
            function _decodeBlob(encodedBlob) {
              var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
              return createBlob([arrayBuff], { type: encodedBlob.type });
            }
            function _isEncodedBlob(value) {
              return value && value.__local_forage_encoded_blob;
            }
            function _fullyReady(callback) {
              var self2 = this;
              var promise = self2._initReady().then(function() {
                var dbContext = dbContexts[self2._dbInfo.name];
                if (dbContext && dbContext.dbReady) {
                  return dbContext.dbReady;
                }
              });
              executeTwoCallbacks(promise, callback, callback);
              return promise;
            }
            function _tryReconnect(dbInfo) {
              _deferReadiness(dbInfo);
              var dbContext = dbContexts[dbInfo.name];
              var forages = dbContext.forages;
              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                if (forage._dbInfo.db) {
                  forage._dbInfo.db.close();
                  forage._dbInfo.db = null;
                }
              }
              dbInfo.db = null;
              return _getOriginalConnection(dbInfo).then(function(db) {
                dbInfo.db = db;
                if (_isUpgradeNeeded(dbInfo)) {
                  return _getUpgradedConnection(dbInfo);
                }
                return db;
              }).then(function(db) {
                dbInfo.db = dbContext.db = db;
                for (var i2 = 0; i2 < forages.length; i2++) {
                  forages[i2]._dbInfo.db = db;
                }
              })["catch"](function(err) {
                _rejectReadiness(dbInfo, err);
                throw err;
              });
            }
            function createTransaction(dbInfo, mode, callback, retries) {
              if (retries === void 0) {
                retries = 1;
              }
              try {
                var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
                callback(null, tx);
              } catch (err) {
                if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
                  return Promise$12.resolve().then(function() {
                    if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                      if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                      }
                      return _getUpgradedConnection(dbInfo);
                    }
                  }).then(function() {
                    return _tryReconnect(dbInfo).then(function() {
                      createTransaction(dbInfo, mode, callback, retries - 1);
                    });
                  })["catch"](callback);
                }
                callback(err);
              }
            }
            function createDbContext() {
              return {
                // Running localForages sharing a database.
                forages: [],
                // Shared database.
                db: null,
                // Database readiness (promise).
                dbReady: null,
                // Deferred operations on the database.
                deferredOperations: []
              };
            }
            function _initStorage(options) {
              var self2 = this;
              var dbInfo = {
                db: null
              };
              if (options) {
                for (var i in options) {
                  dbInfo[i] = options[i];
                }
              }
              var dbContext = dbContexts[dbInfo.name];
              if (!dbContext) {
                dbContext = createDbContext();
                dbContexts[dbInfo.name] = dbContext;
              }
              dbContext.forages.push(self2);
              if (!self2._initReady) {
                self2._initReady = self2.ready;
                self2.ready = _fullyReady;
              }
              var initPromises = [];
              function ignoreErrors() {
                return Promise$12.resolve();
              }
              for (var j = 0; j < dbContext.forages.length; j++) {
                var forage = dbContext.forages[j];
                if (forage !== self2) {
                  initPromises.push(forage._initReady()["catch"](ignoreErrors));
                }
              }
              var forages = dbContext.forages.slice(0);
              return Promise$12.all(initPromises).then(function() {
                dbInfo.db = dbContext.db;
                return _getOriginalConnection(dbInfo);
              }).then(function(db) {
                dbInfo.db = db;
                if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
                  return _getUpgradedConnection(dbInfo);
                }
                return db;
              }).then(function(db) {
                dbInfo.db = dbContext.db = db;
                self2._dbInfo = dbInfo;
                for (var k = 0; k < forages.length; k++) {
                  var forage2 = forages[k];
                  if (forage2 !== self2) {
                    forage2._dbInfo.db = dbInfo.db;
                    forage2._dbInfo.version = dbInfo.version;
                  }
                }
              });
            }
            function getItem(key2, callback) {
              var self2 = this;
              key2 = normalizeKey2(key2);
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store.get(key2);
                      req.onsuccess = function() {
                        var value = req.result;
                        if (value === void 0) {
                          value = null;
                        }
                        if (_isEncodedBlob(value)) {
                          value = _decodeBlob(value);
                        }
                        resolve2(value);
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function iterate(iterator, callback) {
              var self2 = this;
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store.openCursor();
                      var iterationNumber = 1;
                      req.onsuccess = function() {
                        var cursor = req.result;
                        if (cursor) {
                          var value = cursor.value;
                          if (_isEncodedBlob(value)) {
                            value = _decodeBlob(value);
                          }
                          var result = iterator(value, cursor.key, iterationNumber++);
                          if (result !== void 0) {
                            resolve2(result);
                          } else {
                            cursor["continue"]();
                          }
                        } else {
                          resolve2();
                        }
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function setItem(key2, value, callback) {
              var self2 = this;
              key2 = normalizeKey2(key2);
              var promise = new Promise$12(function(resolve2, reject) {
                var dbInfo;
                self2.ready().then(function() {
                  dbInfo = self2._dbInfo;
                  if (toString2.call(value) === "[object Blob]") {
                    return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                      if (blobSupport) {
                        return value;
                      }
                      return _encodeBlob(value);
                    });
                  }
                  return value;
                }).then(function(value2) {
                  createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      if (value2 === null) {
                        value2 = void 0;
                      }
                      var req = store.put(value2, key2);
                      transaction.oncomplete = function() {
                        if (value2 === void 0) {
                          value2 = null;
                        }
                        resolve2(value2);
                      };
                      transaction.onabort = transaction.onerror = function() {
                        var err2 = req.error ? req.error : req.transaction.error;
                        reject(err2);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function removeItem(key2, callback) {
              var self2 = this;
              key2 = normalizeKey2(key2);
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store["delete"](key2);
                      transaction.oncomplete = function() {
                        resolve2();
                      };
                      transaction.onerror = function() {
                        reject(req.error);
                      };
                      transaction.onabort = function() {
                        var err2 = req.error ? req.error : req.transaction.error;
                        reject(err2);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function clear2(callback) {
              var self2 = this;
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store.clear();
                      transaction.oncomplete = function() {
                        resolve2();
                      };
                      transaction.onabort = transaction.onerror = function() {
                        var err2 = req.error ? req.error : req.transaction.error;
                        reject(err2);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function length(callback) {
              var self2 = this;
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store.count();
                      req.onsuccess = function() {
                        resolve2(req.result);
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function key(n, callback) {
              var self2 = this;
              var promise = new Promise$12(function(resolve2, reject) {
                if (n < 0) {
                  resolve2(null);
                  return;
                }
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var advanced = false;
                      var req = store.openKeyCursor();
                      req.onsuccess = function() {
                        var cursor = req.result;
                        if (!cursor) {
                          resolve2(null);
                          return;
                        }
                        if (n === 0) {
                          resolve2(cursor.key);
                        } else {
                          if (!advanced) {
                            advanced = true;
                            cursor.advance(n);
                          } else {
                            resolve2(cursor.key);
                          }
                        }
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function keys2(callback) {
              var self2 = this;
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store.openKeyCursor();
                      var keys3 = [];
                      req.onsuccess = function() {
                        var cursor = req.result;
                        if (!cursor) {
                          resolve2(keys3);
                          return;
                        }
                        keys3.push(cursor.key);
                        cursor["continue"]();
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function dropInstance(options, callback) {
              callback = getCallback.apply(this, arguments);
              var currentConfig = this.config();
              options = typeof options !== "function" && options || {};
              if (!options.name) {
                options.name = options.name || currentConfig.name;
                options.storeName = options.storeName || currentConfig.storeName;
              }
              var self2 = this;
              var promise;
              if (!options.name) {
                promise = Promise$12.reject("Invalid arguments");
              } else {
                var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
                var dbPromise = isCurrentDb ? Promise$12.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
                  var dbContext = dbContexts[options.name];
                  var forages = dbContext.forages;
                  dbContext.db = db;
                  for (var i = 0; i < forages.length; i++) {
                    forages[i]._dbInfo.db = db;
                  }
                  return db;
                });
                if (!options.storeName) {
                  promise = dbPromise.then(function(db) {
                    _deferReadiness(options);
                    var dbContext = dbContexts[options.name];
                    var forages = dbContext.forages;
                    db.close();
                    for (var i = 0; i < forages.length; i++) {
                      var forage = forages[i];
                      forage._dbInfo.db = null;
                    }
                    var dropDBPromise = new Promise$12(function(resolve2, reject) {
                      var req = idb.deleteDatabase(options.name);
                      req.onerror = function() {
                        var db2 = req.result;
                        if (db2) {
                          db2.close();
                        }
                        reject(req.error);
                      };
                      req.onblocked = function() {
                        console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                      };
                      req.onsuccess = function() {
                        var db2 = req.result;
                        if (db2) {
                          db2.close();
                        }
                        resolve2(db2);
                      };
                    });
                    return dropDBPromise.then(function(db2) {
                      dbContext.db = db2;
                      for (var i2 = 0; i2 < forages.length; i2++) {
                        var _forage = forages[i2];
                        _advanceReadiness(_forage._dbInfo);
                      }
                    })["catch"](function(err) {
                      (_rejectReadiness(options, err) || Promise$12.resolve())["catch"](function() {
                      });
                      throw err;
                    });
                  });
                } else {
                  promise = dbPromise.then(function(db) {
                    if (!db.objectStoreNames.contains(options.storeName)) {
                      return;
                    }
                    var newVersion = db.version + 1;
                    _deferReadiness(options);
                    var dbContext = dbContexts[options.name];
                    var forages = dbContext.forages;
                    db.close();
                    for (var i = 0; i < forages.length; i++) {
                      var forage = forages[i];
                      forage._dbInfo.db = null;
                      forage._dbInfo.version = newVersion;
                    }
                    var dropObjectPromise = new Promise$12(function(resolve2, reject) {
                      var req = idb.open(options.name, newVersion);
                      req.onerror = function(err) {
                        var db2 = req.result;
                        db2.close();
                        reject(err);
                      };
                      req.onupgradeneeded = function() {
                        var db2 = req.result;
                        db2.deleteObjectStore(options.storeName);
                      };
                      req.onsuccess = function() {
                        var db2 = req.result;
                        db2.close();
                        resolve2(db2);
                      };
                    });
                    return dropObjectPromise.then(function(db2) {
                      dbContext.db = db2;
                      for (var j = 0; j < forages.length; j++) {
                        var _forage2 = forages[j];
                        _forage2._dbInfo.db = db2;
                        _advanceReadiness(_forage2._dbInfo);
                      }
                    })["catch"](function(err) {
                      (_rejectReadiness(options, err) || Promise$12.resolve())["catch"](function() {
                      });
                      throw err;
                    });
                  });
                }
              }
              executeCallback2(promise, callback);
              return promise;
            }
            var asyncStorage = {
              _driver: "asyncStorage",
              _initStorage,
              _support: isIndexedDBValid(),
              iterate,
              getItem,
              setItem,
              removeItem,
              clear: clear2,
              length,
              key,
              keys: keys2,
              dropInstance
            };
            function isWebSQLValid() {
              return typeof openDatabase === "function";
            }
            var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var BLOB_TYPE_PREFIX = "~~local_forage_type~";
            var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
            var SERIALIZED_MARKER = "__lfsc__:";
            var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
            var TYPE_ARRAYBUFFER = "arbf";
            var TYPE_BLOB = "blob";
            var TYPE_INT8ARRAY = "si08";
            var TYPE_UINT8ARRAY = "ui08";
            var TYPE_UINT8CLAMPEDARRAY = "uic8";
            var TYPE_INT16ARRAY = "si16";
            var TYPE_INT32ARRAY = "si32";
            var TYPE_UINT16ARRAY = "ur16";
            var TYPE_UINT32ARRAY = "ui32";
            var TYPE_FLOAT32ARRAY = "fl32";
            var TYPE_FLOAT64ARRAY = "fl64";
            var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
            var toString$12 = Object.prototype.toString;
            function stringToBuffer(serializedString) {
              var bufferLength = serializedString.length * 0.75;
              var len = serializedString.length;
              var i;
              var p2 = 0;
              var encoded1, encoded2, encoded3, encoded4;
              if (serializedString[serializedString.length - 1] === "=") {
                bufferLength--;
                if (serializedString[serializedString.length - 2] === "=") {
                  bufferLength--;
                }
              }
              var buffer = new ArrayBuffer(bufferLength);
              var bytes = new Uint8Array(buffer);
              for (i = 0; i < len; i += 4) {
                encoded1 = BASE_CHARS.indexOf(serializedString[i]);
                encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
                encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
                encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
                bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
                bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
                bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
              }
              return buffer;
            }
            function bufferToString(buffer) {
              var bytes = new Uint8Array(buffer);
              var base64String = "";
              var i;
              for (i = 0; i < bytes.length; i += 3) {
                base64String += BASE_CHARS[bytes[i] >> 2];
                base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
                base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
                base64String += BASE_CHARS[bytes[i + 2] & 63];
              }
              if (bytes.length % 3 === 2) {
                base64String = base64String.substring(0, base64String.length - 1) + "=";
              } else if (bytes.length % 3 === 1) {
                base64String = base64String.substring(0, base64String.length - 2) + "==";
              }
              return base64String;
            }
            function serialize(value, callback) {
              var valueType = "";
              if (value) {
                valueType = toString$12.call(value);
              }
              if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$12.call(value.buffer) === "[object ArrayBuffer]")) {
                var buffer;
                var marker = SERIALIZED_MARKER;
                if (value instanceof ArrayBuffer) {
                  buffer = value;
                  marker += TYPE_ARRAYBUFFER;
                } else {
                  buffer = value.buffer;
                  if (valueType === "[object Int8Array]") {
                    marker += TYPE_INT8ARRAY;
                  } else if (valueType === "[object Uint8Array]") {
                    marker += TYPE_UINT8ARRAY;
                  } else if (valueType === "[object Uint8ClampedArray]") {
                    marker += TYPE_UINT8CLAMPEDARRAY;
                  } else if (valueType === "[object Int16Array]") {
                    marker += TYPE_INT16ARRAY;
                  } else if (valueType === "[object Uint16Array]") {
                    marker += TYPE_UINT16ARRAY;
                  } else if (valueType === "[object Int32Array]") {
                    marker += TYPE_INT32ARRAY;
                  } else if (valueType === "[object Uint32Array]") {
                    marker += TYPE_UINT32ARRAY;
                  } else if (valueType === "[object Float32Array]") {
                    marker += TYPE_FLOAT32ARRAY;
                  } else if (valueType === "[object Float64Array]") {
                    marker += TYPE_FLOAT64ARRAY;
                  } else {
                    callback(new Error("Failed to get type for BinaryArray"));
                  }
                }
                callback(marker + bufferToString(buffer));
              } else if (valueType === "[object Blob]") {
                var fileReader = new FileReader();
                fileReader.onload = function() {
                  var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
                  callback(SERIALIZED_MARKER + TYPE_BLOB + str);
                };
                fileReader.readAsArrayBuffer(value);
              } else {
                try {
                  callback(JSON.stringify(value));
                } catch (e) {
                  console.error("Couldn't convert value into a JSON string: ", value);
                  callback(null, e);
                }
              }
            }
            function deserialize(value) {
              if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
                return JSON.parse(value);
              }
              var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
              var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
              var blobType;
              if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
                var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
                blobType = matcher[1];
                serializedString = serializedString.substring(matcher[0].length);
              }
              var buffer = stringToBuffer(serializedString);
              switch (type) {
                case TYPE_ARRAYBUFFER:
                  return buffer;
                case TYPE_BLOB:
                  return createBlob([buffer], { type: blobType });
                case TYPE_INT8ARRAY:
                  return new Int8Array(buffer);
                case TYPE_UINT8ARRAY:
                  return new Uint8Array(buffer);
                case TYPE_UINT8CLAMPEDARRAY:
                  return new Uint8ClampedArray(buffer);
                case TYPE_INT16ARRAY:
                  return new Int16Array(buffer);
                case TYPE_UINT16ARRAY:
                  return new Uint16Array(buffer);
                case TYPE_INT32ARRAY:
                  return new Int32Array(buffer);
                case TYPE_UINT32ARRAY:
                  return new Uint32Array(buffer);
                case TYPE_FLOAT32ARRAY:
                  return new Float32Array(buffer);
                case TYPE_FLOAT64ARRAY:
                  return new Float64Array(buffer);
                default:
                  throw new Error("Unkown type: " + type);
              }
            }
            var localforageSerializer = {
              serialize,
              deserialize,
              stringToBuffer,
              bufferToString
            };
            function createDbTable(t2, dbInfo, callback, errorCallback) {
              t2.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
            }
            function _initStorage$1(options) {
              var self2 = this;
              var dbInfo = {
                db: null
              };
              if (options) {
                for (var i in options) {
                  dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
                }
              }
              var dbInfoPromise = new Promise$12(function(resolve2, reject) {
                try {
                  dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
                } catch (e) {
                  return reject(e);
                }
                dbInfo.db.transaction(function(t2) {
                  createDbTable(t2, dbInfo, function() {
                    self2._dbInfo = dbInfo;
                    resolve2();
                  }, function(t3, error) {
                    reject(error);
                  });
                }, reject);
              });
              dbInfo.serializer = localforageSerializer;
              return dbInfoPromise;
            }
            function tryExecuteSql(t2, dbInfo, sqlStatement, args, callback, errorCallback) {
              t2.executeSql(sqlStatement, args, callback, function(t3, error) {
                if (error.code === error.SYNTAX_ERR) {
                  t3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t4, results) {
                    if (!results.rows.length) {
                      createDbTable(t4, dbInfo, function() {
                        t4.executeSql(sqlStatement, args, callback, errorCallback);
                      }, errorCallback);
                    } else {
                      errorCallback(t4, error);
                    }
                  }, errorCallback);
                } else {
                  errorCallback(t3, error);
                }
              }, errorCallback);
            }
            function getItem$1(key2, callback) {
              var self2 = this;
              key2 = normalizeKey2(key2);
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t3, results) {
                      var result = results.rows.length ? results.rows.item(0).value : null;
                      if (result) {
                        result = dbInfo.serializer.deserialize(result);
                      }
                      resolve2(result);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function iterate$1(iterator, callback) {
              var self2 = this;
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t3, results) {
                      var rows = results.rows;
                      var length2 = rows.length;
                      for (var i = 0; i < length2; i++) {
                        var item = rows.item(i);
                        var result = item.value;
                        if (result) {
                          result = dbInfo.serializer.deserialize(result);
                        }
                        result = iterator(result, item.key, i + 1);
                        if (result !== void 0) {
                          resolve2(result);
                          return;
                        }
                      }
                      resolve2();
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function _setItem(key2, value, callback, retriesLeft) {
              var self2 = this;
              key2 = normalizeKey2(key2);
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  if (value === void 0) {
                    value = null;
                  }
                  var originalValue = value;
                  var dbInfo = self2._dbInfo;
                  dbInfo.serializer.serialize(value, function(value2, error) {
                    if (error) {
                      reject(error);
                    } else {
                      dbInfo.db.transaction(function(t2) {
                        tryExecuteSql(t2, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                          resolve2(originalValue);
                        }, function(t3, error2) {
                          reject(error2);
                        });
                      }, function(sqlError) {
                        if (sqlError.code === sqlError.QUOTA_ERR) {
                          if (retriesLeft > 0) {
                            resolve2(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                            return;
                          }
                          reject(sqlError);
                        }
                      });
                    }
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function setItem$1(key2, value, callback) {
              return _setItem.apply(this, [key2, value, callback, 1]);
            }
            function removeItem$1(key2, callback) {
              var self2 = this;
              key2 = normalizeKey2(key2);
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                      resolve2();
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function clear$1(callback) {
              var self2 = this;
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                      resolve2();
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function length$1(callback) {
              var self2 = this;
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t3, results) {
                      var result = results.rows.item(0).c;
                      resolve2(result);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function key$1(n, callback) {
              var self2 = this;
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t3, results) {
                      var result = results.rows.length ? results.rows.item(0).key : null;
                      resolve2(result);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function keys$1(callback) {
              var self2 = this;
              var promise = new Promise$12(function(resolve2, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t3, results) {
                      var keys3 = [];
                      for (var i = 0; i < results.rows.length; i++) {
                        keys3.push(results.rows.item(i).key);
                      }
                      resolve2(keys3);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function getAllStoreNames(db) {
              return new Promise$12(function(resolve2, reject) {
                db.transaction(function(t2) {
                  t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t3, results) {
                    var storeNames = [];
                    for (var i = 0; i < results.rows.length; i++) {
                      storeNames.push(results.rows.item(i).name);
                    }
                    resolve2({
                      db,
                      storeNames
                    });
                  }, function(t3, error) {
                    reject(error);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            }
            function dropInstance$1(options, callback) {
              callback = getCallback.apply(this, arguments);
              var currentConfig = this.config();
              options = typeof options !== "function" && options || {};
              if (!options.name) {
                options.name = options.name || currentConfig.name;
                options.storeName = options.storeName || currentConfig.storeName;
              }
              var self2 = this;
              var promise;
              if (!options.name) {
                promise = Promise$12.reject("Invalid arguments");
              } else {
                promise = new Promise$12(function(resolve2) {
                  var db;
                  if (options.name === currentConfig.name) {
                    db = self2._dbInfo.db;
                  } else {
                    db = openDatabase(options.name, "", "", 0);
                  }
                  if (!options.storeName) {
                    resolve2(getAllStoreNames(db));
                  } else {
                    resolve2({
                      db,
                      storeNames: [options.storeName]
                    });
                  }
                }).then(function(operationInfo) {
                  return new Promise$12(function(resolve2, reject) {
                    operationInfo.db.transaction(function(t2) {
                      function dropTable(storeName) {
                        return new Promise$12(function(resolve3, reject2) {
                          t2.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                            resolve3();
                          }, function(t3, error) {
                            reject2(error);
                          });
                        });
                      }
                      var operations = [];
                      for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                        operations.push(dropTable(operationInfo.storeNames[i]));
                      }
                      Promise$12.all(operations).then(function() {
                        resolve2();
                      })["catch"](function(e) {
                        reject(e);
                      });
                    }, function(sqlError) {
                      reject(sqlError);
                    });
                  });
                });
              }
              executeCallback2(promise, callback);
              return promise;
            }
            var webSQLStorage = {
              _driver: "webSQLStorage",
              _initStorage: _initStorage$1,
              _support: isWebSQLValid(),
              iterate: iterate$1,
              getItem: getItem$1,
              setItem: setItem$1,
              removeItem: removeItem$1,
              clear: clear$1,
              length: length$1,
              key: key$1,
              keys: keys$1,
              dropInstance: dropInstance$1
            };
            function isLocalStorageValid() {
              try {
                return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
                !!localStorage.setItem;
              } catch (e) {
                return false;
              }
            }
            function _getKeyPrefix(options, defaultConfig) {
              var keyPrefix = options.name + "/";
              if (options.storeName !== defaultConfig.storeName) {
                keyPrefix += options.storeName + "/";
              }
              return keyPrefix;
            }
            function checkIfLocalStorageThrows() {
              var localStorageTestKey = "_localforage_support_test";
              try {
                localStorage.setItem(localStorageTestKey, true);
                localStorage.removeItem(localStorageTestKey);
                return false;
              } catch (e) {
                return true;
              }
            }
            function _isLocalStorageUsable() {
              return !checkIfLocalStorageThrows() || localStorage.length > 0;
            }
            function _initStorage$2(options) {
              var self2 = this;
              var dbInfo = {};
              if (options) {
                for (var i in options) {
                  dbInfo[i] = options[i];
                }
              }
              dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
              if (!_isLocalStorageUsable()) {
                return Promise$12.reject();
              }
              self2._dbInfo = dbInfo;
              dbInfo.serializer = localforageSerializer;
              return Promise$12.resolve();
            }
            function clear$2(callback) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var keyPrefix = self2._dbInfo.keyPrefix;
                for (var i = localStorage.length - 1; i >= 0; i--) {
                  var key2 = localStorage.key(i);
                  if (key2.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key2);
                  }
                }
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function getItem$2(key2, callback) {
              var self2 = this;
              key2 = normalizeKey2(key2);
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var result = localStorage.getItem(dbInfo.keyPrefix + key2);
                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }
                return result;
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function iterate$2(iterator, callback) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var keyPrefix = dbInfo.keyPrefix;
                var keyPrefixLength = keyPrefix.length;
                var length2 = localStorage.length;
                var iterationNumber = 1;
                for (var i = 0; i < length2; i++) {
                  var key2 = localStorage.key(i);
                  if (key2.indexOf(keyPrefix) !== 0) {
                    continue;
                  }
                  var value = localStorage.getItem(key2);
                  if (value) {
                    value = dbInfo.serializer.deserialize(value);
                  }
                  value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
                  if (value !== void 0) {
                    return value;
                  }
                }
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function key$2(n, callback) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var result;
                try {
                  result = localStorage.key(n);
                } catch (error) {
                  result = null;
                }
                if (result) {
                  result = result.substring(dbInfo.keyPrefix.length);
                }
                return result;
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function keys$2(callback) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var length2 = localStorage.length;
                var keys3 = [];
                for (var i = 0; i < length2; i++) {
                  var itemKey = localStorage.key(i);
                  if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                    keys3.push(itemKey.substring(dbInfo.keyPrefix.length));
                  }
                }
                return keys3;
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function length$2(callback) {
              var self2 = this;
              var promise = self2.keys().then(function(keys3) {
                return keys3.length;
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function removeItem$2(key2, callback) {
              var self2 = this;
              key2 = normalizeKey2(key2);
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                localStorage.removeItem(dbInfo.keyPrefix + key2);
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function setItem$2(key2, value, callback) {
              var self2 = this;
              key2 = normalizeKey2(key2);
              var promise = self2.ready().then(function() {
                if (value === void 0) {
                  value = null;
                }
                var originalValue = value;
                return new Promise$12(function(resolve2, reject) {
                  var dbInfo = self2._dbInfo;
                  dbInfo.serializer.serialize(value, function(value2, error) {
                    if (error) {
                      reject(error);
                    } else {
                      try {
                        localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                        resolve2(originalValue);
                      } catch (e) {
                        if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                          reject(e);
                        }
                        reject(e);
                      }
                    }
                  });
                });
              });
              executeCallback2(promise, callback);
              return promise;
            }
            function dropInstance$2(options, callback) {
              callback = getCallback.apply(this, arguments);
              options = typeof options !== "function" && options || {};
              if (!options.name) {
                var currentConfig = this.config();
                options.name = options.name || currentConfig.name;
                options.storeName = options.storeName || currentConfig.storeName;
              }
              var self2 = this;
              var promise;
              if (!options.name) {
                promise = Promise$12.reject("Invalid arguments");
              } else {
                promise = new Promise$12(function(resolve2) {
                  if (!options.storeName) {
                    resolve2(options.name + "/");
                  } else {
                    resolve2(_getKeyPrefix(options, self2._defaultConfig));
                  }
                }).then(function(keyPrefix) {
                  for (var i = localStorage.length - 1; i >= 0; i--) {
                    var key2 = localStorage.key(i);
                    if (key2.indexOf(keyPrefix) === 0) {
                      localStorage.removeItem(key2);
                    }
                  }
                });
              }
              executeCallback2(promise, callback);
              return promise;
            }
            var localStorageWrapper = {
              _driver: "localStorageWrapper",
              _initStorage: _initStorage$2,
              _support: isLocalStorageValid(),
              iterate: iterate$2,
              getItem: getItem$2,
              setItem: setItem$2,
              removeItem: removeItem$2,
              clear: clear$2,
              length: length$2,
              key: key$2,
              keys: keys$2,
              dropInstance: dropInstance$2
            };
            var sameValue = function sameValue2(x2, y) {
              return x2 === y || typeof x2 === "number" && typeof y === "number" && isNaN(x2) && isNaN(y);
            };
            var includes = function includes2(array, searchElement) {
              var len = array.length;
              var i = 0;
              while (i < len) {
                if (sameValue(array[i], searchElement)) {
                  return true;
                }
                i++;
              }
              return false;
            };
            var isArray2 = Array.isArray || function(arg) {
              return Object.prototype.toString.call(arg) === "[object Array]";
            };
            var DefinedDrivers = {};
            var DriverSupport = {};
            var DefaultDrivers = {
              INDEXEDDB: asyncStorage,
              WEBSQL: webSQLStorage,
              LOCALSTORAGE: localStorageWrapper
            };
            var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
            var OptionalDriverMethods = ["dropInstance"];
            var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
            var DefaultConfig = {
              description: "",
              driver: DefaultDriverOrder.slice(),
              name: "localforage",
              // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
              // we can use without a prompt.
              size: 4980736,
              storeName: "keyvaluepairs",
              version: 1
            };
            function callWhenReady(localForageInstance, libraryMethod) {
              localForageInstance[libraryMethod] = function() {
                var _args = arguments;
                return localForageInstance.ready().then(function() {
                  return localForageInstance[libraryMethod].apply(localForageInstance, _args);
                });
              };
            }
            function extend2() {
              for (var i = 1; i < arguments.length; i++) {
                var arg = arguments[i];
                if (arg) {
                  for (var _key in arg) {
                    if (arg.hasOwnProperty(_key)) {
                      if (isArray2(arg[_key])) {
                        arguments[0][_key] = arg[_key].slice();
                      } else {
                        arguments[0][_key] = arg[_key];
                      }
                    }
                  }
                }
              }
              return arguments[0];
            }
            var LocalForage = function() {
              function LocalForage2(options) {
                _classCallCheck(this, LocalForage2);
                for (var driverTypeKey in DefaultDrivers) {
                  if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                    var driver = DefaultDrivers[driverTypeKey];
                    var driverName = driver._driver;
                    this[driverTypeKey] = driverName;
                    if (!DefinedDrivers[driverName]) {
                      this.defineDriver(driver);
                    }
                  }
                }
                this._defaultConfig = extend2({}, DefaultConfig);
                this._config = extend2({}, this._defaultConfig, options);
                this._driverSet = null;
                this._initDriver = null;
                this._ready = false;
                this._dbInfo = null;
                this._wrapLibraryMethodsWithReady();
                this.setDriver(this._config.driver)["catch"](function() {
                });
              }
              LocalForage2.prototype.config = function config(options) {
                if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
                  if (this._ready) {
                    return new Error("Can't call config() after localforage has been used.");
                  }
                  for (var i in options) {
                    if (i === "storeName") {
                      options[i] = options[i].replace(/\W/g, "_");
                    }
                    if (i === "version" && typeof options[i] !== "number") {
                      return new Error("Database version must be a number.");
                    }
                    this._config[i] = options[i];
                  }
                  if ("driver" in options && options.driver) {
                    return this.setDriver(this._config.driver);
                  }
                  return true;
                } else if (typeof options === "string") {
                  return this._config[options];
                } else {
                  return this._config;
                }
              };
              LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
                var promise = new Promise$12(function(resolve2, reject) {
                  try {
                    var driverName = driverObject._driver;
                    var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                    if (!driverObject._driver) {
                      reject(complianceError);
                      return;
                    }
                    var driverMethods = LibraryMethods.concat("_initStorage");
                    for (var i = 0, len = driverMethods.length; i < len; i++) {
                      var driverMethodName = driverMethods[i];
                      var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                      if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                        reject(complianceError);
                        return;
                      }
                    }
                    var configureMissingMethods = function configureMissingMethods2() {
                      var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                        return function() {
                          var error = new Error("Method " + methodName + " is not implemented by the current driver");
                          var promise2 = Promise$12.reject(error);
                          executeCallback2(promise2, arguments[arguments.length - 1]);
                          return promise2;
                        };
                      };
                      for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                        var optionalDriverMethod = OptionalDriverMethods[_i];
                        if (!driverObject[optionalDriverMethod]) {
                          driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                        }
                      }
                    };
                    configureMissingMethods();
                    var setDriverSupport = function setDriverSupport2(support) {
                      if (DefinedDrivers[driverName]) {
                        console.info("Redefining LocalForage driver: " + driverName);
                      }
                      DefinedDrivers[driverName] = driverObject;
                      DriverSupport[driverName] = support;
                      resolve2();
                    };
                    if ("_support" in driverObject) {
                      if (driverObject._support && typeof driverObject._support === "function") {
                        driverObject._support().then(setDriverSupport, reject);
                      } else {
                        setDriverSupport(!!driverObject._support);
                      }
                    } else {
                      setDriverSupport(true);
                    }
                  } catch (e) {
                    reject(e);
                  }
                });
                executeTwoCallbacks(promise, callback, errorCallback);
                return promise;
              };
              LocalForage2.prototype.driver = function driver() {
                return this._driver || null;
              };
              LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
                var getDriverPromise = DefinedDrivers[driverName] ? Promise$12.resolve(DefinedDrivers[driverName]) : Promise$12.reject(new Error("Driver not found."));
                executeTwoCallbacks(getDriverPromise, callback, errorCallback);
                return getDriverPromise;
              };
              LocalForage2.prototype.getSerializer = function getSerializer(callback) {
                var serializerPromise = Promise$12.resolve(localforageSerializer);
                executeTwoCallbacks(serializerPromise, callback);
                return serializerPromise;
              };
              LocalForage2.prototype.ready = function ready(callback) {
                var self2 = this;
                var promise = self2._driverSet.then(function() {
                  if (self2._ready === null) {
                    self2._ready = self2._initDriver();
                  }
                  return self2._ready;
                });
                executeTwoCallbacks(promise, callback, callback);
                return promise;
              };
              LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
                var self2 = this;
                if (!isArray2(drivers)) {
                  drivers = [drivers];
                }
                var supportedDrivers = this._getSupportedDrivers(drivers);
                function setDriverToConfig() {
                  self2._config.driver = self2.driver();
                }
                function extendSelfWithDriver(driver) {
                  self2._extend(driver);
                  setDriverToConfig();
                  self2._ready = self2._initStorage(self2._config);
                  return self2._ready;
                }
                function initDriver(supportedDrivers2) {
                  return function() {
                    var currentDriverIndex = 0;
                    function driverPromiseLoop() {
                      while (currentDriverIndex < supportedDrivers2.length) {
                        var driverName = supportedDrivers2[currentDriverIndex];
                        currentDriverIndex++;
                        self2._dbInfo = null;
                        self2._ready = null;
                        return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                      }
                      setDriverToConfig();
                      var error = new Error("No available storage method found.");
                      self2._driverSet = Promise$12.reject(error);
                      return self2._driverSet;
                    }
                    return driverPromiseLoop();
                  };
                }
                var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
                  return Promise$12.resolve();
                }) : Promise$12.resolve();
                this._driverSet = oldDriverSetDone.then(function() {
                  var driverName = supportedDrivers[0];
                  self2._dbInfo = null;
                  self2._ready = null;
                  return self2.getDriver(driverName).then(function(driver) {
                    self2._driver = driver._driver;
                    setDriverToConfig();
                    self2._wrapLibraryMethodsWithReady();
                    self2._initDriver = initDriver(supportedDrivers);
                  });
                })["catch"](function() {
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$12.reject(error);
                  return self2._driverSet;
                });
                executeTwoCallbacks(this._driverSet, callback, errorCallback);
                return this._driverSet;
              };
              LocalForage2.prototype.supports = function supports(driverName) {
                return !!DriverSupport[driverName];
              };
              LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
                extend2(this, libraryMethodsAndProperties);
              };
              LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
                var supportedDrivers = [];
                for (var i = 0, len = drivers.length; i < len; i++) {
                  var driverName = drivers[i];
                  if (this.supports(driverName)) {
                    supportedDrivers.push(driverName);
                  }
                }
                return supportedDrivers;
              };
              LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
                for (var i = 0, len = LibraryMethods.length; i < len; i++) {
                  callWhenReady(this, LibraryMethods[i]);
                }
              };
              LocalForage2.prototype.createInstance = function createInstance(options) {
                return new LocalForage2(options);
              };
              return LocalForage2;
            }();
            var localforage_js = new LocalForage();
            module3.exports = localforage_js;
          }, { "3": 3 }] }, {}, [4])(4);
        });
      })(localforage$1);
      var localforageExports = localforage$1.exports;
      const localforage = /* @__PURE__ */ getDefaultExportFromCjs(localforageExports);
      function getSerializerPromise(localForageInstance) {
        if (getSerializerPromise.result) {
          return getSerializerPromise.result;
        }
        if (!localForageInstance || typeof localForageInstance.getSerializer !== "function") {
          return Promise.reject(new Error("localforage.getSerializer() was not available! localforage v1.4+ is required!"));
        }
        getSerializerPromise.result = localForageInstance.getSerializer();
        return getSerializerPromise.result;
      }
      function executeCallback(promise, callback) {
        if (callback) {
          promise.then(function(result) {
            callback(null, result);
          }, function(error) {
            callback(error);
          });
        }
      }
      function forEachItem(items, keyFn, valueFn, loopFn) {
        function ensurePropGetterMethod(propFn, defaultPropName) {
          var propName = propFn || defaultPropName;
          if ((!propFn || typeof propFn !== "function") && typeof propName === "string") {
            propFn = function propFn2(item2) {
              return item2[propName];
            };
          }
          return propFn;
        }
        var result = [];
        if (Object.prototype.toString.call(items) === "[object Array]") {
          keyFn = ensurePropGetterMethod(keyFn, "key");
          valueFn = ensurePropGetterMethod(valueFn, "value");
          for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            result.push(loopFn(keyFn(item), valueFn(item)));
          }
        } else {
          for (var prop in items) {
            if (items.hasOwnProperty(prop)) {
              result.push(loopFn(prop, items[prop]));
            }
          }
        }
        return result;
      }
      function setItemsIndexedDB(items, keyFn, valueFn, callback) {
        var localforageInstance = this;
        var promise = localforageInstance.ready().then(function() {
          return new Promise(function(resolve2, reject) {
            var dbInfo = localforageInstance._dbInfo;
            var transaction = dbInfo.db.transaction(dbInfo.storeName, "readwrite");
            var store = transaction.objectStore(dbInfo.storeName);
            var lastError;
            transaction.oncomplete = function() {
              resolve2(items);
            };
            transaction.onabort = transaction.onerror = function(event) {
              reject(lastError || event.target);
            };
            function requestOnError(evt) {
              var request2 = evt.target || this;
              lastError = request2.error || request2.transaction.error;
              reject(lastError);
            }
            forEachItem(items, keyFn, valueFn, function(key, value) {
              if (value === null) {
                value = void 0;
              }
              var request2 = store.put(value, key);
              request2.onerror = requestOnError;
            });
          });
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItemsWebsql(items, keyFn, valueFn, callback) {
        var localforageInstance = this;
        var promise = new Promise(function(resolve2, reject) {
          localforageInstance.ready().then(function() {
            return getSerializerPromise(localforageInstance);
          }).then(function(serializer) {
            var dbInfo = localforageInstance._dbInfo;
            dbInfo.db.transaction(
              function(t2) {
                var query = "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)";
                var itemPromises = forEachItem(items, keyFn, valueFn, function(key, value) {
                  return new Promise(function(resolve3, reject2) {
                    serializer.serialize(value, function(value2, error) {
                      if (error) {
                        reject2(error);
                      } else {
                        t2.executeSql(query, [key, value2], function() {
                          resolve3();
                        }, function(t3, error2) {
                          reject2(error2);
                        });
                      }
                    });
                  });
                });
                Promise.all(itemPromises).then(function() {
                  resolve2(items);
                }, reject);
              },
              function(sqlError) {
                reject(sqlError);
              }
              /*, function() {
                 if (resolving) {
                     resolve(items);
                 }
              }*/
            );
          }).catch(reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItemsGeneric(items, keyFn, valueFn, callback) {
        var localforageInstance = this;
        var itemPromises = forEachItem(items, keyFn, valueFn, function(key, value) {
          return localforageInstance.setItem(key, value);
        });
        var promise = Promise.all(itemPromises);
        executeCallback(promise, callback);
        return promise;
      }
      function localforageSetItems(items, keyFn, valueFn, callback) {
        var localforageInstance = this;
        var currentDriver = localforageInstance.driver();
        if (currentDriver === localforageInstance.INDEXEDDB) {
          return setItemsIndexedDB.call(localforageInstance, items, keyFn, valueFn, callback);
        } else if (currentDriver === localforageInstance.WEBSQL) {
          return setItemsWebsql.call(localforageInstance, items, keyFn, valueFn, callback);
        } else {
          return setItemsGeneric.call(localforageInstance, items, keyFn, valueFn, callback);
        }
      }
      function extendPrototype(localforage$$1) {
        var localforagePrototype = Object.getPrototypeOf(localforage$$1);
        if (localforagePrototype) {
          localforagePrototype.setItems = localforageSetItems;
          localforagePrototype.setItems.indexedDB = function() {
            return setItemsIndexedDB.apply(this, arguments);
          };
          localforagePrototype.setItems.websql = function() {
            return setItemsWebsql.apply(this, arguments);
          };
          localforagePrototype.setItems.generic = function() {
            return setItemsGeneric.apply(this, arguments);
          };
        }
      }
      extendPrototype(localforage);
      var md5$1 = { exports: {} };
      var crypt = { exports: {} };
      (function() {
        var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt$1 = {
          // Bit-wise rotation left
          rotl: function(n, b2) {
            return n << b2 | n >>> 32 - b2;
          },
          // Bit-wise rotation right
          rotr: function(n, b2) {
            return n << 32 - b2 | n >>> b2;
          },
          // Swap big-endian to little-endian and vice versa
          endian: function(n) {
            if (n.constructor == Number) {
              return crypt$1.rotl(n, 8) & 16711935 | crypt$1.rotl(n, 24) & 4278255360;
            }
            for (var i = 0; i < n.length; i++)
              n[i] = crypt$1.endian(n[i]);
            return n;
          },
          // Generate an array of any length of random bytes
          randomBytes: function(n) {
            for (var bytes = []; n > 0; n--)
              bytes.push(Math.floor(Math.random() * 256));
            return bytes;
          },
          // Convert a byte array to big-endian 32-bit words
          bytesToWords: function(bytes) {
            for (var words2 = [], i = 0, b2 = 0; i < bytes.length; i++, b2 += 8)
              words2[b2 >>> 5] |= bytes[i] << 24 - b2 % 32;
            return words2;
          },
          // Convert big-endian 32-bit words to a byte array
          wordsToBytes: function(words2) {
            for (var bytes = [], b2 = 0; b2 < words2.length * 32; b2 += 8)
              bytes.push(words2[b2 >>> 5] >>> 24 - b2 % 32 & 255);
            return bytes;
          },
          // Convert a byte array to a hex string
          bytesToHex: function(bytes) {
            for (var hex = [], i = 0; i < bytes.length; i++) {
              hex.push((bytes[i] >>> 4).toString(16));
              hex.push((bytes[i] & 15).toString(16));
            }
            return hex.join("");
          },
          // Convert a hex string to a byte array
          hexToBytes: function(hex) {
            for (var bytes = [], c2 = 0; c2 < hex.length; c2 += 2)
              bytes.push(parseInt(hex.substr(c2, 2), 16));
            return bytes;
          },
          // Convert a byte array to a base-64 string
          bytesToBase64: function(bytes) {
            for (var base64 = [], i = 0; i < bytes.length; i += 3) {
              var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
              for (var j = 0; j < 4; j++)
                if (i * 8 + j * 6 <= bytes.length * 8)
                  base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
                else
                  base64.push("=");
            }
            return base64.join("");
          },
          // Convert a base-64 string to a byte array
          base64ToBytes: function(base64) {
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
            for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
              if (imod4 == 0)
                continue;
              bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
            }
            return bytes;
          }
        };
        crypt.exports = crypt$1;
      })();
      var cryptExports = crypt.exports;
      var charenc = {
        // UTF-8 encoding
        utf8: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
          },
          // Convert a byte array to a string
          bytesToString: function(bytes) {
            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
          }
        },
        // Binary encoding
        bin: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            for (var bytes = [], i = 0; i < str.length; i++)
              bytes.push(str.charCodeAt(i) & 255);
            return bytes;
          },
          // Convert a byte array to a string
          bytesToString: function(bytes) {
            for (var str = [], i = 0; i < bytes.length; i++)
              str.push(String.fromCharCode(bytes[i]));
            return str.join("");
          }
        }
      };
      var charenc_1 = charenc;
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      var isBuffer_1 = function(obj) {
        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
      };
      function isBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
      }
      (function() {
        var crypt2 = cryptExports, utf8 = charenc_1.utf8, isBuffer2 = isBuffer_1, bin = charenc_1.bin, md52 = function(message2, options) {
          if (message2.constructor == String)
            if (options && options.encoding === "binary")
              message2 = bin.stringToBytes(message2);
            else
              message2 = utf8.stringToBytes(message2);
          else if (isBuffer2(message2))
            message2 = Array.prototype.slice.call(message2, 0);
          else if (!Array.isArray(message2) && message2.constructor !== Uint8Array)
            message2 = message2.toString();
          var m2 = crypt2.bytesToWords(message2), l2 = message2.length * 8, a2 = 1732584193, b2 = -271733879, c2 = -1732584194, d2 = 271733878;
          for (var i = 0; i < m2.length; i++) {
            m2[i] = (m2[i] << 8 | m2[i] >>> 24) & 16711935 | (m2[i] << 24 | m2[i] >>> 8) & 4278255360;
          }
          m2[l2 >>> 5] |= 128 << l2 % 32;
          m2[(l2 + 64 >>> 9 << 4) + 14] = l2;
          var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
          for (var i = 0; i < m2.length; i += 16) {
            var aa = a2, bb = b2, cc = c2, dd = d2;
            a2 = FF(a2, b2, c2, d2, m2[i + 0], 7, -680876936);
            d2 = FF(d2, a2, b2, c2, m2[i + 1], 12, -389564586);
            c2 = FF(c2, d2, a2, b2, m2[i + 2], 17, 606105819);
            b2 = FF(b2, c2, d2, a2, m2[i + 3], 22, -1044525330);
            a2 = FF(a2, b2, c2, d2, m2[i + 4], 7, -176418897);
            d2 = FF(d2, a2, b2, c2, m2[i + 5], 12, 1200080426);
            c2 = FF(c2, d2, a2, b2, m2[i + 6], 17, -1473231341);
            b2 = FF(b2, c2, d2, a2, m2[i + 7], 22, -45705983);
            a2 = FF(a2, b2, c2, d2, m2[i + 8], 7, 1770035416);
            d2 = FF(d2, a2, b2, c2, m2[i + 9], 12, -1958414417);
            c2 = FF(c2, d2, a2, b2, m2[i + 10], 17, -42063);
            b2 = FF(b2, c2, d2, a2, m2[i + 11], 22, -1990404162);
            a2 = FF(a2, b2, c2, d2, m2[i + 12], 7, 1804603682);
            d2 = FF(d2, a2, b2, c2, m2[i + 13], 12, -40341101);
            c2 = FF(c2, d2, a2, b2, m2[i + 14], 17, -1502002290);
            b2 = FF(b2, c2, d2, a2, m2[i + 15], 22, 1236535329);
            a2 = GG(a2, b2, c2, d2, m2[i + 1], 5, -165796510);
            d2 = GG(d2, a2, b2, c2, m2[i + 6], 9, -1069501632);
            c2 = GG(c2, d2, a2, b2, m2[i + 11], 14, 643717713);
            b2 = GG(b2, c2, d2, a2, m2[i + 0], 20, -373897302);
            a2 = GG(a2, b2, c2, d2, m2[i + 5], 5, -701558691);
            d2 = GG(d2, a2, b2, c2, m2[i + 10], 9, 38016083);
            c2 = GG(c2, d2, a2, b2, m2[i + 15], 14, -660478335);
            b2 = GG(b2, c2, d2, a2, m2[i + 4], 20, -405537848);
            a2 = GG(a2, b2, c2, d2, m2[i + 9], 5, 568446438);
            d2 = GG(d2, a2, b2, c2, m2[i + 14], 9, -1019803690);
            c2 = GG(c2, d2, a2, b2, m2[i + 3], 14, -187363961);
            b2 = GG(b2, c2, d2, a2, m2[i + 8], 20, 1163531501);
            a2 = GG(a2, b2, c2, d2, m2[i + 13], 5, -1444681467);
            d2 = GG(d2, a2, b2, c2, m2[i + 2], 9, -51403784);
            c2 = GG(c2, d2, a2, b2, m2[i + 7], 14, 1735328473);
            b2 = GG(b2, c2, d2, a2, m2[i + 12], 20, -1926607734);
            a2 = HH(a2, b2, c2, d2, m2[i + 5], 4, -378558);
            d2 = HH(d2, a2, b2, c2, m2[i + 8], 11, -2022574463);
            c2 = HH(c2, d2, a2, b2, m2[i + 11], 16, 1839030562);
            b2 = HH(b2, c2, d2, a2, m2[i + 14], 23, -35309556);
            a2 = HH(a2, b2, c2, d2, m2[i + 1], 4, -1530992060);
            d2 = HH(d2, a2, b2, c2, m2[i + 4], 11, 1272893353);
            c2 = HH(c2, d2, a2, b2, m2[i + 7], 16, -155497632);
            b2 = HH(b2, c2, d2, a2, m2[i + 10], 23, -1094730640);
            a2 = HH(a2, b2, c2, d2, m2[i + 13], 4, 681279174);
            d2 = HH(d2, a2, b2, c2, m2[i + 0], 11, -358537222);
            c2 = HH(c2, d2, a2, b2, m2[i + 3], 16, -722521979);
            b2 = HH(b2, c2, d2, a2, m2[i + 6], 23, 76029189);
            a2 = HH(a2, b2, c2, d2, m2[i + 9], 4, -640364487);
            d2 = HH(d2, a2, b2, c2, m2[i + 12], 11, -421815835);
            c2 = HH(c2, d2, a2, b2, m2[i + 15], 16, 530742520);
            b2 = HH(b2, c2, d2, a2, m2[i + 2], 23, -995338651);
            a2 = II(a2, b2, c2, d2, m2[i + 0], 6, -198630844);
            d2 = II(d2, a2, b2, c2, m2[i + 7], 10, 1126891415);
            c2 = II(c2, d2, a2, b2, m2[i + 14], 15, -1416354905);
            b2 = II(b2, c2, d2, a2, m2[i + 5], 21, -57434055);
            a2 = II(a2, b2, c2, d2, m2[i + 12], 6, 1700485571);
            d2 = II(d2, a2, b2, c2, m2[i + 3], 10, -1894986606);
            c2 = II(c2, d2, a2, b2, m2[i + 10], 15, -1051523);
            b2 = II(b2, c2, d2, a2, m2[i + 1], 21, -2054922799);
            a2 = II(a2, b2, c2, d2, m2[i + 8], 6, 1873313359);
            d2 = II(d2, a2, b2, c2, m2[i + 15], 10, -30611744);
            c2 = II(c2, d2, a2, b2, m2[i + 6], 15, -1560198380);
            b2 = II(b2, c2, d2, a2, m2[i + 13], 21, 1309151649);
            a2 = II(a2, b2, c2, d2, m2[i + 4], 6, -145523070);
            d2 = II(d2, a2, b2, c2, m2[i + 11], 10, -1120210379);
            c2 = II(c2, d2, a2, b2, m2[i + 2], 15, 718787259);
            b2 = II(b2, c2, d2, a2, m2[i + 9], 21, -343485551);
            a2 = a2 + aa >>> 0;
            b2 = b2 + bb >>> 0;
            c2 = c2 + cc >>> 0;
            d2 = d2 + dd >>> 0;
          }
          return crypt2.endian([a2, b2, c2, d2]);
        };
        md52._ff = function(a2, b2, c2, d2, x2, s2, t2) {
          var n = a2 + (b2 & c2 | ~b2 & d2) + (x2 >>> 0) + t2;
          return (n << s2 | n >>> 32 - s2) + b2;
        };
        md52._gg = function(a2, b2, c2, d2, x2, s2, t2) {
          var n = a2 + (b2 & d2 | c2 & ~d2) + (x2 >>> 0) + t2;
          return (n << s2 | n >>> 32 - s2) + b2;
        };
        md52._hh = function(a2, b2, c2, d2, x2, s2, t2) {
          var n = a2 + (b2 ^ c2 ^ d2) + (x2 >>> 0) + t2;
          return (n << s2 | n >>> 32 - s2) + b2;
        };
        md52._ii = function(a2, b2, c2, d2, x2, s2, t2) {
          var n = a2 + (c2 ^ (b2 | ~d2)) + (x2 >>> 0) + t2;
          return (n << s2 | n >>> 32 - s2) + b2;
        };
        md52._blocksize = 16;
        md52._digestsize = 16;
        md5$1.exports = function(message2, options) {
          if (message2 === void 0 || message2 === null)
            throw new Error("Illegal argument " + message2);
          var digestbytes = crypt2.wordsToBytes(md52(message2, options));
          return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt2.bytesToHex(digestbytes);
        };
      })();
      var md5Exports = md5$1.exports;
      const md5 = /* @__PURE__ */ getDefaultExportFromCjs(md5Exports);
      const dateTimeFormatter = new Intl.DateTimeFormat(void 0, {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false
      });
      (function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      })();
      /**
       * @license
       * Copyright 2019 Google LLC
       * SPDX-License-Identifier: Apache-2.0
       */
      const proxyMarker = Symbol("Comlink.proxy");
      const createEndpoint = Symbol("Comlink.endpoint");
      const releaseProxy = Symbol("Comlink.releaseProxy");
      const finalizer = Symbol("Comlink.finalizer");
      const throwMarker = Symbol("Comlink.thrown");
      const isObject$1 = (val) => typeof val === "object" && val !== null || typeof val === "function";
      const proxyTransferHandler = {
        canHandle: (val) => isObject$1(val) && val[proxyMarker],
        serialize(obj) {
          const { port1, port2 } = new MessageChannel();
          expose(obj, port1);
          return [port2, [port2]];
        },
        deserialize(port) {
          port.start();
          return wrap(port);
        }
      };
      const throwTransferHandler = {
        canHandle: (value) => isObject$1(value) && throwMarker in value,
        serialize({ value }) {
          let serialized;
          if (value instanceof Error) {
            serialized = {
              isError: true,
              value: {
                message: value.message,
                name: value.name,
                stack: value.stack
              }
            };
          } else {
            serialized = { isError: false, value };
          }
          return [serialized, []];
        },
        deserialize(serialized) {
          if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
          }
          throw serialized.value;
        }
      };
      const transferHandlers = /* @__PURE__ */ new Map([
        ["proxy", proxyTransferHandler],
        ["throw", throwTransferHandler]
      ]);
      function isAllowedOrigin(allowedOrigins, origin) {
        for (const allowedOrigin of allowedOrigins) {
          if (origin === allowedOrigin || allowedOrigin === "*") {
            return true;
          }
          if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
            return true;
          }
        }
        return false;
      }
      function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
        ep.addEventListener("message", function callback(ev) {
          if (!ev || !ev.data) {
            return;
          }
          if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
            return;
          }
          const { id, type, path } = Object.assign({ path: [] }, ev.data);
          const argumentList = (ev.data.argumentList || []).map(fromWireValue);
          let returnValue;
          try {
            const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
            const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
            switch (type) {
              case "GET":
                {
                  returnValue = rawValue;
                }
                break;
              case "SET":
                {
                  parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                  returnValue = true;
                }
                break;
              case "APPLY":
                {
                  returnValue = rawValue.apply(parent, argumentList);
                }
                break;
              case "CONSTRUCT":
                {
                  const value = new rawValue(...argumentList);
                  returnValue = proxy(value);
                }
                break;
              case "ENDPOINT":
                {
                  const { port1, port2 } = new MessageChannel();
                  expose(obj, port2);
                  returnValue = transfer(port1, [port1]);
                }
                break;
              case "RELEASE":
                {
                  returnValue = void 0;
                }
                break;
              default:
                return;
            }
          } catch (value) {
            returnValue = { value, [throwMarker]: 0 };
          }
          Promise.resolve(returnValue).catch((value) => {
            return { value, [throwMarker]: 0 };
          }).then((returnValue2) => {
            const [wireValue, transferables] = toWireValue(returnValue2);
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
            if (type === "RELEASE") {
              ep.removeEventListener("message", callback);
              closeEndPoint(ep);
              if (finalizer in obj && typeof obj[finalizer] === "function") {
                obj[finalizer]();
              }
            }
          }).catch((error) => {
            const [wireValue, transferables] = toWireValue({
              value: new TypeError("Unserializable return value"),
              [throwMarker]: 0
            });
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
          });
        });
        if (ep.start) {
          ep.start();
        }
      }
      function isMessagePort(endpoint) {
        return endpoint.constructor.name === "MessagePort";
      }
      function closeEndPoint(endpoint) {
        if (isMessagePort(endpoint))
          endpoint.close();
      }
      function wrap(ep, target) {
        return createProxy(ep, [], target);
      }
      function throwIfProxyReleased(isReleased) {
        if (isReleased) {
          throw new Error("Proxy has been released and is not useable");
        }
      }
      function releaseEndpoint(ep) {
        return requestResponseMessage(ep, {
          type: "RELEASE"
        }).then(() => {
          closeEndPoint(ep);
        });
      }
      const proxyCounter = /* @__PURE__ */ new WeakMap();
      const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
        const newCount = (proxyCounter.get(ep) || 0) - 1;
        proxyCounter.set(ep, newCount);
        if (newCount === 0) {
          releaseEndpoint(ep);
        }
      });
      function registerProxy(proxy2, ep) {
        const newCount = (proxyCounter.get(ep) || 0) + 1;
        proxyCounter.set(ep, newCount);
        if (proxyFinalizers) {
          proxyFinalizers.register(proxy2, ep, proxy2);
        }
      }
      function unregisterProxy(proxy2) {
        if (proxyFinalizers) {
          proxyFinalizers.unregister(proxy2);
        }
      }
      function createProxy(ep, path = [], target = function() {
      }) {
        let isProxyReleased = false;
        const proxy2 = new Proxy(target, {
          get(_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
              return () => {
                unregisterProxy(proxy2);
                releaseEndpoint(ep);
                isProxyReleased = true;
              };
            }
            if (prop === "then") {
              if (path.length === 0) {
                return { then: () => proxy2 };
              }
              const r = requestResponseMessage(ep, {
                type: "GET",
                path: path.map((p2) => p2.toString())
              }).then(fromWireValue);
              return r.then.bind(r);
            }
            return createProxy(ep, [...path, prop]);
          },
          set(_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep, {
              type: "SET",
              path: [...path, prop].map((p2) => p2.toString()),
              value
            }, transferables).then(fromWireValue);
          },
          apply(_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last2 = path[path.length - 1];
            if (last2 === createEndpoint) {
              return requestResponseMessage(ep, {
                type: "ENDPOINT"
              }).then(fromWireValue);
            }
            if (last2 === "bind") {
              return createProxy(ep, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
              type: "APPLY",
              path: path.map((p2) => p2.toString()),
              argumentList
            }, transferables).then(fromWireValue);
          },
          construct(_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, {
              type: "CONSTRUCT",
              path: path.map((p2) => p2.toString()),
              argumentList
            }, transferables).then(fromWireValue);
          }
        });
        registerProxy(proxy2, ep);
        return proxy2;
      }
      function myFlat(arr) {
        return Array.prototype.concat.apply([], arr);
      }
      function processArguments(argumentList) {
        const processed = argumentList.map(toWireValue);
        return [processed.map((v2) => v2[0]), myFlat(processed.map((v2) => v2[1]))];
      }
      const transferCache = /* @__PURE__ */ new WeakMap();
      function transfer(obj, transfers) {
        transferCache.set(obj, transfers);
        return obj;
      }
      function proxy(obj) {
        return Object.assign(obj, { [proxyMarker]: true });
      }
      function toWireValue(value) {
        for (const [name, handler] of transferHandlers) {
          if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
              {
                type: "HANDLER",
                name,
                value: serializedValue
              },
              transferables
            ];
          }
        }
        return [
          {
            type: "RAW",
            value
          },
          transferCache.get(value) || []
        ];
      }
      function fromWireValue(value) {
        switch (value.type) {
          case "HANDLER":
            return transferHandlers.get(value.name).deserialize(value.value);
          case "RAW":
            return value.value;
        }
      }
      function requestResponseMessage(ep, msg, transfers) {
        return new Promise((resolve2) => {
          const id = generateUUID();
          ep.addEventListener("message", function l2(ev) {
            if (!ev.data || !ev.data.id || ev.data.id !== id) {
              return;
            }
            ep.removeEventListener("message", l2);
            resolve2(ev.data);
          });
          if (ep.start) {
            ep.start();
          }
          ep.postMessage(Object.assign({ id }, msg), transfers);
        });
      }
      function generateUUID() {
        return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
      }
      const encodedJs = "dmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTsKdmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlOwp2YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHsKICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSAic3ltYm9sIiA/IGtleSArICIiIDoga2V5LCB2YWx1ZSk7CiAgcmV0dXJuIHZhbHVlOwp9OwooZnVuY3Rpb24oKSB7CiAgInVzZSBzdHJpY3QiOwogIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHt9OwogIGZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHgpIHsKICAgIHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgImRlZmF1bHQiKSA/IHhbImRlZmF1bHQiXSA6IHg7CiAgfQogIGZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZShwYXRoKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkeW5hbWljYWxseSByZXF1aXJlICInICsgcGF0aCArICciLiBQbGVhc2UgY29uZmlndXJlIHRoZSBkeW5hbWljUmVxdWlyZVRhcmdldHMgb3IvYW5kIGlnbm9yZUR5bmFtaWNSZXF1aXJlcyBvcHRpb24gb2YgQHJvbGx1cC9wbHVnaW4tY29tbW9uanMgYXBwcm9wcmlhdGVseSBmb3IgdGhpcyByZXF1aXJlIGNhbGwgdG8gd29yay4nKTsKICB9CiAgdmFyIGpzemlwX21pbiA9IHsgZXhwb3J0czoge30gfTsKICAvKiEKICAKICAJSlNaaXAgdjMuMTAuMSAtIEEgSmF2YVNjcmlwdCBjbGFzcyBmb3IgZ2VuZXJhdGluZyBhbmQgcmVhZGluZyB6aXAgZmlsZXMKICAJPGh0dHA6Ly9zdHVhcnRrLmNvbS9qc3ppcD4KICAKICAJKGMpIDIwMDktMjAxNiBTdHVhcnQgS25pZ2h0bGV5IDxzdHVhcnQgW2F0XSBzdHVhcnRrLmNvbT4KICAJRHVhbCBsaWNlbmNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2Ugb3IgR1BMdjMuIFNlZSBodHRwczovL3Jhdy5naXRodWIuY29tL1N0dWsvanN6aXAvbWFpbi9MSUNFTlNFLm1hcmtkb3duLgogIAogIAlKU1ppcCB1c2VzIHRoZSBsaWJyYXJ5IHBha28gcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIDoKICAJaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL2Jsb2IvbWFpbi9MSUNFTlNFCiAgCSovCiAgKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykgewogICAgIWZ1bmN0aW9uKGUpIHsKICAgICAgbW9kdWxlLmV4cG9ydHMgPSBlKCk7CiAgICB9KGZ1bmN0aW9uKCkgewogICAgICByZXR1cm4gZnVuY3Rpb24gcyhhLCBvLCBoKSB7CiAgICAgICAgZnVuY3Rpb24gdShyLCBlMikgewogICAgICAgICAgaWYgKCFvW3JdKSB7CiAgICAgICAgICAgIGlmICghYVtyXSkgewogICAgICAgICAgICAgIHZhciB0ID0gImZ1bmN0aW9uIiA9PSB0eXBlb2YgY29tbW9uanNSZXF1aXJlICYmIGNvbW1vbmpzUmVxdWlyZTsKICAgICAgICAgICAgICBpZiAoIWUyICYmIHQpCiAgICAgICAgICAgICAgICByZXR1cm4gdChyLCB0cnVlKTsKICAgICAgICAgICAgICBpZiAobCkKICAgICAgICAgICAgICAgIHJldHVybiBsKHIsIHRydWUpOwogICAgICAgICAgICAgIHZhciBuID0gbmV3IEVycm9yKCJDYW5ub3QgZmluZCBtb2R1bGUgJyIgKyByICsgIiciKTsKICAgICAgICAgICAgICB0aHJvdyBuLmNvZGUgPSAiTU9EVUxFX05PVF9GT1VORCIsIG47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdmFyIGkgPSBvW3JdID0geyBleHBvcnRzOiB7fSB9OwogICAgICAgICAgICBhW3JdWzBdLmNhbGwoaS5leHBvcnRzLCBmdW5jdGlvbihlMykgewogICAgICAgICAgICAgIHZhciB0MiA9IGFbcl1bMV1bZTNdOwogICAgICAgICAgICAgIHJldHVybiB1KHQyIHx8IGUzKTsKICAgICAgICAgICAgfSwgaSwgaS5leHBvcnRzLCBzLCBhLCBvLCBoKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBvW3JdLmV4cG9ydHM7CiAgICAgICAgfQogICAgICAgIGZvciAodmFyIGwgPSAiZnVuY3Rpb24iID09IHR5cGVvZiBjb21tb25qc1JlcXVpcmUgJiYgY29tbW9uanNSZXF1aXJlLCBlID0gMDsgZSA8IGgubGVuZ3RoOyBlKyspCiAgICAgICAgICB1KGhbZV0pOwogICAgICAgIHJldHVybiB1OwogICAgICB9KHsgMTogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgZCA9IGUoIi4vdXRpbHMiKSwgYyA9IGUoIi4vc3VwcG9ydCIpLCBwID0gIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89IjsKICAgICAgICByLmVuY29kZSA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICBmb3IgKHZhciB0MiwgcjIsIG4sIGksIHMsIGEsIG8sIGggPSBbXSwgdSA9IDAsIGwgPSBlMi5sZW5ndGgsIGYgPSBsLCBjMiA9ICJzdHJpbmciICE9PSBkLmdldFR5cGVPZihlMik7IHUgPCBlMi5sZW5ndGg7ICkKICAgICAgICAgICAgZiA9IGwgLSB1LCBuID0gYzIgPyAodDIgPSBlMlt1KytdLCByMiA9IHUgPCBsID8gZTJbdSsrXSA6IDAsIHUgPCBsID8gZTJbdSsrXSA6IDApIDogKHQyID0gZTIuY2hhckNvZGVBdCh1KyspLCByMiA9IHUgPCBsID8gZTIuY2hhckNvZGVBdCh1KyspIDogMCwgdSA8IGwgPyBlMi5jaGFyQ29kZUF0KHUrKykgOiAwKSwgaSA9IHQyID4+IDIsIHMgPSAoMyAmIHQyKSA8PCA0IHwgcjIgPj4gNCwgYSA9IDEgPCBmID8gKDE1ICYgcjIpIDw8IDIgfCBuID4+IDYgOiA2NCwgbyA9IDIgPCBmID8gNjMgJiBuIDogNjQsIGgucHVzaChwLmNoYXJBdChpKSArIHAuY2hhckF0KHMpICsgcC5jaGFyQXQoYSkgKyBwLmNoYXJBdChvKSk7CiAgICAgICAgICByZXR1cm4gaC5qb2luKCIiKTsKICAgICAgICB9LCByLmRlY29kZSA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB2YXIgdDIsIHIyLCBuLCBpLCBzLCBhLCBvID0gMCwgaCA9IDAsIHUgPSAiZGF0YToiOwogICAgICAgICAgaWYgKGUyLnN1YnN0cigwLCB1Lmxlbmd0aCkgPT09IHUpCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBiYXNlNjQgaW5wdXQsIGl0IGxvb2tzIGxpa2UgYSBkYXRhIHVybC4iKTsKICAgICAgICAgIHZhciBsLCBmID0gMyAqIChlMiA9IGUyLnJlcGxhY2UoL1teQS1aYS16MC05Ky89XS9nLCAiIikpLmxlbmd0aCAvIDQ7CiAgICAgICAgICBpZiAoZTIuY2hhckF0KGUyLmxlbmd0aCAtIDEpID09PSBwLmNoYXJBdCg2NCkgJiYgZi0tLCBlMi5jaGFyQXQoZTIubGVuZ3RoIC0gMikgPT09IHAuY2hhckF0KDY0KSAmJiBmLS0sIGYgJSAxICE9IDApCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBiYXNlNjQgaW5wdXQsIGJhZCBjb250ZW50IGxlbmd0aC4iKTsKICAgICAgICAgIGZvciAobCA9IGMudWludDhhcnJheSA/IG5ldyBVaW50OEFycmF5KDAgfCBmKSA6IG5ldyBBcnJheSgwIHwgZik7IG8gPCBlMi5sZW5ndGg7ICkKICAgICAgICAgICAgdDIgPSBwLmluZGV4T2YoZTIuY2hhckF0KG8rKykpIDw8IDIgfCAoaSA9IHAuaW5kZXhPZihlMi5jaGFyQXQobysrKSkpID4+IDQsIHIyID0gKDE1ICYgaSkgPDwgNCB8IChzID0gcC5pbmRleE9mKGUyLmNoYXJBdChvKyspKSkgPj4gMiwgbiA9ICgzICYgcykgPDwgNiB8IChhID0gcC5pbmRleE9mKGUyLmNoYXJBdChvKyspKSksIGxbaCsrXSA9IHQyLCA2NCAhPT0gcyAmJiAobFtoKytdID0gcjIpLCA2NCAhPT0gYSAmJiAobFtoKytdID0gbik7CiAgICAgICAgICByZXR1cm4gbDsKICAgICAgICB9OwogICAgICB9LCB7ICIuL3N1cHBvcnQiOiAzMCwgIi4vdXRpbHMiOiAzMiB9XSwgMjogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgbiA9IGUoIi4vZXh0ZXJuYWwiKSwgaSA9IGUoIi4vc3RyZWFtL0RhdGFXb3JrZXIiKSwgcyA9IGUoIi4vc3RyZWFtL0NyYzMyUHJvYmUiKSwgYSA9IGUoIi4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZSIpOwogICAgICAgIGZ1bmN0aW9uIG8oZTIsIHQyLCByMiwgbjIsIGkyKSB7CiAgICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gZTIsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHQyLCB0aGlzLmNyYzMyID0gcjIsIHRoaXMuY29tcHJlc3Npb24gPSBuMiwgdGhpcy5jb21wcmVzc2VkQ29udGVudCA9IGkyOwogICAgICAgIH0KICAgICAgICBvLnByb3RvdHlwZSA9IHsgZ2V0Q29udGVudFdvcmtlcjogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgZTIgPSBuZXcgaShuLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSkucGlwZSh0aGlzLmNvbXByZXNzaW9uLnVuY29tcHJlc3NXb3JrZXIoKSkucGlwZShuZXcgYSgiZGF0YV9sZW5ndGgiKSksIHQyID0gdGhpczsKICAgICAgICAgIHJldHVybiBlMi5vbigiZW5kIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbUluZm8uZGF0YV9sZW5ndGggIT09IHQyLnVuY29tcHJlc3NlZFNpemUpCiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJCdWcgOiB1bmNvbXByZXNzZWQgZGF0YSBzaXplIG1pc21hdGNoIik7CiAgICAgICAgICB9KSwgZTI7CiAgICAgICAgfSwgZ2V0Q29tcHJlc3NlZFdvcmtlcjogZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gbmV3IGkobi5Qcm9taXNlLnJlc29sdmUodGhpcy5jb21wcmVzc2VkQ29udGVudCkpLndpdGhTdHJlYW1JbmZvKCJjb21wcmVzc2VkU2l6ZSIsIHRoaXMuY29tcHJlc3NlZFNpemUpLndpdGhTdHJlYW1JbmZvKCJ1bmNvbXByZXNzZWRTaXplIiwgdGhpcy51bmNvbXByZXNzZWRTaXplKS53aXRoU3RyZWFtSW5mbygiY3JjMzIiLCB0aGlzLmNyYzMyKS53aXRoU3RyZWFtSW5mbygiY29tcHJlc3Npb24iLCB0aGlzLmNvbXByZXNzaW9uKTsKICAgICAgICB9IH0sIG8uY3JlYXRlV29ya2VyRnJvbSA9IGZ1bmN0aW9uKGUyLCB0MiwgcjIpIHsKICAgICAgICAgIHJldHVybiBlMi5waXBlKG5ldyBzKCkpLnBpcGUobmV3IGEoInVuY29tcHJlc3NlZFNpemUiKSkucGlwZSh0Mi5jb21wcmVzc1dvcmtlcihyMikpLnBpcGUobmV3IGEoImNvbXByZXNzZWRTaXplIikpLndpdGhTdHJlYW1JbmZvKCJjb21wcmVzc2lvbiIsIHQyKTsKICAgICAgICB9LCB0LmV4cG9ydHMgPSBvOwogICAgICB9LCB7ICIuL2V4dGVybmFsIjogNiwgIi4vc3RyZWFtL0NyYzMyUHJvYmUiOiAyNSwgIi4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZSI6IDI2LCAiLi9zdHJlYW0vRGF0YVdvcmtlciI6IDI3IH1dLCAzOiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBuID0gZSgiLi9zdHJlYW0vR2VuZXJpY1dvcmtlciIpOwogICAgICAgIHIuU1RPUkUgPSB7IG1hZ2ljOiAiXDBcMCIsIGNvbXByZXNzV29ya2VyOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiBuZXcgbigiU1RPUkUgY29tcHJlc3Npb24iKTsKICAgICAgICB9LCB1bmNvbXByZXNzV29ya2VyOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiBuZXcgbigiU1RPUkUgZGVjb21wcmVzc2lvbiIpOwogICAgICAgIH0gfSwgci5ERUZMQVRFID0gZSgiLi9mbGF0ZSIpOwogICAgICB9LCB7ICIuL2ZsYXRlIjogNywgIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXIiOiAyOCB9XSwgNDogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgbiA9IGUoIi4vdXRpbHMiKTsKICAgICAgICB2YXIgbyA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgZm9yICh2YXIgZTIsIHQyID0gW10sIHIyID0gMDsgcjIgPCAyNTY7IHIyKyspIHsKICAgICAgICAgICAgZTIgPSByMjsKICAgICAgICAgICAgZm9yICh2YXIgbjIgPSAwOyBuMiA8IDg7IG4yKyspCiAgICAgICAgICAgICAgZTIgPSAxICYgZTIgPyAzOTg4MjkyMzg0IF4gZTIgPj4+IDEgOiBlMiA+Pj4gMTsKICAgICAgICAgICAgdDJbcjJdID0gZTI7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdDI7CiAgICAgICAgfSgpOwogICAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gZTIgJiYgZTIubGVuZ3RoID8gInN0cmluZyIgIT09IG4uZ2V0VHlwZU9mKGUyKSA/IGZ1bmN0aW9uKGUzLCB0MywgcjIsIG4yKSB7CiAgICAgICAgICAgIHZhciBpID0gbywgcyA9IG4yICsgcjI7CiAgICAgICAgICAgIGUzIF49IC0xOwogICAgICAgICAgICBmb3IgKHZhciBhID0gbjI7IGEgPCBzOyBhKyspCiAgICAgICAgICAgICAgZTMgPSBlMyA+Pj4gOCBeIGlbMjU1ICYgKGUzIF4gdDNbYV0pXTsKICAgICAgICAgICAgcmV0dXJuIC0xIF4gZTM7CiAgICAgICAgICB9KDAgfCB0MiwgZTIsIGUyLmxlbmd0aCwgMCkgOiBmdW5jdGlvbihlMywgdDMsIHIyLCBuMikgewogICAgICAgICAgICB2YXIgaSA9IG8sIHMgPSBuMiArIHIyOwogICAgICAgICAgICBlMyBePSAtMTsKICAgICAgICAgICAgZm9yICh2YXIgYSA9IG4yOyBhIDwgczsgYSsrKQogICAgICAgICAgICAgIGUzID0gZTMgPj4+IDggXiBpWzI1NSAmIChlMyBeIHQzLmNoYXJDb2RlQXQoYSkpXTsKICAgICAgICAgICAgcmV0dXJuIC0xIF4gZTM7CiAgICAgICAgICB9KDAgfCB0MiwgZTIsIGUyLmxlbmd0aCwgMCkgOiAwOwogICAgICAgIH07CiAgICAgIH0sIHsgIi4vdXRpbHMiOiAzMiB9XSwgNTogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICByLmJhc2U2NCA9IGZhbHNlLCByLmJpbmFyeSA9IGZhbHNlLCByLmRpciA9IGZhbHNlLCByLmNyZWF0ZUZvbGRlcnMgPSB0cnVlLCByLmRhdGUgPSBudWxsLCByLmNvbXByZXNzaW9uID0gbnVsbCwgci5jb21wcmVzc2lvbk9wdGlvbnMgPSBudWxsLCByLmNvbW1lbnQgPSBudWxsLCByLnVuaXhQZXJtaXNzaW9ucyA9IG51bGwsIHIuZG9zUGVybWlzc2lvbnMgPSBudWxsOwogICAgICB9LCB7fV0sIDY6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIG4gPSBudWxsOwogICAgICAgIG4gPSAidW5kZWZpbmVkIiAhPSB0eXBlb2YgUHJvbWlzZSA/IFByb21pc2UgOiBlKCJsaWUiKSwgdC5leHBvcnRzID0geyBQcm9taXNlOiBuIH07CiAgICAgIH0sIHsgbGllOiAzNyB9XSwgNzogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgbiA9ICJ1bmRlZmluZWQiICE9IHR5cGVvZiBVaW50OEFycmF5ICYmICJ1bmRlZmluZWQiICE9IHR5cGVvZiBVaW50MTZBcnJheSAmJiAidW5kZWZpbmVkIiAhPSB0eXBlb2YgVWludDMyQXJyYXksIGkgPSBlKCJwYWtvIiksIHMgPSBlKCIuL3V0aWxzIiksIGEgPSBlKCIuL3N0cmVhbS9HZW5lcmljV29ya2VyIiksIG8gPSBuID8gInVpbnQ4YXJyYXkiIDogImFycmF5IjsKICAgICAgICBmdW5jdGlvbiBoKGUyLCB0MikgewogICAgICAgICAgYS5jYWxsKHRoaXMsICJGbGF0ZVdvcmtlci8iICsgZTIpLCB0aGlzLl9wYWtvID0gbnVsbCwgdGhpcy5fcGFrb0FjdGlvbiA9IGUyLCB0aGlzLl9wYWtvT3B0aW9ucyA9IHQyLCB0aGlzLm1ldGEgPSB7fTsKICAgICAgICB9CiAgICAgICAgci5tYWdpYyA9ICJcYlwwIiwgcy5pbmhlcml0cyhoLCBhKSwgaC5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHRoaXMubWV0YSA9IGUyLm1ldGEsIG51bGwgPT09IHRoaXMuX3Bha28gJiYgdGhpcy5fY3JlYXRlUGFrbygpLCB0aGlzLl9wYWtvLnB1c2gocy50cmFuc2Zvcm1UbyhvLCBlMi5kYXRhKSwgZmFsc2UpOwogICAgICAgIH0sIGgucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICBhLnByb3RvdHlwZS5mbHVzaC5jYWxsKHRoaXMpLCBudWxsID09PSB0aGlzLl9wYWtvICYmIHRoaXMuX2NyZWF0ZVBha28oKSwgdGhpcy5fcGFrby5wdXNoKFtdLCB0cnVlKTsKICAgICAgICB9LCBoLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICBhLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyksIHRoaXMuX3Bha28gPSBudWxsOwogICAgICAgIH0sIGgucHJvdG90eXBlLl9jcmVhdGVQYWtvID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICB0aGlzLl9wYWtvID0gbmV3IGlbdGhpcy5fcGFrb0FjdGlvbl0oeyByYXc6IHRydWUsIGxldmVsOiB0aGlzLl9wYWtvT3B0aW9ucy5sZXZlbCB8fCAtMSB9KTsKICAgICAgICAgIHZhciB0MiA9IHRoaXM7CiAgICAgICAgICB0aGlzLl9wYWtvLm9uRGF0YSA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICAgIHQyLnB1c2goeyBkYXRhOiBlMiwgbWV0YTogdDIubWV0YSB9KTsKICAgICAgICAgIH07CiAgICAgICAgfSwgci5jb21wcmVzc1dvcmtlciA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICByZXR1cm4gbmV3IGgoIkRlZmxhdGUiLCBlMik7CiAgICAgICAgfSwgci51bmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gbmV3IGgoIkluZmxhdGUiLCB7fSk7CiAgICAgICAgfTsKICAgICAgfSwgeyAiLi9zdHJlYW0vR2VuZXJpY1dvcmtlciI6IDI4LCAiLi91dGlscyI6IDMyLCBwYWtvOiAzOCB9XSwgODogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICBmdW5jdGlvbiBBKGUyLCB0MikgewogICAgICAgICAgdmFyIHIyLCBuMiA9ICIiOwogICAgICAgICAgZm9yIChyMiA9IDA7IHIyIDwgdDI7IHIyKyspCiAgICAgICAgICAgIG4yICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgZTIpLCBlMiA+Pj49IDg7CiAgICAgICAgICByZXR1cm4gbjI7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG4oZTIsIHQyLCByMiwgbjIsIGkyLCBzMikgewogICAgICAgICAgdmFyIGEsIG8sIGggPSBlMi5maWxlLCB1ID0gZTIuY29tcHJlc3Npb24sIGwgPSBzMiAhPT0gTy51dGY4ZW5jb2RlLCBmID0gSS50cmFuc2Zvcm1Ubygic3RyaW5nIiwgczIoaC5uYW1lKSksIGMgPSBJLnRyYW5zZm9ybVRvKCJzdHJpbmciLCBPLnV0ZjhlbmNvZGUoaC5uYW1lKSksIGQgPSBoLmNvbW1lbnQsIHAgPSBJLnRyYW5zZm9ybVRvKCJzdHJpbmciLCBzMihkKSksIG0gPSBJLnRyYW5zZm9ybVRvKCJzdHJpbmciLCBPLnV0ZjhlbmNvZGUoZCkpLCBfID0gYy5sZW5ndGggIT09IGgubmFtZS5sZW5ndGgsIGcgPSBtLmxlbmd0aCAhPT0gZC5sZW5ndGgsIGIgPSAiIiwgdiA9ICIiLCB5ID0gIiIsIHcgPSBoLmRpciwgayA9IGguZGF0ZSwgeCA9IHsgY3JjMzI6IDAsIGNvbXByZXNzZWRTaXplOiAwLCB1bmNvbXByZXNzZWRTaXplOiAwIH07CiAgICAgICAgICB0MiAmJiAhcjIgfHwgKHguY3JjMzIgPSBlMi5jcmMzMiwgeC5jb21wcmVzc2VkU2l6ZSA9IGUyLmNvbXByZXNzZWRTaXplLCB4LnVuY29tcHJlc3NlZFNpemUgPSBlMi51bmNvbXByZXNzZWRTaXplKTsKICAgICAgICAgIHZhciBTID0gMDsKICAgICAgICAgIHQyICYmIChTIHw9IDgpLCBsIHx8ICFfICYmICFnIHx8IChTIHw9IDIwNDgpOwogICAgICAgICAgdmFyIHogPSAwLCBDID0gMDsKICAgICAgICAgIHcgJiYgKHogfD0gMTYpLCAiVU5JWCIgPT09IGkyID8gKEMgPSA3OTgsIHogfD0gZnVuY3Rpb24oZTMsIHQzKSB7CiAgICAgICAgICAgIHZhciByMyA9IGUzOwogICAgICAgICAgICByZXR1cm4gZTMgfHwgKHIzID0gdDMgPyAxNjg5MyA6IDMzMjA0KSwgKDY1NTM1ICYgcjMpIDw8IDE2OwogICAgICAgICAgfShoLnVuaXhQZXJtaXNzaW9ucywgdykpIDogKEMgPSAyMCwgeiB8PSBmdW5jdGlvbihlMykgewogICAgICAgICAgICByZXR1cm4gNjMgJiAoZTMgfHwgMCk7CiAgICAgICAgICB9KGguZG9zUGVybWlzc2lvbnMpKSwgYSA9IGsuZ2V0VVRDSG91cnMoKSwgYSA8PD0gNiwgYSB8PSBrLmdldFVUQ01pbnV0ZXMoKSwgYSA8PD0gNSwgYSB8PSBrLmdldFVUQ1NlY29uZHMoKSAvIDIsIG8gPSBrLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTgwLCBvIDw8PSA0LCBvIHw9IGsuZ2V0VVRDTW9udGgoKSArIDEsIG8gPDw9IDUsIG8gfD0gay5nZXRVVENEYXRlKCksIF8gJiYgKHYgPSBBKDEsIDEpICsgQShCKGYpLCA0KSArIGMsIGIgKz0gInVwIiArIEEodi5sZW5ndGgsIDIpICsgdiksIGcgJiYgKHkgPSBBKDEsIDEpICsgQShCKHApLCA0KSArIG0sIGIgKz0gInVjIiArIEEoeS5sZW5ndGgsIDIpICsgeSk7CiAgICAgICAgICB2YXIgRSA9ICIiOwogICAgICAgICAgcmV0dXJuIEUgKz0gIlxuXDAiLCBFICs9IEEoUywgMiksIEUgKz0gdS5tYWdpYywgRSArPSBBKGEsIDIpLCBFICs9IEEobywgMiksIEUgKz0gQSh4LmNyYzMyLCA0KSwgRSArPSBBKHguY29tcHJlc3NlZFNpemUsIDQpLCBFICs9IEEoeC51bmNvbXByZXNzZWRTaXplLCA0KSwgRSArPSBBKGYubGVuZ3RoLCAyKSwgRSArPSBBKGIubGVuZ3RoLCAyKSwgeyBmaWxlUmVjb3JkOiBSLkxPQ0FMX0ZJTEVfSEVBREVSICsgRSArIGYgKyBiLCBkaXJSZWNvcmQ6IFIuQ0VOVFJBTF9GSUxFX0hFQURFUiArIEEoQywgMikgKyBFICsgQShwLmxlbmd0aCwgMikgKyAiXDBcMFwwXDAiICsgQSh6LCA0KSArIEEobjIsIDQpICsgZiArIGIgKyBwIH07CiAgICAgICAgfQogICAgICAgIHZhciBJID0gZSgiLi4vdXRpbHMiKSwgaSA9IGUoIi4uL3N0cmVhbS9HZW5lcmljV29ya2VyIiksIE8gPSBlKCIuLi91dGY4IiksIEIgPSBlKCIuLi9jcmMzMiIpLCBSID0gZSgiLi4vc2lnbmF0dXJlIik7CiAgICAgICAgZnVuY3Rpb24gcyhlMiwgdDIsIHIyLCBuMikgewogICAgICAgICAgaS5jYWxsKHRoaXMsICJaaXBGaWxlV29ya2VyIiksIHRoaXMuYnl0ZXNXcml0dGVuID0gMCwgdGhpcy56aXBDb21tZW50ID0gdDIsIHRoaXMuemlwUGxhdGZvcm0gPSByMiwgdGhpcy5lbmNvZGVGaWxlTmFtZSA9IG4yLCB0aGlzLnN0cmVhbUZpbGVzID0gZTIsIHRoaXMuYWNjdW11bGF0ZSA9IGZhbHNlLCB0aGlzLmNvbnRlbnRCdWZmZXIgPSBbXSwgdGhpcy5kaXJSZWNvcmRzID0gW10sIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCA9IDAsIHRoaXMuZW50cmllc0NvdW50ID0gMCwgdGhpcy5jdXJyZW50RmlsZSA9IG51bGwsIHRoaXMuX3NvdXJjZXMgPSBbXTsKICAgICAgICB9CiAgICAgICAgSS5pbmhlcml0cyhzLCBpKSwgcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB2YXIgdDIgPSBlMi5tZXRhLnBlcmNlbnQgfHwgMCwgcjIgPSB0aGlzLmVudHJpZXNDb3VudCwgbjIgPSB0aGlzLl9zb3VyY2VzLmxlbmd0aDsKICAgICAgICAgIHRoaXMuYWNjdW11bGF0ZSA/IHRoaXMuY29udGVudEJ1ZmZlci5wdXNoKGUyKSA6ICh0aGlzLmJ5dGVzV3JpdHRlbiArPSBlMi5kYXRhLmxlbmd0aCwgaS5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIHsgZGF0YTogZTIuZGF0YSwgbWV0YTogeyBjdXJyZW50RmlsZTogdGhpcy5jdXJyZW50RmlsZSwgcGVyY2VudDogcjIgPyAodDIgKyAxMDAgKiAocjIgLSBuMiAtIDEpKSAvIHIyIDogMTAwIH0gfSkpOwogICAgICAgIH0sIHMucHJvdG90eXBlLm9wZW5lZFNvdXJjZSA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSB0aGlzLmJ5dGVzV3JpdHRlbiwgdGhpcy5jdXJyZW50RmlsZSA9IGUyLmZpbGUubmFtZTsKICAgICAgICAgIHZhciB0MiA9IHRoaXMuc3RyZWFtRmlsZXMgJiYgIWUyLmZpbGUuZGlyOwogICAgICAgICAgaWYgKHQyKSB7CiAgICAgICAgICAgIHZhciByMiA9IG4oZTIsIHQyLCBmYWxzZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTsKICAgICAgICAgICAgdGhpcy5wdXNoKHsgZGF0YTogcjIuZmlsZVJlY29yZCwgbWV0YTogeyBwZXJjZW50OiAwIH0gfSk7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRlID0gdHJ1ZTsKICAgICAgICB9LCBzLnByb3RvdHlwZS5jbG9zZWRTb3VyY2UgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgdGhpcy5hY2N1bXVsYXRlID0gZmFsc2U7CiAgICAgICAgICB2YXIgdDIgPSB0aGlzLnN0cmVhbUZpbGVzICYmICFlMi5maWxlLmRpciwgcjIgPSBuKGUyLCB0MiwgdHJ1ZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTsKICAgICAgICAgIGlmICh0aGlzLmRpclJlY29yZHMucHVzaChyMi5kaXJSZWNvcmQpLCB0MikKICAgICAgICAgICAgdGhpcy5wdXNoKHsgZGF0YTogZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgICByZXR1cm4gUi5EQVRBX0RFU0NSSVBUT1IgKyBBKGUzLmNyYzMyLCA0KSArIEEoZTMuY29tcHJlc3NlZFNpemUsIDQpICsgQShlMy51bmNvbXByZXNzZWRTaXplLCA0KTsKICAgICAgICAgICAgfShlMiksIG1ldGE6IHsgcGVyY2VudDogMTAwIH0gfSk7CiAgICAgICAgICBlbHNlCiAgICAgICAgICAgIGZvciAodGhpcy5wdXNoKHsgZGF0YTogcjIuZmlsZVJlY29yZCwgbWV0YTogeyBwZXJjZW50OiAwIH0gfSk7IHRoaXMuY29udGVudEJ1ZmZlci5sZW5ndGg7ICkKICAgICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jb250ZW50QnVmZmVyLnNoaWZ0KCkpOwogICAgICAgICAgdGhpcy5jdXJyZW50RmlsZSA9IG51bGw7CiAgICAgICAgfSwgcy5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHsKICAgICAgICAgIGZvciAodmFyIGUyID0gdGhpcy5ieXRlc1dyaXR0ZW4sIHQyID0gMDsgdDIgPCB0aGlzLmRpclJlY29yZHMubGVuZ3RoOyB0MisrKQogICAgICAgICAgICB0aGlzLnB1c2goeyBkYXRhOiB0aGlzLmRpclJlY29yZHNbdDJdLCBtZXRhOiB7IHBlcmNlbnQ6IDEwMCB9IH0pOwogICAgICAgICAgdmFyIHIyID0gdGhpcy5ieXRlc1dyaXR0ZW4gLSBlMiwgbjIgPSBmdW5jdGlvbihlMywgdDMsIHIzLCBuMywgaTIpIHsKICAgICAgICAgICAgdmFyIHMyID0gSS50cmFuc2Zvcm1Ubygic3RyaW5nIiwgaTIobjMpKTsKICAgICAgICAgICAgcmV0dXJuIFIuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EICsgIlwwXDBcMFwwIiArIEEoZTMsIDIpICsgQShlMywgMikgKyBBKHQzLCA0KSArIEEocjMsIDQpICsgQShzMi5sZW5ndGgsIDIpICsgczI7CiAgICAgICAgICB9KHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGgsIHIyLCBlMiwgdGhpcy56aXBDb21tZW50LCB0aGlzLmVuY29kZUZpbGVOYW1lKTsKICAgICAgICAgIHRoaXMucHVzaCh7IGRhdGE6IG4yLCBtZXRhOiB7IHBlcmNlbnQ6IDEwMCB9IH0pOwogICAgICAgIH0sIHMucHJvdG90eXBlLnByZXBhcmVOZXh0U291cmNlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICB0aGlzLnByZXZpb3VzID0gdGhpcy5fc291cmNlcy5zaGlmdCgpLCB0aGlzLm9wZW5lZFNvdXJjZSh0aGlzLnByZXZpb3VzLnN0cmVhbUluZm8pLCB0aGlzLmlzUGF1c2VkID8gdGhpcy5wcmV2aW91cy5wYXVzZSgpIDogdGhpcy5wcmV2aW91cy5yZXN1bWUoKTsKICAgICAgICB9LCBzLnByb3RvdHlwZS5yZWdpc3RlclByZXZpb3VzID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHRoaXMuX3NvdXJjZXMucHVzaChlMik7CiAgICAgICAgICB2YXIgdDIgPSB0aGlzOwogICAgICAgICAgcmV0dXJuIGUyLm9uKCJkYXRhIiwgZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgdDIucHJvY2Vzc0NodW5rKGUzKTsKICAgICAgICAgIH0pLCBlMi5vbigiZW5kIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHQyLmNsb3NlZFNvdXJjZSh0Mi5wcmV2aW91cy5zdHJlYW1JbmZvKSwgdDIuX3NvdXJjZXMubGVuZ3RoID8gdDIucHJlcGFyZU5leHRTb3VyY2UoKSA6IHQyLmVuZCgpOwogICAgICAgICAgfSksIGUyLm9uKCJlcnJvciIsIGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgIHQyLmVycm9yKGUzKTsKICAgICAgICAgIH0pLCB0aGlzOwogICAgICAgIH0sIHMucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuICEhaS5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykgJiYgKCF0aGlzLnByZXZpb3VzICYmIHRoaXMuX3NvdXJjZXMubGVuZ3RoID8gKHRoaXMucHJlcGFyZU5leHRTb3VyY2UoKSwgdHJ1ZSkgOiB0aGlzLnByZXZpb3VzIHx8IHRoaXMuX3NvdXJjZXMubGVuZ3RoIHx8IHRoaXMuZ2VuZXJhdGVkRXJyb3IgPyB2b2lkIDAgOiAodGhpcy5lbmQoKSwgdHJ1ZSkpOwogICAgICAgIH0sIHMucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHZhciB0MiA9IHRoaXMuX3NvdXJjZXM7CiAgICAgICAgICBpZiAoIWkucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZTIpKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICBmb3IgKHZhciByMiA9IDA7IHIyIDwgdDIubGVuZ3RoOyByMisrKQogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHQyW3IyXS5lcnJvcihlMik7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUzKSB7CiAgICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0sIHMucHJvdG90eXBlLmxvY2sgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIGkucHJvdG90eXBlLmxvY2suY2FsbCh0aGlzKTsKICAgICAgICAgIGZvciAodmFyIGUyID0gdGhpcy5fc291cmNlcywgdDIgPSAwOyB0MiA8IGUyLmxlbmd0aDsgdDIrKykKICAgICAgICAgICAgZTJbdDJdLmxvY2soKTsKICAgICAgICB9LCB0LmV4cG9ydHMgPSBzOwogICAgICB9LCB7ICIuLi9jcmMzMiI6IDQsICIuLi9zaWduYXR1cmUiOiAyMywgIi4uL3N0cmVhbS9HZW5lcmljV29ya2VyIjogMjgsICIuLi91dGY4IjogMzEsICIuLi91dGlscyI6IDMyIH1dLCA5OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciB1ID0gZSgiLi4vY29tcHJlc3Npb25zIiksIG4gPSBlKCIuL1ppcEZpbGVXb3JrZXIiKTsKICAgICAgICByLmdlbmVyYXRlV29ya2VyID0gZnVuY3Rpb24oZTIsIGEsIHQyKSB7CiAgICAgICAgICB2YXIgbyA9IG5ldyBuKGEuc3RyZWFtRmlsZXMsIHQyLCBhLnBsYXRmb3JtLCBhLmVuY29kZUZpbGVOYW1lKSwgaCA9IDA7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBlMi5mb3JFYWNoKGZ1bmN0aW9uKGUzLCB0MykgewogICAgICAgICAgICAgIGgrKzsKICAgICAgICAgICAgICB2YXIgcjIgPSBmdW5jdGlvbihlNCwgdDQpIHsKICAgICAgICAgICAgICAgIHZhciByMyA9IGU0IHx8IHQ0LCBuMyA9IHVbcjNdOwogICAgICAgICAgICAgICAgaWYgKCFuMykKICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHIzICsgIiBpcyBub3QgYSB2YWxpZCBjb21wcmVzc2lvbiBtZXRob2QgISIpOwogICAgICAgICAgICAgICAgcmV0dXJuIG4zOwogICAgICAgICAgICAgIH0odDMub3B0aW9ucy5jb21wcmVzc2lvbiwgYS5jb21wcmVzc2lvbiksIG4yID0gdDMub3B0aW9ucy5jb21wcmVzc2lvbk9wdGlvbnMgfHwgYS5jb21wcmVzc2lvbk9wdGlvbnMgfHwge30sIGkgPSB0My5kaXIsIHMgPSB0My5kYXRlOwogICAgICAgICAgICAgIHQzLl9jb21wcmVzc1dvcmtlcihyMiwgbjIpLndpdGhTdHJlYW1JbmZvKCJmaWxlIiwgeyBuYW1lOiBlMywgZGlyOiBpLCBkYXRlOiBzLCBjb21tZW50OiB0My5jb21tZW50IHx8ICIiLCB1bml4UGVybWlzc2lvbnM6IHQzLnVuaXhQZXJtaXNzaW9ucywgZG9zUGVybWlzc2lvbnM6IHQzLmRvc1Blcm1pc3Npb25zIH0pLnBpcGUobyk7CiAgICAgICAgICAgIH0pLCBvLmVudHJpZXNDb3VudCA9IGg7CiAgICAgICAgICB9IGNhdGNoIChlMykgewogICAgICAgICAgICBvLmVycm9yKGUzKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBvOwogICAgICAgIH07CiAgICAgIH0sIHsgIi4uL2NvbXByZXNzaW9ucyI6IDMsICIuL1ppcEZpbGVXb3JrZXIiOiA4IH1dLCAxMDogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICBmdW5jdGlvbiBuKCkgewogICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIG4pKQogICAgICAgICAgICByZXR1cm4gbmV3IG4oKTsKICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlRoZSBjb25zdHJ1Y3RvciB3aXRoIHBhcmFtZXRlcnMgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS4iKTsKICAgICAgICAgIHRoaXMuZmlsZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy5jb21tZW50ID0gbnVsbCwgdGhpcy5yb290ID0gIiIsIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIGUyID0gbmV3IG4oKTsKICAgICAgICAgICAgZm9yICh2YXIgdDIgaW4gdGhpcykKICAgICAgICAgICAgICAiZnVuY3Rpb24iICE9IHR5cGVvZiB0aGlzW3QyXSAmJiAoZTJbdDJdID0gdGhpc1t0Ml0pOwogICAgICAgICAgICByZXR1cm4gZTI7CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICAobi5wcm90b3R5cGUgPSBlKCIuL29iamVjdCIpKS5sb2FkQXN5bmMgPSBlKCIuL2xvYWQiKSwgbi5zdXBwb3J0ID0gZSgiLi9zdXBwb3J0IiksIG4uZGVmYXVsdHMgPSBlKCIuL2RlZmF1bHRzIiksIG4udmVyc2lvbiA9ICIzLjEwLjEiLCBuLmxvYWRBc3luYyA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgcmV0dXJuIG5ldyBuKCkubG9hZEFzeW5jKGUyLCB0Mik7CiAgICAgICAgfSwgbi5leHRlcm5hbCA9IGUoIi4vZXh0ZXJuYWwiKSwgdC5leHBvcnRzID0gbjsKICAgICAgfSwgeyAiLi9kZWZhdWx0cyI6IDUsICIuL2V4dGVybmFsIjogNiwgIi4vbG9hZCI6IDExLCAiLi9vYmplY3QiOiAxNSwgIi4vc3VwcG9ydCI6IDMwIH1dLCAxMTogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgdSA9IGUoIi4vdXRpbHMiKSwgaSA9IGUoIi4vZXh0ZXJuYWwiKSwgbiA9IGUoIi4vdXRmOCIpLCBzID0gZSgiLi96aXBFbnRyaWVzIiksIGEgPSBlKCIuL3N0cmVhbS9DcmMzMlByb2JlIiksIGwgPSBlKCIuL25vZGVqc1V0aWxzIik7CiAgICAgICAgZnVuY3Rpb24gZihuMikgewogICAgICAgICAgcmV0dXJuIG5ldyBpLlByb21pc2UoZnVuY3Rpb24oZTIsIHQyKSB7CiAgICAgICAgICAgIHZhciByMiA9IG4yLmRlY29tcHJlc3NlZC5nZXRDb250ZW50V29ya2VyKCkucGlwZShuZXcgYSgpKTsKICAgICAgICAgICAgcjIub24oImVycm9yIiwgZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgICB0MihlMyk7CiAgICAgICAgICAgIH0pLm9uKCJlbmQiLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICByMi5zdHJlYW1JbmZvLmNyYzMyICE9PSBuMi5kZWNvbXByZXNzZWQuY3JjMzIgPyB0MihuZXcgRXJyb3IoIkNvcnJ1cHRlZCB6aXAgOiBDUkMzMiBtaXNtYXRjaCIpKSA6IGUyKCk7CiAgICAgICAgICAgIH0pLnJlc3VtZSgpOwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uKGUyLCBvKSB7CiAgICAgICAgICB2YXIgaCA9IHRoaXM7CiAgICAgICAgICByZXR1cm4gbyA9IHUuZXh0ZW5kKG8gfHwge30sIHsgYmFzZTY0OiBmYWxzZSwgY2hlY2tDUkMzMjogZmFsc2UsIG9wdGltaXplZEJpbmFyeVN0cmluZzogZmFsc2UsIGNyZWF0ZUZvbGRlcnM6IGZhbHNlLCBkZWNvZGVGaWxlTmFtZTogbi51dGY4ZGVjb2RlIH0pLCBsLmlzTm9kZSAmJiBsLmlzU3RyZWFtKGUyKSA/IGkuUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCJKU1ppcCBjYW4ndCBhY2NlcHQgYSBzdHJlYW0gd2hlbiBsb2FkaW5nIGEgemlwIGZpbGUuIikpIDogdS5wcmVwYXJlQ29udGVudCgidGhlIGxvYWRlZCB6aXAgZmlsZSIsIGUyLCB0cnVlLCBvLm9wdGltaXplZEJpbmFyeVN0cmluZywgby5iYXNlNjQpLnRoZW4oZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgdmFyIHQyID0gbmV3IHMobyk7CiAgICAgICAgICAgIHJldHVybiB0Mi5sb2FkKGUzKSwgdDI7CiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgIHZhciB0MiA9IFtpLlByb21pc2UucmVzb2x2ZShlMyldLCByMiA9IGUzLmZpbGVzOwogICAgICAgICAgICBpZiAoby5jaGVja0NSQzMyKQogICAgICAgICAgICAgIGZvciAodmFyIG4yID0gMDsgbjIgPCByMi5sZW5ndGg7IG4yKyspCiAgICAgICAgICAgICAgICB0Mi5wdXNoKGYocjJbbjJdKSk7CiAgICAgICAgICAgIHJldHVybiBpLlByb21pc2UuYWxsKHQyKTsKICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgZm9yICh2YXIgdDIgPSBlMy5zaGlmdCgpLCByMiA9IHQyLmZpbGVzLCBuMiA9IDA7IG4yIDwgcjIubGVuZ3RoOyBuMisrKSB7CiAgICAgICAgICAgICAgdmFyIGkyID0gcjJbbjJdLCBzMiA9IGkyLmZpbGVOYW1lU3RyLCBhMiA9IHUucmVzb2x2ZShpMi5maWxlTmFtZVN0cik7CiAgICAgICAgICAgICAgaC5maWxlKGEyLCBpMi5kZWNvbXByZXNzZWQsIHsgYmluYXJ5OiB0cnVlLCBvcHRpbWl6ZWRCaW5hcnlTdHJpbmc6IHRydWUsIGRhdGU6IGkyLmRhdGUsIGRpcjogaTIuZGlyLCBjb21tZW50OiBpMi5maWxlQ29tbWVudFN0ci5sZW5ndGggPyBpMi5maWxlQ29tbWVudFN0ciA6IG51bGwsIHVuaXhQZXJtaXNzaW9uczogaTIudW5peFBlcm1pc3Npb25zLCBkb3NQZXJtaXNzaW9uczogaTIuZG9zUGVybWlzc2lvbnMsIGNyZWF0ZUZvbGRlcnM6IG8uY3JlYXRlRm9sZGVycyB9KSwgaTIuZGlyIHx8IChoLmZpbGUoYTIpLnVuc2FmZU9yaWdpbmFsTmFtZSA9IHMyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdDIuemlwQ29tbWVudC5sZW5ndGggJiYgKGguY29tbWVudCA9IHQyLnppcENvbW1lbnQpLCBoOwogICAgICAgICAgfSk7CiAgICAgICAgfTsKICAgICAgfSwgeyAiLi9leHRlcm5hbCI6IDYsICIuL25vZGVqc1V0aWxzIjogMTQsICIuL3N0cmVhbS9DcmMzMlByb2JlIjogMjUsICIuL3V0ZjgiOiAzMSwgIi4vdXRpbHMiOiAzMiwgIi4vemlwRW50cmllcyI6IDMzIH1dLCAxMjogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgbiA9IGUoIi4uL3V0aWxzIiksIGkgPSBlKCIuLi9zdHJlYW0vR2VuZXJpY1dvcmtlciIpOwogICAgICAgIGZ1bmN0aW9uIHMoZTIsIHQyKSB7CiAgICAgICAgICBpLmNhbGwodGhpcywgIk5vZGVqcyBzdHJlYW0gaW5wdXQgYWRhcHRlciBmb3IgIiArIGUyKSwgdGhpcy5fdXBzdHJlYW1FbmRlZCA9IGZhbHNlLCB0aGlzLl9iaW5kU3RyZWFtKHQyKTsKICAgICAgICB9CiAgICAgICAgbi5pbmhlcml0cyhzLCBpKSwgcy5wcm90b3R5cGUuX2JpbmRTdHJlYW0gPSBmdW5jdGlvbihlMikgewogICAgICAgICAgdmFyIHQyID0gdGhpczsKICAgICAgICAgICh0aGlzLl9zdHJlYW0gPSBlMikucGF1c2UoKSwgZTIub24oImRhdGEiLCBmdW5jdGlvbihlMykgewogICAgICAgICAgICB0Mi5wdXNoKHsgZGF0YTogZTMsIG1ldGE6IHsgcGVyY2VudDogMCB9IH0pOwogICAgICAgICAgfSkub24oImVycm9yIiwgZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgdDIuaXNQYXVzZWQgPyB0aGlzLmdlbmVyYXRlZEVycm9yID0gZTMgOiB0Mi5lcnJvcihlMyk7CiAgICAgICAgICB9KS5vbigiZW5kIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHQyLmlzUGF1c2VkID8gdDIuX3Vwc3RyZWFtRW5kZWQgPSB0cnVlIDogdDIuZW5kKCk7CiAgICAgICAgICB9KTsKICAgICAgICB9LCBzLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuICEhaS5wcm90b3R5cGUucGF1c2UuY2FsbCh0aGlzKSAmJiAodGhpcy5fc3RyZWFtLnBhdXNlKCksIHRydWUpOwogICAgICAgIH0sIHMucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuICEhaS5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykgJiYgKHRoaXMuX3Vwc3RyZWFtRW5kZWQgPyB0aGlzLmVuZCgpIDogdGhpcy5fc3RyZWFtLnJlc3VtZSgpLCB0cnVlKTsKICAgICAgICB9LCB0LmV4cG9ydHMgPSBzOwogICAgICB9LCB7ICIuLi9zdHJlYW0vR2VuZXJpY1dvcmtlciI6IDI4LCAiLi4vdXRpbHMiOiAzMiB9XSwgMTM6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIGkgPSBlKCJyZWFkYWJsZS1zdHJlYW0iKS5SZWFkYWJsZTsKICAgICAgICBmdW5jdGlvbiBuKGUyLCB0MiwgcjIpIHsKICAgICAgICAgIGkuY2FsbCh0aGlzLCB0MiksIHRoaXMuX2hlbHBlciA9IGUyOwogICAgICAgICAgdmFyIG4yID0gdGhpczsKICAgICAgICAgIGUyLm9uKCJkYXRhIiwgZnVuY3Rpb24oZTMsIHQzKSB7CiAgICAgICAgICAgIG4yLnB1c2goZTMpIHx8IG4yLl9oZWxwZXIucGF1c2UoKSwgcjIgJiYgcjIodDMpOwogICAgICAgICAgfSkub24oImVycm9yIiwgZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgbjIuZW1pdCgiZXJyb3IiLCBlMyk7CiAgICAgICAgICB9KS5vbigiZW5kIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIG4yLnB1c2gobnVsbCk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgZSgiLi4vdXRpbHMiKS5pbmhlcml0cyhuLCBpKSwgbi5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHRoaXMuX2hlbHBlci5yZXN1bWUoKTsKICAgICAgICB9LCB0LmV4cG9ydHMgPSBuOwogICAgICB9LCB7ICIuLi91dGlscyI6IDMyLCAicmVhZGFibGUtc3RyZWFtIjogMTYgfV0sIDE0OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHQuZXhwb3J0cyA9IHsgaXNOb2RlOiAidW5kZWZpbmVkIiAhPSB0eXBlb2YgQnVmZmVyLCBuZXdCdWZmZXJGcm9tOiBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIGlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tKQogICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZTIsIHQyKTsKICAgICAgICAgIGlmICgibnVtYmVyIiA9PSB0eXBlb2YgZTIpCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlICJkYXRhIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpOwogICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZTIsIHQyKTsKICAgICAgICB9LCBhbGxvY0J1ZmZlcjogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGlmIChCdWZmZXIuYWxsb2MpCiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoZTIpOwogICAgICAgICAgdmFyIHQyID0gbmV3IEJ1ZmZlcihlMik7CiAgICAgICAgICByZXR1cm4gdDIuZmlsbCgwKSwgdDI7CiAgICAgICAgfSwgaXNCdWZmZXI6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGUyKTsKICAgICAgICB9LCBpc1N0cmVhbTogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiBlMiAmJiAiZnVuY3Rpb24iID09IHR5cGVvZiBlMi5vbiAmJiAiZnVuY3Rpb24iID09IHR5cGVvZiBlMi5wYXVzZSAmJiAiZnVuY3Rpb24iID09IHR5cGVvZiBlMi5yZXN1bWU7CiAgICAgICAgfSB9OwogICAgICB9LCB7fV0sIDE1OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIGZ1bmN0aW9uIHMoZTIsIHQyLCByMikgewogICAgICAgICAgdmFyIG4yLCBpMiA9IHUuZ2V0VHlwZU9mKHQyKSwgczIgPSB1LmV4dGVuZChyMiB8fCB7fSwgZik7CiAgICAgICAgICBzMi5kYXRlID0gczIuZGF0ZSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgbnVsbCAhPT0gczIuY29tcHJlc3Npb24gJiYgKHMyLmNvbXByZXNzaW9uID0gczIuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKSksICJzdHJpbmciID09IHR5cGVvZiBzMi51bml4UGVybWlzc2lvbnMgJiYgKHMyLnVuaXhQZXJtaXNzaW9ucyA9IHBhcnNlSW50KHMyLnVuaXhQZXJtaXNzaW9ucywgOCkpLCBzMi51bml4UGVybWlzc2lvbnMgJiYgMTYzODQgJiBzMi51bml4UGVybWlzc2lvbnMgJiYgKHMyLmRpciA9IHRydWUpLCBzMi5kb3NQZXJtaXNzaW9ucyAmJiAxNiAmIHMyLmRvc1Blcm1pc3Npb25zICYmIChzMi5kaXIgPSB0cnVlKSwgczIuZGlyICYmIChlMiA9IGcoZTIpKSwgczIuY3JlYXRlRm9sZGVycyAmJiAobjIgPSBfKGUyKSkgJiYgYi5jYWxsKHRoaXMsIG4yLCB0cnVlKTsKICAgICAgICAgIHZhciBhMiA9ICJzdHJpbmciID09PSBpMiAmJiBmYWxzZSA9PT0gczIuYmluYXJ5ICYmIGZhbHNlID09PSBzMi5iYXNlNjQ7CiAgICAgICAgICByMiAmJiB2b2lkIDAgIT09IHIyLmJpbmFyeSB8fCAoczIuYmluYXJ5ID0gIWEyKSwgKHQyIGluc3RhbmNlb2YgYyAmJiAwID09PSB0Mi51bmNvbXByZXNzZWRTaXplIHx8IHMyLmRpciB8fCAhdDIgfHwgMCA9PT0gdDIubGVuZ3RoKSAmJiAoczIuYmFzZTY0ID0gZmFsc2UsIHMyLmJpbmFyeSA9IHRydWUsIHQyID0gIiIsIHMyLmNvbXByZXNzaW9uID0gIlNUT1JFIiwgaTIgPSAic3RyaW5nIik7CiAgICAgICAgICB2YXIgbzIgPSBudWxsOwogICAgICAgICAgbzIgPSB0MiBpbnN0YW5jZW9mIGMgfHwgdDIgaW5zdGFuY2VvZiBsID8gdDIgOiBwLmlzTm9kZSAmJiBwLmlzU3RyZWFtKHQyKSA/IG5ldyBtKGUyLCB0MikgOiB1LnByZXBhcmVDb250ZW50KGUyLCB0MiwgczIuYmluYXJ5LCBzMi5vcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIHMyLmJhc2U2NCk7CiAgICAgICAgICB2YXIgaDIgPSBuZXcgZChlMiwgbzIsIHMyKTsKICAgICAgICAgIHRoaXMuZmlsZXNbZTJdID0gaDI7CiAgICAgICAgfQogICAgICAgIHZhciBpID0gZSgiLi91dGY4IiksIHUgPSBlKCIuL3V0aWxzIiksIGwgPSBlKCIuL3N0cmVhbS9HZW5lcmljV29ya2VyIiksIGEgPSBlKCIuL3N0cmVhbS9TdHJlYW1IZWxwZXIiKSwgZiA9IGUoIi4vZGVmYXVsdHMiKSwgYyA9IGUoIi4vY29tcHJlc3NlZE9iamVjdCIpLCBkID0gZSgiLi96aXBPYmplY3QiKSwgbyA9IGUoIi4vZ2VuZXJhdGUiKSwgcCA9IGUoIi4vbm9kZWpzVXRpbHMiKSwgbSA9IGUoIi4vbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlciIpLCBfID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgICIvIiA9PT0gZTIuc2xpY2UoLTEpICYmIChlMiA9IGUyLnN1YnN0cmluZygwLCBlMi5sZW5ndGggLSAxKSk7CiAgICAgICAgICB2YXIgdDIgPSBlMi5sYXN0SW5kZXhPZigiLyIpOwogICAgICAgICAgcmV0dXJuIDAgPCB0MiA/IGUyLnN1YnN0cmluZygwLCB0MikgOiAiIjsKICAgICAgICB9LCBnID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiAiLyIgIT09IGUyLnNsaWNlKC0xKSAmJiAoZTIgKz0gIi8iKSwgZTI7CiAgICAgICAgfSwgYiA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgcmV0dXJuIHQyID0gdm9pZCAwICE9PSB0MiA/IHQyIDogZi5jcmVhdGVGb2xkZXJzLCBlMiA9IGcoZTIpLCB0aGlzLmZpbGVzW2UyXSB8fCBzLmNhbGwodGhpcywgZTIsIG51bGwsIHsgZGlyOiB0cnVlLCBjcmVhdGVGb2xkZXJzOiB0MiB9KSwgdGhpcy5maWxlc1tlMl07CiAgICAgICAgfTsKICAgICAgICBmdW5jdGlvbiBoKGUyKSB7CiAgICAgICAgICByZXR1cm4gIltvYmplY3QgUmVnRXhwXSIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlMik7CiAgICAgICAgfQogICAgICAgIHZhciBuID0geyBsb2FkOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS4iKTsKICAgICAgICB9LCBmb3JFYWNoOiBmdW5jdGlvbihlMikgewogICAgICAgICAgdmFyIHQyLCByMiwgbjI7CiAgICAgICAgICBmb3IgKHQyIGluIHRoaXMuZmlsZXMpCiAgICAgICAgICAgIG4yID0gdGhpcy5maWxlc1t0Ml0sIChyMiA9IHQyLnNsaWNlKHRoaXMucm9vdC5sZW5ndGgsIHQyLmxlbmd0aCkpICYmIHQyLnNsaWNlKDAsIHRoaXMucm9vdC5sZW5ndGgpID09PSB0aGlzLnJvb3QgJiYgZTIocjIsIG4yKTsKICAgICAgICB9LCBmaWx0ZXI6IGZ1bmN0aW9uKHIyKSB7CiAgICAgICAgICB2YXIgbjIgPSBbXTsKICAgICAgICAgIHJldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24oZTIsIHQyKSB7CiAgICAgICAgICAgIHIyKGUyLCB0MikgJiYgbjIucHVzaCh0Mik7CiAgICAgICAgICB9KSwgbjI7CiAgICAgICAgfSwgZmlsZTogZnVuY3Rpb24oZTIsIHQyLCByMikgewogICAgICAgICAgaWYgKDEgIT09IGFyZ3VtZW50cy5sZW5ndGgpCiAgICAgICAgICAgIHJldHVybiBlMiA9IHRoaXMucm9vdCArIGUyLCBzLmNhbGwodGhpcywgZTIsIHQyLCByMiksIHRoaXM7CiAgICAgICAgICBpZiAoaChlMikpIHsKICAgICAgICAgICAgdmFyIG4yID0gZTI7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihlMywgdDMpIHsKICAgICAgICAgICAgICByZXR1cm4gIXQzLmRpciAmJiBuMi50ZXN0KGUzKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgaTIgPSB0aGlzLmZpbGVzW3RoaXMucm9vdCArIGUyXTsKICAgICAgICAgIHJldHVybiBpMiAmJiAhaTIuZGlyID8gaTIgOiBudWxsOwogICAgICAgIH0sIGZvbGRlcjogZnVuY3Rpb24ocjIpIHsKICAgICAgICAgIGlmICghcjIpCiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgaWYgKGgocjIpKQogICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oZTMsIHQzKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHQzLmRpciAmJiByMi50ZXN0KGUzKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB2YXIgZTIgPSB0aGlzLnJvb3QgKyByMiwgdDIgPSBiLmNhbGwodGhpcywgZTIpLCBuMiA9IHRoaXMuY2xvbmUoKTsKICAgICAgICAgIHJldHVybiBuMi5yb290ID0gdDIubmFtZSwgbjI7CiAgICAgICAgfSwgcmVtb3ZlOiBmdW5jdGlvbihyMikgewogICAgICAgICAgcjIgPSB0aGlzLnJvb3QgKyByMjsKICAgICAgICAgIHZhciBlMiA9IHRoaXMuZmlsZXNbcjJdOwogICAgICAgICAgaWYgKGUyIHx8ICgiLyIgIT09IHIyLnNsaWNlKC0xKSAmJiAocjIgKz0gIi8iKSwgZTIgPSB0aGlzLmZpbGVzW3IyXSksIGUyICYmICFlMi5kaXIpCiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW3IyXTsKICAgICAgICAgIGVsc2UKICAgICAgICAgICAgZm9yICh2YXIgdDIgPSB0aGlzLmZpbHRlcihmdW5jdGlvbihlMywgdDMpIHsKICAgICAgICAgICAgICByZXR1cm4gdDMubmFtZS5zbGljZSgwLCByMi5sZW5ndGgpID09PSByMjsKICAgICAgICAgICAgfSksIG4yID0gMDsgbjIgPCB0Mi5sZW5ndGg7IG4yKyspCiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNbdDJbbjJdLm5hbWVdOwogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfSwgZ2VuZXJhdGU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLiIpOwogICAgICAgIH0sIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW06IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB2YXIgdDIsIHIyID0ge307CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoKHIyID0gdS5leHRlbmQoZTIgfHwge30sIHsgc3RyZWFtRmlsZXM6IGZhbHNlLCBjb21wcmVzc2lvbjogIlNUT1JFIiwgY29tcHJlc3Npb25PcHRpb25zOiBudWxsLCB0eXBlOiAiIiwgcGxhdGZvcm06ICJET1MiLCBjb21tZW50OiBudWxsLCBtaW1lVHlwZTogImFwcGxpY2F0aW9uL3ppcCIsIGVuY29kZUZpbGVOYW1lOiBpLnV0ZjhlbmNvZGUgfSkpLnR5cGUgPSByMi50eXBlLnRvTG93ZXJDYXNlKCksIHIyLmNvbXByZXNzaW9uID0gcjIuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKSwgImJpbmFyeXN0cmluZyIgPT09IHIyLnR5cGUgJiYgKHIyLnR5cGUgPSAic3RyaW5nIiksICFyMi50eXBlKQogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLiIpOwogICAgICAgICAgICB1LmNoZWNrU3VwcG9ydChyMi50eXBlKSwgImRhcndpbiIgIT09IHIyLnBsYXRmb3JtICYmICJmcmVlYnNkIiAhPT0gcjIucGxhdGZvcm0gJiYgImxpbnV4IiAhPT0gcjIucGxhdGZvcm0gJiYgInN1bm9zIiAhPT0gcjIucGxhdGZvcm0gfHwgKHIyLnBsYXRmb3JtID0gIlVOSVgiKSwgIndpbjMyIiA9PT0gcjIucGxhdGZvcm0gJiYgKHIyLnBsYXRmb3JtID0gIkRPUyIpOwogICAgICAgICAgICB2YXIgbjIgPSByMi5jb21tZW50IHx8IHRoaXMuY29tbWVudCB8fCAiIjsKICAgICAgICAgICAgdDIgPSBvLmdlbmVyYXRlV29ya2VyKHRoaXMsIHIyLCBuMik7CiAgICAgICAgICB9IGNhdGNoIChlMykgewogICAgICAgICAgICAodDIgPSBuZXcgbCgiZXJyb3IiKSkuZXJyb3IoZTMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG5ldyBhKHQyLCByMi50eXBlIHx8ICJzdHJpbmciLCByMi5taW1lVHlwZSk7CiAgICAgICAgfSwgZ2VuZXJhdGVBc3luYzogZnVuY3Rpb24oZTIsIHQyKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKGUyKS5hY2N1bXVsYXRlKHQyKTsKICAgICAgICB9LCBnZW5lcmF0ZU5vZGVTdHJlYW06IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgcmV0dXJuIChlMiA9IGUyIHx8IHt9KS50eXBlIHx8IChlMi50eXBlID0gIm5vZGVidWZmZXIiKSwgdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKGUyKS50b05vZGVqc1N0cmVhbSh0Mik7CiAgICAgICAgfSB9OwogICAgICAgIHQuZXhwb3J0cyA9IG47CiAgICAgIH0sIHsgIi4vY29tcHJlc3NlZE9iamVjdCI6IDIsICIuL2RlZmF1bHRzIjogNSwgIi4vZ2VuZXJhdGUiOiA5LCAiLi9ub2RlanMvTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyIjogMTIsICIuL25vZGVqc1V0aWxzIjogMTQsICIuL3N0cmVhbS9HZW5lcmljV29ya2VyIjogMjgsICIuL3N0cmVhbS9TdHJlYW1IZWxwZXIiOiAyOSwgIi4vdXRmOCI6IDMxLCAiLi91dGlscyI6IDMyLCAiLi96aXBPYmplY3QiOiAzNSB9XSwgMTY6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdC5leHBvcnRzID0gZSgic3RyZWFtIik7CiAgICAgIH0sIHsgc3RyZWFtOiB2b2lkIDAgfV0sIDE3OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBuID0gZSgiLi9EYXRhUmVhZGVyIik7CiAgICAgICAgZnVuY3Rpb24gaShlMikgewogICAgICAgICAgbi5jYWxsKHRoaXMsIGUyKTsKICAgICAgICAgIGZvciAodmFyIHQyID0gMDsgdDIgPCB0aGlzLmRhdGEubGVuZ3RoOyB0MisrKQogICAgICAgICAgICBlMlt0Ml0gPSAyNTUgJiBlMlt0Ml07CiAgICAgICAgfQogICAgICAgIGUoIi4uL3V0aWxzIikuaW5oZXJpdHMoaSwgbiksIGkucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuemVybyArIGUyXTsKICAgICAgICB9LCBpLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICBmb3IgKHZhciB0MiA9IGUyLmNoYXJDb2RlQXQoMCksIHIyID0gZTIuY2hhckNvZGVBdCgxKSwgbjIgPSBlMi5jaGFyQ29kZUF0KDIpLCBpMiA9IGUyLmNoYXJDb2RlQXQoMyksIHMgPSB0aGlzLmxlbmd0aCAtIDQ7IDAgPD0gczsgLS1zKQogICAgICAgICAgICBpZiAodGhpcy5kYXRhW3NdID09PSB0MiAmJiB0aGlzLmRhdGFbcyArIDFdID09PSByMiAmJiB0aGlzLmRhdGFbcyArIDJdID09PSBuMiAmJiB0aGlzLmRhdGFbcyArIDNdID09PSBpMikKICAgICAgICAgICAgICByZXR1cm4gcyAtIHRoaXMuemVybzsKICAgICAgICAgIHJldHVybiAtMTsKICAgICAgICB9LCBpLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgdmFyIHQyID0gZTIuY2hhckNvZGVBdCgwKSwgcjIgPSBlMi5jaGFyQ29kZUF0KDEpLCBuMiA9IGUyLmNoYXJDb2RlQXQoMiksIGkyID0gZTIuY2hhckNvZGVBdCgzKSwgcyA9IHRoaXMucmVhZERhdGEoNCk7CiAgICAgICAgICByZXR1cm4gdDIgPT09IHNbMF0gJiYgcjIgPT09IHNbMV0gJiYgbjIgPT09IHNbMl0gJiYgaTIgPT09IHNbM107CiAgICAgICAgfSwgaS5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgaWYgKHRoaXMuY2hlY2tPZmZzZXQoZTIpLCAwID09PSBlMikKICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgdmFyIHQyID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBlMik7CiAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCArPSBlMiwgdDI7CiAgICAgICAgfSwgdC5leHBvcnRzID0gaTsKICAgICAgfSwgeyAiLi4vdXRpbHMiOiAzMiwgIi4vRGF0YVJlYWRlciI6IDE4IH1dLCAxODogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgbiA9IGUoIi4uL3V0aWxzIik7CiAgICAgICAgZnVuY3Rpb24gaShlMikgewogICAgICAgICAgdGhpcy5kYXRhID0gZTIsIHRoaXMubGVuZ3RoID0gZTIubGVuZ3RoLCB0aGlzLmluZGV4ID0gMCwgdGhpcy56ZXJvID0gMDsKICAgICAgICB9CiAgICAgICAgaS5wcm90b3R5cGUgPSB7IGNoZWNrT2Zmc2V0OiBmdW5jdGlvbihlMikgewogICAgICAgICAgdGhpcy5jaGVja0luZGV4KHRoaXMuaW5kZXggKyBlMik7CiAgICAgICAgfSwgY2hlY2tJbmRleDogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IHRoaXMuemVybyArIGUyIHx8IGUyIDwgMCkKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJFbmQgb2YgZGF0YSByZWFjaGVkIChkYXRhIGxlbmd0aCA9ICIgKyB0aGlzLmxlbmd0aCArICIsIGFza2VkIGluZGV4ID0gIiArIGUyICsgIikuIENvcnJ1cHRlZCB6aXAgPyIpOwogICAgICAgIH0sIHNldEluZGV4OiBmdW5jdGlvbihlMikgewogICAgICAgICAgdGhpcy5jaGVja0luZGV4KGUyKSwgdGhpcy5pbmRleCA9IGUyOwogICAgICAgIH0sIHNraXA6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB0aGlzLnNldEluZGV4KHRoaXMuaW5kZXggKyBlMik7CiAgICAgICAgfSwgYnl0ZUF0OiBmdW5jdGlvbigpIHsKICAgICAgICB9LCByZWFkSW50OiBmdW5jdGlvbihlMikgewogICAgICAgICAgdmFyIHQyLCByMiA9IDA7CiAgICAgICAgICBmb3IgKHRoaXMuY2hlY2tPZmZzZXQoZTIpLCB0MiA9IHRoaXMuaW5kZXggKyBlMiAtIDE7IHQyID49IHRoaXMuaW5kZXg7IHQyLS0pCiAgICAgICAgICAgIHIyID0gKHIyIDw8IDgpICsgdGhpcy5ieXRlQXQodDIpOwogICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggKz0gZTIsIHIyOwogICAgICAgIH0sIHJlYWRTdHJpbmc6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICByZXR1cm4gbi50cmFuc2Zvcm1Ubygic3RyaW5nIiwgdGhpcy5yZWFkRGF0YShlMikpOwogICAgICAgIH0sIHJlYWREYXRhOiBmdW5jdGlvbigpIHsKICAgICAgICB9LCBsYXN0SW5kZXhPZlNpZ25hdHVyZTogZnVuY3Rpb24oKSB7CiAgICAgICAgfSwgcmVhZEFuZENoZWNrU2lnbmF0dXJlOiBmdW5jdGlvbigpIHsKICAgICAgICB9LCByZWFkRGF0ZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgZTIgPSB0aGlzLnJlYWRJbnQoNCk7CiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk4MCArIChlMiA+PiAyNSAmIDEyNyksIChlMiA+PiAyMSAmIDE1KSAtIDEsIGUyID4+IDE2ICYgMzEsIGUyID4+IDExICYgMzEsIGUyID4+IDUgJiA2MywgKDMxICYgZTIpIDw8IDEpKTsKICAgICAgICB9IH0sIHQuZXhwb3J0cyA9IGk7CiAgICAgIH0sIHsgIi4uL3V0aWxzIjogMzIgfV0sIDE5OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBuID0gZSgiLi9VaW50OEFycmF5UmVhZGVyIik7CiAgICAgICAgZnVuY3Rpb24gaShlMikgewogICAgICAgICAgbi5jYWxsKHRoaXMsIGUyKTsKICAgICAgICB9CiAgICAgICAgZSgiLi4vdXRpbHMiKS5pbmhlcml0cyhpLCBuKSwgaS5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgdGhpcy5jaGVja09mZnNldChlMik7CiAgICAgICAgICB2YXIgdDIgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIGUyKTsKICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4ICs9IGUyLCB0MjsKICAgICAgICB9LCB0LmV4cG9ydHMgPSBpOwogICAgICB9LCB7ICIuLi91dGlscyI6IDMyLCAiLi9VaW50OEFycmF5UmVhZGVyIjogMjEgfV0sIDIwOiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBuID0gZSgiLi9EYXRhUmVhZGVyIik7CiAgICAgICAgZnVuY3Rpb24gaShlMikgewogICAgICAgICAgbi5jYWxsKHRoaXMsIGUyKTsKICAgICAgICB9CiAgICAgICAgZSgiLi4vdXRpbHMiKS5pbmhlcml0cyhpLCBuKSwgaS5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnplcm8gKyBlMik7CiAgICAgICAgfSwgaS5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sYXN0SW5kZXhPZihlMikgLSB0aGlzLnplcm87CiAgICAgICAgfSwgaS5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiBlMiA9PT0gdGhpcy5yZWFkRGF0YSg0KTsKICAgICAgICB9LCBpLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KGUyKTsKICAgICAgICAgIHZhciB0MiA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgZTIpOwogICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggKz0gZTIsIHQyOwogICAgICAgIH0sIHQuZXhwb3J0cyA9IGk7CiAgICAgIH0sIHsgIi4uL3V0aWxzIjogMzIsICIuL0RhdGFSZWFkZXIiOiAxOCB9XSwgMjE6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIG4gPSBlKCIuL0FycmF5UmVhZGVyIik7CiAgICAgICAgZnVuY3Rpb24gaShlMikgewogICAgICAgICAgbi5jYWxsKHRoaXMsIGUyKTsKICAgICAgICB9CiAgICAgICAgZSgiLi4vdXRpbHMiKS5pbmhlcml0cyhpLCBuKSwgaS5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgaWYgKHRoaXMuY2hlY2tPZmZzZXQoZTIpLCAwID09PSBlMikKICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApOwogICAgICAgICAgdmFyIHQyID0gdGhpcy5kYXRhLnN1YmFycmF5KHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBlMik7CiAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCArPSBlMiwgdDI7CiAgICAgICAgfSwgdC5leHBvcnRzID0gaTsKICAgICAgfSwgeyAiLi4vdXRpbHMiOiAzMiwgIi4vQXJyYXlSZWFkZXIiOiAxNyB9XSwgMjI6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIG4gPSBlKCIuLi91dGlscyIpLCBpID0gZSgiLi4vc3VwcG9ydCIpLCBzID0gZSgiLi9BcnJheVJlYWRlciIpLCBhID0gZSgiLi9TdHJpbmdSZWFkZXIiKSwgbyA9IGUoIi4vTm9kZUJ1ZmZlclJlYWRlciIpLCBoID0gZSgiLi9VaW50OEFycmF5UmVhZGVyIik7CiAgICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHZhciB0MiA9IG4uZ2V0VHlwZU9mKGUyKTsKICAgICAgICAgIHJldHVybiBuLmNoZWNrU3VwcG9ydCh0MiksICJzdHJpbmciICE9PSB0MiB8fCBpLnVpbnQ4YXJyYXkgPyAibm9kZWJ1ZmZlciIgPT09IHQyID8gbmV3IG8oZTIpIDogaS51aW50OGFycmF5ID8gbmV3IGgobi50cmFuc2Zvcm1UbygidWludDhhcnJheSIsIGUyKSkgOiBuZXcgcyhuLnRyYW5zZm9ybVRvKCJhcnJheSIsIGUyKSkgOiBuZXcgYShlMik7CiAgICAgICAgfTsKICAgICAgfSwgeyAiLi4vc3VwcG9ydCI6IDMwLCAiLi4vdXRpbHMiOiAzMiwgIi4vQXJyYXlSZWFkZXIiOiAxNywgIi4vTm9kZUJ1ZmZlclJlYWRlciI6IDE5LCAiLi9TdHJpbmdSZWFkZXIiOiAyMCwgIi4vVWludDhBcnJheVJlYWRlciI6IDIxIH1dLCAyMzogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICByLkxPQ0FMX0ZJTEVfSEVBREVSID0gIlBLAwQiLCByLkNFTlRSQUxfRklMRV9IRUFERVIgPSAiUEsBAiIsIHIuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gIlBLBQYiLCByLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IgPSAiUEsGXHgwNyIsIHIuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gIlBLBgYiLCByLkRBVEFfREVTQ1JJUFRPUiA9ICJQS1x4MDdcYiI7CiAgICAgIH0sIHt9XSwgMjQ6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIG4gPSBlKCIuL0dlbmVyaWNXb3JrZXIiKSwgaSA9IGUoIi4uL3V0aWxzIik7CiAgICAgICAgZnVuY3Rpb24gcyhlMikgewogICAgICAgICAgbi5jYWxsKHRoaXMsICJDb252ZXJ0V29ya2VyIHRvICIgKyBlMiksIHRoaXMuZGVzdFR5cGUgPSBlMjsKICAgICAgICB9CiAgICAgICAgaS5pbmhlcml0cyhzLCBuKSwgcy5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHRoaXMucHVzaCh7IGRhdGE6IGkudHJhbnNmb3JtVG8odGhpcy5kZXN0VHlwZSwgZTIuZGF0YSksIG1ldGE6IGUyLm1ldGEgfSk7CiAgICAgICAgfSwgdC5leHBvcnRzID0gczsKICAgICAgfSwgeyAiLi4vdXRpbHMiOiAzMiwgIi4vR2VuZXJpY1dvcmtlciI6IDI4IH1dLCAyNTogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgbiA9IGUoIi4vR2VuZXJpY1dvcmtlciIpLCBpID0gZSgiLi4vY3JjMzIiKTsKICAgICAgICBmdW5jdGlvbiBzKCkgewogICAgICAgICAgbi5jYWxsKHRoaXMsICJDcmMzMlByb2JlIiksIHRoaXMud2l0aFN0cmVhbUluZm8oImNyYzMyIiwgMCk7CiAgICAgICAgfQogICAgICAgIGUoIi4uL3V0aWxzIikuaW5oZXJpdHMocywgbiksIHMucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB0aGlzLnN0cmVhbUluZm8uY3JjMzIgPSBpKGUyLmRhdGEsIHRoaXMuc3RyZWFtSW5mby5jcmMzMiB8fCAwKSwgdGhpcy5wdXNoKGUyKTsKICAgICAgICB9LCB0LmV4cG9ydHMgPSBzOwogICAgICB9LCB7ICIuLi9jcmMzMiI6IDQsICIuLi91dGlscyI6IDMyLCAiLi9HZW5lcmljV29ya2VyIjogMjggfV0sIDI2OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBuID0gZSgiLi4vdXRpbHMiKSwgaSA9IGUoIi4vR2VuZXJpY1dvcmtlciIpOwogICAgICAgIGZ1bmN0aW9uIHMoZTIpIHsKICAgICAgICAgIGkuY2FsbCh0aGlzLCAiRGF0YUxlbmd0aFByb2JlIGZvciAiICsgZTIpLCB0aGlzLnByb3BOYW1lID0gZTIsIHRoaXMud2l0aFN0cmVhbUluZm8oZTIsIDApOwogICAgICAgIH0KICAgICAgICBuLmluaGVyaXRzKHMsIGkpLCBzLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgaWYgKGUyKSB7CiAgICAgICAgICAgIHZhciB0MiA9IHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSB8fCAwOwogICAgICAgICAgICB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gPSB0MiArIGUyLmRhdGEubGVuZ3RoOwogICAgICAgICAgfQogICAgICAgICAgaS5wcm90b3R5cGUucHJvY2Vzc0NodW5rLmNhbGwodGhpcywgZTIpOwogICAgICAgIH0sIHQuZXhwb3J0cyA9IHM7CiAgICAgIH0sIHsgIi4uL3V0aWxzIjogMzIsICIuL0dlbmVyaWNXb3JrZXIiOiAyOCB9XSwgMjc6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIG4gPSBlKCIuLi91dGlscyIpLCBpID0gZSgiLi9HZW5lcmljV29ya2VyIik7CiAgICAgICAgZnVuY3Rpb24gcyhlMikgewogICAgICAgICAgaS5jYWxsKHRoaXMsICJEYXRhV29ya2VyIik7CiAgICAgICAgICB2YXIgdDIgPSB0aGlzOwogICAgICAgICAgdGhpcy5kYXRhSXNSZWFkeSA9IGZhbHNlLCB0aGlzLmluZGV4ID0gMCwgdGhpcy5tYXggPSAwLCB0aGlzLmRhdGEgPSBudWxsLCB0aGlzLnR5cGUgPSAiIiwgdGhpcy5fdGlja1NjaGVkdWxlZCA9IGZhbHNlLCBlMi50aGVuKGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgIHQyLmRhdGFJc1JlYWR5ID0gdHJ1ZSwgdDIuZGF0YSA9IGUzLCB0Mi5tYXggPSBlMyAmJiBlMy5sZW5ndGggfHwgMCwgdDIudHlwZSA9IG4uZ2V0VHlwZU9mKGUzKSwgdDIuaXNQYXVzZWQgfHwgdDIuX3RpY2tBbmRSZXBlYXQoKTsKICAgICAgICAgIH0sIGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgIHQyLmVycm9yKGUzKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBuLmluaGVyaXRzKHMsIGkpLCBzLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICBpLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyksIHRoaXMuZGF0YSA9IG51bGw7CiAgICAgICAgfSwgcy5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gISFpLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSAmJiAoIXRoaXMuX3RpY2tTY2hlZHVsZWQgJiYgdGhpcy5kYXRhSXNSZWFkeSAmJiAodGhpcy5fdGlja1NjaGVkdWxlZCA9IHRydWUsIG4uZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCwgW10sIHRoaXMpKSwgdHJ1ZSk7CiAgICAgICAgfSwgcy5wcm90b3R5cGUuX3RpY2tBbmRSZXBlYXQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSBmYWxzZSwgdGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQgfHwgKHRoaXMuX3RpY2soKSwgdGhpcy5pc0ZpbmlzaGVkIHx8IChuLmRlbGF5KHRoaXMuX3RpY2tBbmRSZXBlYXQsIFtdLCB0aGlzKSwgdGhpcy5fdGlja1NjaGVkdWxlZCA9IHRydWUpKTsKICAgICAgICB9LCBzLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB2YXIgZTIgPSBudWxsLCB0MiA9IE1hdGgubWluKHRoaXMubWF4LCB0aGlzLmluZGV4ICsgMTYzODQpOwogICAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5tYXgpCiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZCgpOwogICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHsKICAgICAgICAgICAgY2FzZSAic3RyaW5nIjoKICAgICAgICAgICAgICBlMiA9IHRoaXMuZGF0YS5zdWJzdHJpbmcodGhpcy5pbmRleCwgdDIpOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlICJ1aW50OGFycmF5IjoKICAgICAgICAgICAgICBlMiA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmluZGV4LCB0Mik7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgImFycmF5IjoKICAgICAgICAgICAgY2FzZSAibm9kZWJ1ZmZlciI6CiAgICAgICAgICAgICAgZTIgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5pbmRleCwgdDIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPSB0MiwgdGhpcy5wdXNoKHsgZGF0YTogZTIsIG1ldGE6IHsgcGVyY2VudDogdGhpcy5tYXggPyB0aGlzLmluZGV4IC8gdGhpcy5tYXggKiAxMDAgOiAwIH0gfSk7CiAgICAgICAgfSwgdC5leHBvcnRzID0gczsKICAgICAgfSwgeyAiLi4vdXRpbHMiOiAzMiwgIi4vR2VuZXJpY1dvcmtlciI6IDI4IH1dLCAyODogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICBmdW5jdGlvbiBuKGUyKSB7CiAgICAgICAgICB0aGlzLm5hbWUgPSBlMiB8fCAiZGVmYXVsdCIsIHRoaXMuc3RyZWFtSW5mbyA9IHt9LCB0aGlzLmdlbmVyYXRlZEVycm9yID0gbnVsbCwgdGhpcy5leHRyYVN0cmVhbUluZm8gPSB7fSwgdGhpcy5pc1BhdXNlZCA9IHRydWUsIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlLCB0aGlzLmlzTG9ja2VkID0gZmFsc2UsIHRoaXMuX2xpc3RlbmVycyA9IHsgZGF0YTogW10sIGVuZDogW10sIGVycm9yOiBbXSB9LCB0aGlzLnByZXZpb3VzID0gbnVsbDsKICAgICAgICB9CiAgICAgICAgbi5wcm90b3R5cGUgPSB7IHB1c2g6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB0aGlzLmVtaXQoImRhdGEiLCBlMik7CiAgICAgICAgfSwgZW5kOiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpCiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIHRoaXMuZmx1c2goKTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHRoaXMuZW1pdCgiZW5kIiksIHRoaXMuY2xlYW5VcCgpLCB0aGlzLmlzRmluaXNoZWQgPSB0cnVlOwogICAgICAgICAgfSBjYXRjaCAoZTIpIHsKICAgICAgICAgICAgdGhpcy5lbWl0KCJlcnJvciIsIGUyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0sIGVycm9yOiBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuICF0aGlzLmlzRmluaXNoZWQgJiYgKHRoaXMuaXNQYXVzZWQgPyB0aGlzLmdlbmVyYXRlZEVycm9yID0gZTIgOiAodGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZSwgdGhpcy5lbWl0KCJlcnJvciIsIGUyKSwgdGhpcy5wcmV2aW91cyAmJiB0aGlzLnByZXZpb3VzLmVycm9yKGUyKSwgdGhpcy5jbGVhblVwKCkpLCB0cnVlKTsKICAgICAgICB9LCBvbjogZnVuY3Rpb24oZTIsIHQyKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzW2UyXS5wdXNoKHQyKSwgdGhpczsKICAgICAgICB9LCBjbGVhblVwOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IG51bGwsIHRoaXMuX2xpc3RlbmVycyA9IFtdOwogICAgICAgIH0sIGVtaXQ6IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tlMl0pCiAgICAgICAgICAgIGZvciAodmFyIHIyID0gMDsgcjIgPCB0aGlzLl9saXN0ZW5lcnNbZTJdLmxlbmd0aDsgcjIrKykKICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZTJdW3IyXS5jYWxsKHRoaXMsIHQyKTsKICAgICAgICB9LCBwaXBlOiBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIGUyLnJlZ2lzdGVyUHJldmlvdXModGhpcyk7CiAgICAgICAgfSwgcmVnaXN0ZXJQcmV2aW91czogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlRoZSBzdHJlYW0gJyIgKyB0aGlzICsgIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLiIpOwogICAgICAgICAgdGhpcy5zdHJlYW1JbmZvID0gZTIuc3RyZWFtSW5mbywgdGhpcy5tZXJnZVN0cmVhbUluZm8oKSwgdGhpcy5wcmV2aW91cyA9IGUyOwogICAgICAgICAgdmFyIHQyID0gdGhpczsKICAgICAgICAgIHJldHVybiBlMi5vbigiZGF0YSIsIGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgIHQyLnByb2Nlc3NDaHVuayhlMyk7CiAgICAgICAgICB9KSwgZTIub24oImVuZCIsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICB0Mi5lbmQoKTsKICAgICAgICAgIH0pLCBlMi5vbigiZXJyb3IiLCBmdW5jdGlvbihlMykgewogICAgICAgICAgICB0Mi5lcnJvcihlMyk7CiAgICAgICAgICB9KSwgdGhpczsKICAgICAgICB9LCBwYXVzZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gIXRoaXMuaXNQYXVzZWQgJiYgIXRoaXMuaXNGaW5pc2hlZCAmJiAodGhpcy5pc1BhdXNlZCA9IHRydWUsIHRoaXMucHJldmlvdXMgJiYgdGhpcy5wcmV2aW91cy5wYXVzZSgpLCB0cnVlKTsKICAgICAgICB9LCByZXN1bWU6IGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKCF0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgdmFyIGUyID0gdGhpcy5pc1BhdXNlZCA9IGZhbHNlOwogICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVkRXJyb3IgJiYgKHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvciksIGUyID0gdHJ1ZSksIHRoaXMucHJldmlvdXMgJiYgdGhpcy5wcmV2aW91cy5yZXN1bWUoKSwgIWUyOwogICAgICAgIH0sIGZsdXNoOiBmdW5jdGlvbigpIHsKICAgICAgICB9LCBwcm9jZXNzQ2h1bms6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB0aGlzLnB1c2goZTIpOwogICAgICAgIH0sIHdpdGhTdHJlYW1JbmZvOiBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmV4dHJhU3RyZWFtSW5mb1tlMl0gPSB0MiwgdGhpcy5tZXJnZVN0cmVhbUluZm8oKSwgdGhpczsKICAgICAgICB9LCBtZXJnZVN0cmVhbUluZm86IGZ1bmN0aW9uKCkgewogICAgICAgICAgZm9yICh2YXIgZTIgaW4gdGhpcy5leHRyYVN0cmVhbUluZm8pCiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmV4dHJhU3RyZWFtSW5mbywgZTIpICYmICh0aGlzLnN0cmVhbUluZm9bZTJdID0gdGhpcy5leHRyYVN0cmVhbUluZm9bZTJdKTsKICAgICAgICB9LCBsb2NrOiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlRoZSBzdHJlYW0gJyIgKyB0aGlzICsgIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLiIpOwogICAgICAgICAgdGhpcy5pc0xvY2tlZCA9IHRydWUsIHRoaXMucHJldmlvdXMgJiYgdGhpcy5wcmV2aW91cy5sb2NrKCk7CiAgICAgICAgfSwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIGUyID0gIldvcmtlciAiICsgdGhpcy5uYW1lOwogICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMgPyB0aGlzLnByZXZpb3VzICsgIiAtPiAiICsgZTIgOiBlMjsKICAgICAgICB9IH0sIHQuZXhwb3J0cyA9IG47CiAgICAgIH0sIHt9XSwgMjk6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIGggPSBlKCIuLi91dGlscyIpLCBpID0gZSgiLi9Db252ZXJ0V29ya2VyIiksIHMgPSBlKCIuL0dlbmVyaWNXb3JrZXIiKSwgdSA9IGUoIi4uL2Jhc2U2NCIpLCBuID0gZSgiLi4vc3VwcG9ydCIpLCBhID0gZSgiLi4vZXh0ZXJuYWwiKSwgbyA9IG51bGw7CiAgICAgICAgaWYgKG4ubm9kZXN0cmVhbSkKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIG8gPSBlKCIuLi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlciIpOwogICAgICAgICAgfSBjYXRjaCAoZTIpIHsKICAgICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBsKGUyLCBvMikgewogICAgICAgICAgcmV0dXJuIG5ldyBhLlByb21pc2UoZnVuY3Rpb24odDIsIHIyKSB7CiAgICAgICAgICAgIHZhciBuMiA9IFtdLCBpMiA9IGUyLl9pbnRlcm5hbFR5cGUsIHMyID0gZTIuX291dHB1dFR5cGUsIGEyID0gZTIuX21pbWVUeXBlOwogICAgICAgICAgICBlMi5vbigiZGF0YSIsIGZ1bmN0aW9uKGUzLCB0MykgewogICAgICAgICAgICAgIG4yLnB1c2goZTMpLCBvMiAmJiBvMih0Myk7CiAgICAgICAgICAgIH0pLm9uKCJlcnJvciIsIGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgICAgbjIgPSBbXSwgcjIoZTMpOwogICAgICAgICAgICB9KS5vbigiZW5kIiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIHZhciBlMyA9IGZ1bmN0aW9uKGU0LCB0MywgcjMpIHsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChlNCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgImJsb2IiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgubmV3QmxvYihoLnRyYW5zZm9ybVRvKCJhcnJheWJ1ZmZlciIsIHQzKSwgcjMpOwogICAgICAgICAgICAgICAgICAgIGNhc2UgImJhc2U2NCI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdS5lbmNvZGUodDMpOwogICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaC50cmFuc2Zvcm1UbyhlNCwgdDMpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KHMyLCBmdW5jdGlvbihlNCwgdDMpIHsKICAgICAgICAgICAgICAgICAgdmFyIHIzLCBuMyA9IDAsIGkzID0gbnVsbCwgczMgPSAwOwogICAgICAgICAgICAgICAgICBmb3IgKHIzID0gMDsgcjMgPCB0My5sZW5ndGg7IHIzKyspCiAgICAgICAgICAgICAgICAgICAgczMgKz0gdDNbcjNdLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgc3dpdGNoIChlNCkgewogICAgICAgICAgICAgICAgICAgIGNhc2UgInN0cmluZyI6CiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDMuam9pbigiIik7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAiYXJyYXkiOgogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHQzKTsKICAgICAgICAgICAgICAgICAgICBjYXNlICJ1aW50OGFycmF5IjoKICAgICAgICAgICAgICAgICAgICAgIGZvciAoaTMgPSBuZXcgVWludDhBcnJheShzMyksIHIzID0gMDsgcjMgPCB0My5sZW5ndGg7IHIzKyspCiAgICAgICAgICAgICAgICAgICAgICAgIGkzLnNldCh0M1tyM10sIG4zKSwgbjMgKz0gdDNbcjNdLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMzsKICAgICAgICAgICAgICAgICAgICBjYXNlICJub2RlYnVmZmVyIjoKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KHQzKTsKICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjb25jYXQgOiB1bnN1cHBvcnRlZCB0eXBlICciICsgZTQgKyAiJyIpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9KGkyLCBuMiksIGEyKTsKICAgICAgICAgICAgICAgIHQyKGUzKTsKICAgICAgICAgICAgICB9IGNhdGNoIChlNCkgewogICAgICAgICAgICAgICAgcjIoZTQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBuMiA9IFtdOwogICAgICAgICAgICB9KS5yZXN1bWUoKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBmKGUyLCB0MiwgcjIpIHsKICAgICAgICAgIHZhciBuMiA9IHQyOwogICAgICAgICAgc3dpdGNoICh0MikgewogICAgICAgICAgICBjYXNlICJibG9iIjoKICAgICAgICAgICAgY2FzZSAiYXJyYXlidWZmZXIiOgogICAgICAgICAgICAgIG4yID0gInVpbnQ4YXJyYXkiOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlICJiYXNlNjQiOgogICAgICAgICAgICAgIG4yID0gInN0cmluZyI7CiAgICAgICAgICB9CiAgICAgICAgICB0cnkgewogICAgICAgICAgICB0aGlzLl9pbnRlcm5hbFR5cGUgPSBuMiwgdGhpcy5fb3V0cHV0VHlwZSA9IHQyLCB0aGlzLl9taW1lVHlwZSA9IHIyLCBoLmNoZWNrU3VwcG9ydChuMiksIHRoaXMuX3dvcmtlciA9IGUyLnBpcGUobmV3IGkobjIpKSwgZTIubG9jaygpOwogICAgICAgICAgfSBjYXRjaCAoZTMpIHsKICAgICAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IHMoImVycm9yIiksIHRoaXMuX3dvcmtlci5lcnJvcihlMyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGYucHJvdG90eXBlID0geyBhY2N1bXVsYXRlOiBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIGwodGhpcywgZTIpOwogICAgICAgIH0sIG9uOiBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiA9IHRoaXM7CiAgICAgICAgICByZXR1cm4gImRhdGEiID09PSBlMiA/IHRoaXMuX3dvcmtlci5vbihlMiwgZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgdDIuY2FsbChyMiwgZTMuZGF0YSwgZTMubWV0YSk7CiAgICAgICAgICB9KSA6IHRoaXMuX3dvcmtlci5vbihlMiwgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGguZGVsYXkodDIsIGFyZ3VtZW50cywgcjIpOwogICAgICAgICAgfSksIHRoaXM7CiAgICAgICAgfSwgcmVzdW1lOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiBoLmRlbGF5KHRoaXMuX3dvcmtlci5yZXN1bWUsIFtdLCB0aGlzLl93b3JrZXIpLCB0aGlzOwogICAgICAgIH0sIHBhdXNlOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiB0aGlzLl93b3JrZXIucGF1c2UoKSwgdGhpczsKICAgICAgICB9LCB0b05vZGVqc1N0cmVhbTogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGlmIChoLmNoZWNrU3VwcG9ydCgibm9kZXN0cmVhbSIpLCAibm9kZWJ1ZmZlciIgIT09IHRoaXMuX291dHB1dFR5cGUpCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9vdXRwdXRUeXBlICsgIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgbWV0aG9kIik7CiAgICAgICAgICByZXR1cm4gbmV3IG8odGhpcywgeyBvYmplY3RNb2RlOiAibm9kZWJ1ZmZlciIgIT09IHRoaXMuX291dHB1dFR5cGUgfSwgZTIpOwogICAgICAgIH0gfSwgdC5leHBvcnRzID0gZjsKICAgICAgfSwgeyAiLi4vYmFzZTY0IjogMSwgIi4uL2V4dGVybmFsIjogNiwgIi4uL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyIjogMTMsICIuLi9zdXBwb3J0IjogMzAsICIuLi91dGlscyI6IDMyLCAiLi9Db252ZXJ0V29ya2VyIjogMjQsICIuL0dlbmVyaWNXb3JrZXIiOiAyOCB9XSwgMzA6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgaWYgKHIuYmFzZTY0ID0gdHJ1ZSwgci5hcnJheSA9IHRydWUsIHIuc3RyaW5nID0gdHJ1ZSwgci5hcnJheWJ1ZmZlciA9ICJ1bmRlZmluZWQiICE9IHR5cGVvZiBBcnJheUJ1ZmZlciAmJiAidW5kZWZpbmVkIiAhPSB0eXBlb2YgVWludDhBcnJheSwgci5ub2RlYnVmZmVyID0gInVuZGVmaW5lZCIgIT0gdHlwZW9mIEJ1ZmZlciwgci51aW50OGFycmF5ID0gInVuZGVmaW5lZCIgIT0gdHlwZW9mIFVpbnQ4QXJyYXksICJ1bmRlZmluZWQiID09IHR5cGVvZiBBcnJheUJ1ZmZlcikKICAgICAgICAgIHIuYmxvYiA9IGZhbHNlOwogICAgICAgIGVsc2UgewogICAgICAgICAgdmFyIG4gPSBuZXcgQXJyYXlCdWZmZXIoMCk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByLmJsb2IgPSAwID09PSBuZXcgQmxvYihbbl0sIHsgdHlwZTogImFwcGxpY2F0aW9uL3ppcCIgfSkuc2l6ZTsKICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgdmFyIGkgPSBuZXcgKHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcikoKTsKICAgICAgICAgICAgICBpLmFwcGVuZChuKSwgci5ibG9iID0gMCA9PT0gaS5nZXRCbG9iKCJhcHBsaWNhdGlvbi96aXAiKS5zaXplOwogICAgICAgICAgICB9IGNhdGNoIChlMykgewogICAgICAgICAgICAgIHIuYmxvYiA9IGZhbHNlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRyeSB7CiAgICAgICAgICByLm5vZGVzdHJlYW0gPSAhIWUoInJlYWRhYmxlLXN0cmVhbSIpLlJlYWRhYmxlOwogICAgICAgIH0gY2F0Y2ggKGUyKSB7CiAgICAgICAgICByLm5vZGVzdHJlYW0gPSBmYWxzZTsKICAgICAgICB9CiAgICAgIH0sIHsgInJlYWRhYmxlLXN0cmVhbSI6IDE2IH1dLCAzMTogW2Z1bmN0aW9uKGUsIHQsIHMpIHsKICAgICAgICBmb3IgKHZhciBvID0gZSgiLi91dGlscyIpLCBoID0gZSgiLi9zdXBwb3J0IiksIHIgPSBlKCIuL25vZGVqc1V0aWxzIiksIG4gPSBlKCIuL3N0cmVhbS9HZW5lcmljV29ya2VyIiksIHUgPSBuZXcgQXJyYXkoMjU2KSwgaSA9IDA7IGkgPCAyNTY7IGkrKykKICAgICAgICAgIHVbaV0gPSAyNTIgPD0gaSA/IDYgOiAyNDggPD0gaSA/IDUgOiAyNDAgPD0gaSA/IDQgOiAyMjQgPD0gaSA/IDMgOiAxOTIgPD0gaSA/IDIgOiAxOwogICAgICAgIHVbMjU0XSA9IHVbMjU0XSA9IDE7CiAgICAgICAgZnVuY3Rpb24gYSgpIHsKICAgICAgICAgIG4uY2FsbCh0aGlzLCAidXRmLTggZGVjb2RlIiksIHRoaXMubGVmdE92ZXIgPSBudWxsOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBsKCkgewogICAgICAgICAgbi5jYWxsKHRoaXMsICJ1dGYtOCBlbmNvZGUiKTsKICAgICAgICB9CiAgICAgICAgcy51dGY4ZW5jb2RlID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiBoLm5vZGVidWZmZXIgPyByLm5ld0J1ZmZlckZyb20oZTIsICJ1dGYtOCIpIDogZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgdmFyIHQyLCByMiwgbjIsIGkyLCBzMiwgYTIgPSBlMy5sZW5ndGgsIG8yID0gMDsKICAgICAgICAgICAgZm9yIChpMiA9IDA7IGkyIDwgYTI7IGkyKyspCiAgICAgICAgICAgICAgNTUyOTYgPT0gKDY0NTEyICYgKHIyID0gZTMuY2hhckNvZGVBdChpMikpKSAmJiBpMiArIDEgPCBhMiAmJiA1NjMyMCA9PSAoNjQ1MTIgJiAobjIgPSBlMy5jaGFyQ29kZUF0KGkyICsgMSkpKSAmJiAocjIgPSA2NTUzNiArIChyMiAtIDU1Mjk2IDw8IDEwKSArIChuMiAtIDU2MzIwKSwgaTIrKyksIG8yICs9IHIyIDwgMTI4ID8gMSA6IHIyIDwgMjA0OCA/IDIgOiByMiA8IDY1NTM2ID8gMyA6IDQ7CiAgICAgICAgICAgIGZvciAodDIgPSBoLnVpbnQ4YXJyYXkgPyBuZXcgVWludDhBcnJheShvMikgOiBuZXcgQXJyYXkobzIpLCBpMiA9IHMyID0gMDsgczIgPCBvMjsgaTIrKykKICAgICAgICAgICAgICA1NTI5NiA9PSAoNjQ1MTIgJiAocjIgPSBlMy5jaGFyQ29kZUF0KGkyKSkpICYmIGkyICsgMSA8IGEyICYmIDU2MzIwID09ICg2NDUxMiAmIChuMiA9IGUzLmNoYXJDb2RlQXQoaTIgKyAxKSkpICYmIChyMiA9IDY1NTM2ICsgKHIyIC0gNTUyOTYgPDwgMTApICsgKG4yIC0gNTYzMjApLCBpMisrKSwgcjIgPCAxMjggPyB0MltzMisrXSA9IHIyIDogKHIyIDwgMjA0OCA/IHQyW3MyKytdID0gMTkyIHwgcjIgPj4+IDYgOiAocjIgPCA2NTUzNiA/IHQyW3MyKytdID0gMjI0IHwgcjIgPj4+IDEyIDogKHQyW3MyKytdID0gMjQwIHwgcjIgPj4+IDE4LCB0MltzMisrXSA9IDEyOCB8IHIyID4+PiAxMiAmIDYzKSwgdDJbczIrK10gPSAxMjggfCByMiA+Pj4gNiAmIDYzKSwgdDJbczIrK10gPSAxMjggfCA2MyAmIHIyKTsKICAgICAgICAgICAgcmV0dXJuIHQyOwogICAgICAgICAgfShlMik7CiAgICAgICAgfSwgcy51dGY4ZGVjb2RlID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiBoLm5vZGVidWZmZXIgPyBvLnRyYW5zZm9ybVRvKCJub2RlYnVmZmVyIiwgZTIpLnRvU3RyaW5nKCJ1dGYtOCIpIDogZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgdmFyIHQyLCByMiwgbjIsIGkyLCBzMiA9IGUzLmxlbmd0aCwgYTIgPSBuZXcgQXJyYXkoMiAqIHMyKTsKICAgICAgICAgICAgZm9yICh0MiA9IHIyID0gMDsgdDIgPCBzMjsgKQogICAgICAgICAgICAgIGlmICgobjIgPSBlM1t0MisrXSkgPCAxMjgpCiAgICAgICAgICAgICAgICBhMltyMisrXSA9IG4yOwogICAgICAgICAgICAgIGVsc2UgaWYgKDQgPCAoaTIgPSB1W24yXSkpCiAgICAgICAgICAgICAgICBhMltyMisrXSA9IDY1NTMzLCB0MiArPSBpMiAtIDE7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBmb3IgKG4yICY9IDIgPT09IGkyID8gMzEgOiAzID09PSBpMiA/IDE1IDogNzsgMSA8IGkyICYmIHQyIDwgczI7ICkKICAgICAgICAgICAgICAgICAgbjIgPSBuMiA8PCA2IHwgNjMgJiBlM1t0MisrXSwgaTItLTsKICAgICAgICAgICAgICAgIDEgPCBpMiA/IGEyW3IyKytdID0gNjU1MzMgOiBuMiA8IDY1NTM2ID8gYTJbcjIrK10gPSBuMiA6IChuMiAtPSA2NTUzNiwgYTJbcjIrK10gPSA1NTI5NiB8IG4yID4+IDEwICYgMTAyMywgYTJbcjIrK10gPSA1NjMyMCB8IDEwMjMgJiBuMik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gYTIubGVuZ3RoICE9PSByMiAmJiAoYTIuc3ViYXJyYXkgPyBhMiA9IGEyLnN1YmFycmF5KDAsIHIyKSA6IGEyLmxlbmd0aCA9IHIyKSwgby5hcHBseUZyb21DaGFyQ29kZShhMik7CiAgICAgICAgICB9KGUyID0gby50cmFuc2Zvcm1UbyhoLnVpbnQ4YXJyYXkgPyAidWludDhhcnJheSIgOiAiYXJyYXkiLCBlMikpOwogICAgICAgIH0sIG8uaW5oZXJpdHMoYSwgbiksIGEucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB2YXIgdDIgPSBvLnRyYW5zZm9ybVRvKGgudWludDhhcnJheSA/ICJ1aW50OGFycmF5IiA6ICJhcnJheSIsIGUyLmRhdGEpOwogICAgICAgICAgaWYgKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHsKICAgICAgICAgICAgaWYgKGgudWludDhhcnJheSkgewogICAgICAgICAgICAgIHZhciByMiA9IHQyOwogICAgICAgICAgICAgICh0MiA9IG5ldyBVaW50OEFycmF5KHIyLmxlbmd0aCArIHRoaXMubGVmdE92ZXIubGVuZ3RoKSkuc2V0KHRoaXMubGVmdE92ZXIsIDApLCB0Mi5zZXQocjIsIHRoaXMubGVmdE92ZXIubGVuZ3RoKTsKICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgdDIgPSB0aGlzLmxlZnRPdmVyLmNvbmNhdCh0Mik7CiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsOwogICAgICAgICAgfQogICAgICAgICAgdmFyIG4yID0gZnVuY3Rpb24oZTMsIHQzKSB7CiAgICAgICAgICAgIHZhciByMzsKICAgICAgICAgICAgZm9yICgodDMgPSB0MyB8fCBlMy5sZW5ndGgpID4gZTMubGVuZ3RoICYmICh0MyA9IGUzLmxlbmd0aCksIHIzID0gdDMgLSAxOyAwIDw9IHIzICYmIDEyOCA9PSAoMTkyICYgZTNbcjNdKTsgKQogICAgICAgICAgICAgIHIzLS07CiAgICAgICAgICAgIHJldHVybiByMyA8IDAgPyB0MyA6IDAgPT09IHIzID8gdDMgOiByMyArIHVbZTNbcjNdXSA+IHQzID8gcjMgOiB0MzsKICAgICAgICAgIH0odDIpLCBpMiA9IHQyOwogICAgICAgICAgbjIgIT09IHQyLmxlbmd0aCAmJiAoaC51aW50OGFycmF5ID8gKGkyID0gdDIuc3ViYXJyYXkoMCwgbjIpLCB0aGlzLmxlZnRPdmVyID0gdDIuc3ViYXJyYXkobjIsIHQyLmxlbmd0aCkpIDogKGkyID0gdDIuc2xpY2UoMCwgbjIpLCB0aGlzLmxlZnRPdmVyID0gdDIuc2xpY2UobjIsIHQyLmxlbmd0aCkpKSwgdGhpcy5wdXNoKHsgZGF0YTogcy51dGY4ZGVjb2RlKGkyKSwgbWV0YTogZTIubWV0YSB9KTsKICAgICAgICB9LCBhLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgdGhpcy5sZWZ0T3ZlciAmJiB0aGlzLmxlZnRPdmVyLmxlbmd0aCAmJiAodGhpcy5wdXNoKHsgZGF0YTogcy51dGY4ZGVjb2RlKHRoaXMubGVmdE92ZXIpLCBtZXRhOiB7fSB9KSwgdGhpcy5sZWZ0T3ZlciA9IG51bGwpOwogICAgICAgIH0sIHMuVXRmOERlY29kZVdvcmtlciA9IGEsIG8uaW5oZXJpdHMobCwgbiksIGwucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB0aGlzLnB1c2goeyBkYXRhOiBzLnV0ZjhlbmNvZGUoZTIuZGF0YSksIG1ldGE6IGUyLm1ldGEgfSk7CiAgICAgICAgfSwgcy5VdGY4RW5jb2RlV29ya2VyID0gbDsKICAgICAgfSwgeyAiLi9ub2RlanNVdGlscyI6IDE0LCAiLi9zdHJlYW0vR2VuZXJpY1dvcmtlciI6IDI4LCAiLi9zdXBwb3J0IjogMzAsICIuL3V0aWxzIjogMzIgfV0sIDMyOiBbZnVuY3Rpb24oZSwgdCwgYSkgewogICAgICAgIHZhciBvID0gZSgiLi9zdXBwb3J0IiksIGggPSBlKCIuL2Jhc2U2NCIpLCByID0gZSgiLi9ub2RlanNVdGlscyIpLCB1ID0gZSgiLi9leHRlcm5hbCIpOwogICAgICAgIGZ1bmN0aW9uIG4oZTIpIHsKICAgICAgICAgIHJldHVybiBlMjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbChlMiwgdDIpIHsKICAgICAgICAgIGZvciAodmFyIHIyID0gMDsgcjIgPCBlMi5sZW5ndGg7ICsrcjIpCiAgICAgICAgICAgIHQyW3IyXSA9IDI1NSAmIGUyLmNoYXJDb2RlQXQocjIpOwogICAgICAgICAgcmV0dXJuIHQyOwogICAgICAgIH0KICAgICAgICBlKCJzZXRpbW1lZGlhdGUiKSwgYS5uZXdCbG9iID0gZnVuY3Rpb24odDIsIHIyKSB7CiAgICAgICAgICBhLmNoZWNrU3VwcG9ydCgiYmxvYiIpOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFt0Ml0sIHsgdHlwZTogcjIgfSk7CiAgICAgICAgICB9IGNhdGNoIChlMikgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHZhciBuMiA9IG5ldyAoc2VsZi5CbG9iQnVpbGRlciB8fCBzZWxmLldlYktpdEJsb2JCdWlsZGVyIHx8IHNlbGYuTW96QmxvYkJ1aWxkZXIgfHwgc2VsZi5NU0Jsb2JCdWlsZGVyKSgpOwogICAgICAgICAgICAgIHJldHVybiBuMi5hcHBlbmQodDIpLCBuMi5nZXRCbG9iKHIyKTsKICAgICAgICAgICAgfSBjYXRjaCAoZTMpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkJ1ZyA6IGNhbid0IGNvbnN0cnVjdCB0aGUgQmxvYi4iKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgdmFyIGkgPSB7IHN0cmluZ2lmeUJ5Q2h1bms6IGZ1bmN0aW9uKGUyLCB0MiwgcjIpIHsKICAgICAgICAgIHZhciBuMiA9IFtdLCBpMiA9IDAsIHMyID0gZTIubGVuZ3RoOwogICAgICAgICAgaWYgKHMyIDw9IHIyKQogICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBlMik7CiAgICAgICAgICBmb3IgKDsgaTIgPCBzMjsgKQogICAgICAgICAgICAiYXJyYXkiID09PSB0MiB8fCAibm9kZWJ1ZmZlciIgPT09IHQyID8gbjIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGUyLnNsaWNlKGkyLCBNYXRoLm1pbihpMiArIHIyLCBzMikpKSkgOiBuMi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZTIuc3ViYXJyYXkoaTIsIE1hdGgubWluKGkyICsgcjIsIHMyKSkpKSwgaTIgKz0gcjI7CiAgICAgICAgICByZXR1cm4gbjIuam9pbigiIik7CiAgICAgICAgfSwgc3RyaW5naWZ5QnlDaGFyOiBmdW5jdGlvbihlMikgewogICAgICAgICAgZm9yICh2YXIgdDIgPSAiIiwgcjIgPSAwOyByMiA8IGUyLmxlbmd0aDsgcjIrKykKICAgICAgICAgICAgdDIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlMltyMl0pOwogICAgICAgICAgcmV0dXJuIHQyOwogICAgICAgIH0sIGFwcGx5Q2FuQmVVc2VkOiB7IHVpbnQ4YXJyYXk6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmV0dXJuIG8udWludDhhcnJheSAmJiAxID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKS5sZW5ndGg7CiAgICAgICAgICB9IGNhdGNoIChlMikgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgfSgpLCBub2RlYnVmZmVyOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiBvLm5vZGVidWZmZXIgJiYgMSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCByLmFsbG9jQnVmZmVyKDEpKS5sZW5ndGg7CiAgICAgICAgICB9IGNhdGNoIChlMikgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgfSgpIH0gfTsKICAgICAgICBmdW5jdGlvbiBzKGUyKSB7CiAgICAgICAgICB2YXIgdDIgPSA2NTUzNiwgcjIgPSBhLmdldFR5cGVPZihlMiksIG4yID0gdHJ1ZTsKICAgICAgICAgIGlmICgidWludDhhcnJheSIgPT09IHIyID8gbjIgPSBpLmFwcGx5Q2FuQmVVc2VkLnVpbnQ4YXJyYXkgOiAibm9kZWJ1ZmZlciIgPT09IHIyICYmIChuMiA9IGkuYXBwbHlDYW5CZVVzZWQubm9kZWJ1ZmZlciksIG4yKQogICAgICAgICAgICBmb3IgKDsgMSA8IHQyOyApCiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIHJldHVybiBpLnN0cmluZ2lmeUJ5Q2h1bmsoZTIsIHIyLCB0Mik7CiAgICAgICAgICAgICAgfSBjYXRjaCAoZTMpIHsKICAgICAgICAgICAgICAgIHQyID0gTWF0aC5mbG9vcih0MiAvIDIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBpLnN0cmluZ2lmeUJ5Q2hhcihlMik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGYoZTIsIHQyKSB7CiAgICAgICAgICBmb3IgKHZhciByMiA9IDA7IHIyIDwgZTIubGVuZ3RoOyByMisrKQogICAgICAgICAgICB0MltyMl0gPSBlMltyMl07CiAgICAgICAgICByZXR1cm4gdDI7CiAgICAgICAgfQogICAgICAgIGEuYXBwbHlGcm9tQ2hhckNvZGUgPSBzOwogICAgICAgIHZhciBjID0ge307CiAgICAgICAgYy5zdHJpbmcgPSB7IHN0cmluZzogbiwgYXJyYXk6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICByZXR1cm4gbChlMiwgbmV3IEFycmF5KGUyLmxlbmd0aCkpOwogICAgICAgIH0sIGFycmF5YnVmZmVyOiBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIGMuc3RyaW5nLnVpbnQ4YXJyYXkoZTIpLmJ1ZmZlcjsKICAgICAgICB9LCB1aW50OGFycmF5OiBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIGwoZTIsIG5ldyBVaW50OEFycmF5KGUyLmxlbmd0aCkpOwogICAgICAgIH0sIG5vZGVidWZmZXI6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICByZXR1cm4gbChlMiwgci5hbGxvY0J1ZmZlcihlMi5sZW5ndGgpKTsKICAgICAgICB9IH0sIGMuYXJyYXkgPSB7IHN0cmluZzogcywgYXJyYXk6IG4sIGFycmF5YnVmZmVyOiBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGUyKS5idWZmZXI7CiAgICAgICAgfSwgdWludDhhcnJheTogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShlMik7CiAgICAgICAgfSwgbm9kZWJ1ZmZlcjogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiByLm5ld0J1ZmZlckZyb20oZTIpOwogICAgICAgIH0gfSwgYy5hcnJheWJ1ZmZlciA9IHsgc3RyaW5nOiBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIHMobmV3IFVpbnQ4QXJyYXkoZTIpKTsKICAgICAgICB9LCBhcnJheTogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiBmKG5ldyBVaW50OEFycmF5KGUyKSwgbmV3IEFycmF5KGUyLmJ5dGVMZW5ndGgpKTsKICAgICAgICB9LCBhcnJheWJ1ZmZlcjogbiwgdWludDhhcnJheTogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShlMik7CiAgICAgICAgfSwgbm9kZWJ1ZmZlcjogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiByLm5ld0J1ZmZlckZyb20obmV3IFVpbnQ4QXJyYXkoZTIpKTsKICAgICAgICB9IH0sIGMudWludDhhcnJheSA9IHsgc3RyaW5nOiBzLCBhcnJheTogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiBmKGUyLCBuZXcgQXJyYXkoZTIubGVuZ3RoKSk7CiAgICAgICAgfSwgYXJyYXlidWZmZXI6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICByZXR1cm4gZTIuYnVmZmVyOwogICAgICAgIH0sIHVpbnQ4YXJyYXk6IG4sIG5vZGVidWZmZXI6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICByZXR1cm4gci5uZXdCdWZmZXJGcm9tKGUyKTsKICAgICAgICB9IH0sIGMubm9kZWJ1ZmZlciA9IHsgc3RyaW5nOiBzLCBhcnJheTogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHJldHVybiBmKGUyLCBuZXcgQXJyYXkoZTIubGVuZ3RoKSk7CiAgICAgICAgfSwgYXJyYXlidWZmZXI6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICByZXR1cm4gYy5ub2RlYnVmZmVyLnVpbnQ4YXJyYXkoZTIpLmJ1ZmZlcjsKICAgICAgICB9LCB1aW50OGFycmF5OiBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIGYoZTIsIG5ldyBVaW50OEFycmF5KGUyLmxlbmd0aCkpOwogICAgICAgIH0sIG5vZGVidWZmZXI6IG4gfSwgYS50cmFuc2Zvcm1UbyA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgaWYgKHQyID0gdDIgfHwgIiIsICFlMikKICAgICAgICAgICAgcmV0dXJuIHQyOwogICAgICAgICAgYS5jaGVja1N1cHBvcnQoZTIpOwogICAgICAgICAgdmFyIHIyID0gYS5nZXRUeXBlT2YodDIpOwogICAgICAgICAgcmV0dXJuIGNbcjJdW2UyXSh0Mik7CiAgICAgICAgfSwgYS5yZXNvbHZlID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGZvciAodmFyIHQyID0gZTIuc3BsaXQoIi8iKSwgcjIgPSBbXSwgbjIgPSAwOyBuMiA8IHQyLmxlbmd0aDsgbjIrKykgewogICAgICAgICAgICB2YXIgaTIgPSB0MltuMl07CiAgICAgICAgICAgICIuIiA9PT0gaTIgfHwgIiIgPT09IGkyICYmIDAgIT09IG4yICYmIG4yICE9PSB0Mi5sZW5ndGggLSAxIHx8ICgiLi4iID09PSBpMiA/IHIyLnBvcCgpIDogcjIucHVzaChpMikpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHIyLmpvaW4oIi8iKTsKICAgICAgICB9LCBhLmdldFR5cGVPZiA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICByZXR1cm4gInN0cmluZyIgPT0gdHlwZW9mIGUyID8gInN0cmluZyIgOiAiW29iamVjdCBBcnJheV0iID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZTIpID8gImFycmF5IiA6IG8ubm9kZWJ1ZmZlciAmJiByLmlzQnVmZmVyKGUyKSA/ICJub2RlYnVmZmVyIiA6IG8udWludDhhcnJheSAmJiBlMiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyAidWludDhhcnJheSIgOiBvLmFycmF5YnVmZmVyICYmIGUyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyAiYXJyYXlidWZmZXIiIDogdm9pZCAwOwogICAgICAgIH0sIGEuY2hlY2tTdXBwb3J0ID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGlmICghb1tlMi50b0xvd2VyQ2FzZSgpXSkKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUyICsgIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcGxhdGZvcm0iKTsKICAgICAgICB9LCBhLk1BWF9WQUxVRV8xNkJJVFMgPSA2NTUzNSwgYS5NQVhfVkFMVUVfMzJCSVRTID0gLTEsIGEucHJldHR5ID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHZhciB0MiwgcjIsIG4yID0gIiI7CiAgICAgICAgICBmb3IgKHIyID0gMDsgcjIgPCAoZTIgfHwgIiIpLmxlbmd0aDsgcjIrKykKICAgICAgICAgICAgbjIgKz0gIlxceCIgKyAoKHQyID0gZTIuY2hhckNvZGVBdChyMikpIDwgMTYgPyAiMCIgOiAiIikgKyB0Mi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsKICAgICAgICAgIHJldHVybiBuMjsKICAgICAgICB9LCBhLmRlbGF5ID0gZnVuY3Rpb24oZTIsIHQyLCByMikgewogICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkgewogICAgICAgICAgICBlMi5hcHBseShyMiB8fCBudWxsLCB0MiB8fCBbXSk7CiAgICAgICAgICB9KTsKICAgICAgICB9LCBhLmluaGVyaXRzID0gZnVuY3Rpb24oZTIsIHQyKSB7CiAgICAgICAgICBmdW5jdGlvbiByMigpIHsKICAgICAgICAgIH0KICAgICAgICAgIHIyLnByb3RvdHlwZSA9IHQyLnByb3RvdHlwZSwgZTIucHJvdG90eXBlID0gbmV3IHIyKCk7CiAgICAgICAgfSwgYS5leHRlbmQgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBlMiwgdDIsIHIyID0ge307CiAgICAgICAgICBmb3IgKGUyID0gMDsgZTIgPCBhcmd1bWVudHMubGVuZ3RoOyBlMisrKQogICAgICAgICAgICBmb3IgKHQyIGluIGFyZ3VtZW50c1tlMl0pCiAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1tlMl0sIHQyKSAmJiB2b2lkIDAgPT09IHIyW3QyXSAmJiAocjJbdDJdID0gYXJndW1lbnRzW2UyXVt0Ml0pOwogICAgICAgICAgcmV0dXJuIHIyOwogICAgICAgIH0sIGEucHJlcGFyZUNvbnRlbnQgPSBmdW5jdGlvbihyMiwgZTIsIG4yLCBpMiwgczIpIHsKICAgICAgICAgIHJldHVybiB1LlByb21pc2UucmVzb2x2ZShlMikudGhlbihmdW5jdGlvbihuMykgewogICAgICAgICAgICByZXR1cm4gby5ibG9iICYmIChuMyBpbnN0YW5jZW9mIEJsb2IgfHwgLTEgIT09IFsiW29iamVjdCBGaWxlXSIsICJbb2JqZWN0IEJsb2JdIl0uaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobjMpKSkgJiYgInVuZGVmaW5lZCIgIT0gdHlwZW9mIEZpbGVSZWFkZXIgPyBuZXcgdS5Qcm9taXNlKGZ1bmN0aW9uKHQyLCByMykgewogICAgICAgICAgICAgIHZhciBlMyA9IG5ldyBGaWxlUmVhZGVyKCk7CiAgICAgICAgICAgICAgZTMub25sb2FkID0gZnVuY3Rpb24oZTQpIHsKICAgICAgICAgICAgICAgIHQyKGU0LnRhcmdldC5yZXN1bHQpOwogICAgICAgICAgICAgIH0sIGUzLm9uZXJyb3IgPSBmdW5jdGlvbihlNCkgewogICAgICAgICAgICAgICAgcjMoZTQudGFyZ2V0LmVycm9yKTsKICAgICAgICAgICAgICB9LCBlMy5yZWFkQXNBcnJheUJ1ZmZlcihuMyk7CiAgICAgICAgICAgIH0pIDogbjM7CiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgIHZhciB0MiA9IGEuZ2V0VHlwZU9mKGUzKTsKICAgICAgICAgICAgcmV0dXJuIHQyID8gKCJhcnJheWJ1ZmZlciIgPT09IHQyID8gZTMgPSBhLnRyYW5zZm9ybVRvKCJ1aW50OGFycmF5IiwgZTMpIDogInN0cmluZyIgPT09IHQyICYmIChzMiA/IGUzID0gaC5kZWNvZGUoZTMpIDogbjIgJiYgdHJ1ZSAhPT0gaTIgJiYgKGUzID0gZnVuY3Rpb24oZTQpIHsKICAgICAgICAgICAgICByZXR1cm4gbChlNCwgby51aW50OGFycmF5ID8gbmV3IFVpbnQ4QXJyYXkoZTQubGVuZ3RoKSA6IG5ldyBBcnJheShlNC5sZW5ndGgpKTsKICAgICAgICAgICAgfShlMykpKSwgZTMpIDogdS5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoIkNhbid0IHJlYWQgdGhlIGRhdGEgb2YgJyIgKyByMiArICInLiBJcyBpdCBpbiBhIHN1cHBvcnRlZCBKYXZhU2NyaXB0IHR5cGUgKFN0cmluZywgQmxvYiwgQXJyYXlCdWZmZXIsIGV0YykgPyIpKTsKICAgICAgICAgIH0pOwogICAgICAgIH07CiAgICAgIH0sIHsgIi4vYmFzZTY0IjogMSwgIi4vZXh0ZXJuYWwiOiA2LCAiLi9ub2RlanNVdGlscyI6IDE0LCAiLi9zdXBwb3J0IjogMzAsIHNldGltbWVkaWF0ZTogNTQgfV0sIDMzOiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBuID0gZSgiLi9yZWFkZXIvcmVhZGVyRm9yIiksIGkgPSBlKCIuL3V0aWxzIiksIHMgPSBlKCIuL3NpZ25hdHVyZSIpLCBhID0gZSgiLi96aXBFbnRyeSIpLCBvID0gZSgiLi9zdXBwb3J0Iik7CiAgICAgICAgZnVuY3Rpb24gaChlMikgewogICAgICAgICAgdGhpcy5maWxlcyA9IFtdLCB0aGlzLmxvYWRPcHRpb25zID0gZTI7CiAgICAgICAgfQogICAgICAgIGgucHJvdG90eXBlID0geyBjaGVja1NpZ25hdHVyZTogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGlmICghdGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKGUyKSkgewogICAgICAgICAgICB0aGlzLnJlYWRlci5pbmRleCAtPSA0OwogICAgICAgICAgICB2YXIgdDIgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpOwogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiB1bmV4cGVjdGVkIHNpZ25hdHVyZSAoIiArIGkucHJldHR5KHQyKSArICIsIGV4cGVjdGVkICIgKyBpLnByZXR0eShlMikgKyAiKSIpOwogICAgICAgICAgfQogICAgICAgIH0sIGlzU2lnbmF0dXJlOiBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiA9IHRoaXMucmVhZGVyLmluZGV4OwogICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoZTIpOwogICAgICAgICAgdmFyIG4yID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KSA9PT0gdDI7CiAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXIuc2V0SW5kZXgocjIpLCBuMjsKICAgICAgICB9LCByZWFkQmxvY2tFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCgyKSwgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMiksIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCgyKSwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMiksIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpLCB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpLCB0aGlzLnppcENvbW1lbnRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpOwogICAgICAgICAgdmFyIGUyID0gdGhpcy5yZWFkZXIucmVhZERhdGEodGhpcy56aXBDb21tZW50TGVuZ3RoKSwgdDIgPSBvLnVpbnQ4YXJyYXkgPyAidWludDhhcnJheSIgOiAiYXJyYXkiLCByMiA9IGkudHJhbnNmb3JtVG8odDIsIGUyKTsKICAgICAgICAgIHRoaXMuemlwQ29tbWVudCA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUocjIpOwogICAgICAgIH0sIHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KSwgdGhpcy5yZWFkZXIuc2tpcCg0KSwgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCg0KSwgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCksIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCg4KSwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCksIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpLCB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpLCB0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGEgPSB7fTsKICAgICAgICAgIGZvciAodmFyIGUyLCB0MiwgcjIsIG4yID0gdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUgLSA0NDsgMCA8IG4yOyApCiAgICAgICAgICAgIGUyID0gdGhpcy5yZWFkZXIucmVhZEludCgyKSwgdDIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpLCByMiA9IHRoaXMucmVhZGVyLnJlYWREYXRhKHQyKSwgdGhpcy56aXA2NEV4dGVuc2libGVEYXRhW2UyXSA9IHsgaWQ6IGUyLCBsZW5ndGg6IHQyLCB2YWx1ZTogcjIgfTsKICAgICAgICB9LCByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3I6IGZ1bmN0aW9uKCkgewogICAgICAgICAgaWYgKHRoaXMuZGlza1dpdGhaaXA2NENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCksIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCksIHRoaXMuZGlza3NDb3VudCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCksIDEgPCB0aGlzLmRpc2tzQ291bnQpCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiTXVsdGktdm9sdW1lcyB6aXAgYXJlIG5vdCBzdXBwb3J0ZWQiKTsKICAgICAgICB9LCByZWFkTG9jYWxGaWxlczogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgZTIsIHQyOwogICAgICAgICAgZm9yIChlMiA9IDA7IGUyIDwgdGhpcy5maWxlcy5sZW5ndGg7IGUyKyspCiAgICAgICAgICAgIHQyID0gdGhpcy5maWxlc1tlMl0sIHRoaXMucmVhZGVyLnNldEluZGV4KHQyLmxvY2FsSGVhZGVyT2Zmc2V0KSwgdGhpcy5jaGVja1NpZ25hdHVyZShzLkxPQ0FMX0ZJTEVfSEVBREVSKSwgdDIucmVhZExvY2FsUGFydCh0aGlzLnJlYWRlciksIHQyLmhhbmRsZVVURjgoKSwgdDIucHJvY2Vzc0F0dHJpYnV0ZXMoKTsKICAgICAgICB9LCByZWFkQ2VudHJhbERpcjogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgZTI7CiAgICAgICAgICBmb3IgKHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMuY2VudHJhbERpck9mZnNldCk7IHRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShzLkNFTlRSQUxfRklMRV9IRUFERVIpOyApCiAgICAgICAgICAgIChlMiA9IG5ldyBhKHsgemlwNjQ6IHRoaXMuemlwNjQgfSwgdGhpcy5sb2FkT3B0aW9ucykpLnJlYWRDZW50cmFsUGFydCh0aGlzLnJlYWRlciksIHRoaXMuZmlsZXMucHVzaChlMik7CiAgICAgICAgICBpZiAodGhpcy5jZW50cmFsRGlyUmVjb3JkcyAhPT0gdGhpcy5maWxlcy5sZW5ndGggJiYgMCAhPT0gdGhpcy5jZW50cmFsRGlyUmVjb3JkcyAmJiAwID09PSB0aGlzLmZpbGVzLmxlbmd0aCkKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJDb3JydXB0ZWQgemlwIG9yIGJ1ZzogZXhwZWN0ZWQgIiArIHRoaXMuY2VudHJhbERpclJlY29yZHMgKyAiIHJlY29yZHMgaW4gY2VudHJhbCBkaXIsIGdvdCAiICsgdGhpcy5maWxlcy5sZW5ndGgpOwogICAgICAgIH0sIHJlYWRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIGUyID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUocy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpOwogICAgICAgICAgaWYgKGUyIDwgMCkKICAgICAgICAgICAgdGhyb3cgIXRoaXMuaXNTaWduYXR1cmUoMCwgcy5MT0NBTF9GSUxFX0hFQURFUikgPyBuZXcgRXJyb3IoIkNhbid0IGZpbmQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IDogaXMgdGhpcyBhIHppcCBmaWxlID8gSWYgaXQgaXMsIHNlZSBodHRwczovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vaG93dG8vcmVhZF96aXAuaHRtbCIpIDogbmV3IEVycm9yKCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSIpOwogICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoZTIpOwogICAgICAgICAgdmFyIHQyID0gZTI7CiAgICAgICAgICBpZiAodGhpcy5jaGVja1NpZ25hdHVyZShzLkNFTlRSQUxfRElSRUNUT1JZX0VORCksIHRoaXMucmVhZEJsb2NrRW5kT2ZDZW50cmFsKCksIHRoaXMuZGlza051bWJlciA9PT0gaS5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPT09IGkuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzayA9PT0gaS5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHMgPT09IGkuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJTaXplID09PSBpLk1BWF9WQUxVRV8zMkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyT2Zmc2V0ID09PSBpLk1BWF9WQUxVRV8zMkJJVFMpIHsKICAgICAgICAgICAgaWYgKHRoaXMuemlwNjQgPSB0cnVlLCAoZTIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpKSA8IDApCiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvciIpOwogICAgICAgICAgICBpZiAodGhpcy5yZWFkZXIuc2V0SW5kZXgoZTIpLCB0aGlzLmNoZWNrU2lnbmF0dXJlKHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiksIHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yKCksICF0aGlzLmlzU2lnbmF0dXJlKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciwgcy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpICYmICh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCksIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA8IDApKQogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5Iik7CiAgICAgICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciksIHRoaXMuY2hlY2tTaWduYXR1cmUocy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpLCB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsKCk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgcjIgPSB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgKyB0aGlzLmNlbnRyYWxEaXJTaXplOwogICAgICAgICAgdGhpcy56aXA2NCAmJiAocjIgKz0gMjAsIHIyICs9IDEyICsgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUpOwogICAgICAgICAgdmFyIG4yID0gdDIgLSByMjsKICAgICAgICAgIGlmICgwIDwgbjIpCiAgICAgICAgICAgIHRoaXMuaXNTaWduYXR1cmUodDIsIHMuQ0VOVFJBTF9GSUxFX0hFQURFUikgfHwgKHRoaXMucmVhZGVyLnplcm8gPSBuMik7CiAgICAgICAgICBlbHNlIGlmIChuMiA8IDApCiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQ29ycnVwdGVkIHppcDogbWlzc2luZyAiICsgTWF0aC5hYnMobjIpICsgIiBieXRlcy4iKTsKICAgICAgICB9LCBwcmVwYXJlUmVhZGVyOiBmdW5jdGlvbihlMikgewogICAgICAgICAgdGhpcy5yZWFkZXIgPSBuKGUyKTsKICAgICAgICB9LCBsb2FkOiBmdW5jdGlvbihlMikgewogICAgICAgICAgdGhpcy5wcmVwYXJlUmVhZGVyKGUyKSwgdGhpcy5yZWFkRW5kT2ZDZW50cmFsKCksIHRoaXMucmVhZENlbnRyYWxEaXIoKSwgdGhpcy5yZWFkTG9jYWxGaWxlcygpOwogICAgICAgIH0gfSwgdC5leHBvcnRzID0gaDsKICAgICAgfSwgeyAiLi9yZWFkZXIvcmVhZGVyRm9yIjogMjIsICIuL3NpZ25hdHVyZSI6IDIzLCAiLi9zdXBwb3J0IjogMzAsICIuL3V0aWxzIjogMzIsICIuL3ppcEVudHJ5IjogMzQgfV0sIDM0OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBuID0gZSgiLi9yZWFkZXIvcmVhZGVyRm9yIiksIHMgPSBlKCIuL3V0aWxzIiksIGkgPSBlKCIuL2NvbXByZXNzZWRPYmplY3QiKSwgYSA9IGUoIi4vY3JjMzIiKSwgbyA9IGUoIi4vdXRmOCIpLCBoID0gZSgiLi9jb21wcmVzc2lvbnMiKSwgdSA9IGUoIi4vc3VwcG9ydCIpOwogICAgICAgIGZ1bmN0aW9uIGwoZTIsIHQyKSB7CiAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBlMiwgdGhpcy5sb2FkT3B0aW9ucyA9IHQyOwogICAgICAgIH0KICAgICAgICBsLnByb3RvdHlwZSA9IHsgaXNFbmNyeXB0ZWQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIDEgPT0gKDEgJiB0aGlzLmJpdEZsYWcpOwogICAgICAgIH0sIHVzZVVURjg6IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIDIwNDggPT0gKDIwNDggJiB0aGlzLmJpdEZsYWcpOwogICAgICAgIH0sIHJlYWRMb2NhbFBhcnQ6IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB2YXIgdDIsIHIyOwogICAgICAgICAgaWYgKGUyLnNraXAoMjIpLCB0aGlzLmZpbGVOYW1lTGVuZ3RoID0gZTIucmVhZEludCgyKSwgcjIgPSBlMi5yZWFkSW50KDIpLCB0aGlzLmZpbGVOYW1lID0gZTIucmVhZERhdGEodGhpcy5maWxlTmFtZUxlbmd0aCksIGUyLnNraXAocjIpLCAtMSA9PT0gdGhpcy5jb21wcmVzc2VkU2l6ZSB8fCAtMSA9PT0gdGhpcy51bmNvbXByZXNzZWRTaXplKQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkJ1ZyBvciBjb3JydXB0ZWQgemlwIDogZGlkbid0IGdldCBlbm91Z2ggaW5mb3JtYXRpb24gZnJvbSB0aGUgY2VudHJhbCBkaXJlY3RvcnkgKGNvbXByZXNzZWRTaXplID09PSAtMSB8fCB1bmNvbXByZXNzZWRTaXplID09PSAtMSkiKTsKICAgICAgICAgIGlmIChudWxsID09PSAodDIgPSBmdW5jdGlvbihlMykgewogICAgICAgICAgICBmb3IgKHZhciB0MyBpbiBoKQogICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaCwgdDMpICYmIGhbdDNdLm1hZ2ljID09PSBlMykKICAgICAgICAgICAgICAgIHJldHVybiBoW3QzXTsKICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9KHRoaXMuY29tcHJlc3Npb25NZXRob2QpKSkKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJDb3JydXB0ZWQgemlwIDogY29tcHJlc3Npb24gIiArIHMucHJldHR5KHRoaXMuY29tcHJlc3Npb25NZXRob2QpICsgIiB1bmtub3duIChpbm5lciBmaWxlIDogIiArIHMudHJhbnNmb3JtVG8oInN0cmluZyIsIHRoaXMuZmlsZU5hbWUpICsgIikiKTsKICAgICAgICAgIHRoaXMuZGVjb21wcmVzc2VkID0gbmV3IGkodGhpcy5jb21wcmVzc2VkU2l6ZSwgdGhpcy51bmNvbXByZXNzZWRTaXplLCB0aGlzLmNyYzMyLCB0MiwgZTIucmVhZERhdGEodGhpcy5jb21wcmVzc2VkU2l6ZSkpOwogICAgICAgIH0sIHJlYWRDZW50cmFsUGFydDogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHRoaXMudmVyc2lvbk1hZGVCeSA9IGUyLnJlYWRJbnQoMiksIGUyLnNraXAoMiksIHRoaXMuYml0RmxhZyA9IGUyLnJlYWRJbnQoMiksIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSBlMi5yZWFkU3RyaW5nKDIpLCB0aGlzLmRhdGUgPSBlMi5yZWFkRGF0ZSgpLCB0aGlzLmNyYzMyID0gZTIucmVhZEludCg0KSwgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGUyLnJlYWRJbnQoNCksIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IGUyLnJlYWRJbnQoNCk7CiAgICAgICAgICB2YXIgdDIgPSBlMi5yZWFkSW50KDIpOwogICAgICAgICAgaWYgKHRoaXMuZXh0cmFGaWVsZHNMZW5ndGggPSBlMi5yZWFkSW50KDIpLCB0aGlzLmZpbGVDb21tZW50TGVuZ3RoID0gZTIucmVhZEludCgyKSwgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSBlMi5yZWFkSW50KDIpLCB0aGlzLmludGVybmFsRmlsZUF0dHJpYnV0ZXMgPSBlMi5yZWFkSW50KDIpLCB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPSBlMi5yZWFkSW50KDQpLCB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gZTIucmVhZEludCg0KSwgdGhpcy5pc0VuY3J5cHRlZCgpKQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkVuY3J5cHRlZCB6aXAgYXJlIG5vdCBzdXBwb3J0ZWQiKTsKICAgICAgICAgIGUyLnNraXAodDIpLCB0aGlzLnJlYWRFeHRyYUZpZWxkcyhlMiksIHRoaXMucGFyc2VaSVA2NEV4dHJhRmllbGQoZTIpLCB0aGlzLmZpbGVDb21tZW50ID0gZTIucmVhZERhdGEodGhpcy5maWxlQ29tbWVudExlbmd0aCk7CiAgICAgICAgfSwgcHJvY2Vzc0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBudWxsLCB0aGlzLmRvc1Blcm1pc3Npb25zID0gbnVsbDsKICAgICAgICAgIHZhciBlMiA9IHRoaXMudmVyc2lvbk1hZGVCeSA+PiA4OwogICAgICAgICAgdGhpcy5kaXIgPSAhISgxNiAmIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyksIDAgPT0gZTIgJiYgKHRoaXMuZG9zUGVybWlzc2lvbnMgPSA2MyAmIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyksIDMgPT0gZTIgJiYgKHRoaXMudW5peFBlcm1pc3Npb25zID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID4+IDE2ICYgNjU1MzUpLCB0aGlzLmRpciB8fCAiLyIgIT09IHRoaXMuZmlsZU5hbWVTdHIuc2xpY2UoLTEpIHx8ICh0aGlzLmRpciA9IHRydWUpOwogICAgICAgIH0sIHBhcnNlWklQNjRFeHRyYUZpZWxkOiBmdW5jdGlvbigpIHsKICAgICAgICAgIGlmICh0aGlzLmV4dHJhRmllbGRzWzFdKSB7CiAgICAgICAgICAgIHZhciBlMiA9IG4odGhpcy5leHRyYUZpZWxkc1sxXS52YWx1ZSk7CiAgICAgICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gcy5NQVhfVkFMVUVfMzJCSVRTICYmICh0aGlzLnVuY29tcHJlc3NlZFNpemUgPSBlMi5yZWFkSW50KDgpKSwgdGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gcy5NQVhfVkFMVUVfMzJCSVRTICYmICh0aGlzLmNvbXByZXNzZWRTaXplID0gZTIucmVhZEludCg4KSksIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPT09IHMuTUFYX1ZBTFVFXzMyQklUUyAmJiAodGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IGUyLnJlYWRJbnQoOCkpLCB0aGlzLmRpc2tOdW1iZXJTdGFydCA9PT0gcy5NQVhfVkFMVUVfMzJCSVRTICYmICh0aGlzLmRpc2tOdW1iZXJTdGFydCA9IGUyLnJlYWRJbnQoNCkpOwogICAgICAgICAgfQogICAgICAgIH0sIHJlYWRFeHRyYUZpZWxkczogZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHZhciB0MiwgcjIsIG4yLCBpMiA9IGUyLmluZGV4ICsgdGhpcy5leHRyYUZpZWxkc0xlbmd0aDsKICAgICAgICAgIGZvciAodGhpcy5leHRyYUZpZWxkcyB8fCAodGhpcy5leHRyYUZpZWxkcyA9IHt9KTsgZTIuaW5kZXggKyA0IDwgaTI7ICkKICAgICAgICAgICAgdDIgPSBlMi5yZWFkSW50KDIpLCByMiA9IGUyLnJlYWRJbnQoMiksIG4yID0gZTIucmVhZERhdGEocjIpLCB0aGlzLmV4dHJhRmllbGRzW3QyXSA9IHsgaWQ6IHQyLCBsZW5ndGg6IHIyLCB2YWx1ZTogbjIgfTsKICAgICAgICAgIGUyLnNldEluZGV4KGkyKTsKICAgICAgICB9LCBoYW5kbGVVVEY4OiBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBlMiA9IHUudWludDhhcnJheSA/ICJ1aW50OGFycmF5IiA6ICJhcnJheSI7CiAgICAgICAgICBpZiAodGhpcy51c2VVVEY4KCkpCiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSBvLnV0ZjhkZWNvZGUodGhpcy5maWxlTmFtZSksIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSBvLnV0ZjhkZWNvZGUodGhpcy5maWxlQ29tbWVudCk7CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgdmFyIHQyID0gdGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoKCk7CiAgICAgICAgICAgIGlmIChudWxsICE9PSB0MikKICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdDI7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIHZhciByMiA9IHMudHJhbnNmb3JtVG8oZTIsIHRoaXMuZmlsZU5hbWUpOwogICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKHIyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgbjIgPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQoKTsKICAgICAgICAgICAgaWYgKG51bGwgIT09IG4yKQogICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSBuMjsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgdmFyIGkyID0gcy50cmFuc2Zvcm1UbyhlMiwgdGhpcy5maWxlQ29tbWVudCk7CiAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoaTIpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwgZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aDogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgZTIgPSB0aGlzLmV4dHJhRmllbGRzWzI4Nzg5XTsKICAgICAgICAgIGlmIChlMikgewogICAgICAgICAgICB2YXIgdDIgPSBuKGUyLnZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuIDEgIT09IHQyLnJlYWRJbnQoMSkgPyBudWxsIDogYSh0aGlzLmZpbGVOYW1lKSAhPT0gdDIucmVhZEludCg0KSA/IG51bGwgOiBvLnV0ZjhkZWNvZGUodDIucmVhZERhdGEoZTIubGVuZ3RoIC0gNSkpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfSwgZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudDogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgZTIgPSB0aGlzLmV4dHJhRmllbGRzWzI1NDYxXTsKICAgICAgICAgIGlmIChlMikgewogICAgICAgICAgICB2YXIgdDIgPSBuKGUyLnZhbHVlKTsKICAgICAgICAgICAgcmV0dXJuIDEgIT09IHQyLnJlYWRJbnQoMSkgPyBudWxsIDogYSh0aGlzLmZpbGVDb21tZW50KSAhPT0gdDIucmVhZEludCg0KSA/IG51bGwgOiBvLnV0ZjhkZWNvZGUodDIucmVhZERhdGEoZTIubGVuZ3RoIC0gNSkpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfSB9LCB0LmV4cG9ydHMgPSBsOwogICAgICB9LCB7ICIuL2NvbXByZXNzZWRPYmplY3QiOiAyLCAiLi9jb21wcmVzc2lvbnMiOiAzLCAiLi9jcmMzMiI6IDQsICIuL3JlYWRlci9yZWFkZXJGb3IiOiAyMiwgIi4vc3VwcG9ydCI6IDMwLCAiLi91dGY4IjogMzEsICIuL3V0aWxzIjogMzIgfV0sIDM1OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIGZ1bmN0aW9uIG4oZTIsIHQyLCByMikgewogICAgICAgICAgdGhpcy5uYW1lID0gZTIsIHRoaXMuZGlyID0gcjIuZGlyLCB0aGlzLmRhdGUgPSByMi5kYXRlLCB0aGlzLmNvbW1lbnQgPSByMi5jb21tZW50LCB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9IHIyLnVuaXhQZXJtaXNzaW9ucywgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IHIyLmRvc1Blcm1pc3Npb25zLCB0aGlzLl9kYXRhID0gdDIsIHRoaXMuX2RhdGFCaW5hcnkgPSByMi5iaW5hcnksIHRoaXMub3B0aW9ucyA9IHsgY29tcHJlc3Npb246IHIyLmNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnM6IHIyLmNvbXByZXNzaW9uT3B0aW9ucyB9OwogICAgICAgIH0KICAgICAgICB2YXIgcyA9IGUoIi4vc3RyZWFtL1N0cmVhbUhlbHBlciIpLCBpID0gZSgiLi9zdHJlYW0vRGF0YVdvcmtlciIpLCBhID0gZSgiLi91dGY4IiksIG8gPSBlKCIuL2NvbXByZXNzZWRPYmplY3QiKSwgaCA9IGUoIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXIiKTsKICAgICAgICBuLnByb3RvdHlwZSA9IHsgaW50ZXJuYWxTdHJlYW06IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB2YXIgdDIgPSBudWxsLCByMiA9ICJzdHJpbmciOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKCFlMikKICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIk5vIG91dHB1dCB0eXBlIHNwZWNpZmllZC4iKTsKICAgICAgICAgICAgdmFyIG4yID0gInN0cmluZyIgPT09IChyMiA9IGUyLnRvTG93ZXJDYXNlKCkpIHx8ICJ0ZXh0IiA9PT0gcjI7CiAgICAgICAgICAgICJiaW5hcnlzdHJpbmciICE9PSByMiAmJiAidGV4dCIgIT09IHIyIHx8IChyMiA9ICJzdHJpbmciKSwgdDIgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7CiAgICAgICAgICAgIHZhciBpMiA9ICF0aGlzLl9kYXRhQmluYXJ5OwogICAgICAgICAgICBpMiAmJiAhbjIgJiYgKHQyID0gdDIucGlwZShuZXcgYS5VdGY4RW5jb2RlV29ya2VyKCkpKSwgIWkyICYmIG4yICYmICh0MiA9IHQyLnBpcGUobmV3IGEuVXRmOERlY29kZVdvcmtlcigpKSk7CiAgICAgICAgICB9IGNhdGNoIChlMykgewogICAgICAgICAgICAodDIgPSBuZXcgaCgiZXJyb3IiKSkuZXJyb3IoZTMpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIG5ldyBzKHQyLCByMiwgIiIpOwogICAgICAgIH0sIGFzeW5jOiBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKGUyKS5hY2N1bXVsYXRlKHQyKTsKICAgICAgICB9LCBub2RlU3RyZWFtOiBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKGUyIHx8ICJub2RlYnVmZmVyIikudG9Ob2RlanNTdHJlYW0odDIpOwogICAgICAgIH0sIF9jb21wcmVzc1dvcmtlcjogZnVuY3Rpb24oZTIsIHQyKSB7CiAgICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIG8gJiYgdGhpcy5fZGF0YS5jb21wcmVzc2lvbi5tYWdpYyA9PT0gZTIubWFnaWMpCiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbXByZXNzZWRXb3JrZXIoKTsKICAgICAgICAgIHZhciByMiA9IHRoaXMuX2RlY29tcHJlc3NXb3JrZXIoKTsKICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhQmluYXJ5IHx8IChyMiA9IHIyLnBpcGUobmV3IGEuVXRmOEVuY29kZVdvcmtlcigpKSksIG8uY3JlYXRlV29ya2VyRnJvbShyMiwgZTIsIHQyKTsKICAgICAgICB9LCBfZGVjb21wcmVzc1dvcmtlcjogZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YSBpbnN0YW5jZW9mIG8gPyB0aGlzLl9kYXRhLmdldENvbnRlbnRXb3JrZXIoKSA6IHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBoID8gdGhpcy5fZGF0YSA6IG5ldyBpKHRoaXMuX2RhdGEpOwogICAgICAgIH0gfTsKICAgICAgICBmb3IgKHZhciB1ID0gWyJhc1RleHQiLCAiYXNCaW5hcnkiLCAiYXNOb2RlQnVmZmVyIiwgImFzVWludDhBcnJheSIsICJhc0FycmF5QnVmZmVyIl0sIGwgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS4iKTsKICAgICAgICB9LCBmID0gMDsgZiA8IHUubGVuZ3RoOyBmKyspCiAgICAgICAgICBuLnByb3RvdHlwZVt1W2ZdXSA9IGw7CiAgICAgICAgdC5leHBvcnRzID0gbjsKICAgICAgfSwgeyAiLi9jb21wcmVzc2VkT2JqZWN0IjogMiwgIi4vc3RyZWFtL0RhdGFXb3JrZXIiOiAyNywgIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXIiOiAyOCwgIi4vc3RyZWFtL1N0cmVhbUhlbHBlciI6IDI5LCAiLi91dGY4IjogMzEgfV0sIDM2OiBbZnVuY3Rpb24oZSwgbCwgdCkgewogICAgICAgIChmdW5jdGlvbih0MikgewogICAgICAgICAgdmFyIHIsIG4sIGUyID0gdDIuTXV0YXRpb25PYnNlcnZlciB8fCB0Mi5XZWJLaXRNdXRhdGlvbk9ic2VydmVyOwogICAgICAgICAgaWYgKGUyKSB7CiAgICAgICAgICAgIHZhciBpID0gMCwgcyA9IG5ldyBlMih1KSwgYSA9IHQyLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIiKTsKICAgICAgICAgICAgcy5vYnNlcnZlKGEsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KSwgciA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIGEuZGF0YSA9IGkgPSArK2kgJSAyOwogICAgICAgICAgICB9OwogICAgICAgICAgfSBlbHNlIGlmICh0Mi5zZXRJbW1lZGlhdGUgfHwgdm9pZCAwID09PSB0Mi5NZXNzYWdlQ2hhbm5lbCkKICAgICAgICAgICAgciA9ICJkb2N1bWVudCIgaW4gdDIgJiYgIm9ucmVhZHlzdGF0ZWNoYW5nZSIgaW4gdDIuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgic2NyaXB0IikgPyBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICB2YXIgZTMgPSB0Mi5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKTsKICAgICAgICAgICAgICBlMy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHUoKSwgZTMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbCwgZTMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlMyksIGUzID0gbnVsbDsKICAgICAgICAgICAgICB9LCB0Mi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZTMpOwogICAgICAgICAgICB9IDogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgc2V0VGltZW91dCh1LCAwKTsKICAgICAgICAgICAgfTsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICB2YXIgbyA9IG5ldyB0Mi5NZXNzYWdlQ2hhbm5lbCgpOwogICAgICAgICAgICBvLnBvcnQxLm9ubWVzc2FnZSA9IHUsIHIgPSBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICBvLnBvcnQyLnBvc3RNZXNzYWdlKDApOwogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgICAgdmFyIGggPSBbXTsKICAgICAgICAgIGZ1bmN0aW9uIHUoKSB7CiAgICAgICAgICAgIHZhciBlMywgdDM7CiAgICAgICAgICAgIG4gPSB0cnVlOwogICAgICAgICAgICBmb3IgKHZhciByMiA9IGgubGVuZ3RoOyByMjsgKSB7CiAgICAgICAgICAgICAgZm9yICh0MyA9IGgsIGggPSBbXSwgZTMgPSAtMTsgKytlMyA8IHIyOyApCiAgICAgICAgICAgICAgICB0M1tlM10oKTsKICAgICAgICAgICAgICByMiA9IGgubGVuZ3RoOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG4gPSBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICAgIGwuZXhwb3J0cyA9IGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgIDEgIT09IGgucHVzaChlMykgfHwgbiB8fCByKCk7CiAgICAgICAgICB9OwogICAgICAgIH0pLmNhbGwodGhpcywgInVuZGVmaW5lZCIgIT0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID8gY29tbW9uanNHbG9iYWwgOiAidW5kZWZpbmVkIiAhPSB0eXBlb2Ygc2VsZiA/IHNlbGYgOiAidW5kZWZpbmVkIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDoge30pOwogICAgICB9LCB7fV0sIDM3OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBpID0gZSgiaW1tZWRpYXRlIik7CiAgICAgICAgZnVuY3Rpb24gdSgpIHsKICAgICAgICB9CiAgICAgICAgdmFyIGwgPSB7fSwgcyA9IFsiUkVKRUNURUQiXSwgYSA9IFsiRlVMRklMTEVEIl0sIG4gPSBbIlBFTkRJTkciXTsKICAgICAgICBmdW5jdGlvbiBvKGUyKSB7CiAgICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgZTIpCiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoInJlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbiIpOwogICAgICAgICAgdGhpcy5zdGF0ZSA9IG4sIHRoaXMucXVldWUgPSBbXSwgdGhpcy5vdXRjb21lID0gdm9pZCAwLCBlMiAhPT0gdSAmJiBkKHRoaXMsIGUyKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaChlMiwgdDIsIHIyKSB7CiAgICAgICAgICB0aGlzLnByb21pc2UgPSBlMiwgImZ1bmN0aW9uIiA9PSB0eXBlb2YgdDIgJiYgKHRoaXMub25GdWxmaWxsZWQgPSB0MiwgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQpLCAiZnVuY3Rpb24iID09IHR5cGVvZiByMiAmJiAodGhpcy5vblJlamVjdGVkID0gcjIsIHRoaXMuY2FsbFJlamVjdGVkID0gdGhpcy5vdGhlckNhbGxSZWplY3RlZCk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGYodDIsIHIyLCBuMikgewogICAgICAgICAgaShmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIGUyOwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGUyID0gcjIobjIpOwogICAgICAgICAgICB9IGNhdGNoIChlMykgewogICAgICAgICAgICAgIHJldHVybiBsLnJlamVjdCh0MiwgZTMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGUyID09PSB0MiA/IGwucmVqZWN0KHQyLCBuZXcgVHlwZUVycm9yKCJDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmIikpIDogbC5yZXNvbHZlKHQyLCBlMik7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gYyhlMikgewogICAgICAgICAgdmFyIHQyID0gZTIgJiYgZTIudGhlbjsKICAgICAgICAgIGlmIChlMiAmJiAoIm9iamVjdCIgPT0gdHlwZW9mIGUyIHx8ICJmdW5jdGlvbiIgPT0gdHlwZW9mIGUyKSAmJiAiZnVuY3Rpb24iID09IHR5cGVvZiB0MikKICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgIHQyLmFwcGx5KGUyLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBkKHQyLCBlMikgewogICAgICAgICAgdmFyIHIyID0gZmFsc2U7CiAgICAgICAgICBmdW5jdGlvbiBuMihlMykgewogICAgICAgICAgICByMiB8fCAocjIgPSB0cnVlLCBsLnJlamVjdCh0MiwgZTMpKTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGkyKGUzKSB7CiAgICAgICAgICAgIHIyIHx8IChyMiA9IHRydWUsIGwucmVzb2x2ZSh0MiwgZTMpKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBzMiA9IHAoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIGUyKGkyLCBuMik7CiAgICAgICAgICB9KTsKICAgICAgICAgICJlcnJvciIgPT09IHMyLnN0YXR1cyAmJiBuMihzMi52YWx1ZSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHAoZTIsIHQyKSB7CiAgICAgICAgICB2YXIgcjIgPSB7fTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHIyLnZhbHVlID0gZTIodDIpLCByMi5zdGF0dXMgPSAic3VjY2VzcyI7CiAgICAgICAgICB9IGNhdGNoIChlMykgewogICAgICAgICAgICByMi5zdGF0dXMgPSAiZXJyb3IiLCByMi52YWx1ZSA9IGUzOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHIyOwogICAgICAgIH0KICAgICAgICAodC5leHBvcnRzID0gbykucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbih0MikgewogICAgICAgICAgaWYgKCJmdW5jdGlvbiIgIT0gdHlwZW9mIHQyKQogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgIHZhciByMiA9IHRoaXMuY29uc3RydWN0b3I7CiAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICAgIHJldHVybiByMi5yZXNvbHZlKHQyKCkpLnRoZW4oZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGUyOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0sIGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICAgIHJldHVybiByMi5yZXNvbHZlKHQyKCkpLnRoZW4oZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgdGhyb3cgZTI7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgfSwgby5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBlMik7CiAgICAgICAgfSwgby5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgaWYgKCJmdW5jdGlvbiIgIT0gdHlwZW9mIGUyICYmIHRoaXMuc3RhdGUgPT09IGEgfHwgImZ1bmN0aW9uIiAhPSB0eXBlb2YgdDIgJiYgdGhpcy5zdGF0ZSA9PT0gcykKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgICB2YXIgcjIgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih1KTsKICAgICAgICAgIHRoaXMuc3RhdGUgIT09IG4gPyBmKHIyLCB0aGlzLnN0YXRlID09PSBhID8gZTIgOiB0MiwgdGhpcy5vdXRjb21lKSA6IHRoaXMucXVldWUucHVzaChuZXcgaChyMiwgZTIsIHQyKSk7CiAgICAgICAgICByZXR1cm4gcjI7CiAgICAgICAgfSwgaC5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICBsLnJlc29sdmUodGhpcy5wcm9taXNlLCBlMik7CiAgICAgICAgfSwgaC5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGYodGhpcy5wcm9taXNlLCB0aGlzLm9uRnVsZmlsbGVkLCBlMik7CiAgICAgICAgfSwgaC5wcm90b3R5cGUuY2FsbFJlamVjdGVkID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGwucmVqZWN0KHRoaXMucHJvbWlzZSwgZTIpOwogICAgICAgIH0sIGgucHJvdG90eXBlLm90aGVyQ2FsbFJlamVjdGVkID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGYodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIGUyKTsKICAgICAgICB9LCBsLnJlc29sdmUgPSBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiA9IHAoYywgdDIpOwogICAgICAgICAgaWYgKCJlcnJvciIgPT09IHIyLnN0YXR1cykKICAgICAgICAgICAgcmV0dXJuIGwucmVqZWN0KGUyLCByMi52YWx1ZSk7CiAgICAgICAgICB2YXIgbjIgPSByMi52YWx1ZTsKICAgICAgICAgIGlmIChuMikKICAgICAgICAgICAgZChlMiwgbjIpOwogICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGUyLnN0YXRlID0gYSwgZTIub3V0Y29tZSA9IHQyOwogICAgICAgICAgICBmb3IgKHZhciBpMiA9IC0xLCBzMiA9IGUyLnF1ZXVlLmxlbmd0aDsgKytpMiA8IHMyOyApCiAgICAgICAgICAgICAgZTIucXVldWVbaTJdLmNhbGxGdWxmaWxsZWQodDIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGUyOwogICAgICAgIH0sIGwucmVqZWN0ID0gZnVuY3Rpb24oZTIsIHQyKSB7CiAgICAgICAgICBlMi5zdGF0ZSA9IHMsIGUyLm91dGNvbWUgPSB0MjsKICAgICAgICAgIGZvciAodmFyIHIyID0gLTEsIG4yID0gZTIucXVldWUubGVuZ3RoOyArK3IyIDwgbjI7ICkKICAgICAgICAgICAgZTIucXVldWVbcjJdLmNhbGxSZWplY3RlZCh0Mik7CiAgICAgICAgICByZXR1cm4gZTI7CiAgICAgICAgfSwgby5yZXNvbHZlID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGlmIChlMiBpbnN0YW5jZW9mIHRoaXMpCiAgICAgICAgICAgIHJldHVybiBlMjsKICAgICAgICAgIHJldHVybiBsLnJlc29sdmUobmV3IHRoaXModSksIGUyKTsKICAgICAgICB9LCBvLnJlamVjdCA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB2YXIgdDIgPSBuZXcgdGhpcyh1KTsKICAgICAgICAgIHJldHVybiBsLnJlamVjdCh0MiwgZTIpOwogICAgICAgIH0sIG8uYWxsID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHZhciByMiA9IHRoaXM7CiAgICAgICAgICBpZiAoIltvYmplY3QgQXJyYXldIiAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUyKSkKICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoIm11c3QgYmUgYW4gYXJyYXkiKSk7CiAgICAgICAgICB2YXIgbjIgPSBlMi5sZW5ndGgsIGkyID0gZmFsc2U7CiAgICAgICAgICBpZiAoIW4yKQogICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTsKICAgICAgICAgIHZhciBzMiA9IG5ldyBBcnJheShuMiksIGEyID0gMCwgdDIgPSAtMSwgbzIgPSBuZXcgdGhpcyh1KTsKICAgICAgICAgIGZvciAoOyArK3QyIDwgbjI7ICkKICAgICAgICAgICAgaDIoZTJbdDJdLCB0Mik7CiAgICAgICAgICByZXR1cm4gbzI7CiAgICAgICAgICBmdW5jdGlvbiBoMihlMywgdDMpIHsKICAgICAgICAgICAgcjIucmVzb2x2ZShlMykudGhlbihmdW5jdGlvbihlNCkgewogICAgICAgICAgICAgIHMyW3QzXSA9IGU0LCArK2EyICE9PSBuMiB8fCBpMiB8fCAoaTIgPSB0cnVlLCBsLnJlc29sdmUobzIsIHMyKSk7CiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGU0KSB7CiAgICAgICAgICAgICAgaTIgfHwgKGkyID0gdHJ1ZSwgbC5yZWplY3QobzIsIGU0KSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0sIG8ucmFjZSA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB2YXIgdDIgPSB0aGlzOwogICAgICAgICAgaWYgKCJbb2JqZWN0IEFycmF5XSIgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlMikpCiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCJtdXN0IGJlIGFuIGFycmF5IikpOwogICAgICAgICAgdmFyIHIyID0gZTIubGVuZ3RoLCBuMiA9IGZhbHNlOwogICAgICAgICAgaWYgKCFyMikKICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7CiAgICAgICAgICB2YXIgaTIgPSAtMSwgczIgPSBuZXcgdGhpcyh1KTsKICAgICAgICAgIGZvciAoOyArK2kyIDwgcjI7ICkKICAgICAgICAgICAgYTIgPSBlMltpMl0sIHQyLnJlc29sdmUoYTIpLnRoZW4oZnVuY3Rpb24oZTMpIHsKICAgICAgICAgICAgICBuMiB8fCAobjIgPSB0cnVlLCBsLnJlc29sdmUoczIsIGUzKSk7CiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgICAgbjIgfHwgKG4yID0gdHJ1ZSwgbC5yZWplY3QoczIsIGUzKSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgdmFyIGEyOwogICAgICAgICAgcmV0dXJuIHMyOwogICAgICAgIH07CiAgICAgIH0sIHsgaW1tZWRpYXRlOiAzNiB9XSwgMzg6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIG4gPSB7fTsKICAgICAgICAoMCwgZSgiLi9saWIvdXRpbHMvY29tbW9uIikuYXNzaWduKShuLCBlKCIuL2xpYi9kZWZsYXRlIiksIGUoIi4vbGliL2luZmxhdGUiKSwgZSgiLi9saWIvemxpYi9jb25zdGFudHMiKSksIHQuZXhwb3J0cyA9IG47CiAgICAgIH0sIHsgIi4vbGliL2RlZmxhdGUiOiAzOSwgIi4vbGliL2luZmxhdGUiOiA0MCwgIi4vbGliL3V0aWxzL2NvbW1vbiI6IDQxLCAiLi9saWIvemxpYi9jb25zdGFudHMiOiA0NCB9XSwgMzk6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIGEgPSBlKCIuL3psaWIvZGVmbGF0ZSIpLCBvID0gZSgiLi91dGlscy9jb21tb24iKSwgaCA9IGUoIi4vdXRpbHMvc3RyaW5ncyIpLCBpID0gZSgiLi96bGliL21lc3NhZ2VzIiksIHMgPSBlKCIuL3psaWIvenN0cmVhbSIpLCB1ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZywgbCA9IDAsIGYgPSAtMSwgYyA9IDAsIGQgPSA4OwogICAgICAgIGZ1bmN0aW9uIHAoZTIpIHsKICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBwKSkKICAgICAgICAgICAgcmV0dXJuIG5ldyBwKGUyKTsKICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG8uYXNzaWduKHsgbGV2ZWw6IGYsIG1ldGhvZDogZCwgY2h1bmtTaXplOiAxNjM4NCwgd2luZG93Qml0czogMTUsIG1lbUxldmVsOiA4LCBzdHJhdGVneTogYywgdG86ICIiIH0sIGUyIHx8IHt9KTsKICAgICAgICAgIHZhciB0MiA9IHRoaXMub3B0aW9uczsKICAgICAgICAgIHQyLnJhdyAmJiAwIDwgdDIud2luZG93Qml0cyA/IHQyLndpbmRvd0JpdHMgPSAtdDIud2luZG93Qml0cyA6IHQyLmd6aXAgJiYgMCA8IHQyLndpbmRvd0JpdHMgJiYgdDIud2luZG93Qml0cyA8IDE2ICYmICh0Mi53aW5kb3dCaXRzICs9IDE2KSwgdGhpcy5lcnIgPSAwLCB0aGlzLm1zZyA9ICIiLCB0aGlzLmVuZGVkID0gZmFsc2UsIHRoaXMuY2h1bmtzID0gW10sIHRoaXMuc3RybSA9IG5ldyBzKCksIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgICAgdmFyIHIyID0gYS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLCB0Mi5sZXZlbCwgdDIubWV0aG9kLCB0Mi53aW5kb3dCaXRzLCB0Mi5tZW1MZXZlbCwgdDIuc3RyYXRlZ3kpOwogICAgICAgICAgaWYgKHIyICE9PSBsKQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaVtyMl0pOwogICAgICAgICAgaWYgKHQyLmhlYWRlciAmJiBhLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCB0Mi5oZWFkZXIpLCB0Mi5kaWN0aW9uYXJ5KSB7CiAgICAgICAgICAgIHZhciBuMjsKICAgICAgICAgICAgaWYgKG4yID0gInN0cmluZyIgPT0gdHlwZW9mIHQyLmRpY3Rpb25hcnkgPyBoLnN0cmluZzJidWYodDIuZGljdGlvbmFyeSkgOiAiW29iamVjdCBBcnJheUJ1ZmZlcl0iID09PSB1LmNhbGwodDIuZGljdGlvbmFyeSkgPyBuZXcgVWludDhBcnJheSh0Mi5kaWN0aW9uYXJ5KSA6IHQyLmRpY3Rpb25hcnksIChyMiA9IGEuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBuMikpICE9PSBsKQogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpW3IyXSk7CiAgICAgICAgICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbihlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiA9IG5ldyBwKHQyKTsKICAgICAgICAgIGlmIChyMi5wdXNoKGUyLCB0cnVlKSwgcjIuZXJyKQogICAgICAgICAgICB0aHJvdyByMi5tc2cgfHwgaVtyMi5lcnJdOwogICAgICAgICAgcmV0dXJuIHIyLnJlc3VsdDsKICAgICAgICB9CiAgICAgICAgcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgdmFyIHIyLCBuMiwgaTIgPSB0aGlzLnN0cm0sIHMyID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTsKICAgICAgICAgIGlmICh0aGlzLmVuZGVkKQogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICBuMiA9IHQyID09PSB+fnQyID8gdDIgOiB0cnVlID09PSB0MiA/IDQgOiAwLCAic3RyaW5nIiA9PSB0eXBlb2YgZTIgPyBpMi5pbnB1dCA9IGguc3RyaW5nMmJ1ZihlMikgOiAiW29iamVjdCBBcnJheUJ1ZmZlcl0iID09PSB1LmNhbGwoZTIpID8gaTIuaW5wdXQgPSBuZXcgVWludDhBcnJheShlMikgOiBpMi5pbnB1dCA9IGUyLCBpMi5uZXh0X2luID0gMCwgaTIuYXZhaWxfaW4gPSBpMi5pbnB1dC5sZW5ndGg7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGlmICgwID09PSBpMi5hdmFpbF9vdXQgJiYgKGkyLm91dHB1dCA9IG5ldyBvLkJ1ZjgoczIpLCBpMi5uZXh0X291dCA9IDAsIGkyLmF2YWlsX291dCA9IHMyKSwgMSAhPT0gKHIyID0gYS5kZWZsYXRlKGkyLCBuMikpICYmIHIyICE9PSBsKQogICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRW5kKHIyKSwgISh0aGlzLmVuZGVkID0gdHJ1ZSk7CiAgICAgICAgICAgIDAgIT09IGkyLmF2YWlsX291dCAmJiAoMCAhPT0gaTIuYXZhaWxfaW4gfHwgNCAhPT0gbjIgJiYgMiAhPT0gbjIpIHx8ICgic3RyaW5nIiA9PT0gdGhpcy5vcHRpb25zLnRvID8gdGhpcy5vbkRhdGEoaC5idWYyYmluc3RyaW5nKG8uc2hyaW5rQnVmKGkyLm91dHB1dCwgaTIubmV4dF9vdXQpKSkgOiB0aGlzLm9uRGF0YShvLnNocmlua0J1ZihpMi5vdXRwdXQsIGkyLm5leHRfb3V0KSkpOwogICAgICAgICAgfSB3aGlsZSAoKDAgPCBpMi5hdmFpbF9pbiB8fCAwID09PSBpMi5hdmFpbF9vdXQpICYmIDEgIT09IHIyKTsKICAgICAgICAgIHJldHVybiA0ID09PSBuMiA/IChyMiA9IGEuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pLCB0aGlzLm9uRW5kKHIyKSwgdGhpcy5lbmRlZCA9IHRydWUsIHIyID09PSBsKSA6IDIgIT09IG4yIHx8ICh0aGlzLm9uRW5kKGwpLCAhKGkyLmF2YWlsX291dCA9IDApKTsKICAgICAgICB9LCBwLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgdGhpcy5jaHVua3MucHVzaChlMik7CiAgICAgICAgfSwgcC5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgZTIgPT09IGwgJiYgKCJzdHJpbmciID09PSB0aGlzLm9wdGlvbnMudG8gPyB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oIiIpIDogdGhpcy5yZXN1bHQgPSBvLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpKSwgdGhpcy5jaHVua3MgPSBbXSwgdGhpcy5lcnIgPSBlMiwgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnOwogICAgICAgIH0sIHIuRGVmbGF0ZSA9IHAsIHIuZGVmbGF0ZSA9IG4sIHIuZGVmbGF0ZVJhdyA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgcmV0dXJuICh0MiA9IHQyIHx8IHt9KS5yYXcgPSB0cnVlLCBuKGUyLCB0Mik7CiAgICAgICAgfSwgci5nemlwID0gZnVuY3Rpb24oZTIsIHQyKSB7CiAgICAgICAgICByZXR1cm4gKHQyID0gdDIgfHwge30pLmd6aXAgPSB0cnVlLCBuKGUyLCB0Mik7CiAgICAgICAgfTsKICAgICAgfSwgeyAiLi91dGlscy9jb21tb24iOiA0MSwgIi4vdXRpbHMvc3RyaW5ncyI6IDQyLCAiLi96bGliL2RlZmxhdGUiOiA0NiwgIi4vemxpYi9tZXNzYWdlcyI6IDUxLCAiLi96bGliL3pzdHJlYW0iOiA1MyB9XSwgNDA6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIGMgPSBlKCIuL3psaWIvaW5mbGF0ZSIpLCBkID0gZSgiLi91dGlscy9jb21tb24iKSwgcCA9IGUoIi4vdXRpbHMvc3RyaW5ncyIpLCBtID0gZSgiLi96bGliL2NvbnN0YW50cyIpLCBuID0gZSgiLi96bGliL21lc3NhZ2VzIiksIGkgPSBlKCIuL3psaWIvenN0cmVhbSIpLCBzID0gZSgiLi96bGliL2d6aGVhZGVyIiksIF8gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nOwogICAgICAgIGZ1bmN0aW9uIGEoZTIpIHsKICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBhKSkKICAgICAgICAgICAgcmV0dXJuIG5ldyBhKGUyKTsKICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGQuYXNzaWduKHsgY2h1bmtTaXplOiAxNjM4NCwgd2luZG93Qml0czogMCwgdG86ICIiIH0sIGUyIHx8IHt9KTsKICAgICAgICAgIHZhciB0MiA9IHRoaXMub3B0aW9uczsKICAgICAgICAgIHQyLnJhdyAmJiAwIDw9IHQyLndpbmRvd0JpdHMgJiYgdDIud2luZG93Qml0cyA8IDE2ICYmICh0Mi53aW5kb3dCaXRzID0gLXQyLndpbmRvd0JpdHMsIDAgPT09IHQyLndpbmRvd0JpdHMgJiYgKHQyLndpbmRvd0JpdHMgPSAtMTUpKSwgISgwIDw9IHQyLndpbmRvd0JpdHMgJiYgdDIud2luZG93Qml0cyA8IDE2KSB8fCBlMiAmJiBlMi53aW5kb3dCaXRzIHx8ICh0Mi53aW5kb3dCaXRzICs9IDMyKSwgMTUgPCB0Mi53aW5kb3dCaXRzICYmIHQyLndpbmRvd0JpdHMgPCA0OCAmJiAwID09ICgxNSAmIHQyLndpbmRvd0JpdHMpICYmICh0Mi53aW5kb3dCaXRzIHw9IDE1KSwgdGhpcy5lcnIgPSAwLCB0aGlzLm1zZyA9ICIiLCB0aGlzLmVuZGVkID0gZmFsc2UsIHRoaXMuY2h1bmtzID0gW10sIHRoaXMuc3RybSA9IG5ldyBpKCksIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwOwogICAgICAgICAgdmFyIHIyID0gYy5pbmZsYXRlSW5pdDIodGhpcy5zdHJtLCB0Mi53aW5kb3dCaXRzKTsKICAgICAgICAgIGlmIChyMiAhPT0gbS5aX09LKQogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobltyMl0pOwogICAgICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgcygpLCBjLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG8oZTIsIHQyKSB7CiAgICAgICAgICB2YXIgcjIgPSBuZXcgYSh0Mik7CiAgICAgICAgICBpZiAocjIucHVzaChlMiwgdHJ1ZSksIHIyLmVycikKICAgICAgICAgICAgdGhyb3cgcjIubXNnIHx8IG5bcjIuZXJyXTsKICAgICAgICAgIHJldHVybiByMi5yZXN1bHQ7CiAgICAgICAgfQogICAgICAgIGEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiwgbjIsIGkyLCBzMiwgYTIsIG8yLCBoID0gdGhpcy5zdHJtLCB1ID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZSwgbCA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5LCBmID0gZmFsc2U7CiAgICAgICAgICBpZiAodGhpcy5lbmRlZCkKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgbjIgPSB0MiA9PT0gfn50MiA/IHQyIDogdHJ1ZSA9PT0gdDIgPyBtLlpfRklOSVNIIDogbS5aX05PX0ZMVVNILCAic3RyaW5nIiA9PSB0eXBlb2YgZTIgPyBoLmlucHV0ID0gcC5iaW5zdHJpbmcyYnVmKGUyKSA6ICJbb2JqZWN0IEFycmF5QnVmZmVyXSIgPT09IF8uY2FsbChlMikgPyBoLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZTIpIDogaC5pbnB1dCA9IGUyLCBoLm5leHRfaW4gPSAwLCBoLmF2YWlsX2luID0gaC5pbnB1dC5sZW5ndGg7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIGlmICgwID09PSBoLmF2YWlsX291dCAmJiAoaC5vdXRwdXQgPSBuZXcgZC5CdWY4KHUpLCBoLm5leHRfb3V0ID0gMCwgaC5hdmFpbF9vdXQgPSB1KSwgKHIyID0gYy5pbmZsYXRlKGgsIG0uWl9OT19GTFVTSCkpID09PSBtLlpfTkVFRF9ESUNUICYmIGwgJiYgKG8yID0gInN0cmluZyIgPT0gdHlwZW9mIGwgPyBwLnN0cmluZzJidWYobCkgOiAiW29iamVjdCBBcnJheUJ1ZmZlcl0iID09PSBfLmNhbGwobCkgPyBuZXcgVWludDhBcnJheShsKSA6IGwsIHIyID0gYy5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG8yKSksIHIyID09PSBtLlpfQlVGX0VSUk9SICYmIHRydWUgPT09IGYgJiYgKHIyID0gbS5aX09LLCBmID0gZmFsc2UpLCByMiAhPT0gbS5aX1NUUkVBTV9FTkQgJiYgcjIgIT09IG0uWl9PSykKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vbkVuZChyMiksICEodGhpcy5lbmRlZCA9IHRydWUpOwogICAgICAgICAgICBoLm5leHRfb3V0ICYmICgwICE9PSBoLmF2YWlsX291dCAmJiByMiAhPT0gbS5aX1NUUkVBTV9FTkQgJiYgKDAgIT09IGguYXZhaWxfaW4gfHwgbjIgIT09IG0uWl9GSU5JU0ggJiYgbjIgIT09IG0uWl9TWU5DX0ZMVVNIKSB8fCAoInN0cmluZyIgPT09IHRoaXMub3B0aW9ucy50byA/IChpMiA9IHAudXRmOGJvcmRlcihoLm91dHB1dCwgaC5uZXh0X291dCksIHMyID0gaC5uZXh0X291dCAtIGkyLCBhMiA9IHAuYnVmMnN0cmluZyhoLm91dHB1dCwgaTIpLCBoLm5leHRfb3V0ID0gczIsIGguYXZhaWxfb3V0ID0gdSAtIHMyLCBzMiAmJiBkLmFycmF5U2V0KGgub3V0cHV0LCBoLm91dHB1dCwgaTIsIHMyLCAwKSwgdGhpcy5vbkRhdGEoYTIpKSA6IHRoaXMub25EYXRhKGQuc2hyaW5rQnVmKGgub3V0cHV0LCBoLm5leHRfb3V0KSkpKSwgMCA9PT0gaC5hdmFpbF9pbiAmJiAwID09PSBoLmF2YWlsX291dCAmJiAoZiA9IHRydWUpOwogICAgICAgICAgfSB3aGlsZSAoKDAgPCBoLmF2YWlsX2luIHx8IDAgPT09IGguYXZhaWxfb3V0KSAmJiByMiAhPT0gbS5aX1NUUkVBTV9FTkQpOwogICAgICAgICAgcmV0dXJuIHIyID09PSBtLlpfU1RSRUFNX0VORCAmJiAobjIgPSBtLlpfRklOSVNIKSwgbjIgPT09IG0uWl9GSU5JU0ggPyAocjIgPSBjLmluZmxhdGVFbmQodGhpcy5zdHJtKSwgdGhpcy5vbkVuZChyMiksIHRoaXMuZW5kZWQgPSB0cnVlLCByMiA9PT0gbS5aX09LKSA6IG4yICE9PSBtLlpfU1lOQ19GTFVTSCB8fCAodGhpcy5vbkVuZChtLlpfT0spLCAhKGguYXZhaWxfb3V0ID0gMCkpOwogICAgICAgIH0sIGEucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGUyKTsKICAgICAgICB9LCBhLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICBlMiA9PT0gbS5aX09LICYmICgic3RyaW5nIiA9PT0gdGhpcy5vcHRpb25zLnRvID8gdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCIiKSA6IHRoaXMucmVzdWx0ID0gZC5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKSksIHRoaXMuY2h1bmtzID0gW10sIHRoaXMuZXJyID0gZTIsIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZzsKICAgICAgICB9LCByLkluZmxhdGUgPSBhLCByLmluZmxhdGUgPSBvLCByLmluZmxhdGVSYXcgPSBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHJldHVybiAodDIgPSB0MiB8fCB7fSkucmF3ID0gdHJ1ZSwgbyhlMiwgdDIpOwogICAgICAgIH0sIHIudW5nemlwID0gbzsKICAgICAgfSwgeyAiLi91dGlscy9jb21tb24iOiA0MSwgIi4vdXRpbHMvc3RyaW5ncyI6IDQyLCAiLi96bGliL2NvbnN0YW50cyI6IDQ0LCAiLi96bGliL2d6aGVhZGVyIjogNDcsICIuL3psaWIvaW5mbGF0ZSI6IDQ5LCAiLi96bGliL21lc3NhZ2VzIjogNTEsICIuL3psaWIvenN0cmVhbSI6IDUzIH1dLCA0MTogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgbiA9ICJ1bmRlZmluZWQiICE9IHR5cGVvZiBVaW50OEFycmF5ICYmICJ1bmRlZmluZWQiICE9IHR5cGVvZiBVaW50MTZBcnJheSAmJiAidW5kZWZpbmVkIiAhPSB0eXBlb2YgSW50MzJBcnJheTsKICAgICAgICByLmFzc2lnbiA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICBmb3IgKHZhciB0MiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IHQyLmxlbmd0aDsgKSB7CiAgICAgICAgICAgIHZhciByMiA9IHQyLnNoaWZ0KCk7CiAgICAgICAgICAgIGlmIChyMikgewogICAgICAgICAgICAgIGlmICgib2JqZWN0IiAhPSB0eXBlb2YgcjIpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHIyICsgIm11c3QgYmUgbm9uLW9iamVjdCIpOwogICAgICAgICAgICAgIGZvciAodmFyIG4yIGluIHIyKQogICAgICAgICAgICAgICAgcjIuaGFzT3duUHJvcGVydHkobjIpICYmIChlMltuMl0gPSByMltuMl0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZTI7CiAgICAgICAgfSwgci5zaHJpbmtCdWYgPSBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHJldHVybiBlMi5sZW5ndGggPT09IHQyID8gZTIgOiBlMi5zdWJhcnJheSA/IGUyLnN1YmFycmF5KDAsIHQyKSA6IChlMi5sZW5ndGggPSB0MiwgZTIpOwogICAgICAgIH07CiAgICAgICAgdmFyIGkgPSB7IGFycmF5U2V0OiBmdW5jdGlvbihlMiwgdDIsIHIyLCBuMiwgaTIpIHsKICAgICAgICAgIGlmICh0Mi5zdWJhcnJheSAmJiBlMi5zdWJhcnJheSkKICAgICAgICAgICAgZTIuc2V0KHQyLnN1YmFycmF5KHIyLCByMiArIG4yKSwgaTIpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBmb3IgKHZhciBzMiA9IDA7IHMyIDwgbjI7IHMyKyspCiAgICAgICAgICAgICAgZTJbaTIgKyBzMl0gPSB0MltyMiArIHMyXTsKICAgICAgICB9LCBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihlMikgewogICAgICAgICAgdmFyIHQyLCByMiwgbjIsIGkyLCBzMiwgYTsKICAgICAgICAgIGZvciAodDIgPSBuMiA9IDAsIHIyID0gZTIubGVuZ3RoOyB0MiA8IHIyOyB0MisrKQogICAgICAgICAgICBuMiArPSBlMlt0Ml0ubGVuZ3RoOwogICAgICAgICAgZm9yIChhID0gbmV3IFVpbnQ4QXJyYXkobjIpLCB0MiA9IGkyID0gMCwgcjIgPSBlMi5sZW5ndGg7IHQyIDwgcjI7IHQyKyspCiAgICAgICAgICAgIHMyID0gZTJbdDJdLCBhLnNldChzMiwgaTIpLCBpMiArPSBzMi5sZW5ndGg7CiAgICAgICAgICByZXR1cm4gYTsKICAgICAgICB9IH0sIHMgPSB7IGFycmF5U2V0OiBmdW5jdGlvbihlMiwgdDIsIHIyLCBuMiwgaTIpIHsKICAgICAgICAgIGZvciAodmFyIHMyID0gMDsgczIgPCBuMjsgczIrKykKICAgICAgICAgICAgZTJbaTIgKyBzMl0gPSB0MltyMiArIHMyXTsKICAgICAgICB9LCBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgZTIpOwogICAgICAgIH0gfTsKICAgICAgICByLnNldFR5cGVkID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGUyID8gKHIuQnVmOCA9IFVpbnQ4QXJyYXksIHIuQnVmMTYgPSBVaW50MTZBcnJheSwgci5CdWYzMiA9IEludDMyQXJyYXksIHIuYXNzaWduKHIsIGkpKSA6IChyLkJ1ZjggPSBBcnJheSwgci5CdWYxNiA9IEFycmF5LCByLkJ1ZjMyID0gQXJyYXksIHIuYXNzaWduKHIsIHMpKTsKICAgICAgICB9LCByLnNldFR5cGVkKG4pOwogICAgICB9LCB7fV0sIDQyOiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBoID0gZSgiLi9jb21tb24iKSwgaSA9IHRydWUsIHMgPSB0cnVlOwogICAgICAgIHRyeSB7CiAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIFswXSk7CiAgICAgICAgfSBjYXRjaCAoZTIpIHsKICAgICAgICAgIGkgPSBmYWxzZTsKICAgICAgICB9CiAgICAgICAgdHJ5IHsKICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOwogICAgICAgIH0gY2F0Y2ggKGUyKSB7CiAgICAgICAgICBzID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIGZvciAodmFyIHUgPSBuZXcgaC5CdWY4KDI1NiksIG4gPSAwOyBuIDwgMjU2OyBuKyspCiAgICAgICAgICB1W25dID0gMjUyIDw9IG4gPyA2IDogMjQ4IDw9IG4gPyA1IDogMjQwIDw9IG4gPyA0IDogMjI0IDw9IG4gPyAzIDogMTkyIDw9IG4gPyAyIDogMTsKICAgICAgICBmdW5jdGlvbiBsKGUyLCB0MikgewogICAgICAgICAgaWYgKHQyIDwgNjU1MzcgJiYgKGUyLnN1YmFycmF5ICYmIHMgfHwgIWUyLnN1YmFycmF5ICYmIGkpKQogICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBoLnNocmlua0J1ZihlMiwgdDIpKTsKICAgICAgICAgIGZvciAodmFyIHIyID0gIiIsIG4yID0gMDsgbjIgPCB0MjsgbjIrKykKICAgICAgICAgICAgcjIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlMltuMl0pOwogICAgICAgICAgcmV0dXJuIHIyOwogICAgICAgIH0KICAgICAgICB1WzI1NF0gPSB1WzI1NF0gPSAxLCByLnN0cmluZzJidWYgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgdmFyIHQyLCByMiwgbjIsIGkyLCBzMiwgYSA9IGUyLmxlbmd0aCwgbyA9IDA7CiAgICAgICAgICBmb3IgKGkyID0gMDsgaTIgPCBhOyBpMisrKQogICAgICAgICAgICA1NTI5NiA9PSAoNjQ1MTIgJiAocjIgPSBlMi5jaGFyQ29kZUF0KGkyKSkpICYmIGkyICsgMSA8IGEgJiYgNTYzMjAgPT0gKDY0NTEyICYgKG4yID0gZTIuY2hhckNvZGVBdChpMiArIDEpKSkgJiYgKHIyID0gNjU1MzYgKyAocjIgLSA1NTI5NiA8PCAxMCkgKyAobjIgLSA1NjMyMCksIGkyKyspLCBvICs9IHIyIDwgMTI4ID8gMSA6IHIyIDwgMjA0OCA/IDIgOiByMiA8IDY1NTM2ID8gMyA6IDQ7CiAgICAgICAgICBmb3IgKHQyID0gbmV3IGguQnVmOChvKSwgaTIgPSBzMiA9IDA7IHMyIDwgbzsgaTIrKykKICAgICAgICAgICAgNTUyOTYgPT0gKDY0NTEyICYgKHIyID0gZTIuY2hhckNvZGVBdChpMikpKSAmJiBpMiArIDEgPCBhICYmIDU2MzIwID09ICg2NDUxMiAmIChuMiA9IGUyLmNoYXJDb2RlQXQoaTIgKyAxKSkpICYmIChyMiA9IDY1NTM2ICsgKHIyIC0gNTUyOTYgPDwgMTApICsgKG4yIC0gNTYzMjApLCBpMisrKSwgcjIgPCAxMjggPyB0MltzMisrXSA9IHIyIDogKHIyIDwgMjA0OCA/IHQyW3MyKytdID0gMTkyIHwgcjIgPj4+IDYgOiAocjIgPCA2NTUzNiA/IHQyW3MyKytdID0gMjI0IHwgcjIgPj4+IDEyIDogKHQyW3MyKytdID0gMjQwIHwgcjIgPj4+IDE4LCB0MltzMisrXSA9IDEyOCB8IHIyID4+PiAxMiAmIDYzKSwgdDJbczIrK10gPSAxMjggfCByMiA+Pj4gNiAmIDYzKSwgdDJbczIrK10gPSAxMjggfCA2MyAmIHIyKTsKICAgICAgICAgIHJldHVybiB0MjsKICAgICAgICB9LCByLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIGwoZTIsIGUyLmxlbmd0aCk7CiAgICAgICAgfSwgci5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGZvciAodmFyIHQyID0gbmV3IGguQnVmOChlMi5sZW5ndGgpLCByMiA9IDAsIG4yID0gdDIubGVuZ3RoOyByMiA8IG4yOyByMisrKQogICAgICAgICAgICB0MltyMl0gPSBlMi5jaGFyQ29kZUF0KHIyKTsKICAgICAgICAgIHJldHVybiB0MjsKICAgICAgICB9LCByLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiwgbjIsIGkyLCBzMiwgYSA9IHQyIHx8IGUyLmxlbmd0aCwgbyA9IG5ldyBBcnJheSgyICogYSk7CiAgICAgICAgICBmb3IgKHIyID0gbjIgPSAwOyByMiA8IGE7ICkKICAgICAgICAgICAgaWYgKChpMiA9IGUyW3IyKytdKSA8IDEyOCkKICAgICAgICAgICAgICBvW24yKytdID0gaTI7CiAgICAgICAgICAgIGVsc2UgaWYgKDQgPCAoczIgPSB1W2kyXSkpCiAgICAgICAgICAgICAgb1tuMisrXSA9IDY1NTMzLCByMiArPSBzMiAtIDE7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIGZvciAoaTIgJj0gMiA9PT0gczIgPyAzMSA6IDMgPT09IHMyID8gMTUgOiA3OyAxIDwgczIgJiYgcjIgPCBhOyApCiAgICAgICAgICAgICAgICBpMiA9IGkyIDw8IDYgfCA2MyAmIGUyW3IyKytdLCBzMi0tOwogICAgICAgICAgICAgIDEgPCBzMiA/IG9bbjIrK10gPSA2NTUzMyA6IGkyIDwgNjU1MzYgPyBvW24yKytdID0gaTIgOiAoaTIgLT0gNjU1MzYsIG9bbjIrK10gPSA1NTI5NiB8IGkyID4+IDEwICYgMTAyMywgb1tuMisrXSA9IDU2MzIwIHwgMTAyMyAmIGkyKTsKICAgICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGwobywgbjIpOwogICAgICAgIH0sIHIudXRmOGJvcmRlciA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgdmFyIHIyOwogICAgICAgICAgZm9yICgodDIgPSB0MiB8fCBlMi5sZW5ndGgpID4gZTIubGVuZ3RoICYmICh0MiA9IGUyLmxlbmd0aCksIHIyID0gdDIgLSAxOyAwIDw9IHIyICYmIDEyOCA9PSAoMTkyICYgZTJbcjJdKTsgKQogICAgICAgICAgICByMi0tOwogICAgICAgICAgcmV0dXJuIHIyIDwgMCA/IHQyIDogMCA9PT0gcjIgPyB0MiA6IHIyICsgdVtlMltyMl1dID4gdDIgPyByMiA6IHQyOwogICAgICAgIH07CiAgICAgIH0sIHsgIi4vY29tbW9uIjogNDEgfV0sIDQzOiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uKGUyLCB0MiwgcjIsIG4pIHsKICAgICAgICAgIGZvciAodmFyIGkgPSA2NTUzNSAmIGUyIHwgMCwgcyA9IGUyID4+PiAxNiAmIDY1NTM1IHwgMCwgYSA9IDA7IDAgIT09IHIyOyApIHsKICAgICAgICAgICAgZm9yIChyMiAtPSBhID0gMmUzIDwgcjIgPyAyZTMgOiByMjsgcyA9IHMgKyAoaSA9IGkgKyB0MltuKytdIHwgMCkgfCAwLCAtLWE7ICkKICAgICAgICAgICAgICA7CiAgICAgICAgICAgIGkgJT0gNjU1MjEsIHMgJT0gNjU1MjE7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gaSB8IHMgPDwgMTYgfCAwOwogICAgICAgIH07CiAgICAgIH0sIHt9XSwgNDQ6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdC5leHBvcnRzID0geyBaX05PX0ZMVVNIOiAwLCBaX1BBUlRJQUxfRkxVU0g6IDEsIFpfU1lOQ19GTFVTSDogMiwgWl9GVUxMX0ZMVVNIOiAzLCBaX0ZJTklTSDogNCwgWl9CTE9DSzogNSwgWl9UUkVFUzogNiwgWl9PSzogMCwgWl9TVFJFQU1fRU5EOiAxLCBaX05FRURfRElDVDogMiwgWl9FUlJOTzogLTEsIFpfU1RSRUFNX0VSUk9SOiAtMiwgWl9EQVRBX0VSUk9SOiAtMywgWl9CVUZfRVJST1I6IC01LCBaX05PX0NPTVBSRVNTSU9OOiAwLCBaX0JFU1RfU1BFRUQ6IDEsIFpfQkVTVF9DT01QUkVTU0lPTjogOSwgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAtMSwgWl9GSUxURVJFRDogMSwgWl9IVUZGTUFOX09OTFk6IDIsIFpfUkxFOiAzLCBaX0ZJWEVEOiA0LCBaX0RFRkFVTFRfU1RSQVRFR1k6IDAsIFpfQklOQVJZOiAwLCBaX1RFWFQ6IDEsIFpfVU5LTk9XTjogMiwgWl9ERUZMQVRFRDogOCB9OwogICAgICB9LCB7fV0sIDQ1OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBvID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICBmb3IgKHZhciBlMiwgdDIgPSBbXSwgcjIgPSAwOyByMiA8IDI1NjsgcjIrKykgewogICAgICAgICAgICBlMiA9IHIyOwogICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDg7IG4rKykKICAgICAgICAgICAgICBlMiA9IDEgJiBlMiA/IDM5ODgyOTIzODQgXiBlMiA+Pj4gMSA6IGUyID4+PiAxOwogICAgICAgICAgICB0MltyMl0gPSBlMjsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0MjsKICAgICAgICB9KCk7CiAgICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oZTIsIHQyLCByMiwgbikgewogICAgICAgICAgdmFyIGkgPSBvLCBzID0gbiArIHIyOwogICAgICAgICAgZTIgXj0gLTE7CiAgICAgICAgICBmb3IgKHZhciBhID0gbjsgYSA8IHM7IGErKykKICAgICAgICAgICAgZTIgPSBlMiA+Pj4gOCBeIGlbMjU1ICYgKGUyIF4gdDJbYV0pXTsKICAgICAgICAgIHJldHVybiAtMSBeIGUyOwogICAgICAgIH07CiAgICAgIH0sIHt9XSwgNDY6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdmFyIGgsIGMgPSBlKCIuLi91dGlscy9jb21tb24iKSwgdSA9IGUoIi4vdHJlZXMiKSwgZCA9IGUoIi4vYWRsZXIzMiIpLCBwID0gZSgiLi9jcmMzMiIpLCBuID0gZSgiLi9tZXNzYWdlcyIpLCBsID0gMCwgZiA9IDQsIG0gPSAwLCBfID0gLTIsIGcgPSAtMSwgYiA9IDQsIGkgPSAyLCB2ID0gOCwgeSA9IDksIHMgPSAyODYsIGEgPSAzMCwgbyA9IDE5LCB3ID0gMiAqIHMgKyAxLCBrID0gMTUsIHggPSAzLCBTID0gMjU4LCB6ID0gUyArIHggKyAxLCBDID0gNDIsIEUgPSAxMTMsIEEgPSAxLCBJID0gMiwgTyA9IDMsIEIgPSA0OwogICAgICAgIGZ1bmN0aW9uIFIoZTIsIHQyKSB7CiAgICAgICAgICByZXR1cm4gZTIubXNnID0gblt0Ml0sIHQyOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBUKGUyKSB7CiAgICAgICAgICByZXR1cm4gKGUyIDw8IDEpIC0gKDQgPCBlMiA/IDkgOiAwKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRChlMikgewogICAgICAgICAgZm9yICh2YXIgdDIgPSBlMi5sZW5ndGg7IDAgPD0gLS10MjsgKQogICAgICAgICAgICBlMlt0Ml0gPSAwOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBGKGUyKSB7CiAgICAgICAgICB2YXIgdDIgPSBlMi5zdGF0ZSwgcjIgPSB0Mi5wZW5kaW5nOwogICAgICAgICAgcjIgPiBlMi5hdmFpbF9vdXQgJiYgKHIyID0gZTIuYXZhaWxfb3V0KSwgMCAhPT0gcjIgJiYgKGMuYXJyYXlTZXQoZTIub3V0cHV0LCB0Mi5wZW5kaW5nX2J1ZiwgdDIucGVuZGluZ19vdXQsIHIyLCBlMi5uZXh0X291dCksIGUyLm5leHRfb3V0ICs9IHIyLCB0Mi5wZW5kaW5nX291dCArPSByMiwgZTIudG90YWxfb3V0ICs9IHIyLCBlMi5hdmFpbF9vdXQgLT0gcjIsIHQyLnBlbmRpbmcgLT0gcjIsIDAgPT09IHQyLnBlbmRpbmcgJiYgKHQyLnBlbmRpbmdfb3V0ID0gMCkpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBOKGUyLCB0MikgewogICAgICAgICAgdS5fdHJfZmx1c2hfYmxvY2soZTIsIDAgPD0gZTIuYmxvY2tfc3RhcnQgPyBlMi5ibG9ja19zdGFydCA6IC0xLCBlMi5zdHJzdGFydCAtIGUyLmJsb2NrX3N0YXJ0LCB0MiksIGUyLmJsb2NrX3N0YXJ0ID0gZTIuc3Ryc3RhcnQsIEYoZTIuc3RybSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFUoZTIsIHQyKSB7CiAgICAgICAgICBlMi5wZW5kaW5nX2J1ZltlMi5wZW5kaW5nKytdID0gdDI7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFAoZTIsIHQyKSB7CiAgICAgICAgICBlMi5wZW5kaW5nX2J1ZltlMi5wZW5kaW5nKytdID0gdDIgPj4+IDggJiAyNTUsIGUyLnBlbmRpbmdfYnVmW2UyLnBlbmRpbmcrK10gPSAyNTUgJiB0MjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTChlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiwgbjIsIGkyID0gZTIubWF4X2NoYWluX2xlbmd0aCwgczIgPSBlMi5zdHJzdGFydCwgYTIgPSBlMi5wcmV2X2xlbmd0aCwgbzIgPSBlMi5uaWNlX21hdGNoLCBoMiA9IGUyLnN0cnN0YXJ0ID4gZTIud19zaXplIC0geiA/IGUyLnN0cnN0YXJ0IC0gKGUyLndfc2l6ZSAtIHopIDogMCwgdTIgPSBlMi53aW5kb3csIGwyID0gZTIud19tYXNrLCBmMiA9IGUyLnByZXYsIGMyID0gZTIuc3Ryc3RhcnQgKyBTLCBkMiA9IHUyW3MyICsgYTIgLSAxXSwgcDIgPSB1MltzMiArIGEyXTsKICAgICAgICAgIGUyLnByZXZfbGVuZ3RoID49IGUyLmdvb2RfbWF0Y2ggJiYgKGkyID4+PSAyKSwgbzIgPiBlMi5sb29rYWhlYWQgJiYgKG8yID0gZTIubG9va2FoZWFkKTsKICAgICAgICAgIGRvIHsKICAgICAgICAgICAgaWYgKHUyWyhyMiA9IHQyKSArIGEyXSA9PT0gcDIgJiYgdTJbcjIgKyBhMiAtIDFdID09PSBkMiAmJiB1MltyMl0gPT09IHUyW3MyXSAmJiB1MlsrK3IyXSA9PT0gdTJbczIgKyAxXSkgewogICAgICAgICAgICAgIHMyICs9IDIsIHIyKys7CiAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIH0gd2hpbGUgKHUyWysrczJdID09PSB1MlsrK3IyXSAmJiB1MlsrK3MyXSA9PT0gdTJbKytyMl0gJiYgdTJbKytzMl0gPT09IHUyWysrcjJdICYmIHUyWysrczJdID09PSB1MlsrK3IyXSAmJiB1MlsrK3MyXSA9PT0gdTJbKytyMl0gJiYgdTJbKytzMl0gPT09IHUyWysrcjJdICYmIHUyWysrczJdID09PSB1MlsrK3IyXSAmJiB1MlsrK3MyXSA9PT0gdTJbKytyMl0gJiYgczIgPCBjMik7CiAgICAgICAgICAgICAgaWYgKG4yID0gUyAtIChjMiAtIHMyKSwgczIgPSBjMiAtIFMsIGEyIDwgbjIpIHsKICAgICAgICAgICAgICAgIGlmIChlMi5tYXRjaF9zdGFydCA9IHQyLCBvMiA8PSAoYTIgPSBuMikpCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgZDIgPSB1MltzMiArIGEyIC0gMV0sIHAyID0gdTJbczIgKyBhMl07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IHdoaWxlICgodDIgPSBmMlt0MiAmIGwyXSkgPiBoMiAmJiAwICE9IC0taTIpOwogICAgICAgICAgcmV0dXJuIGEyIDw9IGUyLmxvb2thaGVhZCA/IGEyIDogZTIubG9va2FoZWFkOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBqKGUyKSB7CiAgICAgICAgICB2YXIgdDIsIHIyLCBuMiwgaTIsIHMyLCBhMiwgbzIsIGgyLCB1MiwgbDIsIGYyID0gZTIud19zaXplOwogICAgICAgICAgZG8gewogICAgICAgICAgICBpZiAoaTIgPSBlMi53aW5kb3dfc2l6ZSAtIGUyLmxvb2thaGVhZCAtIGUyLnN0cnN0YXJ0LCBlMi5zdHJzdGFydCA+PSBmMiArIChmMiAtIHopKSB7CiAgICAgICAgICAgICAgZm9yIChjLmFycmF5U2V0KGUyLndpbmRvdywgZTIud2luZG93LCBmMiwgZjIsIDApLCBlMi5tYXRjaF9zdGFydCAtPSBmMiwgZTIuc3Ryc3RhcnQgLT0gZjIsIGUyLmJsb2NrX3N0YXJ0IC09IGYyLCB0MiA9IHIyID0gZTIuaGFzaF9zaXplOyBuMiA9IGUyLmhlYWRbLS10Ml0sIGUyLmhlYWRbdDJdID0gZjIgPD0gbjIgPyBuMiAtIGYyIDogMCwgLS1yMjsgKQogICAgICAgICAgICAgICAgOwogICAgICAgICAgICAgIGZvciAodDIgPSByMiA9IGYyOyBuMiA9IGUyLnByZXZbLS10Ml0sIGUyLnByZXZbdDJdID0gZjIgPD0gbjIgPyBuMiAtIGYyIDogMCwgLS1yMjsgKQogICAgICAgICAgICAgICAgOwogICAgICAgICAgICAgIGkyICs9IGYyOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICgwID09PSBlMi5zdHJtLmF2YWlsX2luKQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBpZiAoYTIgPSBlMi5zdHJtLCBvMiA9IGUyLndpbmRvdywgaDIgPSBlMi5zdHJzdGFydCArIGUyLmxvb2thaGVhZCwgdTIgPSBpMiwgbDIgPSB2b2lkIDAsIGwyID0gYTIuYXZhaWxfaW4sIHUyIDwgbDIgJiYgKGwyID0gdTIpLCByMiA9IDAgPT09IGwyID8gMCA6IChhMi5hdmFpbF9pbiAtPSBsMiwgYy5hcnJheVNldChvMiwgYTIuaW5wdXQsIGEyLm5leHRfaW4sIGwyLCBoMiksIDEgPT09IGEyLnN0YXRlLndyYXAgPyBhMi5hZGxlciA9IGQoYTIuYWRsZXIsIG8yLCBsMiwgaDIpIDogMiA9PT0gYTIuc3RhdGUud3JhcCAmJiAoYTIuYWRsZXIgPSBwKGEyLmFkbGVyLCBvMiwgbDIsIGgyKSksIGEyLm5leHRfaW4gKz0gbDIsIGEyLnRvdGFsX2luICs9IGwyLCBsMiksIGUyLmxvb2thaGVhZCArPSByMiwgZTIubG9va2FoZWFkICsgZTIuaW5zZXJ0ID49IHgpCiAgICAgICAgICAgICAgZm9yIChzMiA9IGUyLnN0cnN0YXJ0IC0gZTIuaW5zZXJ0LCBlMi5pbnNfaCA9IGUyLndpbmRvd1tzMl0sIGUyLmluc19oID0gKGUyLmluc19oIDw8IGUyLmhhc2hfc2hpZnQgXiBlMi53aW5kb3dbczIgKyAxXSkgJiBlMi5oYXNoX21hc2s7IGUyLmluc2VydCAmJiAoZTIuaW5zX2ggPSAoZTIuaW5zX2ggPDwgZTIuaGFzaF9zaGlmdCBeIGUyLndpbmRvd1tzMiArIHggLSAxXSkgJiBlMi5oYXNoX21hc2ssIGUyLnByZXZbczIgJiBlMi53X21hc2tdID0gZTIuaGVhZFtlMi5pbnNfaF0sIGUyLmhlYWRbZTIuaW5zX2hdID0gczIsIHMyKyssIGUyLmluc2VydC0tLCAhKGUyLmxvb2thaGVhZCArIGUyLmluc2VydCA8IHgpKTsgKQogICAgICAgICAgICAgICAgOwogICAgICAgICAgfSB3aGlsZSAoZTIubG9va2FoZWFkIDwgeiAmJiAwICE9PSBlMi5zdHJtLmF2YWlsX2luKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWihlMiwgdDIpIHsKICAgICAgICAgIGZvciAodmFyIHIyLCBuMjsgOyApIHsKICAgICAgICAgICAgaWYgKGUyLmxvb2thaGVhZCA8IHopIHsKICAgICAgICAgICAgICBpZiAoaihlMiksIGUyLmxvb2thaGVhZCA8IHogJiYgdDIgPT09IGwpCiAgICAgICAgICAgICAgICByZXR1cm4gQTsKICAgICAgICAgICAgICBpZiAoMCA9PT0gZTIubG9va2FoZWFkKQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHIyID0gMCwgZTIubG9va2FoZWFkID49IHggJiYgKGUyLmluc19oID0gKGUyLmluc19oIDw8IGUyLmhhc2hfc2hpZnQgXiBlMi53aW5kb3dbZTIuc3Ryc3RhcnQgKyB4IC0gMV0pICYgZTIuaGFzaF9tYXNrLCByMiA9IGUyLnByZXZbZTIuc3Ryc3RhcnQgJiBlMi53X21hc2tdID0gZTIuaGVhZFtlMi5pbnNfaF0sIGUyLmhlYWRbZTIuaW5zX2hdID0gZTIuc3Ryc3RhcnQpLCAwICE9PSByMiAmJiBlMi5zdHJzdGFydCAtIHIyIDw9IGUyLndfc2l6ZSAtIHogJiYgKGUyLm1hdGNoX2xlbmd0aCA9IEwoZTIsIHIyKSksIGUyLm1hdGNoX2xlbmd0aCA+PSB4KQogICAgICAgICAgICAgIGlmIChuMiA9IHUuX3RyX3RhbGx5KGUyLCBlMi5zdHJzdGFydCAtIGUyLm1hdGNoX3N0YXJ0LCBlMi5tYXRjaF9sZW5ndGggLSB4KSwgZTIubG9va2FoZWFkIC09IGUyLm1hdGNoX2xlbmd0aCwgZTIubWF0Y2hfbGVuZ3RoIDw9IGUyLm1heF9sYXp5X21hdGNoICYmIGUyLmxvb2thaGVhZCA+PSB4KSB7CiAgICAgICAgICAgICAgICBmb3IgKGUyLm1hdGNoX2xlbmd0aC0tOyBlMi5zdHJzdGFydCsrLCBlMi5pbnNfaCA9IChlMi5pbnNfaCA8PCBlMi5oYXNoX3NoaWZ0IF4gZTIud2luZG93W2UyLnN0cnN0YXJ0ICsgeCAtIDFdKSAmIGUyLmhhc2hfbWFzaywgcjIgPSBlMi5wcmV2W2UyLnN0cnN0YXJ0ICYgZTIud19tYXNrXSA9IGUyLmhlYWRbZTIuaW5zX2hdLCBlMi5oZWFkW2UyLmluc19oXSA9IGUyLnN0cnN0YXJ0LCAwICE9IC0tZTIubWF0Y2hfbGVuZ3RoOyApCiAgICAgICAgICAgICAgICAgIDsKICAgICAgICAgICAgICAgIGUyLnN0cnN0YXJ0Kys7CiAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICBlMi5zdHJzdGFydCArPSBlMi5tYXRjaF9sZW5ndGgsIGUyLm1hdGNoX2xlbmd0aCA9IDAsIGUyLmluc19oID0gZTIud2luZG93W2UyLnN0cnN0YXJ0XSwgZTIuaW5zX2ggPSAoZTIuaW5zX2ggPDwgZTIuaGFzaF9zaGlmdCBeIGUyLndpbmRvd1tlMi5zdHJzdGFydCArIDFdKSAmIGUyLmhhc2hfbWFzazsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgIG4yID0gdS5fdHJfdGFsbHkoZTIsIDAsIGUyLndpbmRvd1tlMi5zdHJzdGFydF0pLCBlMi5sb29rYWhlYWQtLSwgZTIuc3Ryc3RhcnQrKzsKICAgICAgICAgICAgaWYgKG4yICYmIChOKGUyLCBmYWxzZSksIDAgPT09IGUyLnN0cm0uYXZhaWxfb3V0KSkKICAgICAgICAgICAgICByZXR1cm4gQTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBlMi5pbnNlcnQgPSBlMi5zdHJzdGFydCA8IHggLSAxID8gZTIuc3Ryc3RhcnQgOiB4IC0gMSwgdDIgPT09IGYgPyAoTihlMiwgdHJ1ZSksIDAgPT09IGUyLnN0cm0uYXZhaWxfb3V0ID8gTyA6IEIpIDogZTIubGFzdF9saXQgJiYgKE4oZTIsIGZhbHNlKSwgMCA9PT0gZTIuc3RybS5hdmFpbF9vdXQpID8gQSA6IEk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFcoZTIsIHQyKSB7CiAgICAgICAgICBmb3IgKHZhciByMiwgbjIsIGkyOyA7ICkgewogICAgICAgICAgICBpZiAoZTIubG9va2FoZWFkIDwgeikgewogICAgICAgICAgICAgIGlmIChqKGUyKSwgZTIubG9va2FoZWFkIDwgeiAmJiB0MiA9PT0gbCkKICAgICAgICAgICAgICAgIHJldHVybiBBOwogICAgICAgICAgICAgIGlmICgwID09PSBlMi5sb29rYWhlYWQpCiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocjIgPSAwLCBlMi5sb29rYWhlYWQgPj0geCAmJiAoZTIuaW5zX2ggPSAoZTIuaW5zX2ggPDwgZTIuaGFzaF9zaGlmdCBeIGUyLndpbmRvd1tlMi5zdHJzdGFydCArIHggLSAxXSkgJiBlMi5oYXNoX21hc2ssIHIyID0gZTIucHJldltlMi5zdHJzdGFydCAmIGUyLndfbWFza10gPSBlMi5oZWFkW2UyLmluc19oXSwgZTIuaGVhZFtlMi5pbnNfaF0gPSBlMi5zdHJzdGFydCksIGUyLnByZXZfbGVuZ3RoID0gZTIubWF0Y2hfbGVuZ3RoLCBlMi5wcmV2X21hdGNoID0gZTIubWF0Y2hfc3RhcnQsIGUyLm1hdGNoX2xlbmd0aCA9IHggLSAxLCAwICE9PSByMiAmJiBlMi5wcmV2X2xlbmd0aCA8IGUyLm1heF9sYXp5X21hdGNoICYmIGUyLnN0cnN0YXJ0IC0gcjIgPD0gZTIud19zaXplIC0geiAmJiAoZTIubWF0Y2hfbGVuZ3RoID0gTChlMiwgcjIpLCBlMi5tYXRjaF9sZW5ndGggPD0gNSAmJiAoMSA9PT0gZTIuc3RyYXRlZ3kgfHwgZTIubWF0Y2hfbGVuZ3RoID09PSB4ICYmIDQwOTYgPCBlMi5zdHJzdGFydCAtIGUyLm1hdGNoX3N0YXJ0KSAmJiAoZTIubWF0Y2hfbGVuZ3RoID0geCAtIDEpKSwgZTIucHJldl9sZW5ndGggPj0geCAmJiBlMi5tYXRjaF9sZW5ndGggPD0gZTIucHJldl9sZW5ndGgpIHsKICAgICAgICAgICAgICBmb3IgKGkyID0gZTIuc3Ryc3RhcnQgKyBlMi5sb29rYWhlYWQgLSB4LCBuMiA9IHUuX3RyX3RhbGx5KGUyLCBlMi5zdHJzdGFydCAtIDEgLSBlMi5wcmV2X21hdGNoLCBlMi5wcmV2X2xlbmd0aCAtIHgpLCBlMi5sb29rYWhlYWQgLT0gZTIucHJldl9sZW5ndGggLSAxLCBlMi5wcmV2X2xlbmd0aCAtPSAyOyArK2UyLnN0cnN0YXJ0IDw9IGkyICYmIChlMi5pbnNfaCA9IChlMi5pbnNfaCA8PCBlMi5oYXNoX3NoaWZ0IF4gZTIud2luZG93W2UyLnN0cnN0YXJ0ICsgeCAtIDFdKSAmIGUyLmhhc2hfbWFzaywgcjIgPSBlMi5wcmV2W2UyLnN0cnN0YXJ0ICYgZTIud19tYXNrXSA9IGUyLmhlYWRbZTIuaW5zX2hdLCBlMi5oZWFkW2UyLmluc19oXSA9IGUyLnN0cnN0YXJ0KSwgMCAhPSAtLWUyLnByZXZfbGVuZ3RoOyApCiAgICAgICAgICAgICAgICA7CiAgICAgICAgICAgICAgaWYgKGUyLm1hdGNoX2F2YWlsYWJsZSA9IDAsIGUyLm1hdGNoX2xlbmd0aCA9IHggLSAxLCBlMi5zdHJzdGFydCsrLCBuMiAmJiAoTihlMiwgZmFsc2UpLCAwID09PSBlMi5zdHJtLmF2YWlsX291dCkpCiAgICAgICAgICAgICAgICByZXR1cm4gQTsKICAgICAgICAgICAgfSBlbHNlIGlmIChlMi5tYXRjaF9hdmFpbGFibGUpIHsKICAgICAgICAgICAgICBpZiAoKG4yID0gdS5fdHJfdGFsbHkoZTIsIDAsIGUyLndpbmRvd1tlMi5zdHJzdGFydCAtIDFdKSkgJiYgTihlMiwgZmFsc2UpLCBlMi5zdHJzdGFydCsrLCBlMi5sb29rYWhlYWQtLSwgMCA9PT0gZTIuc3RybS5hdmFpbF9vdXQpCiAgICAgICAgICAgICAgICByZXR1cm4gQTsKICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgZTIubWF0Y2hfYXZhaWxhYmxlID0gMSwgZTIuc3Ryc3RhcnQrKywgZTIubG9va2FoZWFkLS07CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZTIubWF0Y2hfYXZhaWxhYmxlICYmIChuMiA9IHUuX3RyX3RhbGx5KGUyLCAwLCBlMi53aW5kb3dbZTIuc3Ryc3RhcnQgLSAxXSksIGUyLm1hdGNoX2F2YWlsYWJsZSA9IDApLCBlMi5pbnNlcnQgPSBlMi5zdHJzdGFydCA8IHggLSAxID8gZTIuc3Ryc3RhcnQgOiB4IC0gMSwgdDIgPT09IGYgPyAoTihlMiwgdHJ1ZSksIDAgPT09IGUyLnN0cm0uYXZhaWxfb3V0ID8gTyA6IEIpIDogZTIubGFzdF9saXQgJiYgKE4oZTIsIGZhbHNlKSwgMCA9PT0gZTIuc3RybS5hdmFpbF9vdXQpID8gQSA6IEk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIE0oZTIsIHQyLCByMiwgbjIsIGkyKSB7CiAgICAgICAgICB0aGlzLmdvb2RfbGVuZ3RoID0gZTIsIHRoaXMubWF4X2xhenkgPSB0MiwgdGhpcy5uaWNlX2xlbmd0aCA9IHIyLCB0aGlzLm1heF9jaGFpbiA9IG4yLCB0aGlzLmZ1bmMgPSBpMjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSCgpIHsKICAgICAgICAgIHRoaXMuc3RybSA9IG51bGwsIHRoaXMuc3RhdHVzID0gMCwgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGwsIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDAsIHRoaXMucGVuZGluZ19vdXQgPSAwLCB0aGlzLnBlbmRpbmcgPSAwLCB0aGlzLndyYXAgPSAwLCB0aGlzLmd6aGVhZCA9IG51bGwsIHRoaXMuZ3ppbmRleCA9IDAsIHRoaXMubWV0aG9kID0gdiwgdGhpcy5sYXN0X2ZsdXNoID0gLTEsIHRoaXMud19zaXplID0gMCwgdGhpcy53X2JpdHMgPSAwLCB0aGlzLndfbWFzayA9IDAsIHRoaXMud2luZG93ID0gbnVsbCwgdGhpcy53aW5kb3dfc2l6ZSA9IDAsIHRoaXMucHJldiA9IG51bGwsIHRoaXMuaGVhZCA9IG51bGwsIHRoaXMuaW5zX2ggPSAwLCB0aGlzLmhhc2hfc2l6ZSA9IDAsIHRoaXMuaGFzaF9iaXRzID0gMCwgdGhpcy5oYXNoX21hc2sgPSAwLCB0aGlzLmhhc2hfc2hpZnQgPSAwLCB0aGlzLmJsb2NrX3N0YXJ0ID0gMCwgdGhpcy5tYXRjaF9sZW5ndGggPSAwLCB0aGlzLnByZXZfbWF0Y2ggPSAwLCB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDAsIHRoaXMuc3Ryc3RhcnQgPSAwLCB0aGlzLm1hdGNoX3N0YXJ0ID0gMCwgdGhpcy5sb29rYWhlYWQgPSAwLCB0aGlzLnByZXZfbGVuZ3RoID0gMCwgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMCwgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDAsIHRoaXMubGV2ZWwgPSAwLCB0aGlzLnN0cmF0ZWd5ID0gMCwgdGhpcy5nb29kX21hdGNoID0gMCwgdGhpcy5uaWNlX21hdGNoID0gMCwgdGhpcy5keW5fbHRyZWUgPSBuZXcgYy5CdWYxNigyICogdyksIHRoaXMuZHluX2R0cmVlID0gbmV3IGMuQnVmMTYoMiAqICgyICogYSArIDEpKSwgdGhpcy5ibF90cmVlID0gbmV3IGMuQnVmMTYoMiAqICgyICogbyArIDEpKSwgRCh0aGlzLmR5bl9sdHJlZSksIEQodGhpcy5keW5fZHRyZWUpLCBEKHRoaXMuYmxfdHJlZSksIHRoaXMubF9kZXNjID0gbnVsbCwgdGhpcy5kX2Rlc2MgPSBudWxsLCB0aGlzLmJsX2Rlc2MgPSBudWxsLCB0aGlzLmJsX2NvdW50ID0gbmV3IGMuQnVmMTYoayArIDEpLCB0aGlzLmhlYXAgPSBuZXcgYy5CdWYxNigyICogcyArIDEpLCBEKHRoaXMuaGVhcCksIHRoaXMuaGVhcF9sZW4gPSAwLCB0aGlzLmhlYXBfbWF4ID0gMCwgdGhpcy5kZXB0aCA9IG5ldyBjLkJ1ZjE2KDIgKiBzICsgMSksIEQodGhpcy5kZXB0aCksIHRoaXMubF9idWYgPSAwLCB0aGlzLmxpdF9idWZzaXplID0gMCwgdGhpcy5sYXN0X2xpdCA9IDAsIHRoaXMuZF9idWYgPSAwLCB0aGlzLm9wdF9sZW4gPSAwLCB0aGlzLnN0YXRpY19sZW4gPSAwLCB0aGlzLm1hdGNoZXMgPSAwLCB0aGlzLmluc2VydCA9IDAsIHRoaXMuYmlfYnVmID0gMCwgdGhpcy5iaV92YWxpZCA9IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIEcoZTIpIHsKICAgICAgICAgIHZhciB0MjsKICAgICAgICAgIHJldHVybiBlMiAmJiBlMi5zdGF0ZSA/IChlMi50b3RhbF9pbiA9IGUyLnRvdGFsX291dCA9IDAsIGUyLmRhdGFfdHlwZSA9IGksICh0MiA9IGUyLnN0YXRlKS5wZW5kaW5nID0gMCwgdDIucGVuZGluZ19vdXQgPSAwLCB0Mi53cmFwIDwgMCAmJiAodDIud3JhcCA9IC10Mi53cmFwKSwgdDIuc3RhdHVzID0gdDIud3JhcCA/IEMgOiBFLCBlMi5hZGxlciA9IDIgPT09IHQyLndyYXAgPyAwIDogMSwgdDIubGFzdF9mbHVzaCA9IGwsIHUuX3RyX2luaXQodDIpLCBtKSA6IFIoZTIsIF8pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBLKGUyKSB7CiAgICAgICAgICB2YXIgdDIgPSBHKGUyKTsKICAgICAgICAgIHJldHVybiB0MiA9PT0gbSAmJiBmdW5jdGlvbihlMykgewogICAgICAgICAgICBlMy53aW5kb3dfc2l6ZSA9IDIgKiBlMy53X3NpemUsIEQoZTMuaGVhZCksIGUzLm1heF9sYXp5X21hdGNoID0gaFtlMy5sZXZlbF0ubWF4X2xhenksIGUzLmdvb2RfbWF0Y2ggPSBoW2UzLmxldmVsXS5nb29kX2xlbmd0aCwgZTMubmljZV9tYXRjaCA9IGhbZTMubGV2ZWxdLm5pY2VfbGVuZ3RoLCBlMy5tYXhfY2hhaW5fbGVuZ3RoID0gaFtlMy5sZXZlbF0ubWF4X2NoYWluLCBlMy5zdHJzdGFydCA9IDAsIGUzLmJsb2NrX3N0YXJ0ID0gMCwgZTMubG9va2FoZWFkID0gMCwgZTMuaW5zZXJ0ID0gMCwgZTMubWF0Y2hfbGVuZ3RoID0gZTMucHJldl9sZW5ndGggPSB4IC0gMSwgZTMubWF0Y2hfYXZhaWxhYmxlID0gMCwgZTMuaW5zX2ggPSAwOwogICAgICAgICAgfShlMi5zdGF0ZSksIHQyOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBZKGUyLCB0MiwgcjIsIG4yLCBpMiwgczIpIHsKICAgICAgICAgIGlmICghZTIpCiAgICAgICAgICAgIHJldHVybiBfOwogICAgICAgICAgdmFyIGEyID0gMTsKICAgICAgICAgIGlmICh0MiA9PT0gZyAmJiAodDIgPSA2KSwgbjIgPCAwID8gKGEyID0gMCwgbjIgPSAtbjIpIDogMTUgPCBuMiAmJiAoYTIgPSAyLCBuMiAtPSAxNiksIGkyIDwgMSB8fCB5IDwgaTIgfHwgcjIgIT09IHYgfHwgbjIgPCA4IHx8IDE1IDwgbjIgfHwgdDIgPCAwIHx8IDkgPCB0MiB8fCBzMiA8IDAgfHwgYiA8IHMyKQogICAgICAgICAgICByZXR1cm4gUihlMiwgXyk7CiAgICAgICAgICA4ID09PSBuMiAmJiAobjIgPSA5KTsKICAgICAgICAgIHZhciBvMiA9IG5ldyBIKCk7CiAgICAgICAgICByZXR1cm4gKGUyLnN0YXRlID0gbzIpLnN0cm0gPSBlMiwgbzIud3JhcCA9IGEyLCBvMi5nemhlYWQgPSBudWxsLCBvMi53X2JpdHMgPSBuMiwgbzIud19zaXplID0gMSA8PCBvMi53X2JpdHMsIG8yLndfbWFzayA9IG8yLndfc2l6ZSAtIDEsIG8yLmhhc2hfYml0cyA9IGkyICsgNywgbzIuaGFzaF9zaXplID0gMSA8PCBvMi5oYXNoX2JpdHMsIG8yLmhhc2hfbWFzayA9IG8yLmhhc2hfc2l6ZSAtIDEsIG8yLmhhc2hfc2hpZnQgPSB+figobzIuaGFzaF9iaXRzICsgeCAtIDEpIC8geCksIG8yLndpbmRvdyA9IG5ldyBjLkJ1ZjgoMiAqIG8yLndfc2l6ZSksIG8yLmhlYWQgPSBuZXcgYy5CdWYxNihvMi5oYXNoX3NpemUpLCBvMi5wcmV2ID0gbmV3IGMuQnVmMTYobzIud19zaXplKSwgbzIubGl0X2J1ZnNpemUgPSAxIDw8IGkyICsgNiwgbzIucGVuZGluZ19idWZfc2l6ZSA9IDQgKiBvMi5saXRfYnVmc2l6ZSwgbzIucGVuZGluZ19idWYgPSBuZXcgYy5CdWY4KG8yLnBlbmRpbmdfYnVmX3NpemUpLCBvMi5kX2J1ZiA9IDEgKiBvMi5saXRfYnVmc2l6ZSwgbzIubF9idWYgPSAzICogbzIubGl0X2J1ZnNpemUsIG8yLmxldmVsID0gdDIsIG8yLnN0cmF0ZWd5ID0gczIsIG8yLm1ldGhvZCA9IHIyLCBLKGUyKTsKICAgICAgICB9CiAgICAgICAgaCA9IFtuZXcgTSgwLCAwLCAwLCAwLCBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiA9IDY1NTM1OwogICAgICAgICAgZm9yIChyMiA+IGUyLnBlbmRpbmdfYnVmX3NpemUgLSA1ICYmIChyMiA9IGUyLnBlbmRpbmdfYnVmX3NpemUgLSA1KTsgOyApIHsKICAgICAgICAgICAgaWYgKGUyLmxvb2thaGVhZCA8PSAxKSB7CiAgICAgICAgICAgICAgaWYgKGooZTIpLCAwID09PSBlMi5sb29rYWhlYWQgJiYgdDIgPT09IGwpCiAgICAgICAgICAgICAgICByZXR1cm4gQTsKICAgICAgICAgICAgICBpZiAoMCA9PT0gZTIubG9va2FoZWFkKQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZTIuc3Ryc3RhcnQgKz0gZTIubG9va2FoZWFkLCBlMi5sb29rYWhlYWQgPSAwOwogICAgICAgICAgICB2YXIgbjIgPSBlMi5ibG9ja19zdGFydCArIHIyOwogICAgICAgICAgICBpZiAoKDAgPT09IGUyLnN0cnN0YXJ0IHx8IGUyLnN0cnN0YXJ0ID49IG4yKSAmJiAoZTIubG9va2FoZWFkID0gZTIuc3Ryc3RhcnQgLSBuMiwgZTIuc3Ryc3RhcnQgPSBuMiwgTihlMiwgZmFsc2UpLCAwID09PSBlMi5zdHJtLmF2YWlsX291dCkpCiAgICAgICAgICAgICAgcmV0dXJuIEE7CiAgICAgICAgICAgIGlmIChlMi5zdHJzdGFydCAtIGUyLmJsb2NrX3N0YXJ0ID49IGUyLndfc2l6ZSAtIHogJiYgKE4oZTIsIGZhbHNlKSwgMCA9PT0gZTIuc3RybS5hdmFpbF9vdXQpKQogICAgICAgICAgICAgIHJldHVybiBBOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGUyLmluc2VydCA9IDAsIHQyID09PSBmID8gKE4oZTIsIHRydWUpLCAwID09PSBlMi5zdHJtLmF2YWlsX291dCA/IE8gOiBCKSA6IChlMi5zdHJzdGFydCA+IGUyLmJsb2NrX3N0YXJ0ICYmIChOKGUyLCBmYWxzZSksIGUyLnN0cm0uYXZhaWxfb3V0KSwgQSk7CiAgICAgICAgfSksIG5ldyBNKDQsIDQsIDgsIDQsIFopLCBuZXcgTSg0LCA1LCAxNiwgOCwgWiksIG5ldyBNKDQsIDYsIDMyLCAzMiwgWiksIG5ldyBNKDQsIDQsIDE2LCAxNiwgVyksIG5ldyBNKDgsIDE2LCAzMiwgMzIsIFcpLCBuZXcgTSg4LCAxNiwgMTI4LCAxMjgsIFcpLCBuZXcgTSg4LCAzMiwgMTI4LCAyNTYsIFcpLCBuZXcgTSgzMiwgMTI4LCAyNTgsIDEwMjQsIFcpLCBuZXcgTSgzMiwgMjU4LCAyNTgsIDQwOTYsIFcpXSwgci5kZWZsYXRlSW5pdCA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgcmV0dXJuIFkoZTIsIHQyLCB2LCAxNSwgOCwgMCk7CiAgICAgICAgfSwgci5kZWZsYXRlSW5pdDIgPSBZLCByLmRlZmxhdGVSZXNldCA9IEssIHIuZGVmbGF0ZVJlc2V0S2VlcCA9IEcsIHIuZGVmbGF0ZVNldEhlYWRlciA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgcmV0dXJuIGUyICYmIGUyLnN0YXRlID8gMiAhPT0gZTIuc3RhdGUud3JhcCA/IF8gOiAoZTIuc3RhdGUuZ3poZWFkID0gdDIsIG0pIDogXzsKICAgICAgICB9LCByLmRlZmxhdGUgPSBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiwgbjIsIGkyLCBzMjsKICAgICAgICAgIGlmICghZTIgfHwgIWUyLnN0YXRlIHx8IDUgPCB0MiB8fCB0MiA8IDApCiAgICAgICAgICAgIHJldHVybiBlMiA/IFIoZTIsIF8pIDogXzsKICAgICAgICAgIGlmIChuMiA9IGUyLnN0YXRlLCAhZTIub3V0cHV0IHx8ICFlMi5pbnB1dCAmJiAwICE9PSBlMi5hdmFpbF9pbiB8fCA2NjYgPT09IG4yLnN0YXR1cyAmJiB0MiAhPT0gZikKICAgICAgICAgICAgcmV0dXJuIFIoZTIsIDAgPT09IGUyLmF2YWlsX291dCA/IC01IDogXyk7CiAgICAgICAgICBpZiAobjIuc3RybSA9IGUyLCByMiA9IG4yLmxhc3RfZmx1c2gsIG4yLmxhc3RfZmx1c2ggPSB0MiwgbjIuc3RhdHVzID09PSBDKQogICAgICAgICAgICBpZiAoMiA9PT0gbjIud3JhcCkKICAgICAgICAgICAgICBlMi5hZGxlciA9IDAsIFUobjIsIDMxKSwgVShuMiwgMTM5KSwgVShuMiwgOCksIG4yLmd6aGVhZCA/IChVKG4yLCAobjIuZ3poZWFkLnRleHQgPyAxIDogMCkgKyAobjIuZ3poZWFkLmhjcmMgPyAyIDogMCkgKyAobjIuZ3poZWFkLmV4dHJhID8gNCA6IDApICsgKG4yLmd6aGVhZC5uYW1lID8gOCA6IDApICsgKG4yLmd6aGVhZC5jb21tZW50ID8gMTYgOiAwKSksIFUobjIsIDI1NSAmIG4yLmd6aGVhZC50aW1lKSwgVShuMiwgbjIuZ3poZWFkLnRpbWUgPj4gOCAmIDI1NSksIFUobjIsIG4yLmd6aGVhZC50aW1lID4+IDE2ICYgMjU1KSwgVShuMiwgbjIuZ3poZWFkLnRpbWUgPj4gMjQgJiAyNTUpLCBVKG4yLCA5ID09PSBuMi5sZXZlbCA/IDIgOiAyIDw9IG4yLnN0cmF0ZWd5IHx8IG4yLmxldmVsIDwgMiA/IDQgOiAwKSwgVShuMiwgMjU1ICYgbjIuZ3poZWFkLm9zKSwgbjIuZ3poZWFkLmV4dHJhICYmIG4yLmd6aGVhZC5leHRyYS5sZW5ndGggJiYgKFUobjIsIDI1NSAmIG4yLmd6aGVhZC5leHRyYS5sZW5ndGgpLCBVKG4yLCBuMi5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDggJiAyNTUpKSwgbjIuZ3poZWFkLmhjcmMgJiYgKGUyLmFkbGVyID0gcChlMi5hZGxlciwgbjIucGVuZGluZ19idWYsIG4yLnBlbmRpbmcsIDApKSwgbjIuZ3ppbmRleCA9IDAsIG4yLnN0YXR1cyA9IDY5KSA6IChVKG4yLCAwKSwgVShuMiwgMCksIFUobjIsIDApLCBVKG4yLCAwKSwgVShuMiwgMCksIFUobjIsIDkgPT09IG4yLmxldmVsID8gMiA6IDIgPD0gbjIuc3RyYXRlZ3kgfHwgbjIubGV2ZWwgPCAyID8gNCA6IDApLCBVKG4yLCAzKSwgbjIuc3RhdHVzID0gRSk7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIHZhciBhMiA9IHYgKyAobjIud19iaXRzIC0gOCA8PCA0KSA8PCA4OwogICAgICAgICAgICAgIGEyIHw9ICgyIDw9IG4yLnN0cmF0ZWd5IHx8IG4yLmxldmVsIDwgMiA/IDAgOiBuMi5sZXZlbCA8IDYgPyAxIDogNiA9PT0gbjIubGV2ZWwgPyAyIDogMykgPDwgNiwgMCAhPT0gbjIuc3Ryc3RhcnQgJiYgKGEyIHw9IDMyKSwgYTIgKz0gMzEgLSBhMiAlIDMxLCBuMi5zdGF0dXMgPSBFLCBQKG4yLCBhMiksIDAgIT09IG4yLnN0cnN0YXJ0ICYmIChQKG4yLCBlMi5hZGxlciA+Pj4gMTYpLCBQKG4yLCA2NTUzNSAmIGUyLmFkbGVyKSksIGUyLmFkbGVyID0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgaWYgKDY5ID09PSBuMi5zdGF0dXMpCiAgICAgICAgICAgIGlmIChuMi5nemhlYWQuZXh0cmEpIHsKICAgICAgICAgICAgICBmb3IgKGkyID0gbjIucGVuZGluZzsgbjIuZ3ppbmRleCA8ICg2NTUzNSAmIG4yLmd6aGVhZC5leHRyYS5sZW5ndGgpICYmIChuMi5wZW5kaW5nICE9PSBuMi5wZW5kaW5nX2J1Zl9zaXplIHx8IChuMi5nemhlYWQuaGNyYyAmJiBuMi5wZW5kaW5nID4gaTIgJiYgKGUyLmFkbGVyID0gcChlMi5hZGxlciwgbjIucGVuZGluZ19idWYsIG4yLnBlbmRpbmcgLSBpMiwgaTIpKSwgRihlMiksIGkyID0gbjIucGVuZGluZywgbjIucGVuZGluZyAhPT0gbjIucGVuZGluZ19idWZfc2l6ZSkpOyApCiAgICAgICAgICAgICAgICBVKG4yLCAyNTUgJiBuMi5nemhlYWQuZXh0cmFbbjIuZ3ppbmRleF0pLCBuMi5nemluZGV4Kys7CiAgICAgICAgICAgICAgbjIuZ3poZWFkLmhjcmMgJiYgbjIucGVuZGluZyA+IGkyICYmIChlMi5hZGxlciA9IHAoZTIuYWRsZXIsIG4yLnBlbmRpbmdfYnVmLCBuMi5wZW5kaW5nIC0gaTIsIGkyKSksIG4yLmd6aW5kZXggPT09IG4yLmd6aGVhZC5leHRyYS5sZW5ndGggJiYgKG4yLmd6aW5kZXggPSAwLCBuMi5zdGF0dXMgPSA3Myk7CiAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgIG4yLnN0YXR1cyA9IDczOwogICAgICAgICAgaWYgKDczID09PSBuMi5zdGF0dXMpCiAgICAgICAgICAgIGlmIChuMi5nemhlYWQubmFtZSkgewogICAgICAgICAgICAgIGkyID0gbjIucGVuZGluZzsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICBpZiAobjIucGVuZGluZyA9PT0gbjIucGVuZGluZ19idWZfc2l6ZSAmJiAobjIuZ3poZWFkLmhjcmMgJiYgbjIucGVuZGluZyA+IGkyICYmIChlMi5hZGxlciA9IHAoZTIuYWRsZXIsIG4yLnBlbmRpbmdfYnVmLCBuMi5wZW5kaW5nIC0gaTIsIGkyKSksIEYoZTIpLCBpMiA9IG4yLnBlbmRpbmcsIG4yLnBlbmRpbmcgPT09IG4yLnBlbmRpbmdfYnVmX3NpemUpKSB7CiAgICAgICAgICAgICAgICAgIHMyID0gMTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzMiA9IG4yLmd6aW5kZXggPCBuMi5nemhlYWQubmFtZS5sZW5ndGggPyAyNTUgJiBuMi5nemhlYWQubmFtZS5jaGFyQ29kZUF0KG4yLmd6aW5kZXgrKykgOiAwLCBVKG4yLCBzMik7CiAgICAgICAgICAgICAgfSB3aGlsZSAoMCAhPT0gczIpOwogICAgICAgICAgICAgIG4yLmd6aGVhZC5oY3JjICYmIG4yLnBlbmRpbmcgPiBpMiAmJiAoZTIuYWRsZXIgPSBwKGUyLmFkbGVyLCBuMi5wZW5kaW5nX2J1ZiwgbjIucGVuZGluZyAtIGkyLCBpMikpLCAwID09PSBzMiAmJiAobjIuZ3ppbmRleCA9IDAsIG4yLnN0YXR1cyA9IDkxKTsKICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgbjIuc3RhdHVzID0gOTE7CiAgICAgICAgICBpZiAoOTEgPT09IG4yLnN0YXR1cykKICAgICAgICAgICAgaWYgKG4yLmd6aGVhZC5jb21tZW50KSB7CiAgICAgICAgICAgICAgaTIgPSBuMi5wZW5kaW5nOwogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIGlmIChuMi5wZW5kaW5nID09PSBuMi5wZW5kaW5nX2J1Zl9zaXplICYmIChuMi5nemhlYWQuaGNyYyAmJiBuMi5wZW5kaW5nID4gaTIgJiYgKGUyLmFkbGVyID0gcChlMi5hZGxlciwgbjIucGVuZGluZ19idWYsIG4yLnBlbmRpbmcgLSBpMiwgaTIpKSwgRihlMiksIGkyID0gbjIucGVuZGluZywgbjIucGVuZGluZyA9PT0gbjIucGVuZGluZ19idWZfc2l6ZSkpIHsKICAgICAgICAgICAgICAgICAgczIgPSAxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHMyID0gbjIuZ3ppbmRleCA8IG4yLmd6aGVhZC5jb21tZW50Lmxlbmd0aCA/IDI1NSAmIG4yLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQobjIuZ3ppbmRleCsrKSA6IDAsIFUobjIsIHMyKTsKICAgICAgICAgICAgICB9IHdoaWxlICgwICE9PSBzMik7CiAgICAgICAgICAgICAgbjIuZ3poZWFkLmhjcmMgJiYgbjIucGVuZGluZyA+IGkyICYmIChlMi5hZGxlciA9IHAoZTIuYWRsZXIsIG4yLnBlbmRpbmdfYnVmLCBuMi5wZW5kaW5nIC0gaTIsIGkyKSksIDAgPT09IHMyICYmIChuMi5zdGF0dXMgPSAxMDMpOwogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBuMi5zdGF0dXMgPSAxMDM7CiAgICAgICAgICBpZiAoMTAzID09PSBuMi5zdGF0dXMgJiYgKG4yLmd6aGVhZC5oY3JjID8gKG4yLnBlbmRpbmcgKyAyID4gbjIucGVuZGluZ19idWZfc2l6ZSAmJiBGKGUyKSwgbjIucGVuZGluZyArIDIgPD0gbjIucGVuZGluZ19idWZfc2l6ZSAmJiAoVShuMiwgMjU1ICYgZTIuYWRsZXIpLCBVKG4yLCBlMi5hZGxlciA+PiA4ICYgMjU1KSwgZTIuYWRsZXIgPSAwLCBuMi5zdGF0dXMgPSBFKSkgOiBuMi5zdGF0dXMgPSBFKSwgMCAhPT0gbjIucGVuZGluZykgewogICAgICAgICAgICBpZiAoRihlMiksIDAgPT09IGUyLmF2YWlsX291dCkKICAgICAgICAgICAgICByZXR1cm4gbjIubGFzdF9mbHVzaCA9IC0xLCBtOwogICAgICAgICAgfSBlbHNlIGlmICgwID09PSBlMi5hdmFpbF9pbiAmJiBUKHQyKSA8PSBUKHIyKSAmJiB0MiAhPT0gZikKICAgICAgICAgICAgcmV0dXJuIFIoZTIsIC01KTsKICAgICAgICAgIGlmICg2NjYgPT09IG4yLnN0YXR1cyAmJiAwICE9PSBlMi5hdmFpbF9pbikKICAgICAgICAgICAgcmV0dXJuIFIoZTIsIC01KTsKICAgICAgICAgIGlmICgwICE9PSBlMi5hdmFpbF9pbiB8fCAwICE9PSBuMi5sb29rYWhlYWQgfHwgdDIgIT09IGwgJiYgNjY2ICE9PSBuMi5zdGF0dXMpIHsKICAgICAgICAgICAgdmFyIG8yID0gMiA9PT0gbjIuc3RyYXRlZ3kgPyBmdW5jdGlvbihlMywgdDMpIHsKICAgICAgICAgICAgICBmb3IgKHZhciByMzsgOyApIHsKICAgICAgICAgICAgICAgIGlmICgwID09PSBlMy5sb29rYWhlYWQgJiYgKGooZTMpLCAwID09PSBlMy5sb29rYWhlYWQpKSB7CiAgICAgICAgICAgICAgICAgIGlmICh0MyA9PT0gbCkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gQTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoZTMubWF0Y2hfbGVuZ3RoID0gMCwgcjMgPSB1Ll90cl90YWxseShlMywgMCwgZTMud2luZG93W2UzLnN0cnN0YXJ0XSksIGUzLmxvb2thaGVhZC0tLCBlMy5zdHJzdGFydCsrLCByMyAmJiAoTihlMywgZmFsc2UpLCAwID09PSBlMy5zdHJtLmF2YWlsX291dCkpCiAgICAgICAgICAgICAgICAgIHJldHVybiBBOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gZTMuaW5zZXJ0ID0gMCwgdDMgPT09IGYgPyAoTihlMywgdHJ1ZSksIDAgPT09IGUzLnN0cm0uYXZhaWxfb3V0ID8gTyA6IEIpIDogZTMubGFzdF9saXQgJiYgKE4oZTMsIGZhbHNlKSwgMCA9PT0gZTMuc3RybS5hdmFpbF9vdXQpID8gQSA6IEk7CiAgICAgICAgICAgIH0objIsIHQyKSA6IDMgPT09IG4yLnN0cmF0ZWd5ID8gZnVuY3Rpb24oZTMsIHQzKSB7CiAgICAgICAgICAgICAgZm9yICh2YXIgcjMsIG4zLCBpMywgczMsIGEzID0gZTMud2luZG93OyA7ICkgewogICAgICAgICAgICAgICAgaWYgKGUzLmxvb2thaGVhZCA8PSBTKSB7CiAgICAgICAgICAgICAgICAgIGlmIChqKGUzKSwgZTMubG9va2FoZWFkIDw9IFMgJiYgdDMgPT09IGwpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEE7CiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBlMy5sb29rYWhlYWQpCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoZTMubWF0Y2hfbGVuZ3RoID0gMCwgZTMubG9va2FoZWFkID49IHggJiYgMCA8IGUzLnN0cnN0YXJ0ICYmIChuMyA9IGEzW2kzID0gZTMuc3Ryc3RhcnQgLSAxXSkgPT09IGEzWysraTNdICYmIG4zID09PSBhM1srK2kzXSAmJiBuMyA9PT0gYTNbKytpM10pIHsKICAgICAgICAgICAgICAgICAgczMgPSBlMy5zdHJzdGFydCArIFM7CiAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobjMgPT09IGEzWysraTNdICYmIG4zID09PSBhM1srK2kzXSAmJiBuMyA9PT0gYTNbKytpM10gJiYgbjMgPT09IGEzWysraTNdICYmIG4zID09PSBhM1srK2kzXSAmJiBuMyA9PT0gYTNbKytpM10gJiYgbjMgPT09IGEzWysraTNdICYmIG4zID09PSBhM1srK2kzXSAmJiBpMyA8IHMzKTsKICAgICAgICAgICAgICAgICAgZTMubWF0Y2hfbGVuZ3RoID0gUyAtIChzMyAtIGkzKSwgZTMubWF0Y2hfbGVuZ3RoID4gZTMubG9va2FoZWFkICYmIChlMy5tYXRjaF9sZW5ndGggPSBlMy5sb29rYWhlYWQpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGUzLm1hdGNoX2xlbmd0aCA+PSB4ID8gKHIzID0gdS5fdHJfdGFsbHkoZTMsIDEsIGUzLm1hdGNoX2xlbmd0aCAtIHgpLCBlMy5sb29rYWhlYWQgLT0gZTMubWF0Y2hfbGVuZ3RoLCBlMy5zdHJzdGFydCArPSBlMy5tYXRjaF9sZW5ndGgsIGUzLm1hdGNoX2xlbmd0aCA9IDApIDogKHIzID0gdS5fdHJfdGFsbHkoZTMsIDAsIGUzLndpbmRvd1tlMy5zdHJzdGFydF0pLCBlMy5sb29rYWhlYWQtLSwgZTMuc3Ryc3RhcnQrKyksIHIzICYmIChOKGUzLCBmYWxzZSksIDAgPT09IGUzLnN0cm0uYXZhaWxfb3V0KSkKICAgICAgICAgICAgICAgICAgcmV0dXJuIEE7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBlMy5pbnNlcnQgPSAwLCB0MyA9PT0gZiA/IChOKGUzLCB0cnVlKSwgMCA9PT0gZTMuc3RybS5hdmFpbF9vdXQgPyBPIDogQikgOiBlMy5sYXN0X2xpdCAmJiAoTihlMywgZmFsc2UpLCAwID09PSBlMy5zdHJtLmF2YWlsX291dCkgPyBBIDogSTsKICAgICAgICAgICAgfShuMiwgdDIpIDogaFtuMi5sZXZlbF0uZnVuYyhuMiwgdDIpOwogICAgICAgICAgICBpZiAobzIgIT09IE8gJiYgbzIgIT09IEIgfHwgKG4yLnN0YXR1cyA9IDY2NiksIG8yID09PSBBIHx8IG8yID09PSBPKQogICAgICAgICAgICAgIHJldHVybiAwID09PSBlMi5hdmFpbF9vdXQgJiYgKG4yLmxhc3RfZmx1c2ggPSAtMSksIG07CiAgICAgICAgICAgIGlmIChvMiA9PT0gSSAmJiAoMSA9PT0gdDIgPyB1Ll90cl9hbGlnbihuMikgOiA1ICE9PSB0MiAmJiAodS5fdHJfc3RvcmVkX2Jsb2NrKG4yLCAwLCAwLCBmYWxzZSksIDMgPT09IHQyICYmIChEKG4yLmhlYWQpLCAwID09PSBuMi5sb29rYWhlYWQgJiYgKG4yLnN0cnN0YXJ0ID0gMCwgbjIuYmxvY2tfc3RhcnQgPSAwLCBuMi5pbnNlcnQgPSAwKSkpLCBGKGUyKSwgMCA9PT0gZTIuYXZhaWxfb3V0KSkKICAgICAgICAgICAgICByZXR1cm4gbjIubGFzdF9mbHVzaCA9IC0xLCBtOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHQyICE9PSBmID8gbSA6IG4yLndyYXAgPD0gMCA/IDEgOiAoMiA9PT0gbjIud3JhcCA/IChVKG4yLCAyNTUgJiBlMi5hZGxlciksIFUobjIsIGUyLmFkbGVyID4+IDggJiAyNTUpLCBVKG4yLCBlMi5hZGxlciA+PiAxNiAmIDI1NSksIFUobjIsIGUyLmFkbGVyID4+IDI0ICYgMjU1KSwgVShuMiwgMjU1ICYgZTIudG90YWxfaW4pLCBVKG4yLCBlMi50b3RhbF9pbiA+PiA4ICYgMjU1KSwgVShuMiwgZTIudG90YWxfaW4gPj4gMTYgJiAyNTUpLCBVKG4yLCBlMi50b3RhbF9pbiA+PiAyNCAmIDI1NSkpIDogKFAobjIsIGUyLmFkbGVyID4+PiAxNiksIFAobjIsIDY1NTM1ICYgZTIuYWRsZXIpKSwgRihlMiksIDAgPCBuMi53cmFwICYmIChuMi53cmFwID0gLW4yLndyYXApLCAwICE9PSBuMi5wZW5kaW5nID8gbSA6IDEpOwogICAgICAgIH0sIHIuZGVmbGF0ZUVuZCA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICB2YXIgdDI7CiAgICAgICAgICByZXR1cm4gZTIgJiYgZTIuc3RhdGUgPyAodDIgPSBlMi5zdGF0ZS5zdGF0dXMpICE9PSBDICYmIDY5ICE9PSB0MiAmJiA3MyAhPT0gdDIgJiYgOTEgIT09IHQyICYmIDEwMyAhPT0gdDIgJiYgdDIgIT09IEUgJiYgNjY2ICE9PSB0MiA/IFIoZTIsIF8pIDogKGUyLnN0YXRlID0gbnVsbCwgdDIgPT09IEUgPyBSKGUyLCAtMykgOiBtKSA6IF87CiAgICAgICAgfSwgci5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgdmFyIHIyLCBuMiwgaTIsIHMyLCBhMiwgbzIsIGgyLCB1MiwgbDIgPSB0Mi5sZW5ndGg7CiAgICAgICAgICBpZiAoIWUyIHx8ICFlMi5zdGF0ZSkKICAgICAgICAgICAgcmV0dXJuIF87CiAgICAgICAgICBpZiAoMiA9PT0gKHMyID0gKHIyID0gZTIuc3RhdGUpLndyYXApIHx8IDEgPT09IHMyICYmIHIyLnN0YXR1cyAhPT0gQyB8fCByMi5sb29rYWhlYWQpCiAgICAgICAgICAgIHJldHVybiBfOwogICAgICAgICAgZm9yICgxID09PSBzMiAmJiAoZTIuYWRsZXIgPSBkKGUyLmFkbGVyLCB0MiwgbDIsIDApKSwgcjIud3JhcCA9IDAsIGwyID49IHIyLndfc2l6ZSAmJiAoMCA9PT0gczIgJiYgKEQocjIuaGVhZCksIHIyLnN0cnN0YXJ0ID0gMCwgcjIuYmxvY2tfc3RhcnQgPSAwLCByMi5pbnNlcnQgPSAwKSwgdTIgPSBuZXcgYy5CdWY4KHIyLndfc2l6ZSksIGMuYXJyYXlTZXQodTIsIHQyLCBsMiAtIHIyLndfc2l6ZSwgcjIud19zaXplLCAwKSwgdDIgPSB1MiwgbDIgPSByMi53X3NpemUpLCBhMiA9IGUyLmF2YWlsX2luLCBvMiA9IGUyLm5leHRfaW4sIGgyID0gZTIuaW5wdXQsIGUyLmF2YWlsX2luID0gbDIsIGUyLm5leHRfaW4gPSAwLCBlMi5pbnB1dCA9IHQyLCBqKHIyKTsgcjIubG9va2FoZWFkID49IHg7ICkgewogICAgICAgICAgICBmb3IgKG4yID0gcjIuc3Ryc3RhcnQsIGkyID0gcjIubG9va2FoZWFkIC0gKHggLSAxKTsgcjIuaW5zX2ggPSAocjIuaW5zX2ggPDwgcjIuaGFzaF9zaGlmdCBeIHIyLndpbmRvd1tuMiArIHggLSAxXSkgJiByMi5oYXNoX21hc2ssIHIyLnByZXZbbjIgJiByMi53X21hc2tdID0gcjIuaGVhZFtyMi5pbnNfaF0sIHIyLmhlYWRbcjIuaW5zX2hdID0gbjIsIG4yKyssIC0taTI7ICkKICAgICAgICAgICAgICA7CiAgICAgICAgICAgIHIyLnN0cnN0YXJ0ID0gbjIsIHIyLmxvb2thaGVhZCA9IHggLSAxLCBqKHIyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiByMi5zdHJzdGFydCArPSByMi5sb29rYWhlYWQsIHIyLmJsb2NrX3N0YXJ0ID0gcjIuc3Ryc3RhcnQsIHIyLmluc2VydCA9IHIyLmxvb2thaGVhZCwgcjIubG9va2FoZWFkID0gMCwgcjIubWF0Y2hfbGVuZ3RoID0gcjIucHJldl9sZW5ndGggPSB4IC0gMSwgcjIubWF0Y2hfYXZhaWxhYmxlID0gMCwgZTIubmV4dF9pbiA9IG8yLCBlMi5pbnB1dCA9IGgyLCBlMi5hdmFpbF9pbiA9IGEyLCByMi53cmFwID0gczIsIG07CiAgICAgICAgfSwgci5kZWZsYXRlSW5mbyA9ICJwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpIjsKICAgICAgfSwgeyAiLi4vdXRpbHMvY29tbW9uIjogNDEsICIuL2FkbGVyMzIiOiA0MywgIi4vY3JjMzIiOiA0NSwgIi4vbWVzc2FnZXMiOiA1MSwgIi4vdHJlZXMiOiA1MiB9XSwgNDc6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICB0aGlzLnRleHQgPSAwLCB0aGlzLnRpbWUgPSAwLCB0aGlzLnhmbGFncyA9IDAsIHRoaXMub3MgPSAwLCB0aGlzLmV4dHJhID0gbnVsbCwgdGhpcy5leHRyYV9sZW4gPSAwLCB0aGlzLm5hbWUgPSAiIiwgdGhpcy5jb21tZW50ID0gIiIsIHRoaXMuaGNyYyA9IDAsIHRoaXMuZG9uZSA9IGZhbHNlOwogICAgICAgIH07CiAgICAgIH0sIHt9XSwgNDg6IFtmdW5jdGlvbihlLCB0LCByKSB7CiAgICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oZTIsIHQyKSB7CiAgICAgICAgICB2YXIgcjIsIG4sIGksIHMsIGEsIG8sIGgsIHUsIGwsIGYsIGMsIGQsIHAsIG0sIF8sIGcsIGIsIHYsIHksIHcsIGssIHgsIFMsIHosIEM7CiAgICAgICAgICByMiA9IGUyLnN0YXRlLCBuID0gZTIubmV4dF9pbiwgeiA9IGUyLmlucHV0LCBpID0gbiArIChlMi5hdmFpbF9pbiAtIDUpLCBzID0gZTIubmV4dF9vdXQsIEMgPSBlMi5vdXRwdXQsIGEgPSBzIC0gKHQyIC0gZTIuYXZhaWxfb3V0KSwgbyA9IHMgKyAoZTIuYXZhaWxfb3V0IC0gMjU3KSwgaCA9IHIyLmRtYXgsIHUgPSByMi53c2l6ZSwgbCA9IHIyLndoYXZlLCBmID0gcjIud25leHQsIGMgPSByMi53aW5kb3csIGQgPSByMi5ob2xkLCBwID0gcjIuYml0cywgbSA9IHIyLmxlbmNvZGUsIF8gPSByMi5kaXN0Y29kZSwgZyA9ICgxIDw8IHIyLmxlbmJpdHMpIC0gMSwgYiA9ICgxIDw8IHIyLmRpc3RiaXRzKSAtIDE7CiAgICAgICAgICBlOgogICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgcCA8IDE1ICYmIChkICs9IHpbbisrXSA8PCBwLCBwICs9IDgsIGQgKz0geltuKytdIDw8IHAsIHAgKz0gOCksIHYgPSBtW2QgJiBnXTsKICAgICAgICAgICAgICB0OgogICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgIGlmIChkID4+Pj0geSA9IHYgPj4+IDI0LCBwIC09IHksIDAgPT09ICh5ID0gdiA+Pj4gMTYgJiAyNTUpKQogICAgICAgICAgICAgICAgICAgIENbcysrXSA9IDY1NTM1ICYgdjsKICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMTYgJiB5KSkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT0gKDY0ICYgeSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgdiA9IG1bKDY1NTM1ICYgdikgKyAoZCAmICgxIDw8IHkpIC0gMSldOwogICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSB0OwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgaWYgKDMyICYgeSkgewogICAgICAgICAgICAgICAgICAgICAgICByMi5tb2RlID0gMTI7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBlMi5tc2cgPSAiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIiwgcjIubW9kZSA9IDMwOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgdyA9IDY1NTM1ICYgdiwgKHkgJj0gMTUpICYmIChwIDwgeSAmJiAoZCArPSB6W24rK10gPDwgcCwgcCArPSA4KSwgdyArPSBkICYgKDEgPDwgeSkgLSAxLCBkID4+Pj0geSwgcCAtPSB5KSwgcCA8IDE1ICYmIChkICs9IHpbbisrXSA8PCBwLCBwICs9IDgsIGQgKz0geltuKytdIDw8IHAsIHAgKz0gOCksIHYgPSBfW2QgJiBiXTsKICAgICAgICAgICAgICAgICAgICByOgogICAgICAgICAgICAgICAgICAgICAgZm9yICg7IDsgKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID4+Pj0geSA9IHYgPj4+IDI0LCBwIC09IHksICEoMTYgJiAoeSA9IHYgPj4+IDE2ICYgMjU1KSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PSAoNjQgJiB5KSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IF9bKDY1NTM1ICYgdikgKyAoZCAmICgxIDw8IHkpIC0gMSldOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgcjsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gImludmFsaWQgZGlzdGFuY2UgY29kZSIsIHIyLm1vZGUgPSAzMDsKICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrID0gNjU1MzUgJiB2LCBwIDwgKHkgJj0gMTUpICYmIChkICs9IHpbbisrXSA8PCBwLCAocCArPSA4KSA8IHkgJiYgKGQgKz0geltuKytdIDw8IHAsIHAgKz0gOCkpLCBoIDwgKGsgKz0gZCAmICgxIDw8IHkpIC0gMSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siLCByMi5tb2RlID0gMzA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA+Pj49IHksIHAgLT0geSwgKHkgPSBzIC0gYSkgPCBrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgPCAoeSA9IGsgLSB5KSAmJiByMi5zYW5lKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5tc2cgPSAiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siLCByMi5tb2RlID0gMzA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUyA9IGMsICh4ID0gMCkgPT09IGYpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ICs9IHUgLSB5LCB5IDwgdykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHcgLT0geTsgQ1tzKytdID0gY1t4KytdLCAtLXk7ICkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBzIC0gaywgUyA9IEM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmIDwgeSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggKz0gdSArIGYgLSB5LCAoeSAtPSBmKSA8IHcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh3IC09IHk7IENbcysrXSA9IGNbeCsrXSwgLS15OyApCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA9IDAsIGYgPCB3KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh3IC09IHkgPSBmOyBDW3MrK10gPSBjW3grK10sIC0teTsgKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBzIC0gaywgUyA9IEM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHggKz0gZiAtIHksIHkgPCB3KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHcgLT0geTsgQ1tzKytdID0gY1t4KytdLCAtLXk7ICkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHMgLSBrLCBTID0gQzsKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IDIgPCB3OyApCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDW3MrK10gPSBTW3grK10sIENbcysrXSA9IFNbeCsrXSwgQ1tzKytdID0gU1t4KytdLCB3IC09IDM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgdyAmJiAoQ1tzKytdID0gU1t4KytdLCAxIDwgdyAmJiAoQ1tzKytdID0gU1t4KytdKSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh4ID0gcyAtIGs7IENbcysrXSA9IENbeCsrXSwgQ1tzKytdID0gQ1t4KytdLCBDW3MrK10gPSBDW3grK10sIDIgPCAodyAtPSAzKTsgKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgOwogICAgICAgICAgICAgICAgICAgICAgICAgIHcgJiYgKENbcysrXSA9IENbeCsrXSwgMSA8IHcgJiYgKENbcysrXSA9IENbeCsrXSkpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IHdoaWxlIChuIDwgaSAmJiBzIDwgbyk7CiAgICAgICAgICBuIC09IHcgPSBwID4+IDMsIGQgJj0gKDEgPDwgKHAgLT0gdyA8PCAzKSkgLSAxLCBlMi5uZXh0X2luID0gbiwgZTIubmV4dF9vdXQgPSBzLCBlMi5hdmFpbF9pbiA9IG4gPCBpID8gaSAtIG4gKyA1IDogNSAtIChuIC0gaSksIGUyLmF2YWlsX291dCA9IHMgPCBvID8gbyAtIHMgKyAyNTcgOiAyNTcgLSAocyAtIG8pLCByMi5ob2xkID0gZCwgcjIuYml0cyA9IHA7CiAgICAgICAgfTsKICAgICAgfSwge31dLCA0OTogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgSSA9IGUoIi4uL3V0aWxzL2NvbW1vbiIpLCBPID0gZSgiLi9hZGxlcjMyIiksIEIgPSBlKCIuL2NyYzMyIiksIFIgPSBlKCIuL2luZmZhc3QiKSwgVCA9IGUoIi4vaW5mdHJlZXMiKSwgRCA9IDEsIEYgPSAyLCBOID0gMCwgVSA9IC0yLCBQID0gMSwgbiA9IDg1MiwgaSA9IDU5MjsKICAgICAgICBmdW5jdGlvbiBMKGUyKSB7CiAgICAgICAgICByZXR1cm4gKGUyID4+PiAyNCAmIDI1NSkgKyAoZTIgPj4+IDggJiA2NTI4MCkgKyAoKDY1MjgwICYgZTIpIDw8IDgpICsgKCgyNTUgJiBlMikgPDwgMjQpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBzKCkgewogICAgICAgICAgdGhpcy5tb2RlID0gMCwgdGhpcy5sYXN0ID0gZmFsc2UsIHRoaXMud3JhcCA9IDAsIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZSwgdGhpcy5mbGFncyA9IDAsIHRoaXMuZG1heCA9IDAsIHRoaXMuY2hlY2sgPSAwLCB0aGlzLnRvdGFsID0gMCwgdGhpcy5oZWFkID0gbnVsbCwgdGhpcy53Yml0cyA9IDAsIHRoaXMud3NpemUgPSAwLCB0aGlzLndoYXZlID0gMCwgdGhpcy53bmV4dCA9IDAsIHRoaXMud2luZG93ID0gbnVsbCwgdGhpcy5ob2xkID0gMCwgdGhpcy5iaXRzID0gMCwgdGhpcy5sZW5ndGggPSAwLCB0aGlzLm9mZnNldCA9IDAsIHRoaXMuZXh0cmEgPSAwLCB0aGlzLmxlbmNvZGUgPSBudWxsLCB0aGlzLmRpc3Rjb2RlID0gbnVsbCwgdGhpcy5sZW5iaXRzID0gMCwgdGhpcy5kaXN0Yml0cyA9IDAsIHRoaXMubmNvZGUgPSAwLCB0aGlzLm5sZW4gPSAwLCB0aGlzLm5kaXN0ID0gMCwgdGhpcy5oYXZlID0gMCwgdGhpcy5uZXh0ID0gbnVsbCwgdGhpcy5sZW5zID0gbmV3IEkuQnVmMTYoMzIwKSwgdGhpcy53b3JrID0gbmV3IEkuQnVmMTYoMjg4KSwgdGhpcy5sZW5keW4gPSBudWxsLCB0aGlzLmRpc3RkeW4gPSBudWxsLCB0aGlzLnNhbmUgPSAwLCB0aGlzLmJhY2sgPSAwLCB0aGlzLndhcyA9IDA7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGEoZTIpIHsKICAgICAgICAgIHZhciB0MjsKICAgICAgICAgIHJldHVybiBlMiAmJiBlMi5zdGF0ZSA/ICh0MiA9IGUyLnN0YXRlLCBlMi50b3RhbF9pbiA9IGUyLnRvdGFsX291dCA9IHQyLnRvdGFsID0gMCwgZTIubXNnID0gIiIsIHQyLndyYXAgJiYgKGUyLmFkbGVyID0gMSAmIHQyLndyYXApLCB0Mi5tb2RlID0gUCwgdDIubGFzdCA9IDAsIHQyLmhhdmVkaWN0ID0gMCwgdDIuZG1heCA9IDMyNzY4LCB0Mi5oZWFkID0gbnVsbCwgdDIuaG9sZCA9IDAsIHQyLmJpdHMgPSAwLCB0Mi5sZW5jb2RlID0gdDIubGVuZHluID0gbmV3IEkuQnVmMzIobiksIHQyLmRpc3Rjb2RlID0gdDIuZGlzdGR5biA9IG5ldyBJLkJ1ZjMyKGkpLCB0Mi5zYW5lID0gMSwgdDIuYmFjayA9IC0xLCBOKSA6IFU7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG8oZTIpIHsKICAgICAgICAgIHZhciB0MjsKICAgICAgICAgIHJldHVybiBlMiAmJiBlMi5zdGF0ZSA/ICgodDIgPSBlMi5zdGF0ZSkud3NpemUgPSAwLCB0Mi53aGF2ZSA9IDAsIHQyLnduZXh0ID0gMCwgYShlMikpIDogVTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaChlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiwgbjI7CiAgICAgICAgICByZXR1cm4gZTIgJiYgZTIuc3RhdGUgPyAobjIgPSBlMi5zdGF0ZSwgdDIgPCAwID8gKHIyID0gMCwgdDIgPSAtdDIpIDogKHIyID0gMSArICh0MiA+PiA0KSwgdDIgPCA0OCAmJiAodDIgJj0gMTUpKSwgdDIgJiYgKHQyIDwgOCB8fCAxNSA8IHQyKSA/IFUgOiAobnVsbCAhPT0gbjIud2luZG93ICYmIG4yLndiaXRzICE9PSB0MiAmJiAobjIud2luZG93ID0gbnVsbCksIG4yLndyYXAgPSByMiwgbjIud2JpdHMgPSB0MiwgbyhlMikpKSA6IFU7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHUoZTIsIHQyKSB7CiAgICAgICAgICB2YXIgcjIsIG4yOwogICAgICAgICAgcmV0dXJuIGUyID8gKG4yID0gbmV3IHMoKSwgKGUyLnN0YXRlID0gbjIpLndpbmRvdyA9IG51bGwsIChyMiA9IGgoZTIsIHQyKSkgIT09IE4gJiYgKGUyLnN0YXRlID0gbnVsbCksIHIyKSA6IFU7CiAgICAgICAgfQogICAgICAgIHZhciBsLCBmLCBjID0gdHJ1ZTsKICAgICAgICBmdW5jdGlvbiBqKGUyKSB7CiAgICAgICAgICBpZiAoYykgewogICAgICAgICAgICB2YXIgdDI7CiAgICAgICAgICAgIGZvciAobCA9IG5ldyBJLkJ1ZjMyKDUxMiksIGYgPSBuZXcgSS5CdWYzMigzMiksIHQyID0gMDsgdDIgPCAxNDQ7ICkKICAgICAgICAgICAgICBlMi5sZW5zW3QyKytdID0gODsKICAgICAgICAgICAgZm9yICg7IHQyIDwgMjU2OyApCiAgICAgICAgICAgICAgZTIubGVuc1t0MisrXSA9IDk7CiAgICAgICAgICAgIGZvciAoOyB0MiA8IDI4MDsgKQogICAgICAgICAgICAgIGUyLmxlbnNbdDIrK10gPSA3OwogICAgICAgICAgICBmb3IgKDsgdDIgPCAyODg7ICkKICAgICAgICAgICAgICBlMi5sZW5zW3QyKytdID0gODsKICAgICAgICAgICAgZm9yIChUKEQsIGUyLmxlbnMsIDAsIDI4OCwgbCwgMCwgZTIud29yaywgeyBiaXRzOiA5IH0pLCB0MiA9IDA7IHQyIDwgMzI7ICkKICAgICAgICAgICAgICBlMi5sZW5zW3QyKytdID0gNTsKICAgICAgICAgICAgVChGLCBlMi5sZW5zLCAwLCAzMiwgZiwgMCwgZTIud29yaywgeyBiaXRzOiA1IH0pLCBjID0gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgICBlMi5sZW5jb2RlID0gbCwgZTIubGVuYml0cyA9IDksIGUyLmRpc3Rjb2RlID0gZiwgZTIuZGlzdGJpdHMgPSA1OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBaKGUyLCB0MiwgcjIsIG4yKSB7CiAgICAgICAgICB2YXIgaTIsIHMyID0gZTIuc3RhdGU7CiAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gczIud2luZG93ICYmIChzMi53c2l6ZSA9IDEgPDwgczIud2JpdHMsIHMyLnduZXh0ID0gMCwgczIud2hhdmUgPSAwLCBzMi53aW5kb3cgPSBuZXcgSS5CdWY4KHMyLndzaXplKSksIG4yID49IHMyLndzaXplID8gKEkuYXJyYXlTZXQoczIud2luZG93LCB0MiwgcjIgLSBzMi53c2l6ZSwgczIud3NpemUsIDApLCBzMi53bmV4dCA9IDAsIHMyLndoYXZlID0gczIud3NpemUpIDogKG4yIDwgKGkyID0gczIud3NpemUgLSBzMi53bmV4dCkgJiYgKGkyID0gbjIpLCBJLmFycmF5U2V0KHMyLndpbmRvdywgdDIsIHIyIC0gbjIsIGkyLCBzMi53bmV4dCksIChuMiAtPSBpMikgPyAoSS5hcnJheVNldChzMi53aW5kb3csIHQyLCByMiAtIG4yLCBuMiwgMCksIHMyLnduZXh0ID0gbjIsIHMyLndoYXZlID0gczIud3NpemUpIDogKHMyLnduZXh0ICs9IGkyLCBzMi53bmV4dCA9PT0gczIud3NpemUgJiYgKHMyLnduZXh0ID0gMCksIHMyLndoYXZlIDwgczIud3NpemUgJiYgKHMyLndoYXZlICs9IGkyKSkpLCAwOwogICAgICAgIH0KICAgICAgICByLmluZmxhdGVSZXNldCA9IG8sIHIuaW5mbGF0ZVJlc2V0MiA9IGgsIHIuaW5mbGF0ZVJlc2V0S2VlcCA9IGEsIHIuaW5mbGF0ZUluaXQgPSBmdW5jdGlvbihlMikgewogICAgICAgICAgcmV0dXJuIHUoZTIsIDE1KTsKICAgICAgICB9LCByLmluZmxhdGVJbml0MiA9IHUsIHIuaW5mbGF0ZSA9IGZ1bmN0aW9uKGUyLCB0MikgewogICAgICAgICAgdmFyIHIyLCBuMiwgaTIsIHMyLCBhMiwgbzIsIGgyLCB1MiwgbDIsIGYyLCBjMiwgZCwgcCwgbSwgXywgZywgYiwgdiwgeSwgdywgaywgeCwgUywgeiwgQyA9IDAsIEUgPSBuZXcgSS5CdWY4KDQpLCBBID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdOwogICAgICAgICAgaWYgKCFlMiB8fCAhZTIuc3RhdGUgfHwgIWUyLm91dHB1dCB8fCAhZTIuaW5wdXQgJiYgMCAhPT0gZTIuYXZhaWxfaW4pCiAgICAgICAgICAgIHJldHVybiBVOwogICAgICAgICAgMTIgPT09IChyMiA9IGUyLnN0YXRlKS5tb2RlICYmIChyMi5tb2RlID0gMTMpLCBhMiA9IGUyLm5leHRfb3V0LCBpMiA9IGUyLm91dHB1dCwgaDIgPSBlMi5hdmFpbF9vdXQsIHMyID0gZTIubmV4dF9pbiwgbjIgPSBlMi5pbnB1dCwgbzIgPSBlMi5hdmFpbF9pbiwgdTIgPSByMi5ob2xkLCBsMiA9IHIyLmJpdHMsIGYyID0gbzIsIGMyID0gaDIsIHggPSBOOwogICAgICAgICAgZToKICAgICAgICAgICAgZm9yICg7IDsgKQogICAgICAgICAgICAgIHN3aXRjaCAocjIubW9kZSkgewogICAgICAgICAgICAgICAgY2FzZSBQOgogICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcjIud3JhcCkgewogICAgICAgICAgICAgICAgICAgIHIyLm1vZGUgPSAxMzsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBmb3IgKDsgbDIgPCAxNjsgKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoMiAmIHIyLndyYXAgJiYgMzU2MTUgPT09IHUyKSB7CiAgICAgICAgICAgICAgICAgICAgRVtyMi5jaGVjayA9IDBdID0gMjU1ICYgdTIsIEVbMV0gPSB1MiA+Pj4gOCAmIDI1NSwgcjIuY2hlY2sgPSBCKHIyLmNoZWNrLCBFLCAyLCAwKSwgbDIgPSB1MiA9IDAsIHIyLm1vZGUgPSAyOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChyMi5mbGFncyA9IDAsIHIyLmhlYWQgJiYgKHIyLmhlYWQuZG9uZSA9IGZhbHNlKSwgISgxICYgcjIud3JhcCkgfHwgKCgoMjU1ICYgdTIpIDw8IDgpICsgKHUyID4+IDgpKSAlIDMxKSB7CiAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gImluY29ycmVjdCBoZWFkZXIgY2hlY2siLCByMi5tb2RlID0gMzA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKDggIT0gKDE1ICYgdTIpKSB7CiAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIiwgcjIubW9kZSA9IDMwOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChsMiAtPSA0LCBrID0gOCArICgxNSAmICh1MiA+Pj49IDQpKSwgMCA9PT0gcjIud2JpdHMpCiAgICAgICAgICAgICAgICAgICAgcjIud2JpdHMgPSBrOwogICAgICAgICAgICAgICAgICBlbHNlIGlmIChrID4gcjIud2JpdHMpIHsKICAgICAgICAgICAgICAgICAgICBlMi5tc2cgPSAiaW52YWxpZCB3aW5kb3cgc2l6ZSIsIHIyLm1vZGUgPSAzMDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICByMi5kbWF4ID0gMSA8PCBrLCBlMi5hZGxlciA9IHIyLmNoZWNrID0gMSwgcjIubW9kZSA9IDUxMiAmIHUyID8gMTAgOiAxMiwgbDIgPSB1MiA9IDA7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICBmb3IgKDsgbDIgPCAxNjsgKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAocjIuZmxhZ3MgPSB1MiwgOCAhPSAoMjU1ICYgcjIuZmxhZ3MpKSB7CiAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIiwgcjIubW9kZSA9IDMwOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmICg1NzM0NCAmIHIyLmZsYWdzKSB7CiAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gInVua25vd24gaGVhZGVyIGZsYWdzIHNldCIsIHIyLm1vZGUgPSAzMDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICByMi5oZWFkICYmIChyMi5oZWFkLnRleHQgPSB1MiA+PiA4ICYgMSksIDUxMiAmIHIyLmZsYWdzICYmIChFWzBdID0gMjU1ICYgdTIsIEVbMV0gPSB1MiA+Pj4gOCAmIDI1NSwgcjIuY2hlY2sgPSBCKHIyLmNoZWNrLCBFLCAyLCAwKSksIGwyID0gdTIgPSAwLCByMi5tb2RlID0gMzsKICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgZm9yICg7IGwyIDwgMzI7ICkgewogICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgcjIuaGVhZCAmJiAocjIuaGVhZC50aW1lID0gdTIpLCA1MTIgJiByMi5mbGFncyAmJiAoRVswXSA9IDI1NSAmIHUyLCBFWzFdID0gdTIgPj4+IDggJiAyNTUsIEVbMl0gPSB1MiA+Pj4gMTYgJiAyNTUsIEVbM10gPSB1MiA+Pj4gMjQgJiAyNTUsIHIyLmNoZWNrID0gQihyMi5jaGVjaywgRSwgNCwgMCkpLCBsMiA9IHUyID0gMCwgcjIubW9kZSA9IDQ7CiAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgIGZvciAoOyBsMiA8IDE2OyApIHsKICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpCiAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHIyLmhlYWQgJiYgKHIyLmhlYWQueGZsYWdzID0gMjU1ICYgdTIsIHIyLmhlYWQub3MgPSB1MiA+PiA4KSwgNTEyICYgcjIuZmxhZ3MgJiYgKEVbMF0gPSAyNTUgJiB1MiwgRVsxXSA9IHUyID4+PiA4ICYgMjU1LCByMi5jaGVjayA9IEIocjIuY2hlY2ssIEUsIDIsIDApKSwgbDIgPSB1MiA9IDAsIHIyLm1vZGUgPSA1OwogICAgICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgICAgICBpZiAoMTAyNCAmIHIyLmZsYWdzKSB7CiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGwyIDwgMTY7ICkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKQogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHIyLmxlbmd0aCA9IHUyLCByMi5oZWFkICYmIChyMi5oZWFkLmV4dHJhX2xlbiA9IHUyKSwgNTEyICYgcjIuZmxhZ3MgJiYgKEVbMF0gPSAyNTUgJiB1MiwgRVsxXSA9IHUyID4+PiA4ICYgMjU1LCByMi5jaGVjayA9IEIocjIuY2hlY2ssIEUsIDIsIDApKSwgbDIgPSB1MiA9IDA7CiAgICAgICAgICAgICAgICAgIH0gZWxzZQogICAgICAgICAgICAgICAgICAgIHIyLmhlYWQgJiYgKHIyLmhlYWQuZXh0cmEgPSBudWxsKTsKICAgICAgICAgICAgICAgICAgcjIubW9kZSA9IDY7CiAgICAgICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgICAgIGlmICgxMDI0ICYgcjIuZmxhZ3MgJiYgKG8yIDwgKGQgPSByMi5sZW5ndGgpICYmIChkID0gbzIpLCBkICYmIChyMi5oZWFkICYmIChrID0gcjIuaGVhZC5leHRyYV9sZW4gLSByMi5sZW5ndGgsIHIyLmhlYWQuZXh0cmEgfHwgKHIyLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkocjIuaGVhZC5leHRyYV9sZW4pKSwgSS5hcnJheVNldChyMi5oZWFkLmV4dHJhLCBuMiwgczIsIGQsIGspKSwgNTEyICYgcjIuZmxhZ3MgJiYgKHIyLmNoZWNrID0gQihyMi5jaGVjaywgbjIsIGQsIHMyKSksIG8yIC09IGQsIHMyICs9IGQsIHIyLmxlbmd0aCAtPSBkKSwgcjIubGVuZ3RoKSkKICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICByMi5sZW5ndGggPSAwLCByMi5tb2RlID0gNzsKICAgICAgICAgICAgICAgIGNhc2UgNzoKICAgICAgICAgICAgICAgICAgaWYgKDIwNDggJiByMi5mbGFncykgewogICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgICAgZm9yIChkID0gMDsgayA9IG4yW3MyICsgZCsrXSwgcjIuaGVhZCAmJiBrICYmIHIyLmxlbmd0aCA8IDY1NTM2ICYmIChyMi5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShrKSksIGsgJiYgZCA8IG8yOyApCiAgICAgICAgICAgICAgICAgICAgICA7CiAgICAgICAgICAgICAgICAgICAgaWYgKDUxMiAmIHIyLmZsYWdzICYmIChyMi5jaGVjayA9IEIocjIuY2hlY2ssIG4yLCBkLCBzMikpLCBvMiAtPSBkLCBzMiArPSBkLCBrKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgICAgICAgICAgcjIuaGVhZCAmJiAocjIuaGVhZC5uYW1lID0gbnVsbCk7CiAgICAgICAgICAgICAgICAgIHIyLmxlbmd0aCA9IDAsIHIyLm1vZGUgPSA4OwogICAgICAgICAgICAgICAgY2FzZSA4OgogICAgICAgICAgICAgICAgICBpZiAoNDA5NiAmIHIyLmZsYWdzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICBmb3IgKGQgPSAwOyBrID0gbjJbczIgKyBkKytdLCByMi5oZWFkICYmIGsgJiYgcjIubGVuZ3RoIDwgNjU1MzYgJiYgKHIyLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGspKSwgayAmJiBkIDwgbzI7ICkKICAgICAgICAgICAgICAgICAgICAgIDsKICAgICAgICAgICAgICAgICAgICBpZiAoNTEyICYgcjIuZmxhZ3MgJiYgKHIyLmNoZWNrID0gQihyMi5jaGVjaywgbjIsIGQsIHMyKSksIG8yIC09IGQsIHMyICs9IGQsIGspCiAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICByMi5oZWFkICYmIChyMi5oZWFkLmNvbW1lbnQgPSBudWxsKTsKICAgICAgICAgICAgICAgICAgcjIubW9kZSA9IDk7CiAgICAgICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgICAgIGlmICg1MTIgJiByMi5mbGFncykgewogICAgICAgICAgICAgICAgICAgIGZvciAoOyBsMiA8IDE2OyApIHsKICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAodTIgIT09ICg2NTUzNSAmIHIyLmNoZWNrKSkgewogICAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gImhlYWRlciBjcmMgbWlzbWF0Y2giLCByMi5tb2RlID0gMzA7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgbDIgPSB1MiA9IDA7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgcjIuaGVhZCAmJiAocjIuaGVhZC5oY3JjID0gcjIuZmxhZ3MgPj4gOSAmIDEsIHIyLmhlYWQuZG9uZSA9IHRydWUpLCBlMi5hZGxlciA9IHIyLmNoZWNrID0gMCwgcjIubW9kZSA9IDEyOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgMTA6CiAgICAgICAgICAgICAgICAgIGZvciAoOyBsMiA8IDMyOyApIHsKICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpCiAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGUyLmFkbGVyID0gcjIuY2hlY2sgPSBMKHUyKSwgbDIgPSB1MiA9IDAsIHIyLm1vZGUgPSAxMTsKICAgICAgICAgICAgICAgIGNhc2UgMTE6CiAgICAgICAgICAgICAgICAgIGlmICgwID09PSByMi5oYXZlZGljdCkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTIubmV4dF9vdXQgPSBhMiwgZTIuYXZhaWxfb3V0ID0gaDIsIGUyLm5leHRfaW4gPSBzMiwgZTIuYXZhaWxfaW4gPSBvMiwgcjIuaG9sZCA9IHUyLCByMi5iaXRzID0gbDIsIDI7CiAgICAgICAgICAgICAgICAgIGUyLmFkbGVyID0gcjIuY2hlY2sgPSAxLCByMi5tb2RlID0gMTI7CiAgICAgICAgICAgICAgICBjYXNlIDEyOgogICAgICAgICAgICAgICAgICBpZiAoNSA9PT0gdDIgfHwgNiA9PT0gdDIpCiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgICAgICAgIGlmIChyMi5sYXN0KSB7CiAgICAgICAgICAgICAgICAgICAgdTIgPj4+PSA3ICYgbDIsIGwyIC09IDcgJiBsMiwgcjIubW9kZSA9IDI3OwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGZvciAoOyBsMiA8IDM7ICkgewogICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgc3dpdGNoIChyMi5sYXN0ID0gMSAmIHUyLCBsMiAtPSAxLCAzICYgKHUyID4+Pj0gMSkpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgICByMi5tb2RlID0gMTQ7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICAgICAgICBpZiAoaihyMiksIHIyLm1vZGUgPSAyMCwgNiAhPT0gdDIpCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgdTIgPj4+PSAyLCBsMiAtPSAyOwogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgICByMi5tb2RlID0gMTc7CiAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICBlMi5tc2cgPSAiaW52YWxpZCBibG9jayB0eXBlIiwgcjIubW9kZSA9IDMwOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHUyID4+Pj0gMiwgbDIgLT0gMjsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDE0OgogICAgICAgICAgICAgICAgICBmb3IgKHUyID4+Pj0gNyAmIGwyLCBsMiAtPSA3ICYgbDI7IGwyIDwgMzI7ICkgewogICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKCg2NTUzNSAmIHUyKSAhPSAodTIgPj4+IDE2IF4gNjU1MzUpKSB7CiAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gImludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMiLCByMi5tb2RlID0gMzA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHIyLmxlbmd0aCA9IDY1NTM1ICYgdTIsIGwyID0gdTIgPSAwLCByMi5tb2RlID0gMTUsIDYgPT09IHQyKQogICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgICAgICByMi5tb2RlID0gMTY7CiAgICAgICAgICAgICAgICBjYXNlIDE2OgogICAgICAgICAgICAgICAgICBpZiAoZCA9IHIyLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIGlmIChvMiA8IGQgJiYgKGQgPSBvMiksIGgyIDwgZCAmJiAoZCA9IGgyKSwgMCA9PT0gZCkKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgICAgSS5hcnJheVNldChpMiwgbjIsIHMyLCBkLCBhMiksIG8yIC09IGQsIHMyICs9IGQsIGgyIC09IGQsIGEyICs9IGQsIHIyLmxlbmd0aCAtPSBkOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHIyLm1vZGUgPSAxMjsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDE3OgogICAgICAgICAgICAgICAgICBmb3IgKDsgbDIgPCAxNDsgKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKQogICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAocjIubmxlbiA9IDI1NyArICgzMSAmIHUyKSwgdTIgPj4+PSA1LCBsMiAtPSA1LCByMi5uZGlzdCA9IDEgKyAoMzEgJiB1MiksIHUyID4+Pj0gNSwgbDIgLT0gNSwgcjIubmNvZGUgPSA0ICsgKDE1ICYgdTIpLCB1MiA+Pj49IDQsIGwyIC09IDQsIDI4NiA8IHIyLm5sZW4gfHwgMzAgPCByMi5uZGlzdCkgewogICAgICAgICAgICAgICAgICAgIGUyLm1zZyA9ICJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyIsIHIyLm1vZGUgPSAzMDsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICByMi5oYXZlID0gMCwgcjIubW9kZSA9IDE4OwogICAgICAgICAgICAgICAgY2FzZSAxODoKICAgICAgICAgICAgICAgICAgZm9yICg7IHIyLmhhdmUgPCByMi5uY29kZTsgKSB7CiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGwyIDwgMzsgKSB7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcjIubGVuc1tBW3IyLmhhdmUrK11dID0gNyAmIHUyLCB1MiA+Pj49IDMsIGwyIC09IDM7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZm9yICg7IHIyLmhhdmUgPCAxOTsgKQogICAgICAgICAgICAgICAgICAgIHIyLmxlbnNbQVtyMi5oYXZlKytdXSA9IDA7CiAgICAgICAgICAgICAgICAgIGlmIChyMi5sZW5jb2RlID0gcjIubGVuZHluLCByMi5sZW5iaXRzID0gNywgUyA9IHsgYml0czogcjIubGVuYml0cyB9LCB4ID0gVCgwLCByMi5sZW5zLCAwLCAxOSwgcjIubGVuY29kZSwgMCwgcjIud29yaywgUyksIHIyLmxlbmJpdHMgPSBTLmJpdHMsIHgpIHsKICAgICAgICAgICAgICAgICAgICBlMi5tc2cgPSAiaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0IiwgcjIubW9kZSA9IDMwOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHIyLmhhdmUgPSAwLCByMi5tb2RlID0gMTk7CiAgICAgICAgICAgICAgICBjYXNlIDE5OgogICAgICAgICAgICAgICAgICBmb3IgKDsgcjIuaGF2ZSA8IHIyLm5sZW4gKyByMi5uZGlzdDsgKSB7CiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGcgPSAoQyA9IHIyLmxlbmNvZGVbdTIgJiAoMSA8PCByMi5sZW5iaXRzKSAtIDFdKSA+Pj4gMTYgJiAyNTUsIGIgPSA2NTUzNSAmIEMsICEoKF8gPSBDID4+PiAyNCkgPD0gbDIpOyApIHsKICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoYiA8IDE2KQogICAgICAgICAgICAgICAgICAgICAgdTIgPj4+PSBfLCBsMiAtPSBfLCByMi5sZW5zW3IyLmhhdmUrK10gPSBiOwogICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgaWYgKDE2ID09PSBiKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeiA9IF8gKyAyOyBsMiA8IHo7ICkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHUyID4+Pj0gXywgbDIgLT0gXywgMCA9PT0gcjIuaGF2ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgIGUyLm1zZyA9ICJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IiwgcjIubW9kZSA9IDMwOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSByMi5sZW5zW3IyLmhhdmUgLSAxXSwgZCA9IDMgKyAoMyAmIHUyKSwgdTIgPj4+PSAyLCBsMiAtPSAyOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgxNyA9PT0gYikgewogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHogPSBfICsgMzsgbDIgPCB6OyApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGwyIC09IF8sIGsgPSAwLCBkID0gMyArICg3ICYgKHUyID4+Pj0gXykpLCB1MiA+Pj49IDMsIGwyIC09IDM7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHogPSBfICsgNzsgbDIgPCB6OyApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGwyIC09IF8sIGsgPSAwLCBkID0gMTEgKyAoMTI3ICYgKHUyID4+Pj0gXykpLCB1MiA+Pj49IDcsIGwyIC09IDc7CiAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBpZiAocjIuaGF2ZSArIGQgPiByMi5ubGVuICsgcjIubmRpc3QpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiLCByMi5tb2RlID0gMzA7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGQtLTsgKQogICAgICAgICAgICAgICAgICAgICAgICByMi5sZW5zW3IyLmhhdmUrK10gPSBrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoMzAgPT09IHIyLm1vZGUpCiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIGlmICgwID09PSByMi5sZW5zWzI1Nl0pIHsKICAgICAgICAgICAgICAgICAgICBlMi5tc2cgPSAiaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrIiwgcjIubW9kZSA9IDMwOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChyMi5sZW5iaXRzID0gOSwgUyA9IHsgYml0czogcjIubGVuYml0cyB9LCB4ID0gVChELCByMi5sZW5zLCAwLCByMi5ubGVuLCByMi5sZW5jb2RlLCAwLCByMi53b3JrLCBTKSwgcjIubGVuYml0cyA9IFMuYml0cywgeCkgewogICAgICAgICAgICAgICAgICAgIGUyLm1zZyA9ICJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQiLCByMi5tb2RlID0gMzA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHIyLmRpc3RiaXRzID0gNiwgcjIuZGlzdGNvZGUgPSByMi5kaXN0ZHluLCBTID0geyBiaXRzOiByMi5kaXN0Yml0cyB9LCB4ID0gVChGLCByMi5sZW5zLCByMi5ubGVuLCByMi5uZGlzdCwgcjIuZGlzdGNvZGUsIDAsIHIyLndvcmssIFMpLCByMi5kaXN0Yml0cyA9IFMuYml0cywgeCkgewogICAgICAgICAgICAgICAgICAgIGUyLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlcyBzZXQiLCByMi5tb2RlID0gMzA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKHIyLm1vZGUgPSAyMCwgNiA9PT0gdDIpCiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgIGNhc2UgMjA6CiAgICAgICAgICAgICAgICAgIHIyLm1vZGUgPSAyMTsKICAgICAgICAgICAgICAgIGNhc2UgMjE6CiAgICAgICAgICAgICAgICAgIGlmICg2IDw9IG8yICYmIDI1OCA8PSBoMikgewogICAgICAgICAgICAgICAgICAgIGUyLm5leHRfb3V0ID0gYTIsIGUyLmF2YWlsX291dCA9IGgyLCBlMi5uZXh0X2luID0gczIsIGUyLmF2YWlsX2luID0gbzIsIHIyLmhvbGQgPSB1MiwgcjIuYml0cyA9IGwyLCBSKGUyLCBjMiksIGEyID0gZTIubmV4dF9vdXQsIGkyID0gZTIub3V0cHV0LCBoMiA9IGUyLmF2YWlsX291dCwgczIgPSBlMi5uZXh0X2luLCBuMiA9IGUyLmlucHV0LCBvMiA9IGUyLmF2YWlsX2luLCB1MiA9IHIyLmhvbGQsIGwyID0gcjIuYml0cywgMTIgPT09IHIyLm1vZGUgJiYgKHIyLmJhY2sgPSAtMSk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZm9yIChyMi5iYWNrID0gMDsgZyA9IChDID0gcjIubGVuY29kZVt1MiAmICgxIDw8IHIyLmxlbmJpdHMpIC0gMV0pID4+PiAxNiAmIDI1NSwgYiA9IDY1NTM1ICYgQywgISgoXyA9IEMgPj4+IDI0KSA8PSBsMik7ICkgewogICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGcgJiYgMCA9PSAoMjQwICYgZykpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKHYgPSBfLCB5ID0gZywgdyA9IGI7IGcgPSAoQyA9IHIyLmxlbmNvZGVbdyArICgodTIgJiAoMSA8PCB2ICsgeSkgLSAxKSA+PiB2KV0pID4+PiAxNiAmIDI1NSwgYiA9IDY1NTM1ICYgQywgISh2ICsgKF8gPSBDID4+PiAyNCkgPD0gbDIpOyApIHsKICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB1MiA+Pj49IHYsIGwyIC09IHYsIHIyLmJhY2sgKz0gdjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAodTIgPj4+PSBfLCBsMiAtPSBfLCByMi5iYWNrICs9IF8sIHIyLmxlbmd0aCA9IGIsIDAgPT09IGcpIHsKICAgICAgICAgICAgICAgICAgICByMi5tb2RlID0gMjY7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKDMyICYgZykgewogICAgICAgICAgICAgICAgICAgIHIyLmJhY2sgPSAtMSwgcjIubW9kZSA9IDEyOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmICg2NCAmIGcpIHsKICAgICAgICAgICAgICAgICAgICBlMi5tc2cgPSAiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIiwgcjIubW9kZSA9IDMwOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHIyLmV4dHJhID0gMTUgJiBnLCByMi5tb2RlID0gMjI7CiAgICAgICAgICAgICAgICBjYXNlIDIyOgogICAgICAgICAgICAgICAgICBpZiAocjIuZXh0cmEpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKHogPSByMi5leHRyYTsgbDIgPCB6OyApIHsKICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICByMi5sZW5ndGggKz0gdTIgJiAoMSA8PCByMi5leHRyYSkgLSAxLCB1MiA+Pj49IHIyLmV4dHJhLCBsMiAtPSByMi5leHRyYSwgcjIuYmFjayArPSByMi5leHRyYTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICByMi53YXMgPSByMi5sZW5ndGgsIHIyLm1vZGUgPSAyMzsKICAgICAgICAgICAgICAgIGNhc2UgMjM6CiAgICAgICAgICAgICAgICAgIGZvciAoOyBnID0gKEMgPSByMi5kaXN0Y29kZVt1MiAmICgxIDw8IHIyLmRpc3RiaXRzKSAtIDFdKSA+Pj4gMTYgJiAyNTUsIGIgPSA2NTUzNSAmIEMsICEoKF8gPSBDID4+PiAyNCkgPD0gbDIpOyApIHsKICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpCiAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmICgwID09ICgyNDAgJiBnKSkgewogICAgICAgICAgICAgICAgICAgIGZvciAodiA9IF8sIHkgPSBnLCB3ID0gYjsgZyA9IChDID0gcjIuZGlzdGNvZGVbdyArICgodTIgJiAoMSA8PCB2ICsgeSkgLSAxKSA+PiB2KV0pID4+PiAxNiAmIDI1NSwgYiA9IDY1NTM1ICYgQywgISh2ICsgKF8gPSBDID4+PiAyNCkgPD0gbDIpOyApIHsKICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB1MiA+Pj49IHYsIGwyIC09IHYsIHIyLmJhY2sgKz0gdjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAodTIgPj4+PSBfLCBsMiAtPSBfLCByMi5iYWNrICs9IF8sIDY0ICYgZykgewogICAgICAgICAgICAgICAgICAgIGUyLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiLCByMi5tb2RlID0gMzA7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgcjIub2Zmc2V0ID0gYiwgcjIuZXh0cmEgPSAxNSAmIGcsIHIyLm1vZGUgPSAyNDsKICAgICAgICAgICAgICAgIGNhc2UgMjQ6CiAgICAgICAgICAgICAgICAgIGlmIChyMi5leHRyYSkgewogICAgICAgICAgICAgICAgICAgIGZvciAoeiA9IHIyLmV4dHJhOyBsMiA8IHo7ICkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKQogICAgICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHIyLm9mZnNldCArPSB1MiAmICgxIDw8IHIyLmV4dHJhKSAtIDEsIHUyID4+Pj0gcjIuZXh0cmEsIGwyIC09IHIyLmV4dHJhLCByMi5iYWNrICs9IHIyLmV4dHJhOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGlmIChyMi5vZmZzZXQgPiByMi5kbWF4KSB7CiAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIiwgcjIubW9kZSA9IDMwOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHIyLm1vZGUgPSAyNTsKICAgICAgICAgICAgICAgIGNhc2UgMjU6CiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBoMikKICAgICAgICAgICAgICAgICAgICBicmVhayBlOwogICAgICAgICAgICAgICAgICBpZiAoZCA9IGMyIC0gaDIsIHIyLm9mZnNldCA+IGQpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoKGQgPSByMi5vZmZzZXQgLSBkKSA+IHIyLndoYXZlICYmIHIyLnNhbmUpIHsKICAgICAgICAgICAgICAgICAgICAgIGUyLm1zZyA9ICJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayIsIHIyLm1vZGUgPSAzMDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBwID0gZCA+IHIyLnduZXh0ID8gKGQgLT0gcjIud25leHQsIHIyLndzaXplIC0gZCkgOiByMi53bmV4dCAtIGQsIGQgPiByMi5sZW5ndGggJiYgKGQgPSByMi5sZW5ndGgpLCBtID0gcjIud2luZG93OwogICAgICAgICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICAgICAgICBtID0gaTIsIHAgPSBhMiAtIHIyLm9mZnNldCwgZCA9IHIyLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgZm9yIChoMiA8IGQgJiYgKGQgPSBoMiksIGgyIC09IGQsIHIyLmxlbmd0aCAtPSBkOyBpMlthMisrXSA9IG1bcCsrXSwgLS1kOyApCiAgICAgICAgICAgICAgICAgICAgOwogICAgICAgICAgICAgICAgICAwID09PSByMi5sZW5ndGggJiYgKHIyLm1vZGUgPSAyMSk7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAyNjoKICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGgyKQogICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgIGkyW2EyKytdID0gcjIubGVuZ3RoLCBoMi0tLCByMi5tb2RlID0gMjE7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAyNzoKICAgICAgICAgICAgICAgICAgaWYgKHIyLndyYXApIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKDsgbDIgPCAzMjsgKSB7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7CiAgICAgICAgICAgICAgICAgICAgICBvMi0tLCB1MiB8PSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKGMyIC09IGgyLCBlMi50b3RhbF9vdXQgKz0gYzIsIHIyLnRvdGFsICs9IGMyLCBjMiAmJiAoZTIuYWRsZXIgPSByMi5jaGVjayA9IHIyLmZsYWdzID8gQihyMi5jaGVjaywgaTIsIGMyLCBhMiAtIGMyKSA6IE8ocjIuY2hlY2ssIGkyLCBjMiwgYTIgLSBjMikpLCBjMiA9IGgyLCAocjIuZmxhZ3MgPyB1MiA6IEwodTIpKSAhPT0gcjIuY2hlY2spIHsKICAgICAgICAgICAgICAgICAgICAgIGUyLm1zZyA9ICJpbmNvcnJlY3QgZGF0YSBjaGVjayIsIHIyLm1vZGUgPSAzMDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBsMiA9IHUyID0gMDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICByMi5tb2RlID0gMjg7CiAgICAgICAgICAgICAgICBjYXNlIDI4OgogICAgICAgICAgICAgICAgICBpZiAocjIud3JhcCAmJiByMi5mbGFncykgewogICAgICAgICAgICAgICAgICAgIGZvciAoOyBsMiA8IDMyOyApIHsKICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4OwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAodTIgIT09ICg0Mjk0OTY3Mjk1ICYgcjIudG90YWwpKSB7CiAgICAgICAgICAgICAgICAgICAgICBlMi5tc2cgPSAiaW5jb3JyZWN0IGxlbmd0aCBjaGVjayIsIHIyLm1vZGUgPSAzMDsKICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBsMiA9IHUyID0gMDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICByMi5tb2RlID0gMjk7CiAgICAgICAgICAgICAgICBjYXNlIDI5OgogICAgICAgICAgICAgICAgICB4ID0gMTsKICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgIGNhc2UgMzA6CiAgICAgICAgICAgICAgICAgIHggPSAtMzsKICAgICAgICAgICAgICAgICAgYnJlYWsgZTsKICAgICAgICAgICAgICAgIGNhc2UgMzE6CiAgICAgICAgICAgICAgICAgIHJldHVybiAtNDsKICAgICAgICAgICAgICAgIGNhc2UgMzI6CiAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICByZXR1cm4gVTsKICAgICAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gZTIubmV4dF9vdXQgPSBhMiwgZTIuYXZhaWxfb3V0ID0gaDIsIGUyLm5leHRfaW4gPSBzMiwgZTIuYXZhaWxfaW4gPSBvMiwgcjIuaG9sZCA9IHUyLCByMi5iaXRzID0gbDIsIChyMi53c2l6ZSB8fCBjMiAhPT0gZTIuYXZhaWxfb3V0ICYmIHIyLm1vZGUgPCAzMCAmJiAocjIubW9kZSA8IDI3IHx8IDQgIT09IHQyKSkgJiYgWihlMiwgZTIub3V0cHV0LCBlMi5uZXh0X291dCwgYzIgLSBlMi5hdmFpbF9vdXQpID8gKHIyLm1vZGUgPSAzMSwgLTQpIDogKGYyIC09IGUyLmF2YWlsX2luLCBjMiAtPSBlMi5hdmFpbF9vdXQsIGUyLnRvdGFsX2luICs9IGYyLCBlMi50b3RhbF9vdXQgKz0gYzIsIHIyLnRvdGFsICs9IGMyLCByMi53cmFwICYmIGMyICYmIChlMi5hZGxlciA9IHIyLmNoZWNrID0gcjIuZmxhZ3MgPyBCKHIyLmNoZWNrLCBpMiwgYzIsIGUyLm5leHRfb3V0IC0gYzIpIDogTyhyMi5jaGVjaywgaTIsIGMyLCBlMi5uZXh0X291dCAtIGMyKSksIGUyLmRhdGFfdHlwZSA9IHIyLmJpdHMgKyAocjIubGFzdCA/IDY0IDogMCkgKyAoMTIgPT09IHIyLm1vZGUgPyAxMjggOiAwKSArICgyMCA9PT0gcjIubW9kZSB8fCAxNSA9PT0gcjIubW9kZSA/IDI1NiA6IDApLCAoMCA9PSBmMiAmJiAwID09PSBjMiB8fCA0ID09PSB0MikgJiYgeCA9PT0gTiAmJiAoeCA9IC01KSwgeCk7CiAgICAgICAgfSwgci5pbmZsYXRlRW5kID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIGlmICghZTIgfHwgIWUyLnN0YXRlKQogICAgICAgICAgICByZXR1cm4gVTsKICAgICAgICAgIHZhciB0MiA9IGUyLnN0YXRlOwogICAgICAgICAgcmV0dXJuIHQyLndpbmRvdyAmJiAodDIud2luZG93ID0gbnVsbCksIGUyLnN0YXRlID0gbnVsbCwgTjsKICAgICAgICB9LCByLmluZmxhdGVHZXRIZWFkZXIgPSBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHZhciByMjsKICAgICAgICAgIHJldHVybiBlMiAmJiBlMi5zdGF0ZSA/IDAgPT0gKDIgJiAocjIgPSBlMi5zdGF0ZSkud3JhcCkgPyBVIDogKChyMi5oZWFkID0gdDIpLmRvbmUgPSBmYWxzZSwgTikgOiBVOwogICAgICAgIH0sIHIuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBmdW5jdGlvbihlMiwgdDIpIHsKICAgICAgICAgIHZhciByMiwgbjIgPSB0Mi5sZW5ndGg7CiAgICAgICAgICByZXR1cm4gZTIgJiYgZTIuc3RhdGUgPyAwICE9PSAocjIgPSBlMi5zdGF0ZSkud3JhcCAmJiAxMSAhPT0gcjIubW9kZSA/IFUgOiAxMSA9PT0gcjIubW9kZSAmJiBPKDEsIHQyLCBuMiwgMCkgIT09IHIyLmNoZWNrID8gLTMgOiBaKGUyLCB0MiwgbjIsIG4yKSA/IChyMi5tb2RlID0gMzEsIC00KSA6IChyMi5oYXZlZGljdCA9IDEsIE4pIDogVTsKICAgICAgICB9LCByLmluZmxhdGVJbmZvID0gInBha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCkiOwogICAgICB9LCB7ICIuLi91dGlscy9jb21tb24iOiA0MSwgIi4vYWRsZXIzMiI6IDQzLCAiLi9jcmMzMiI6IDQ1LCAiLi9pbmZmYXN0IjogNDgsICIuL2luZnRyZWVzIjogNTAgfV0sIDUwOiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIHZhciBEID0gZSgiLi4vdXRpbHMvY29tbW9uIiksIEYgPSBbMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSwgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBdLCBOID0gWzE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LCAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XSwgVSA9IFsxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSwgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMF0sIFAgPSBbMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LCAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XTsKICAgICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbihlMiwgdDIsIHIyLCBuLCBpLCBzLCBhLCBvKSB7CiAgICAgICAgICB2YXIgaCwgdSwgbCwgZiwgYywgZCwgcCwgbSwgXywgZyA9IG8uYml0cywgYiA9IDAsIHYgPSAwLCB5ID0gMCwgdyA9IDAsIGsgPSAwLCB4ID0gMCwgUyA9IDAsIHogPSAwLCBDID0gMCwgRSA9IDAsIEEgPSBudWxsLCBJID0gMCwgTyA9IG5ldyBELkJ1ZjE2KDE2KSwgQiA9IG5ldyBELkJ1ZjE2KDE2KSwgUiA9IG51bGwsIFQgPSAwOwogICAgICAgICAgZm9yIChiID0gMDsgYiA8PSAxNTsgYisrKQogICAgICAgICAgICBPW2JdID0gMDsKICAgICAgICAgIGZvciAodiA9IDA7IHYgPCBuOyB2KyspCiAgICAgICAgICAgIE9bdDJbcjIgKyB2XV0rKzsKICAgICAgICAgIGZvciAoayA9IGcsIHcgPSAxNTsgMSA8PSB3ICYmIDAgPT09IE9bd107IHctLSkKICAgICAgICAgICAgOwogICAgICAgICAgaWYgKHcgPCBrICYmIChrID0gdyksIDAgPT09IHcpCiAgICAgICAgICAgIHJldHVybiBpW3MrK10gPSAyMDk3MTUyMCwgaVtzKytdID0gMjA5NzE1MjAsIG8uYml0cyA9IDEsIDA7CiAgICAgICAgICBmb3IgKHkgPSAxOyB5IDwgdyAmJiAwID09PSBPW3ldOyB5KyspCiAgICAgICAgICAgIDsKICAgICAgICAgIGZvciAoayA8IHkgJiYgKGsgPSB5KSwgYiA9IHogPSAxOyBiIDw9IDE1OyBiKyspCiAgICAgICAgICAgIGlmICh6IDw8PSAxLCAoeiAtPSBPW2JdKSA8IDApCiAgICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgaWYgKDAgPCB6ICYmICgwID09PSBlMiB8fCAxICE9PSB3KSkKICAgICAgICAgICAgcmV0dXJuIC0xOwogICAgICAgICAgZm9yIChCWzFdID0gMCwgYiA9IDE7IGIgPCAxNTsgYisrKQogICAgICAgICAgICBCW2IgKyAxXSA9IEJbYl0gKyBPW2JdOwogICAgICAgICAgZm9yICh2ID0gMDsgdiA8IG47IHYrKykKICAgICAgICAgICAgMCAhPT0gdDJbcjIgKyB2XSAmJiAoYVtCW3QyW3IyICsgdl1dKytdID0gdik7CiAgICAgICAgICBpZiAoZCA9IDAgPT09IGUyID8gKEEgPSBSID0gYSwgMTkpIDogMSA9PT0gZTIgPyAoQSA9IEYsIEkgLT0gMjU3LCBSID0gTiwgVCAtPSAyNTcsIDI1NikgOiAoQSA9IFUsIFIgPSBQLCAtMSksIGIgPSB5LCBjID0gcywgUyA9IHYgPSBFID0gMCwgbCA9IC0xLCBmID0gKEMgPSAxIDw8ICh4ID0gaykpIC0gMSwgMSA9PT0gZTIgJiYgODUyIDwgQyB8fCAyID09PSBlMiAmJiA1OTIgPCBDKQogICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgIGZvciAoOyA7ICkgewogICAgICAgICAgICBmb3IgKHAgPSBiIC0gUywgXyA9IGFbdl0gPCBkID8gKG0gPSAwLCBhW3ZdKSA6IGFbdl0gPiBkID8gKG0gPSBSW1QgKyBhW3ZdXSwgQVtJICsgYVt2XV0pIDogKG0gPSA5NiwgMCksIGggPSAxIDw8IGIgLSBTLCB5ID0gdSA9IDEgPDwgeDsgaVtjICsgKEUgPj4gUykgKyAodSAtPSBoKV0gPSBwIDw8IDI0IHwgbSA8PCAxNiB8IF8gfCAwLCAwICE9PSB1OyApCiAgICAgICAgICAgICAgOwogICAgICAgICAgICBmb3IgKGggPSAxIDw8IGIgLSAxOyBFICYgaDsgKQogICAgICAgICAgICAgIGggPj49IDE7CiAgICAgICAgICAgIGlmICgwICE9PSBoID8gKEUgJj0gaCAtIDEsIEUgKz0gaCkgOiBFID0gMCwgdisrLCAwID09IC0tT1tiXSkgewogICAgICAgICAgICAgIGlmIChiID09PSB3KQogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgYiA9IHQyW3IyICsgYVt2XV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGsgPCBiICYmIChFICYgZikgIT09IGwpIHsKICAgICAgICAgICAgICBmb3IgKDAgPT09IFMgJiYgKFMgPSBrKSwgYyArPSB5LCB6ID0gMSA8PCAoeCA9IGIgLSBTKTsgeCArIFMgPCB3ICYmICEoKHogLT0gT1t4ICsgU10pIDw9IDApOyApCiAgICAgICAgICAgICAgICB4KyssIHogPDw9IDE7CiAgICAgICAgICAgICAgaWYgKEMgKz0gMSA8PCB4LCAxID09PSBlMiAmJiA4NTIgPCBDIHx8IDIgPT09IGUyICYmIDU5MiA8IEMpCiAgICAgICAgICAgICAgICByZXR1cm4gMTsKICAgICAgICAgICAgICBpW2wgPSBFICYgZl0gPSBrIDw8IDI0IHwgeCA8PCAxNiB8IGMgLSBzIHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIDAgIT09IEUgJiYgKGlbYyArIEVdID0gYiAtIFMgPDwgMjQgfCA2NCA8PCAxNiB8IDApLCBvLmJpdHMgPSBrLCAwOwogICAgICAgIH07CiAgICAgIH0sIHsgIi4uL3V0aWxzL2NvbW1vbiI6IDQxIH1dLCA1MTogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB0LmV4cG9ydHMgPSB7IDI6ICJuZWVkIGRpY3Rpb25hcnkiLCAxOiAic3RyZWFtIGVuZCIsIDA6ICIiLCAiLTEiOiAiZmlsZSBlcnJvciIsICItMiI6ICJzdHJlYW0gZXJyb3IiLCAiLTMiOiAiZGF0YSBlcnJvciIsICItNCI6ICJpbnN1ZmZpY2llbnQgbWVtb3J5IiwgIi01IjogImJ1ZmZlciBlcnJvciIsICItNiI6ICJpbmNvbXBhdGlibGUgdmVyc2lvbiIgfTsKICAgICAgfSwge31dLCA1MjogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB2YXIgaSA9IGUoIi4uL3V0aWxzL2NvbW1vbiIpLCBvID0gMCwgaCA9IDE7CiAgICAgICAgZnVuY3Rpb24gbihlMikgewogICAgICAgICAgZm9yICh2YXIgdDIgPSBlMi5sZW5ndGg7IDAgPD0gLS10MjsgKQogICAgICAgICAgICBlMlt0Ml0gPSAwOwogICAgICAgIH0KICAgICAgICB2YXIgcyA9IDAsIGEgPSAyOSwgdSA9IDI1NiwgbCA9IHUgKyAxICsgYSwgZiA9IDMwLCBjID0gMTksIF8gPSAyICogbCArIDEsIGcgPSAxNSwgZCA9IDE2LCBwID0gNywgbSA9IDI1NiwgYiA9IDE2LCB2ID0gMTcsIHkgPSAxOCwgdyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwXSwgayA9IFswLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTNdLCB4ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDIsIDMsIDddLCBTID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdLCB6ID0gbmV3IEFycmF5KDIgKiAobCArIDIpKTsKICAgICAgICBuKHopOwogICAgICAgIHZhciBDID0gbmV3IEFycmF5KDIgKiBmKTsKICAgICAgICBuKEMpOwogICAgICAgIHZhciBFID0gbmV3IEFycmF5KDUxMik7CiAgICAgICAgbihFKTsKICAgICAgICB2YXIgQSA9IG5ldyBBcnJheSgyNTYpOwogICAgICAgIG4oQSk7CiAgICAgICAgdmFyIEkgPSBuZXcgQXJyYXkoYSk7CiAgICAgICAgbihJKTsKICAgICAgICB2YXIgTywgQiwgUiwgVCA9IG5ldyBBcnJheShmKTsKICAgICAgICBmdW5jdGlvbiBEKGUyLCB0MiwgcjIsIG4yLCBpMikgewogICAgICAgICAgdGhpcy5zdGF0aWNfdHJlZSA9IGUyLCB0aGlzLmV4dHJhX2JpdHMgPSB0MiwgdGhpcy5leHRyYV9iYXNlID0gcjIsIHRoaXMuZWxlbXMgPSBuMiwgdGhpcy5tYXhfbGVuZ3RoID0gaTIsIHRoaXMuaGFzX3N0cmVlID0gZTIgJiYgZTIubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBGKGUyLCB0MikgewogICAgICAgICAgdGhpcy5keW5fdHJlZSA9IGUyLCB0aGlzLm1heF9jb2RlID0gMCwgdGhpcy5zdGF0X2Rlc2MgPSB0MjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTihlMikgewogICAgICAgICAgcmV0dXJuIGUyIDwgMjU2ID8gRVtlMl0gOiBFWzI1NiArIChlMiA+Pj4gNyldOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBVKGUyLCB0MikgewogICAgICAgICAgZTIucGVuZGluZ19idWZbZTIucGVuZGluZysrXSA9IDI1NSAmIHQyLCBlMi5wZW5kaW5nX2J1ZltlMi5wZW5kaW5nKytdID0gdDIgPj4+IDggJiAyNTU7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFAoZTIsIHQyLCByMikgewogICAgICAgICAgZTIuYmlfdmFsaWQgPiBkIC0gcjIgPyAoZTIuYmlfYnVmIHw9IHQyIDw8IGUyLmJpX3ZhbGlkICYgNjU1MzUsIFUoZTIsIGUyLmJpX2J1ZiksIGUyLmJpX2J1ZiA9IHQyID4+IGQgLSBlMi5iaV92YWxpZCwgZTIuYmlfdmFsaWQgKz0gcjIgLSBkKSA6IChlMi5iaV9idWYgfD0gdDIgPDwgZTIuYmlfdmFsaWQgJiA2NTUzNSwgZTIuYmlfdmFsaWQgKz0gcjIpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBMKGUyLCB0MiwgcjIpIHsKICAgICAgICAgIFAoZTIsIHIyWzIgKiB0Ml0sIHIyWzIgKiB0MiArIDFdKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaihlMiwgdDIpIHsKICAgICAgICAgIGZvciAodmFyIHIyID0gMDsgcjIgfD0gMSAmIGUyLCBlMiA+Pj49IDEsIHIyIDw8PSAxLCAwIDwgLS10MjsgKQogICAgICAgICAgICA7CiAgICAgICAgICByZXR1cm4gcjIgPj4+IDE7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFooZTIsIHQyLCByMikgewogICAgICAgICAgdmFyIG4yLCBpMiwgczIgPSBuZXcgQXJyYXkoZyArIDEpLCBhMiA9IDA7CiAgICAgICAgICBmb3IgKG4yID0gMTsgbjIgPD0gZzsgbjIrKykKICAgICAgICAgICAgczJbbjJdID0gYTIgPSBhMiArIHIyW24yIC0gMV0gPDwgMTsKICAgICAgICAgIGZvciAoaTIgPSAwOyBpMiA8PSB0MjsgaTIrKykgewogICAgICAgICAgICB2YXIgbzIgPSBlMlsyICogaTIgKyAxXTsKICAgICAgICAgICAgMCAhPT0gbzIgJiYgKGUyWzIgKiBpMl0gPSBqKHMyW28yXSsrLCBvMikpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBXKGUyKSB7CiAgICAgICAgICB2YXIgdDI7CiAgICAgICAgICBmb3IgKHQyID0gMDsgdDIgPCBsOyB0MisrKQogICAgICAgICAgICBlMi5keW5fbHRyZWVbMiAqIHQyXSA9IDA7CiAgICAgICAgICBmb3IgKHQyID0gMDsgdDIgPCBmOyB0MisrKQogICAgICAgICAgICBlMi5keW5fZHRyZWVbMiAqIHQyXSA9IDA7CiAgICAgICAgICBmb3IgKHQyID0gMDsgdDIgPCBjOyB0MisrKQogICAgICAgICAgICBlMi5ibF90cmVlWzIgKiB0Ml0gPSAwOwogICAgICAgICAgZTIuZHluX2x0cmVlWzIgKiBtXSA9IDEsIGUyLm9wdF9sZW4gPSBlMi5zdGF0aWNfbGVuID0gMCwgZTIubGFzdF9saXQgPSBlMi5tYXRjaGVzID0gMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gTShlMikgewogICAgICAgICAgOCA8IGUyLmJpX3ZhbGlkID8gVShlMiwgZTIuYmlfYnVmKSA6IDAgPCBlMi5iaV92YWxpZCAmJiAoZTIucGVuZGluZ19idWZbZTIucGVuZGluZysrXSA9IGUyLmJpX2J1ZiksIGUyLmJpX2J1ZiA9IDAsIGUyLmJpX3ZhbGlkID0gMDsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSChlMiwgdDIsIHIyLCBuMikgewogICAgICAgICAgdmFyIGkyID0gMiAqIHQyLCBzMiA9IDIgKiByMjsKICAgICAgICAgIHJldHVybiBlMltpMl0gPCBlMltzMl0gfHwgZTJbaTJdID09PSBlMltzMl0gJiYgbjJbdDJdIDw9IG4yW3IyXTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gRyhlMiwgdDIsIHIyKSB7CiAgICAgICAgICBmb3IgKHZhciBuMiA9IGUyLmhlYXBbcjJdLCBpMiA9IHIyIDw8IDE7IGkyIDw9IGUyLmhlYXBfbGVuICYmIChpMiA8IGUyLmhlYXBfbGVuICYmIEgodDIsIGUyLmhlYXBbaTIgKyAxXSwgZTIuaGVhcFtpMl0sIGUyLmRlcHRoKSAmJiBpMisrLCAhSCh0MiwgbjIsIGUyLmhlYXBbaTJdLCBlMi5kZXB0aCkpOyApCiAgICAgICAgICAgIGUyLmhlYXBbcjJdID0gZTIuaGVhcFtpMl0sIHIyID0gaTIsIGkyIDw8PSAxOwogICAgICAgICAgZTIuaGVhcFtyMl0gPSBuMjsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gSyhlMiwgdDIsIHIyKSB7CiAgICAgICAgICB2YXIgbjIsIGkyLCBzMiwgYTIsIG8yID0gMDsKICAgICAgICAgIGlmICgwICE9PSBlMi5sYXN0X2xpdCkKICAgICAgICAgICAgZm9yICg7IG4yID0gZTIucGVuZGluZ19idWZbZTIuZF9idWYgKyAyICogbzJdIDw8IDggfCBlMi5wZW5kaW5nX2J1ZltlMi5kX2J1ZiArIDIgKiBvMiArIDFdLCBpMiA9IGUyLnBlbmRpbmdfYnVmW2UyLmxfYnVmICsgbzJdLCBvMisrLCAwID09PSBuMiA/IEwoZTIsIGkyLCB0MikgOiAoTChlMiwgKHMyID0gQVtpMl0pICsgdSArIDEsIHQyKSwgMCAhPT0gKGEyID0gd1tzMl0pICYmIFAoZTIsIGkyIC09IElbczJdLCBhMiksIEwoZTIsIHMyID0gTigtLW4yKSwgcjIpLCAwICE9PSAoYTIgPSBrW3MyXSkgJiYgUChlMiwgbjIgLT0gVFtzMl0sIGEyKSksIG8yIDwgZTIubGFzdF9saXQ7ICkKICAgICAgICAgICAgICA7CiAgICAgICAgICBMKGUyLCBtLCB0Mik7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFkoZTIsIHQyKSB7CiAgICAgICAgICB2YXIgcjIsIG4yLCBpMiwgczIgPSB0Mi5keW5fdHJlZSwgYTIgPSB0Mi5zdGF0X2Rlc2Muc3RhdGljX3RyZWUsIG8yID0gdDIuc3RhdF9kZXNjLmhhc19zdHJlZSwgaDIgPSB0Mi5zdGF0X2Rlc2MuZWxlbXMsIHUyID0gLTE7CiAgICAgICAgICBmb3IgKGUyLmhlYXBfbGVuID0gMCwgZTIuaGVhcF9tYXggPSBfLCByMiA9IDA7IHIyIDwgaDI7IHIyKyspCiAgICAgICAgICAgIDAgIT09IHMyWzIgKiByMl0gPyAoZTIuaGVhcFsrK2UyLmhlYXBfbGVuXSA9IHUyID0gcjIsIGUyLmRlcHRoW3IyXSA9IDApIDogczJbMiAqIHIyICsgMV0gPSAwOwogICAgICAgICAgZm9yICg7IGUyLmhlYXBfbGVuIDwgMjsgKQogICAgICAgICAgICBzMlsyICogKGkyID0gZTIuaGVhcFsrK2UyLmhlYXBfbGVuXSA9IHUyIDwgMiA/ICsrdTIgOiAwKV0gPSAxLCBlMi5kZXB0aFtpMl0gPSAwLCBlMi5vcHRfbGVuLS0sIG8yICYmIChlMi5zdGF0aWNfbGVuIC09IGEyWzIgKiBpMiArIDFdKTsKICAgICAgICAgIGZvciAodDIubWF4X2NvZGUgPSB1MiwgcjIgPSBlMi5oZWFwX2xlbiA+PiAxOyAxIDw9IHIyOyByMi0tKQogICAgICAgICAgICBHKGUyLCBzMiwgcjIpOwogICAgICAgICAgZm9yIChpMiA9IGgyOyByMiA9IGUyLmhlYXBbMV0sIGUyLmhlYXBbMV0gPSBlMi5oZWFwW2UyLmhlYXBfbGVuLS1dLCBHKGUyLCBzMiwgMSksIG4yID0gZTIuaGVhcFsxXSwgZTIuaGVhcFstLWUyLmhlYXBfbWF4XSA9IHIyLCBlMi5oZWFwWy0tZTIuaGVhcF9tYXhdID0gbjIsIHMyWzIgKiBpMl0gPSBzMlsyICogcjJdICsgczJbMiAqIG4yXSwgZTIuZGVwdGhbaTJdID0gKGUyLmRlcHRoW3IyXSA+PSBlMi5kZXB0aFtuMl0gPyBlMi5kZXB0aFtyMl0gOiBlMi5kZXB0aFtuMl0pICsgMSwgczJbMiAqIHIyICsgMV0gPSBzMlsyICogbjIgKyAxXSA9IGkyLCBlMi5oZWFwWzFdID0gaTIrKywgRyhlMiwgczIsIDEpLCAyIDw9IGUyLmhlYXBfbGVuOyApCiAgICAgICAgICAgIDsKICAgICAgICAgIGUyLmhlYXBbLS1lMi5oZWFwX21heF0gPSBlMi5oZWFwWzFdLCBmdW5jdGlvbihlMywgdDMpIHsKICAgICAgICAgICAgdmFyIHIzLCBuMywgaTMsIHMzLCBhMywgbzMsIGgzID0gdDMuZHluX3RyZWUsIHUzID0gdDMubWF4X2NvZGUsIGwyID0gdDMuc3RhdF9kZXNjLnN0YXRpY190cmVlLCBmMiA9IHQzLnN0YXRfZGVzYy5oYXNfc3RyZWUsIGMyID0gdDMuc3RhdF9kZXNjLmV4dHJhX2JpdHMsIGQyID0gdDMuc3RhdF9kZXNjLmV4dHJhX2Jhc2UsIHAyID0gdDMuc3RhdF9kZXNjLm1heF9sZW5ndGgsIG0yID0gMDsKICAgICAgICAgICAgZm9yIChzMyA9IDA7IHMzIDw9IGc7IHMzKyspCiAgICAgICAgICAgICAgZTMuYmxfY291bnRbczNdID0gMDsKICAgICAgICAgICAgZm9yIChoM1syICogZTMuaGVhcFtlMy5oZWFwX21heF0gKyAxXSA9IDAsIHIzID0gZTMuaGVhcF9tYXggKyAxOyByMyA8IF87IHIzKyspCiAgICAgICAgICAgICAgcDIgPCAoczMgPSBoM1syICogaDNbMiAqIChuMyA9IGUzLmhlYXBbcjNdKSArIDFdICsgMV0gKyAxKSAmJiAoczMgPSBwMiwgbTIrKyksIGgzWzIgKiBuMyArIDFdID0gczMsIHUzIDwgbjMgfHwgKGUzLmJsX2NvdW50W3MzXSsrLCBhMyA9IDAsIGQyIDw9IG4zICYmIChhMyA9IGMyW24zIC0gZDJdKSwgbzMgPSBoM1syICogbjNdLCBlMy5vcHRfbGVuICs9IG8zICogKHMzICsgYTMpLCBmMiAmJiAoZTMuc3RhdGljX2xlbiArPSBvMyAqIChsMlsyICogbjMgKyAxXSArIGEzKSkpOwogICAgICAgICAgICBpZiAoMCAhPT0gbTIpIHsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICBmb3IgKHMzID0gcDIgLSAxOyAwID09PSBlMy5ibF9jb3VudFtzM107ICkKICAgICAgICAgICAgICAgICAgczMtLTsKICAgICAgICAgICAgICAgIGUzLmJsX2NvdW50W3MzXS0tLCBlMy5ibF9jb3VudFtzMyArIDFdICs9IDIsIGUzLmJsX2NvdW50W3AyXS0tLCBtMiAtPSAyOwogICAgICAgICAgICAgIH0gd2hpbGUgKDAgPCBtMik7CiAgICAgICAgICAgICAgZm9yIChzMyA9IHAyOyAwICE9PSBzMzsgczMtLSkKICAgICAgICAgICAgICAgIGZvciAobjMgPSBlMy5ibF9jb3VudFtzM107IDAgIT09IG4zOyApCiAgICAgICAgICAgICAgICAgIHUzIDwgKGkzID0gZTMuaGVhcFstLXIzXSkgfHwgKGgzWzIgKiBpMyArIDFdICE9PSBzMyAmJiAoZTMub3B0X2xlbiArPSAoczMgLSBoM1syICogaTMgKyAxXSkgKiBoM1syICogaTNdLCBoM1syICogaTMgKyAxXSA9IHMzKSwgbjMtLSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0oZTIsIHQyKSwgWihzMiwgdTIsIGUyLmJsX2NvdW50KTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gWChlMiwgdDIsIHIyKSB7CiAgICAgICAgICB2YXIgbjIsIGkyLCBzMiA9IC0xLCBhMiA9IHQyWzFdLCBvMiA9IDAsIGgyID0gNywgdTIgPSA0OwogICAgICAgICAgZm9yICgwID09PSBhMiAmJiAoaDIgPSAxMzgsIHUyID0gMyksIHQyWzIgKiAocjIgKyAxKSArIDFdID0gNjU1MzUsIG4yID0gMDsgbjIgPD0gcjI7IG4yKyspCiAgICAgICAgICAgIGkyID0gYTIsIGEyID0gdDJbMiAqIChuMiArIDEpICsgMV0sICsrbzIgPCBoMiAmJiBpMiA9PT0gYTIgfHwgKG8yIDwgdTIgPyBlMi5ibF90cmVlWzIgKiBpMl0gKz0gbzIgOiAwICE9PSBpMiA/IChpMiAhPT0gczIgJiYgZTIuYmxfdHJlZVsyICogaTJdKyssIGUyLmJsX3RyZWVbMiAqIGJdKyspIDogbzIgPD0gMTAgPyBlMi5ibF90cmVlWzIgKiB2XSsrIDogZTIuYmxfdHJlZVsyICogeV0rKywgczIgPSBpMiwgdTIgPSAobzIgPSAwKSA9PT0gYTIgPyAoaDIgPSAxMzgsIDMpIDogaTIgPT09IGEyID8gKGgyID0gNiwgMykgOiAoaDIgPSA3LCA0KSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIFYoZTIsIHQyLCByMikgewogICAgICAgICAgdmFyIG4yLCBpMiwgczIgPSAtMSwgYTIgPSB0MlsxXSwgbzIgPSAwLCBoMiA9IDcsIHUyID0gNDsKICAgICAgICAgIGZvciAoMCA9PT0gYTIgJiYgKGgyID0gMTM4LCB1MiA9IDMpLCBuMiA9IDA7IG4yIDw9IHIyOyBuMisrKQogICAgICAgICAgICBpZiAoaTIgPSBhMiwgYTIgPSB0MlsyICogKG4yICsgMSkgKyAxXSwgISgrK28yIDwgaDIgJiYgaTIgPT09IGEyKSkgewogICAgICAgICAgICAgIGlmIChvMiA8IHUyKQogICAgICAgICAgICAgICAgZm9yICg7IEwoZTIsIGkyLCBlMi5ibF90cmVlKSwgMCAhPSAtLW8yOyApCiAgICAgICAgICAgICAgICAgIDsKICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAwICE9PSBpMiA/IChpMiAhPT0gczIgJiYgKEwoZTIsIGkyLCBlMi5ibF90cmVlKSwgbzItLSksIEwoZTIsIGIsIGUyLmJsX3RyZWUpLCBQKGUyLCBvMiAtIDMsIDIpKSA6IG8yIDw9IDEwID8gKEwoZTIsIHYsIGUyLmJsX3RyZWUpLCBQKGUyLCBvMiAtIDMsIDMpKSA6IChMKGUyLCB5LCBlMi5ibF90cmVlKSwgUChlMiwgbzIgLSAxMSwgNykpOwogICAgICAgICAgICAgIHMyID0gaTIsIHUyID0gKG8yID0gMCkgPT09IGEyID8gKGgyID0gMTM4LCAzKSA6IGkyID09PSBhMiA/IChoMiA9IDYsIDMpIDogKGgyID0gNywgNCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgbihUKTsKICAgICAgICB2YXIgcSA9IGZhbHNlOwogICAgICAgIGZ1bmN0aW9uIEooZTIsIHQyLCByMiwgbjIpIHsKICAgICAgICAgIFAoZTIsIChzIDw8IDEpICsgKG4yID8gMSA6IDApLCAzKSwgZnVuY3Rpb24oZTMsIHQzLCByMywgbjMpIHsKICAgICAgICAgICAgTShlMyksIG4zICYmIChVKGUzLCByMyksIFUoZTMsIH5yMykpLCBpLmFycmF5U2V0KGUzLnBlbmRpbmdfYnVmLCBlMy53aW5kb3csIHQzLCByMywgZTMucGVuZGluZyksIGUzLnBlbmRpbmcgKz0gcjM7CiAgICAgICAgICB9KGUyLCB0MiwgcjIsIHRydWUpOwogICAgICAgIH0KICAgICAgICByLl90cl9pbml0ID0gZnVuY3Rpb24oZTIpIHsKICAgICAgICAgIHEgfHwgKGZ1bmN0aW9uKCkgewogICAgICAgICAgICB2YXIgZTMsIHQyLCByMiwgbjIsIGkyLCBzMiA9IG5ldyBBcnJheShnICsgMSk7CiAgICAgICAgICAgIGZvciAobjIgPSByMiA9IDA7IG4yIDwgYSAtIDE7IG4yKyspCiAgICAgICAgICAgICAgZm9yIChJW24yXSA9IHIyLCBlMyA9IDA7IGUzIDwgMSA8PCB3W24yXTsgZTMrKykKICAgICAgICAgICAgICAgIEFbcjIrK10gPSBuMjsKICAgICAgICAgICAgZm9yIChBW3IyIC0gMV0gPSBuMiwgbjIgPSBpMiA9IDA7IG4yIDwgMTY7IG4yKyspCiAgICAgICAgICAgICAgZm9yIChUW24yXSA9IGkyLCBlMyA9IDA7IGUzIDwgMSA8PCBrW24yXTsgZTMrKykKICAgICAgICAgICAgICAgIEVbaTIrK10gPSBuMjsKICAgICAgICAgICAgZm9yIChpMiA+Pj0gNzsgbjIgPCBmOyBuMisrKQogICAgICAgICAgICAgIGZvciAoVFtuMl0gPSBpMiA8PCA3LCBlMyA9IDA7IGUzIDwgMSA8PCBrW24yXSAtIDc7IGUzKyspCiAgICAgICAgICAgICAgICBFWzI1NiArIGkyKytdID0gbjI7CiAgICAgICAgICAgIGZvciAodDIgPSAwOyB0MiA8PSBnOyB0MisrKQogICAgICAgICAgICAgIHMyW3QyXSA9IDA7CiAgICAgICAgICAgIGZvciAoZTMgPSAwOyBlMyA8PSAxNDM7ICkKICAgICAgICAgICAgICB6WzIgKiBlMyArIDFdID0gOCwgZTMrKywgczJbOF0rKzsKICAgICAgICAgICAgZm9yICg7IGUzIDw9IDI1NTsgKQogICAgICAgICAgICAgIHpbMiAqIGUzICsgMV0gPSA5LCBlMysrLCBzMls5XSsrOwogICAgICAgICAgICBmb3IgKDsgZTMgPD0gMjc5OyApCiAgICAgICAgICAgICAgelsyICogZTMgKyAxXSA9IDcsIGUzKyssIHMyWzddKys7CiAgICAgICAgICAgIGZvciAoOyBlMyA8PSAyODc7ICkKICAgICAgICAgICAgICB6WzIgKiBlMyArIDFdID0gOCwgZTMrKywgczJbOF0rKzsKICAgICAgICAgICAgZm9yIChaKHosIGwgKyAxLCBzMiksIGUzID0gMDsgZTMgPCBmOyBlMysrKQogICAgICAgICAgICAgIENbMiAqIGUzICsgMV0gPSA1LCBDWzIgKiBlM10gPSBqKGUzLCA1KTsKICAgICAgICAgICAgTyA9IG5ldyBEKHosIHcsIHUgKyAxLCBsLCBnKSwgQiA9IG5ldyBEKEMsIGssIDAsIGYsIGcpLCBSID0gbmV3IEQobmV3IEFycmF5KDApLCB4LCAwLCBjLCBwKTsKICAgICAgICAgIH0oKSwgcSA9IHRydWUpLCBlMi5sX2Rlc2MgPSBuZXcgRihlMi5keW5fbHRyZWUsIE8pLCBlMi5kX2Rlc2MgPSBuZXcgRihlMi5keW5fZHRyZWUsIEIpLCBlMi5ibF9kZXNjID0gbmV3IEYoZTIuYmxfdHJlZSwgUiksIGUyLmJpX2J1ZiA9IDAsIGUyLmJpX3ZhbGlkID0gMCwgVyhlMik7CiAgICAgICAgfSwgci5fdHJfc3RvcmVkX2Jsb2NrID0gSiwgci5fdHJfZmx1c2hfYmxvY2sgPSBmdW5jdGlvbihlMiwgdDIsIHIyLCBuMikgewogICAgICAgICAgdmFyIGkyLCBzMiwgYTIgPSAwOwogICAgICAgICAgMCA8IGUyLmxldmVsID8gKDIgPT09IGUyLnN0cm0uZGF0YV90eXBlICYmIChlMi5zdHJtLmRhdGFfdHlwZSA9IGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgIHZhciB0MywgcjMgPSA0MDkzNjI0NDQ3OwogICAgICAgICAgICBmb3IgKHQzID0gMDsgdDMgPD0gMzE7IHQzKyssIHIzID4+Pj0gMSkKICAgICAgICAgICAgICBpZiAoMSAmIHIzICYmIDAgIT09IGUzLmR5bl9sdHJlZVsyICogdDNdKQogICAgICAgICAgICAgICAgcmV0dXJuIG87CiAgICAgICAgICAgIGlmICgwICE9PSBlMy5keW5fbHRyZWVbMThdIHx8IDAgIT09IGUzLmR5bl9sdHJlZVsyMF0gfHwgMCAhPT0gZTMuZHluX2x0cmVlWzI2XSkKICAgICAgICAgICAgICByZXR1cm4gaDsKICAgICAgICAgICAgZm9yICh0MyA9IDMyOyB0MyA8IHU7IHQzKyspCiAgICAgICAgICAgICAgaWYgKDAgIT09IGUzLmR5bl9sdHJlZVsyICogdDNdKQogICAgICAgICAgICAgICAgcmV0dXJuIGg7CiAgICAgICAgICAgIHJldHVybiBvOwogICAgICAgICAgfShlMikpLCBZKGUyLCBlMi5sX2Rlc2MpLCBZKGUyLCBlMi5kX2Rlc2MpLCBhMiA9IGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgIHZhciB0MzsKICAgICAgICAgICAgZm9yIChYKGUzLCBlMy5keW5fbHRyZWUsIGUzLmxfZGVzYy5tYXhfY29kZSksIFgoZTMsIGUzLmR5bl9kdHJlZSwgZTMuZF9kZXNjLm1heF9jb2RlKSwgWShlMywgZTMuYmxfZGVzYyksIHQzID0gYyAtIDE7IDMgPD0gdDMgJiYgMCA9PT0gZTMuYmxfdHJlZVsyICogU1t0M10gKyAxXTsgdDMtLSkKICAgICAgICAgICAgICA7CiAgICAgICAgICAgIHJldHVybiBlMy5vcHRfbGVuICs9IDMgKiAodDMgKyAxKSArIDUgKyA1ICsgNCwgdDM7CiAgICAgICAgICB9KGUyKSwgaTIgPSBlMi5vcHRfbGVuICsgMyArIDcgPj4+IDMsIChzMiA9IGUyLnN0YXRpY19sZW4gKyAzICsgNyA+Pj4gMykgPD0gaTIgJiYgKGkyID0gczIpKSA6IGkyID0gczIgPSByMiArIDUsIHIyICsgNCA8PSBpMiAmJiAtMSAhPT0gdDIgPyBKKGUyLCB0MiwgcjIsIG4yKSA6IDQgPT09IGUyLnN0cmF0ZWd5IHx8IHMyID09PSBpMiA/IChQKGUyLCAyICsgKG4yID8gMSA6IDApLCAzKSwgSyhlMiwgeiwgQykpIDogKFAoZTIsIDQgKyAobjIgPyAxIDogMCksIDMpLCBmdW5jdGlvbihlMywgdDMsIHIzLCBuMykgewogICAgICAgICAgICB2YXIgaTM7CiAgICAgICAgICAgIGZvciAoUChlMywgdDMgLSAyNTcsIDUpLCBQKGUzLCByMyAtIDEsIDUpLCBQKGUzLCBuMyAtIDQsIDQpLCBpMyA9IDA7IGkzIDwgbjM7IGkzKyspCiAgICAgICAgICAgICAgUChlMywgZTMuYmxfdHJlZVsyICogU1tpM10gKyAxXSwgMyk7CiAgICAgICAgICAgIFYoZTMsIGUzLmR5bl9sdHJlZSwgdDMgLSAxKSwgVihlMywgZTMuZHluX2R0cmVlLCByMyAtIDEpOwogICAgICAgICAgfShlMiwgZTIubF9kZXNjLm1heF9jb2RlICsgMSwgZTIuZF9kZXNjLm1heF9jb2RlICsgMSwgYTIgKyAxKSwgSyhlMiwgZTIuZHluX2x0cmVlLCBlMi5keW5fZHRyZWUpKSwgVyhlMiksIG4yICYmIE0oZTIpOwogICAgICAgIH0sIHIuX3RyX3RhbGx5ID0gZnVuY3Rpb24oZTIsIHQyLCByMikgewogICAgICAgICAgcmV0dXJuIGUyLnBlbmRpbmdfYnVmW2UyLmRfYnVmICsgMiAqIGUyLmxhc3RfbGl0XSA9IHQyID4+PiA4ICYgMjU1LCBlMi5wZW5kaW5nX2J1ZltlMi5kX2J1ZiArIDIgKiBlMi5sYXN0X2xpdCArIDFdID0gMjU1ICYgdDIsIGUyLnBlbmRpbmdfYnVmW2UyLmxfYnVmICsgZTIubGFzdF9saXRdID0gMjU1ICYgcjIsIGUyLmxhc3RfbGl0KyssIDAgPT09IHQyID8gZTIuZHluX2x0cmVlWzIgKiByMl0rKyA6IChlMi5tYXRjaGVzKyssIHQyLS0sIGUyLmR5bl9sdHJlZVsyICogKEFbcjJdICsgdSArIDEpXSsrLCBlMi5keW5fZHRyZWVbMiAqIE4odDIpXSsrKSwgZTIubGFzdF9saXQgPT09IGUyLmxpdF9idWZzaXplIC0gMTsKICAgICAgICB9LCByLl90cl9hbGlnbiA9IGZ1bmN0aW9uKGUyKSB7CiAgICAgICAgICBQKGUyLCAyLCAzKSwgTChlMiwgbSwgeiksIGZ1bmN0aW9uKGUzKSB7CiAgICAgICAgICAgIDE2ID09PSBlMy5iaV92YWxpZCA/IChVKGUzLCBlMy5iaV9idWYpLCBlMy5iaV9idWYgPSAwLCBlMy5iaV92YWxpZCA9IDApIDogOCA8PSBlMy5iaV92YWxpZCAmJiAoZTMucGVuZGluZ19idWZbZTMucGVuZGluZysrXSA9IDI1NSAmIGUzLmJpX2J1ZiwgZTMuYmlfYnVmID4+PSA4LCBlMy5iaV92YWxpZCAtPSA4KTsKICAgICAgICAgIH0oZTIpOwogICAgICAgIH07CiAgICAgIH0sIHsgIi4uL3V0aWxzL2NvbW1vbiI6IDQxIH1dLCA1MzogW2Z1bmN0aW9uKGUsIHQsIHIpIHsKICAgICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHRoaXMuaW5wdXQgPSBudWxsLCB0aGlzLm5leHRfaW4gPSAwLCB0aGlzLmF2YWlsX2luID0gMCwgdGhpcy50b3RhbF9pbiA9IDAsIHRoaXMub3V0cHV0ID0gbnVsbCwgdGhpcy5uZXh0X291dCA9IDAsIHRoaXMuYXZhaWxfb3V0ID0gMCwgdGhpcy50b3RhbF9vdXQgPSAwLCB0aGlzLm1zZyA9ICIiLCB0aGlzLnN0YXRlID0gbnVsbCwgdGhpcy5kYXRhX3R5cGUgPSAyLCB0aGlzLmFkbGVyID0gMDsKICAgICAgICB9OwogICAgICB9LCB7fV0sIDU0OiBbZnVuY3Rpb24oZSwgdCwgcikgewogICAgICAgIChmdW5jdGlvbihlMikgewogICAgICAgICAgIWZ1bmN0aW9uKHIyLCBuKSB7CiAgICAgICAgICAgIGlmICghcjIuc2V0SW1tZWRpYXRlKSB7CiAgICAgICAgICAgICAgdmFyIGksIHMsIHQyLCBhLCBvID0gMSwgaCA9IHt9LCB1ID0gZmFsc2UsIGwgPSByMi5kb2N1bWVudCwgZTMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHIyKTsKICAgICAgICAgICAgICBlMyA9IGUzICYmIGUzLnNldFRpbWVvdXQgPyBlMyA6IHIyLCBpID0gIltvYmplY3QgcHJvY2Vzc10iID09PSB7fS50b1N0cmluZy5jYWxsKHIyLnByb2Nlc3MpID8gZnVuY3Rpb24oZTQpIHsKICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgIGMoZTQpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgaWYgKHIyLnBvc3RNZXNzYWdlICYmICFyMi5pbXBvcnRTY3JpcHRzKSB7CiAgICAgICAgICAgICAgICAgIHZhciBlNCA9IHRydWUsIHQzID0gcjIub25tZXNzYWdlOwogICAgICAgICAgICAgICAgICByZXR1cm4gcjIub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgZTQgPSBmYWxzZTsKICAgICAgICAgICAgICAgICAgfSwgcjIucG9zdE1lc3NhZ2UoIiIsICIqIiksIHIyLm9ubWVzc2FnZSA9IHQzLCBlNDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9KCkgPyAoYSA9ICJzZXRJbW1lZGlhdGUkIiArIE1hdGgucmFuZG9tKCkgKyAiJCIsIHIyLmFkZEV2ZW50TGlzdGVuZXIgPyByMi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgZCwgZmFsc2UpIDogcjIuYXR0YWNoRXZlbnQoIm9ubWVzc2FnZSIsIGQpLCBmdW5jdGlvbihlNCkgewogICAgICAgICAgICAgICAgcjIucG9zdE1lc3NhZ2UoYSArIGU0LCAiKiIpOwogICAgICAgICAgICAgIH0pIDogcjIuTWVzc2FnZUNoYW5uZWwgPyAoKHQyID0gbmV3IE1lc3NhZ2VDaGFubmVsKCkpLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGU0KSB7CiAgICAgICAgICAgICAgICBjKGU0LmRhdGEpOwogICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGU0KSB7CiAgICAgICAgICAgICAgICB0Mi5wb3J0Mi5wb3N0TWVzc2FnZShlNCk7CiAgICAgICAgICAgICAgfSkgOiBsICYmICJvbnJlYWR5c3RhdGVjaGFuZ2UiIGluIGwuY3JlYXRlRWxlbWVudCgic2NyaXB0IikgPyAocyA9IGwuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbihlNCkgewogICAgICAgICAgICAgICAgdmFyIHQzID0gbC5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKTsKICAgICAgICAgICAgICAgIHQzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICBjKGU0KSwgdDMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbCwgcy5yZW1vdmVDaGlsZCh0MyksIHQzID0gbnVsbDsKICAgICAgICAgICAgICAgIH0sIHMuYXBwZW5kQ2hpbGQodDMpOwogICAgICAgICAgICAgIH0pIDogZnVuY3Rpb24oZTQpIHsKICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYywgMCwgZTQpOwogICAgICAgICAgICAgIH0sIGUzLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGU0KSB7CiAgICAgICAgICAgICAgICAiZnVuY3Rpb24iICE9IHR5cGVvZiBlNCAmJiAoZTQgPSBuZXcgRnVuY3Rpb24oIiIgKyBlNCkpOwogICAgICAgICAgICAgICAgZm9yICh2YXIgdDMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLCByMyA9IDA7IHIzIDwgdDMubGVuZ3RoOyByMysrKQogICAgICAgICAgICAgICAgICB0M1tyM10gPSBhcmd1bWVudHNbcjMgKyAxXTsKICAgICAgICAgICAgICAgIHZhciBuMiA9IHsgY2FsbGJhY2s6IGU0LCBhcmdzOiB0MyB9OwogICAgICAgICAgICAgICAgcmV0dXJuIGhbb10gPSBuMiwgaShvKSwgbysrOwogICAgICAgICAgICAgIH0sIGUzLmNsZWFySW1tZWRpYXRlID0gZjsKICAgICAgICAgICAgfQogICAgICAgICAgICBmdW5jdGlvbiBmKGU0KSB7CiAgICAgICAgICAgICAgZGVsZXRlIGhbZTRdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGZ1bmN0aW9uIGMoZTQpIHsKICAgICAgICAgICAgICBpZiAodSkKICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYywgMCwgZTQpOwogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgdmFyIHQzID0gaFtlNF07CiAgICAgICAgICAgICAgICBpZiAodDMpIHsKICAgICAgICAgICAgICAgICAgdSA9IHRydWU7CiAgICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGU1KSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgdDQgPSBlNS5jYWxsYmFjaywgcjMgPSBlNS5hcmdzOwogICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyMy5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgICAgICAgIHQ0KCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgICAgICAgICB0NChyM1swXSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICAgICAgICB0NChyM1swXSwgcjNbMV0pOwogICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgdDQocjNbMF0sIHIzWzFdLCByM1syXSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgdDQuYXBwbHkobiwgcjMpOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0odDMpOwogICAgICAgICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgICAgIGYoZTQpLCB1ID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZChlNCkgewogICAgICAgICAgICAgIGU0LnNvdXJjZSA9PT0gcjIgJiYgInN0cmluZyIgPT0gdHlwZW9mIGU0LmRhdGEgJiYgMCA9PT0gZTQuZGF0YS5pbmRleE9mKGEpICYmIGMoK2U0LmRhdGEuc2xpY2UoYS5sZW5ndGgpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSgidW5kZWZpbmVkIiA9PSB0eXBlb2Ygc2VsZiA/IHZvaWQgMCA9PT0gZTIgPyB0aGlzIDogZTIgOiBzZWxmKTsKICAgICAgICB9KS5jYWxsKHRoaXMsICJ1bmRlZmluZWQiICE9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA/IGNvbW1vbmpzR2xvYmFsIDogInVuZGVmaW5lZCIgIT0gdHlwZW9mIHNlbGYgPyBzZWxmIDogInVuZGVmaW5lZCIgIT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IHt9KTsKICAgICAgfSwge31dIH0sIHt9LCBbMTBdKSgxMCk7CiAgICB9KTsKICB9KShqc3ppcF9taW4pOwogIHZhciBqc3ppcF9taW5FeHBvcnRzID0ganN6aXBfbWluLmV4cG9ydHM7CiAgdmFyIEpTWmlwID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGpzemlwX21pbkV4cG9ydHMpOwogIC8qKgogICAqIEBsaWNlbnNlCiAgICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQwogICAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wCiAgICovCiAgY29uc3QgcHJveHlNYXJrZXIgPSBTeW1ib2woIkNvbWxpbmsucHJveHkiKTsKICBjb25zdCBjcmVhdGVFbmRwb2ludCA9IFN5bWJvbCgiQ29tbGluay5lbmRwb2ludCIpOwogIGNvbnN0IHJlbGVhc2VQcm94eSA9IFN5bWJvbCgiQ29tbGluay5yZWxlYXNlUHJveHkiKTsKICBjb25zdCBmaW5hbGl6ZXIgPSBTeW1ib2woIkNvbWxpbmsuZmluYWxpemVyIik7CiAgY29uc3QgdGhyb3dNYXJrZXIgPSBTeW1ib2woIkNvbWxpbmsudGhyb3duIik7CiAgY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAib2JqZWN0IiAmJiB2YWwgIT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gImZ1bmN0aW9uIjsKICBjb25zdCBwcm94eVRyYW5zZmVySGFuZGxlciA9IHsKICAgIGNhbkhhbmRsZTogKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiB2YWxbcHJveHlNYXJrZXJdLAogICAgc2VyaWFsaXplKG9iaikgewogICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7CiAgICAgIGV4cG9zZShvYmosIHBvcnQxKTsKICAgICAgcmV0dXJuIFtwb3J0MiwgW3BvcnQyXV07CiAgICB9LAogICAgZGVzZXJpYWxpemUocG9ydCkgewogICAgICBwb3J0LnN0YXJ0KCk7CiAgICAgIHJldHVybiB3cmFwKHBvcnQpOwogICAgfQogIH07CiAgY29uc3QgdGhyb3dUcmFuc2ZlckhhbmRsZXIgPSB7CiAgICBjYW5IYW5kbGU6ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHRocm93TWFya2VyIGluIHZhbHVlLAogICAgc2VyaWFsaXplKHsgdmFsdWUgfSkgewogICAgICBsZXQgc2VyaWFsaXplZDsKICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHsKICAgICAgICBzZXJpYWxpemVkID0gewogICAgICAgICAgaXNFcnJvcjogdHJ1ZSwKICAgICAgICAgIHZhbHVlOiB7CiAgICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsCiAgICAgICAgICAgIG5hbWU6IHZhbHVlLm5hbWUsCiAgICAgICAgICAgIHN0YWNrOiB2YWx1ZS5zdGFjawogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc2VyaWFsaXplZCA9IHsgaXNFcnJvcjogZmFsc2UsIHZhbHVlIH07CiAgICAgIH0KICAgICAgcmV0dXJuIFtzZXJpYWxpemVkLCBbXV07CiAgICB9LAogICAgZGVzZXJpYWxpemUoc2VyaWFsaXplZCkgewogICAgICBpZiAoc2VyaWFsaXplZC5pc0Vycm9yKSB7CiAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3Ioc2VyaWFsaXplZC52YWx1ZS5tZXNzYWdlKSwgc2VyaWFsaXplZC52YWx1ZSk7CiAgICAgIH0KICAgICAgdGhyb3cgc2VyaWFsaXplZC52YWx1ZTsKICAgIH0KICB9OwogIGNvbnN0IHRyYW5zZmVySGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbCiAgICBbInByb3h5IiwgcHJveHlUcmFuc2ZlckhhbmRsZXJdLAogICAgWyJ0aHJvdyIsIHRocm93VHJhbnNmZXJIYW5kbGVyXQogIF0pOwogIGZ1bmN0aW9uIGlzQWxsb3dlZE9yaWdpbihhbGxvd2VkT3JpZ2lucywgb3JpZ2luKSB7CiAgICBmb3IgKGNvbnN0IGFsbG93ZWRPcmlnaW4gb2YgYWxsb3dlZE9yaWdpbnMpIHsKICAgICAgaWYgKG9yaWdpbiA9PT0gYWxsb3dlZE9yaWdpbiB8fCBhbGxvd2VkT3JpZ2luID09PSAiKiIpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgICBpZiAoYWxsb3dlZE9yaWdpbiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBhbGxvd2VkT3JpZ2luLnRlc3Qob3JpZ2luKSkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIGZ1bmN0aW9uIGV4cG9zZShvYmosIGVwID0gZ2xvYmFsVGhpcywgYWxsb3dlZE9yaWdpbnMgPSBbIioiXSkgewogICAgZXAuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGZ1bmN0aW9uIGNhbGxiYWNrKGV2KSB7CiAgICAgIGlmICghZXYgfHwgIWV2LmRhdGEpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgaWYgKCFpc0FsbG93ZWRPcmlnaW4oYWxsb3dlZE9yaWdpbnMsIGV2Lm9yaWdpbikpIHsKICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgb3JpZ2luICcke2V2Lm9yaWdpbn0nIGZvciBjb21saW5rIHByb3h5YCk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGNvbnN0IHsgaWQsIHR5cGUsIHBhdGggfSA9IE9iamVjdC5hc3NpZ24oeyBwYXRoOiBbXSB9LCBldi5kYXRhKTsKICAgICAgY29uc3QgYXJndW1lbnRMaXN0ID0gKGV2LmRhdGEuYXJndW1lbnRMaXN0IHx8IFtdKS5tYXAoZnJvbVdpcmVWYWx1ZSk7CiAgICAgIGxldCByZXR1cm5WYWx1ZTsKICAgICAgdHJ5IHsKICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnNsaWNlKDAsIC0xKS5yZWR1Y2UoKG9iajIsIHByb3ApID0+IG9iajJbcHJvcF0sIG9iaik7CiAgICAgICAgY29uc3QgcmF3VmFsdWUgPSBwYXRoLnJlZHVjZSgob2JqMiwgcHJvcCkgPT4gb2JqMltwcm9wXSwgb2JqKTsKICAgICAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgICAgIGNhc2UgIkdFVCI6CiAgICAgICAgICAgIHsKICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAiU0VUIjoKICAgICAgICAgICAgewogICAgICAgICAgICAgIHBhcmVudFtwYXRoLnNsaWNlKC0xKVswXV0gPSBmcm9tV2lyZVZhbHVlKGV2LmRhdGEudmFsdWUpOwogICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgIkFQUExZIjoKICAgICAgICAgICAgewogICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmF3VmFsdWUuYXBwbHkocGFyZW50LCBhcmd1bWVudExpc3QpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAiQ09OU1RSVUNUIjoKICAgICAgICAgICAgewogICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHJhd1ZhbHVlKC4uLmFyZ3VtZW50TGlzdCk7CiAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBwcm94eSh2YWx1ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlICJFTkRQT0lOVCI6CiAgICAgICAgICAgIHsKICAgICAgICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7CiAgICAgICAgICAgICAgZXhwb3NlKG9iaiwgcG9ydDIpOwogICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJhbnNmZXIocG9ydDEsIFtwb3J0MV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSAiUkVMRUFTRSI6CiAgICAgICAgICAgIHsKICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHZvaWQgMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKHZhbHVlKSB7CiAgICAgICAgcmV0dXJuVmFsdWUgPSB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07CiAgICAgIH0KICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKS5jYXRjaCgodmFsdWUpID0+IHsKICAgICAgICByZXR1cm4geyB2YWx1ZSwgW3Rocm93TWFya2VyXTogMCB9OwogICAgICB9KS50aGVuKChyZXR1cm5WYWx1ZTIpID0+IHsKICAgICAgICBjb25zdCBbd2lyZVZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IHRvV2lyZVZhbHVlKHJldHVyblZhbHVlMik7CiAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3aXJlVmFsdWUpLCB7IGlkIH0pLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgICBpZiAodHlwZSA9PT0gIlJFTEVBU0UiKSB7CiAgICAgICAgICBlcC5yZW1vdmVFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgY2FsbGJhY2spOwogICAgICAgICAgY2xvc2VFbmRQb2ludChlcCk7CiAgICAgICAgICBpZiAoZmluYWxpemVyIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpbmFsaXplcl0gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICAgICAgb2JqW2ZpbmFsaXplcl0oKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4gewogICAgICAgIGNvbnN0IFt3aXJlVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUoewogICAgICAgICAgdmFsdWU6IG5ldyBUeXBlRXJyb3IoIlVuc2VyaWFsaXphYmxlIHJldHVybiB2YWx1ZSIpLAogICAgICAgICAgW3Rocm93TWFya2VyXTogMAogICAgICAgIH0pOwogICAgICAgIGVwLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd2lyZVZhbHVlKSwgeyBpZCB9KSwgdHJhbnNmZXJhYmxlcyk7CiAgICAgIH0pOwogICAgfSk7CiAgICBpZiAoZXAuc3RhcnQpIHsKICAgICAgZXAuc3RhcnQoKTsKICAgIH0KICB9CiAgZnVuY3Rpb24gaXNNZXNzYWdlUG9ydChlbmRwb2ludCkgewogICAgcmV0dXJuIGVuZHBvaW50LmNvbnN0cnVjdG9yLm5hbWUgPT09ICJNZXNzYWdlUG9ydCI7CiAgfQogIGZ1bmN0aW9uIGNsb3NlRW5kUG9pbnQoZW5kcG9pbnQpIHsKICAgIGlmIChpc01lc3NhZ2VQb3J0KGVuZHBvaW50KSkKICAgICAgZW5kcG9pbnQuY2xvc2UoKTsKICB9CiAgZnVuY3Rpb24gd3JhcChlcCwgdGFyZ2V0KSB7CiAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIFtdLCB0YXJnZXQpOwogIH0KICBmdW5jdGlvbiB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1JlbGVhc2VkKSB7CiAgICBpZiAoaXNSZWxlYXNlZCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZSIpOwogICAgfQogIH0KICBmdW5jdGlvbiByZWxlYXNlRW5kcG9pbnQoZXApIHsKICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCB7CiAgICAgIHR5cGU6ICJSRUxFQVNFIgogICAgfSkudGhlbigoKSA9PiB7CiAgICAgIGNsb3NlRW5kUG9pbnQoZXApOwogICAgfSk7CiAgfQogIGNvbnN0IHByb3h5Q291bnRlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpOwogIGNvbnN0IHByb3h5RmluYWxpemVycyA9ICJGaW5hbGl6YXRpb25SZWdpc3RyeSIgaW4gZ2xvYmFsVGhpcyAmJiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGVwKSA9PiB7CiAgICBjb25zdCBuZXdDb3VudCA9IChwcm94eUNvdW50ZXIuZ2V0KGVwKSB8fCAwKSAtIDE7CiAgICBwcm94eUNvdW50ZXIuc2V0KGVwLCBuZXdDb3VudCk7CiAgICBpZiAobmV3Q291bnQgPT09IDApIHsKICAgICAgcmVsZWFzZUVuZHBvaW50KGVwKTsKICAgIH0KICB9KTsKICBmdW5jdGlvbiByZWdpc3RlclByb3h5KHByb3h5MiwgZXApIHsKICAgIGNvbnN0IG5ld0NvdW50ID0gKHByb3h5Q291bnRlci5nZXQoZXApIHx8IDApICsgMTsKICAgIHByb3h5Q291bnRlci5zZXQoZXAsIG5ld0NvdW50KTsKICAgIGlmIChwcm94eUZpbmFsaXplcnMpIHsKICAgICAgcHJveHlGaW5hbGl6ZXJzLnJlZ2lzdGVyKHByb3h5MiwgZXAsIHByb3h5Mik7CiAgICB9CiAgfQogIGZ1bmN0aW9uIHVucmVnaXN0ZXJQcm94eShwcm94eTIpIHsKICAgIGlmIChwcm94eUZpbmFsaXplcnMpIHsKICAgICAgcHJveHlGaW5hbGl6ZXJzLnVucmVnaXN0ZXIocHJveHkyKTsKICAgIH0KICB9CiAgZnVuY3Rpb24gY3JlYXRlUHJveHkoZXAsIHBhdGggPSBbXSwgdGFyZ2V0ID0gZnVuY3Rpb24oKSB7CiAgfSkgewogICAgbGV0IGlzUHJveHlSZWxlYXNlZCA9IGZhbHNlOwogICAgY29uc3QgcHJveHkyID0gbmV3IFByb3h5KHRhcmdldCwgewogICAgICBnZXQoX3RhcmdldCwgcHJvcCkgewogICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7CiAgICAgICAgaWYgKHByb3AgPT09IHJlbGVhc2VQcm94eSkgewogICAgICAgICAgcmV0dXJuICgpID0+IHsKICAgICAgICAgICAgdW5yZWdpc3RlclByb3h5KHByb3h5Mik7CiAgICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7CiAgICAgICAgICAgIGlzUHJveHlSZWxlYXNlZCA9IHRydWU7CiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICBpZiAocHJvcCA9PT0gInRoZW4iKSB7CiAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gcHJveHkyIH07CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCByID0gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgewogICAgICAgICAgICB0eXBlOiAiR0VUIiwKICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSkKICAgICAgICAgIH0pLnRoZW4oZnJvbVdpcmVWYWx1ZSk7CiAgICAgICAgICByZXR1cm4gci50aGVuLmJpbmQocik7CiAgICAgICAgfQogICAgICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgWy4uLnBhdGgsIHByb3BdKTsKICAgICAgfSwKICAgICAgc2V0KF90YXJnZXQsIHByb3AsIHJhd1ZhbHVlKSB7CiAgICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTsKICAgICAgICBjb25zdCBbdmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmF3VmFsdWUpOwogICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCB7CiAgICAgICAgICB0eXBlOiAiU0VUIiwKICAgICAgICAgIHBhdGg6IFsuLi5wYXRoLCBwcm9wXS5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksCiAgICAgICAgICB2YWx1ZQogICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7CiAgICAgIH0sCiAgICAgIGFwcGx5KF90YXJnZXQsIF90aGlzQXJnLCByYXdBcmd1bWVudExpc3QpIHsKICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpOwogICAgICAgIGNvbnN0IGxhc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07CiAgICAgICAgaWYgKGxhc3QgPT09IGNyZWF0ZUVuZHBvaW50KSB7CiAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgewogICAgICAgICAgICB0eXBlOiAiRU5EUE9JTlQiCiAgICAgICAgICB9KS50aGVuKGZyb21XaXJlVmFsdWUpOwogICAgICAgIH0KICAgICAgICBpZiAobGFzdCA9PT0gImJpbmQiKSB7CiAgICAgICAgICByZXR1cm4gY3JlYXRlUHJveHkoZXAsIHBhdGguc2xpY2UoMCwgLTEpKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgW2FyZ3VtZW50TGlzdCwgdHJhbnNmZXJhYmxlc10gPSBwcm9jZXNzQXJndW1lbnRzKHJhd0FyZ3VtZW50TGlzdCk7CiAgICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoZXAsIHsKICAgICAgICAgIHR5cGU6ICJBUFBMWSIsCiAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSwKICAgICAgICAgIGFyZ3VtZW50TGlzdAogICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7CiAgICAgIH0sCiAgICAgIGNvbnN0cnVjdChfdGFyZ2V0LCByYXdBcmd1bWVudExpc3QpIHsKICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpOwogICAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpOwogICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCB7CiAgICAgICAgICB0eXBlOiAiQ09OU1RSVUNUIiwKICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLAogICAgICAgICAgYXJndW1lbnRMaXN0CiAgICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTsKICAgICAgfQogICAgfSk7CiAgICByZWdpc3RlclByb3h5KHByb3h5MiwgZXApOwogICAgcmV0dXJuIHByb3h5MjsKICB9CiAgZnVuY3Rpb24gbXlGbGF0KGFycikgewogICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycik7CiAgfQogIGZ1bmN0aW9uIHByb2Nlc3NBcmd1bWVudHMoYXJndW1lbnRMaXN0KSB7CiAgICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTsKICAgIHJldHVybiBbcHJvY2Vzc2VkLm1hcCgodikgPT4gdlswXSksIG15RmxhdChwcm9jZXNzZWQubWFwKCh2KSA9PiB2WzFdKSldOwogIH0KICBjb25zdCB0cmFuc2ZlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7CiAgZnVuY3Rpb24gdHJhbnNmZXIob2JqLCB0cmFuc2ZlcnMpIHsKICAgIHRyYW5zZmVyQ2FjaGUuc2V0KG9iaiwgdHJhbnNmZXJzKTsKICAgIHJldHVybiBvYmo7CiAgfQogIGZ1bmN0aW9uIHByb3h5KG9iaikgewogICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCB7IFtwcm94eU1hcmtlcl06IHRydWUgfSk7CiAgfQogIGZ1bmN0aW9uIHRvV2lyZVZhbHVlKHZhbHVlKSB7CiAgICBmb3IgKGNvbnN0IFtuYW1lLCBoYW5kbGVyXSBvZiB0cmFuc2ZlckhhbmRsZXJzKSB7CiAgICAgIGlmIChoYW5kbGVyLmNhbkhhbmRsZSh2YWx1ZSkpIHsKICAgICAgICBjb25zdCBbc2VyaWFsaXplZFZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IGhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTsKICAgICAgICByZXR1cm4gWwogICAgICAgICAgewogICAgICAgICAgICB0eXBlOiAiSEFORExFUiIsCiAgICAgICAgICAgIG5hbWUsCiAgICAgICAgICAgIHZhbHVlOiBzZXJpYWxpemVkVmFsdWUKICAgICAgICAgIH0sCiAgICAgICAgICB0cmFuc2ZlcmFibGVzCiAgICAgICAgXTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIFsKICAgICAgewogICAgICAgIHR5cGU6ICJSQVciLAogICAgICAgIHZhbHVlCiAgICAgIH0sCiAgICAgIHRyYW5zZmVyQ2FjaGUuZ2V0KHZhbHVlKSB8fCBbXQogICAgXTsKICB9CiAgZnVuY3Rpb24gZnJvbVdpcmVWYWx1ZSh2YWx1ZSkgewogICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7CiAgICAgIGNhc2UgIkhBTkRMRVIiOgogICAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXJzLmdldCh2YWx1ZS5uYW1lKS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7CiAgICAgIGNhc2UgIlJBVyI6CiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlOwogICAgfQogIH0KICBmdW5jdGlvbiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBtc2csIHRyYW5zZmVycykgewogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7CiAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVVVUlEKCk7CiAgICAgIGVwLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCBmdW5jdGlvbiBsKGV2KSB7CiAgICAgICAgaWYgKCFldi5kYXRhIHx8ICFldi5kYXRhLmlkIHx8IGV2LmRhdGEuaWQgIT09IGlkKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLCBsKTsKICAgICAgICByZXNvbHZlKGV2LmRhdGEpOwogICAgICB9KTsKICAgICAgaWYgKGVwLnN0YXJ0KSB7CiAgICAgICAgZXAuc3RhcnQoKTsKICAgICAgfQogICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKHsgaWQgfSwgbXNnKSwgdHJhbnNmZXJzKTsKICAgIH0pOwogIH0KICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7CiAgICByZXR1cm4gbmV3IEFycmF5KDQpLmZpbGwoMCkubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKS50b1N0cmluZygxNikpLmpvaW4oIi0iKTsKICB9CiAgY2xhc3MgRGlzcG9zYWJsZUpTWmlwIHsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsICJ6aXAiLCBuZXcgSlNaaXAoKSk7CiAgICB9CiAgICBmaWxlKHsgbmFtZSwgZGF0YSB9KSB7CiAgICAgIHRoaXMuemlwLmZpbGUobmFtZSwgZGF0YSk7CiAgICB9CiAgICBmaWxlcyhmaWxlcykgewogICAgICBmaWxlcy5mb3JFYWNoKCh7IG5hbWUsIGRhdGEgfSkgPT4gewogICAgICAgIHRoaXMuemlwLmZpbGUobmFtZSwgZGF0YSk7CiAgICAgIH0pOwogICAgfQogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZQogICAgYXN5bmMgdW56aXBGaWxlKHsgZGF0YSwgcGF0aCwgdHlwZSB9KSB7CiAgICAgIHZhciBfYTsKICAgICAgY29uc3QgemlwID0gYXdhaXQgSlNaaXAubG9hZEFzeW5jKGRhdGEpOwogICAgICByZXR1cm4gKF9hID0gemlwLmZpbGUocGF0aCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hc3luYyh0eXBlKTsKICAgIH0KICAgIGFzeW5jIGdlbmVyYXRlQXN5bmMob3B0aW9ucywgb25VcGRhdGUpIHsKICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuemlwLmdlbmVyYXRlQXN5bmMoeyAuLi5vcHRpb25zLCB0eXBlOiAidWludDhhcnJheSIgfSwgb25VcGRhdGUpOwogICAgICByZXR1cm4gdHJhbnNmZXIoZGF0YSwgW2RhdGEuYnVmZmVyXSk7CiAgICB9CiAgICBnZW5lcmF0ZVN0cmVhbShvcHRpb25zLCBvblVwZGF0ZSwgb25FbmQpIHsKICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy56aXAuZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbSh7IC4uLm9wdGlvbnMsIHR5cGU6ICJ1aW50OGFycmF5IiB9KTsKICAgICAgY29uc3QgemlwU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHsKICAgICAgICBzdGFydDogKGNvbnRyb2xsZXIpID0+IHsKICAgICAgICAgIHN0cmVhbS5vbigiZXJyb3IiLCAoZSkgPT4gewogICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGUpOwogICAgICAgICAgICBvbkVuZCA9PSBudWxsID8gdm9pZCAwIDogb25FbmQoKTsKICAgICAgICAgIH0pOwogICAgICAgICAgc3RyZWFtLm9uKCJlbmQiLCAoKSA9PiB7CiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTsKICAgICAgICAgICAgICBvbkVuZCA9PSBudWxsID8gdm9pZCAwIDogb25FbmQoKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9KTsKICAgICAgICAgIHN0cmVhbS5vbigiZGF0YSIsIChkYXRhLCBtZXRhRGF0YSkgPT4gewogICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSk7CiAgICAgICAgICAgIG9uVXBkYXRlID09IG51bGwgPyB2b2lkIDAgOiBvblVwZGF0ZShtZXRhRGF0YSk7CiAgICAgICAgICB9KTsKICAgICAgICAgIHN0cmVhbS5yZXN1bWUoKTsKICAgICAgICB9CiAgICAgIH0pOwogICAgICByZXR1cm4gdHJhbnNmZXIoeyB6aXBTdHJlYW0gfSwgW3ppcFN0cmVhbV0pOwogICAgfQogIH0KICBleHBvc2UoRGlzcG9zYWJsZUpTWmlwKTsKfSkoKTsK";
      const decodeBase64 = (base64) => Uint8Array.from(atob(base64), (c2) => c2.charCodeAt(0));
      const blob = typeof window !== "undefined" && window.Blob && new Blob([decodeBase64(encodedJs)], { type: "text/javascript;charset=utf-8" });
      function WorkerWrapper(options) {
        let objURL;
        try {
          objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
          if (!objURL)
            throw "";
          const worker = new Worker(objURL, {
            name: options == null ? void 0 : options.name
          });
          worker.addEventListener("error", () => {
            (window.URL || window.webkitURL).revokeObjectURL(objURL);
          });
          return worker;
        } catch (e) {
          return new Worker(
            "data:text/javascript;base64," + encodedJs,
            {
              name: options == null ? void 0 : options.name
            }
          );
        } finally {
          objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
        }
      }
      const getTransferableData = (files) => files.map(({ data }) => data).filter((data) => typeof data !== "string");
      class JSZipWorkerPool {
        constructor() {
          __publicField(this, "pool", []);
          __publicField(this, "waitingQueue", []);
          __publicField(this, "unzipFile", async (params) => {
            const worker = await this.acquireWorker();
            const zip = await new worker.JSZip();
            const clean = () => {
              zip[releaseProxy]();
              this.releaseWorker(worker);
            };
            try {
              return await zip.unzipFile(transfer(params, [params.data]));
            } catch (error) {
              clean();
              throw error;
            }
          });
          for (let id = 0; id < WORKER_THREAD_NUM; id++) {
            this.pool.push({
              id,
              idle: true
            });
          }
        }
        async createWorker() {
          const worker = new WorkerWrapper();
          return wrap(worker);
        }
        waitIdleWorker() {
          return new Promise((resolve2) => {
            this.waitingQueue.push(resolve2);
          });
        }
        async acquireWorker() {
          let worker = this.pool.find(({ idle }) => idle);
          if (!worker)
            worker = await this.waitIdleWorker();
          if (!worker.JSZip)
            worker.JSZip = await this.createWorker();
          worker.idle = false;
          return worker;
        }
        releaseWorker(worker) {
          worker.idle = true;
          if (!this.waitingQueue.length)
            return;
          const emit2 = removeAt(this.waitingQueue, 0);
          emit2(worker);
        }
        async generateAsync(files, options, onUpdate) {
          const worker = await this.acquireWorker();
          const zip = await new worker.JSZip();
          try {
            await zip.files(transfer(files, getTransferableData(files)));
            return await zip.generateAsync(
              options,
              proxy((metaData) => {
                if (metaData.currentFile)
                  onUpdate == null ? void 0 : onUpdate({ workerId: worker.id, ...metaData });
              })
            );
          } finally {
            zip[releaseProxy]();
            this.releaseWorker(worker);
          }
        }
        async generateStream(files, options, onUpdate) {
          const worker = await this.acquireWorker();
          const zip = await new worker.JSZip();
          try {
            await zip.files(transfer(files, getTransferableData(files)));
            const { zipStream } = await zip.generateStream(
              options,
              proxy((metaData) => {
                if (metaData.currentFile)
                  onUpdate == null ? void 0 : onUpdate({ workerId: worker.id, ...metaData });
              })
            );
            return zipStream;
          } finally {
            zip[releaseProxy]();
            this.releaseWorker(worker);
          }
        }
      }
      const jszipPool = new JSZipWorkerPool();
      class JSZip {
        constructor() {
          __publicField(this, "files", []);
        }
        file(name, data) {
          this.files.push({ name, data });
        }
        generateAsync(options, onUpdate) {
          const { files } = this;
          this.files = [];
          return jszipPool.generateAsync(files, options, onUpdate);
        }
        generateStream(options, onUpdate) {
          const { files } = this;
          this.files = [];
          return jszipPool.generateStream(files, options, onUpdate);
        }
      }
      __publicField(JSZip, "unzipFile", (params) => jszipPool.unzipFile(params));
      extendPrototype(localforage);
      class DownloadHistory {
        constructor(name) {
          __publicField(this, "store");
          __publicField(this, "ready");
          this.name = name;
          this.store = localforage.createInstance({
            name: "nhentai_helper",
            storeName: name
          });
          this.ready = this.store.ready().then(() => true).catch((e) => {
            logger.error(e);
            return false;
          });
        }
        async add(key) {
          if (!await this.ready)
            return;
          try {
            await this.store.setItem(key, true);
            logger.log(`mark "${key}" as downloaded`);
          } catch (e) {
            logger.error(e);
          }
        }
        async del(key) {
          if (!await this.ready)
            return;
          try {
            await this.store.removeItem(key);
            logger.log(`unmark "${key}" as downloaded`);
          } catch (e) {
            logger.error(e);
          }
        }
        async has(key) {
          if (!await this.ready)
            return false;
          try {
            return await this.store.getItem(key) === true;
          } catch (e) {
            logger.error(e);
          }
          return false;
        }
        async size() {
          if (!await this.ready)
            return NaN;
          return this.store.length();
        }
        async import(keys2) {
          if (!await this.ready)
            throw new Error(`store ${this.name} cannot ready`);
          try {
            await this.store.setItems(keys2.map((gid2) => ({ key: gid2, value: true })));
          } catch (e) {
            logger.error(e);
          }
        }
        async export() {
          if (!await this.ready)
            throw new Error(`store ${this.name} cannot ready`);
          return this.store.keys();
        }
        async clear() {
          if (!await this.ready)
            return;
          await this.store.clear();
        }
      }
      const gidHistory = new DownloadHistory("dl_history_gid");
      const enTitleHistory = new DownloadHistory("dl_history_en");
      const jpTitleHistory = new DownloadHistory("dl_history");
      const prettyTitleHistory = new DownloadHistory("dl_history_pretty");
      const normalizeTitle = (title) => title.replace(/\s/g, "");
      const getTitleMd5 = (title) => md5(normalizeTitle(title));
      const markAsDownloaded = (gid2, { english: english2, japanese: japanese2, pretty } = {}) => {
        void gidHistory.add(String(gid2));
        if (english2)
          void enTitleHistory.add(getTitleMd5(english2));
        if (japanese2)
          void jpTitleHistory.add(getTitleMd5(japanese2));
        if (pretty)
          void prettyTitleHistory.add(getTitleMd5(pretty));
      };
      const unmarkAsDownloaded = (gid2, { english: english2, japanese: japanese2, pretty } = {}) => {
        void gidHistory.del(String(gid2));
        if (english2)
          void enTitleHistory.del(getTitleMd5(english2));
        if (japanese2)
          void jpTitleHistory.del(getTitleMd5(japanese2));
        if (pretty)
          void prettyTitleHistory.del(getTitleMd5(pretty));
      };
      const isDownloadedByGid = (gid2) => gidHistory.has(String(gid2));
      const isDownloadedByTitle = async ({
        english: english2,
        japanese: japanese2,
        pretty
      } = {}) => {
        if (settings.judgeDownloadedByJapanese && japanese2) {
          const md5v2 = getTitleMd5(japanese2);
          if (await jpTitleHistory.has(md5v2))
            return true;
          const md5v1 = md5(japanese2);
          if (await jpTitleHistory.has(md5v1)) {
            void jpTitleHistory.add(md5v2);
            void jpTitleHistory.del(md5v1);
            return true;
          }
        }
        if (settings.judgeDownloadedByEnglish && english2 && await enTitleHistory.has(getTitleMd5(english2))) {
          return true;
        }
        if (settings.judgeDownloadedByPretty && pretty && await enTitleHistory.has(getTitleMd5(pretty))) {
          return true;
        }
        return false;
      };
      const getDownloadNumber = () => gidHistory.size();
      const EXPORT_HEADER_GID = "gid:";
      const EXPORT_HEADER_TITLE_JP = "title:";
      const EXPORT_HEADER_TITLE_EN = "title_en:";
      const EXPORT_HEADER_TITLE_PRETTY = "title_pretty:";
      const EXPORT_SEPARATOR = ",";
      const EXPORT_TEXT_FILENAME = "history.txt";
      const exportDownloadHistory = async () => {
        try {
          const gids = await gidHistory.export();
          const jpTitles = await jpTitleHistory.export();
          const enTitles = await enTitleHistory.export();
          const prettyTitles = await prettyTitleHistory.export();
          const text = `${EXPORT_HEADER_GID}${gids.join(EXPORT_SEPARATOR)}
${EXPORT_HEADER_TITLE_JP}${jpTitles.join(EXPORT_SEPARATOR)}
${EXPORT_HEADER_TITLE_EN}${enTitles.join(EXPORT_SEPARATOR)}
${EXPORT_HEADER_TITLE_PRETTY}${prettyTitles.join(EXPORT_SEPARATOR)}`;
          const zip = new JSZip();
          zip.file(EXPORT_TEXT_FILENAME, text);
          const data = await zip.generateAsync({
            compression: "DEFLATE",
            compressionOptions: { level: 9 }
          });
          const timeStr = dateTimeFormatter.format(Date.now()).replace(/[^\d]/g, "");
          const filename = `nhentai-helper-download-history-${timeStr}.zip`;
          FileSaver_minExports.saveAs(new File([data], filename, { type: "application/zip" }));
          logger.log("export download history", filename);
          return true;
        } catch (error) {
          logger.error(error);
        }
        return false;
      };
      const importDownloadHistory = async (data) => {
        try {
          const str = await JSZip.unzipFile({ data, path: EXPORT_TEXT_FILENAME, type: "string" });
          if (!str) {
            logger.error("zip doesn't contain file", EXPORT_TEXT_FILENAME);
            return false;
          }
          const lines = str.split("\n");
          for (const line of lines) {
            if (line.startsWith(EXPORT_HEADER_GID)) {
              const gids = line.replace(EXPORT_HEADER_GID, "").split(EXPORT_SEPARATOR);
              await gidHistory.import(gids);
            } else if (line.startsWith(EXPORT_HEADER_TITLE_JP)) {
              const titles = line.replace(EXPORT_HEADER_TITLE_JP, "").split(EXPORT_SEPARATOR);
              await jpTitleHistory.import(titles);
            } else if (line.startsWith(EXPORT_HEADER_TITLE_EN)) {
              const titles = line.replace(EXPORT_HEADER_TITLE_EN, "").split(EXPORT_SEPARATOR);
              await enTitleHistory.import(titles);
            } else if (line.startsWith(EXPORT_HEADER_TITLE_PRETTY)) {
              const titles = line.replace(EXPORT_HEADER_TITLE_PRETTY, "").split(EXPORT_SEPARATOR);
              await prettyTitleHistory.import(titles);
            }
          }
          return true;
        } catch (error) {
          logger.error(error);
        }
        return false;
      };
      const clearDownloadHistory = async () => {
        try {
          await gidHistory.clear();
          await enTitleHistory.clear();
          await jpTitleHistory.clear();
          await prettyTitleHistory.clear();
          return true;
        } catch (error) {
          logger.error(error);
        }
        return false;
      };
      const isSameTitleString = (title1, title2) => !!title1 && !!title2 && normalizeTitle(title1) === normalizeTitle(title2);
      const isSameTitle = (title1, title2) => {
        if (settings.judgeDownloadedByJapanese && isSameTitleString(title1.japanese, title2.japanese)) {
          return true;
        }
        if (settings.judgeDownloadedByEnglish && isSameTitleString(title1.english, title2.english)) {
          return true;
        }
        if (settings.judgeDownloadedByPretty && isSameTitleString(title1.pretty, title2.pretty)) {
          return true;
        }
        return false;
      };
      const createElement = (tag, props, ...children) => {
        if (typeof tag === "function")
          return tag(props, ...children);
        const element = document.createElement(tag);
        Object.entries(props ?? {}).forEach(([name, value]) => {
          if (name === "html")
            element.innerHTML = value;
          else if (name === "class")
            element.classList.add(...String(value).split(" "));
          else if (name === "style" && typeof value === "object") {
            const styleString = Object.entries(value).map(([k, v2]) => `${camelCase(k)}:${String(v2)}`).join(";");
            element.setAttribute("style", styleString);
          } else if (name.startsWith("on")) {
            element.addEventListener(kebabCase(name.replace("on", "")), value);
          } else
            element.setAttribute(name, String(value));
        });
        children.flat().forEach((child) => {
          appendChild(element, child);
        });
        return element;
      };
      const appendChild = (parent, child) => {
        if (!child)
          return;
        parent.appendChild(typeof child === "string" ? document.createTextNode(child) : child);
      };
      const Fragment = (props, ...children) => {
        return children;
      };
      const jsx = { createElement, Fragment };
      const readFile = (file) => new Promise((resolve2, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          resolve2(reader.result);
        };
        reader.onabort = reject;
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
      const pickFile = (accept) => new Promise((resolve2) => {
        const input = /* @__PURE__ */ jsx.createElement(
          "input",
          {
            type: "file",
            accept,
            onChange: () => {
              var _a2;
              resolve2((_a2 = input.files) == null ? void 0 : _a2[0]);
            }
          }
        );
        input.click();
      });
      const pickAndReadFile = async (accept) => {
        const file = await pickFile(accept);
        if (file)
          return readFile(file);
      };
      const showMessage = (params) => ElMessage({ ...params, appendTo: _monkeyWindow.document.body });
      const _hoisted_1$1 = { class: "nhentai-helper-setting-help-buttons no-sl" };
      const _hoisted_2 = ["id"];
      const _hoisted_3 = { id: "nhentai-helper-setting-dialog" };
      const _hoisted_4 = {
        class: "asterisk-example no-sl",
        style: { "margin-bottom": "18px" }
      };
      const _hoisted_5 = { class: "inline-item" };
      const _hoisted_6 = { class: "inline-item__name" };
      const _hoisted_7 = { class: "inline-item" };
      const _hoisted_8 = { class: "inline-item__name" };
      const _hoisted_9 = { style: { "color": "var(--el-text-color-regular)" } };
      const _hoisted_10 = {
        key: 0,
        class: "no-sl"
      };
      const _hoisted_11 = {
        key: 0,
        class: "no-sl"
      };
      const _hoisted_12 = { class: "no-sl" };
      const _hoisted_13 = { class: "no-sl" };
      const _sfc_main$1 = /* @__PURE__ */ defineComponent({
        __name: "SettingsDialog",
        setup(__props, { expose: __expose }) {
          startWatchSettings();
          const threadNumMarks = {
            1: "1",
            4: "4",
            8: "8",
            16: "16",
            32: {
              label: "32",
              style: { whiteSpace: "nowrap" }
            }
          };
          const compressionLevelMarks = {
            0: "0",
            1: "1",
            9: "9"
          };
          const { t: t2, n, locale } = useI18n();
          const show = ref(false);
          const downloadedNum = ref(NaN);
          const filenameLengthNumber = computed({
            get: () => typeof writeableSettings.filenameLength === "number" ? writeableSettings.filenameLength : 0,
            set: (val) => {
              writeableSettings.filenameLength = val;
            }
          });
          const filenameLengthAuto = computed({
            get: () => writeableSettings.filenameLength === "auto",
            set: (val) => {
              writeableSettings.filenameLength = val ? "auto" : 0;
            }
          });
          const refreshDownloadNum = async () => {
            downloadedNum.value = await getDownloadNumber();
          };
          const open2 = () => {
            show.value = true;
            refreshDownloadNum();
          };
          const openHelp = () => {
            _GM_openInTab(
              locale.value === "zh" ? "https://github.com/Tsuk1ko/nhentai-helper/blob/master/README-ZH.md#%E8%AE%BE%E7%BD%AE" : "https://github.com/Tsuk1ko/nhentai-helper/blob/master/README.md#settings",
              { active: true, setParent: true }
            );
          };
          const exporting = ref(false);
          const importing = ref(false);
          const clearing = ref(false);
          const showMessageBySucceed = (succeed) => {
            showMessage({
              type: succeed ? "success" : "error",
              message: succeed ? "Succeed" : "Failed, please check console for error message"
            });
          };
          const exportHistory = async () => {
            exporting.value = true;
            const succeed = await exportDownloadHistory();
            exporting.value = false;
            showMessageBySucceed(succeed);
          };
          const importHistory = async () => {
            const data = await pickAndReadFile("application/zip");
            if (!data)
              return;
            importing.value = true;
            const succeed = await importDownloadHistory(data);
            importing.value = false;
            refreshDownloadNum();
            showMessageBySucceed(succeed);
          };
          const clearHistory = async () => {
            clearing.value = true;
            const succeed = await clearDownloadHistory();
            clearing.value = false;
            refreshDownloadNum();
            showMessageBySucceed(succeed);
          };
          const addTitleReplacement = () => {
            writeableSettings.titleReplacement.push({ from: "", to: "", regexp: false });
          };
          const delTitleReplacement = (index) => {
            writeableSettings.titleReplacement.splice(index, 1);
          };
          watch(
            () => writeableSettings.language,
            (val) => {
              locale.value = val;
            }
          );
          __expose({ open: open2 });
          return (_ctx, _cache) => {
            const _component_el_button = ElButton;
            const _component_el_option = ElOption;
            const _component_el_select = ElSelect;
            const _component_el_form_item = ElFormItem;
            const _component_el_slider = ElSlider;
            const _component_el_switch = ElSwitch;
            const _component_el_input = ElInput;
            const _component_el_input_number = ElInputNumber;
            const _component_el_checkbox = ElCheckbox;
            const _component_el_checkbox_group = ElCheckboxGroup$1;
            const _component_el_divider = ElDivider;
            const _component_el_table_column = ElTableColumn;
            const _component_el_table = ElTable;
            const _component_el_collapse_item = ElCollapseItem;
            const _component_el_collapse = ElCollapse;
            const _component_el_form = ElForm;
            const _component_el_dialog = ElDialog;
            return openBlock(), createBlock(_component_el_dialog, {
              modelValue: show.value,
              "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => show.value = $event),
              center: true,
              top: "50px"
            }, {
              header: withCtx(({ titleId, titleClass }) => [
                createBaseVNode("div", _hoisted_1$1, [
                  createVNode(_component_el_button, {
                    size: "small",
                    onClick: openHelp
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(unref(t2)("setting.helpButton")), 1)
                    ]),
                    _: 1
                  })
                ]),
                createBaseVNode("span", {
                  id: titleId,
                  class: normalizeClass([titleClass, "no-sl"])
                }, toDisplayString$1(unref(t2)("setting.title")), 11, _hoisted_2)
              ]),
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_3, [
                  createBaseVNode("div", _hoisted_4, toDisplayString$1(unref(t2)("setting.asteriskTip")), 1),
                  createVNode(_component_el_form, {
                    "label-width": "auto",
                    "label-position": "left"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_form_item, { label: "Language" }, {
                        default: withCtx(() => [
                          createVNode(_component_el_select, {
                            modelValue: unref(writeableSettings).language,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(writeableSettings).language = $event)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_option, {
                                label: "English",
                                value: "en"
                              }),
                              createVNode(_component_el_option, {
                                label: "中文",
                                value: "zh"
                              })
                            ]),
                            _: 1
                          }, 8, ["modelValue"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_form_item, {
                        class: "m-b-32",
                        label: unref(t2)("setting.downloadThread")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_slider, {
                            modelValue: unref(writeableSettings).threadNum,
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(writeableSettings).threadNum = $event),
                            min: 1,
                            max: 32,
                            marks: threadNumMarks
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        class: "refresh-required",
                        label: unref(t2)("setting.openOnNewTab")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_switch, {
                            modelValue: unref(writeableSettings).openOnNewTab,
                            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(writeableSettings).openOnNewTab = $event)
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.compressionFilename")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input, {
                            modelValue: unref(writeableSettings).compressionFilename,
                            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(writeableSettings).compressionFilename = $event),
                            placeholder: unref(settingDefinitions).compressionFilename.default,
                            onBlur: _cache[4] || (_cache[4] = ($event) => {
                              if (!unref(writeableSettings).compressionFilename) {
                                unref(writeableSettings).compressionFilename = unref(settingDefinitions).compressionFilename.default;
                              }
                            })
                          }, null, 8, ["modelValue", "placeholder"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, { label: "└ {{artist}}" }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_5, [
                            createBaseVNode("span", _hoisted_6, toDisplayString$1(unref(t2)("setting.maxNumber")), 1),
                            createVNode(_component_el_input_number, {
                              modelValue: unref(writeableSettings).filenameMaxArtistsNumber,
                              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => unref(writeableSettings).filenameMaxArtistsNumber = $event),
                              size: "small",
                              min: 0,
                              "value-on-clear": unref(settingDefinitions).filenameMaxArtistsNumber.default,
                              "step-strictly": true,
                              style: { width: "90px" }
                            }, null, 8, ["modelValue", "value-on-clear"])
                          ]),
                          createBaseVNode("div", _hoisted_7, [
                            createBaseVNode("span", _hoisted_8, toDisplayString$1(unref(t2)("setting.separator")), 1),
                            createVNode(_component_el_input, {
                              modelValue: unref(writeableSettings).filenameArtistsSeparator,
                              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => unref(writeableSettings).filenameArtistsSeparator = $event),
                              size: "small",
                              placeholder: unref(settingDefinitions).filenameArtistsSeparator.default,
                              style: { width: "50px" }
                            }, null, 8, ["modelValue", "placeholder"])
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_form_item, {
                        class: "m-b-32",
                        label: unref(t2)("setting.compressionLevel")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_slider, {
                            modelValue: unref(writeableSettings).compressionLevel,
                            "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => unref(writeableSettings).compressionLevel = $event),
                            min: 0,
                            max: 9,
                            marks: compressionLevelMarks
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.filenameLength")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input_number, {
                            modelValue: filenameLengthNumber.value,
                            "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => filenameLengthNumber.value = $event),
                            min: 0,
                            "value-on-clear": unref(settingDefinitions).filenameLength.default,
                            "step-strictly": true,
                            disabled: unref(writeableSettings).filenameLength === "auto"
                          }, null, 8, ["modelValue", "value-on-clear", "disabled"]),
                          createVNode(_component_el_checkbox, {
                            modelValue: filenameLengthAuto.value,
                            "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => filenameLengthAuto.value = $event),
                            class: "m-l-16",
                            label: unref(t2)("common.auto")
                          }, null, 8, ["modelValue", "label"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.autoCancelDownloadedManga")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_switch, {
                            modelValue: unref(writeableSettings).autoCancelDownloadedManga,
                            "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => unref(writeableSettings).autoCancelDownloadedManga = $event)
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.autoRetryWhenErrorOccurs")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_switch, {
                            modelValue: unref(writeableSettings).autoRetryWhenErrorOccurs,
                            "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => unref(writeableSettings).autoRetryWhenErrorOccurs = $event)
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.autoShowAll")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_switch, {
                            modelValue: unref(writeableSettings).autoShowAll,
                            "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => unref(writeableSettings).autoShowAll = $event)
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        class: "refresh-required",
                        label: unref(t2)("setting.showIgnoreButton")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_switch, {
                            modelValue: unref(writeableSettings).showIgnoreButton,
                            "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => unref(writeableSettings).showIgnoreButton = $event)
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.judgeDownloadedMangaByTitle")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_checkbox, {
                            modelValue: unref(writeableSettings).judgeDownloadedByEnglish,
                            "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => unref(writeableSettings).judgeDownloadedByEnglish = $event),
                            label: unref(t2)("common.english")
                          }, null, 8, ["modelValue", "label"]),
                          createVNode(_component_el_checkbox, {
                            modelValue: unref(writeableSettings).judgeDownloadedByJapanese,
                            "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => unref(writeableSettings).judgeDownloadedByJapanese = $event),
                            label: unref(t2)("common.japanese")
                          }, null, 8, ["modelValue", "label"]),
                          createVNode(_component_el_checkbox, {
                            modelValue: unref(writeableSettings).judgeDownloadedByPretty,
                            "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => unref(writeableSettings).judgeDownloadedByPretty = $event),
                            label: unref(t2)("common.pretty")
                          }, null, 8, ["modelValue", "label"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.addMetaFile")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_checkbox_group, {
                            modelValue: unref(writeableSettings).addMetaFile,
                            "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => unref(writeableSettings).addMetaFile = $event)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_checkbox, {
                                label: "ComicInfo.xml",
                                value: "ComicInfoXml"
                              }),
                              createVNode(_component_el_checkbox, {
                                label: "info.json (eze)",
                                value: "EzeInfoJson"
                              })
                            ]),
                            _: 1
                          }, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      unref(writeableSettings).addMetaFile.includes("ComicInfoXml") ? (openBlock(), createBlock(_component_el_form_item, {
                        key: 0,
                        label: `└ ${unref(t2)("setting.metaFileTitleLanguage")}`
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_select, {
                            modelValue: unref(writeableSettings).metaFileTitleLanguage,
                            "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => unref(writeableSettings).metaFileTitleLanguage = $event)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_option, {
                                label: unref(t2)("common.english"),
                                value: "english"
                              }, null, 8, ["label"]),
                              createVNode(_component_el_option, {
                                label: unref(t2)("common.japanese"),
                                value: "japanese"
                              }, null, 8, ["label"])
                            ]),
                            _: 1
                          }, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"])) : createCommentVNode("", true),
                      createVNode(_component_el_divider, null, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString$1(unref(t2)("setting.advanceTitle")), 1)
                        ]),
                        _: 1
                      }),
                      unref(IS_NHENTAI) ? (openBlock(), createBlock(_component_el_form_item, {
                        key: 1,
                        label: unref(t2)("setting.nHentaiDownloadHost")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_select, {
                            modelValue: unref(writeableSettings).nHentaiDownloadHost,
                            "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => unref(writeableSettings).nHentaiDownloadHost = $event),
                            disabled: !!unref(writeableSettings).customDownloadUrl
                          }, {
                            default: withCtx(() => [
                              (openBlock(true), createElementBlock(Fragment$1, null, renderList(unref(nHentaiDownloadHosts), (host2) => {
                                return openBlock(), createBlock(_component_el_option, {
                                  key: host2,
                                  label: host2,
                                  value: host2
                                }, null, 8, ["label", "value"]);
                              }), 128)),
                              createVNode(_component_el_option, {
                                label: unref(t2)("common.random"),
                                value: "random"
                              }, null, 8, ["label"]),
                              createVNode(_component_el_option, {
                                label: unref(t2)("common.balance"),
                                value: "balance"
                              }, null, 8, ["label"])
                            ]),
                            _: 1
                          }, 8, ["modelValue", "disabled"])
                        ]),
                        _: 1
                      }, 8, ["label"])) : createCommentVNode("", true),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.customDownloadUrl")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input, {
                            modelValue: unref(writeableSettings).customDownloadUrl,
                            "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => unref(writeableSettings).customDownloadUrl = $event)
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.compressionStreamFiles")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_switch, {
                            modelValue: unref(writeableSettings).compressionStreamFiles,
                            "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => unref(writeableSettings).compressionStreamFiles = $event)
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.seriesMode")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_switch, {
                            modelValue: unref(writeableSettings).seriesMode,
                            "onUpdate:modelValue": _cache[22] || (_cache[22] = ($event) => unref(writeableSettings).seriesMode = $event)
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      createVNode(_component_el_form_item, {
                        label: unref(t2)("setting.streamDownload")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_switch, {
                            modelValue: unref(writeableSettings).streamDownload,
                            "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => unref(writeableSettings).streamDownload = $event),
                            disabled: unref(DISABLE_STREAM_DOWNLOAD)
                          }, null, 8, ["modelValue", "disabled"])
                        ]),
                        _: 1
                      }, 8, ["label"]),
                      unref(IS_NHENTAI) ? (openBlock(), createBlock(_component_el_form_item, {
                        key: 2,
                        class: "refresh-required",
                        label: unref(t2)("setting.preventConsoleClearing")
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_switch, {
                            modelValue: unref(writeableSettings).preventConsoleClearing,
                            "onUpdate:modelValue": _cache[24] || (_cache[24] = ($event) => unref(writeableSettings).preventConsoleClearing = $event)
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }, 8, ["label"])) : createCommentVNode("", true),
                      createVNode(_component_el_collapse, null, {
                        default: withCtx(() => [
                          createVNode(_component_el_collapse_item, null, {
                            title: withCtx(() => [
                              createBaseVNode("span", _hoisted_9, toDisplayString$1(unref(t2)("setting.titleReplacement")), 1)
                            ]),
                            default: withCtx(() => [
                              createVNode(_component_el_table, {
                                id: "title-replacement-table",
                                data: unref(writeableSettings).titleReplacement
                              }, {
                                append: withCtx(() => [
                                  createVNode(_component_el_button, {
                                    text: "",
                                    style: { "width": "100%" },
                                    onClick: addTitleReplacement
                                  }, {
                                    default: withCtx(() => [
                                      createTextVNode("+")
                                    ]),
                                    _: 1
                                  })
                                ]),
                                default: withCtx(() => [
                                  createVNode(_component_el_table_column, { label: "From" }, {
                                    default: withCtx((scope) => [
                                      createVNode(_component_el_input, {
                                        modelValue: scope.row.from,
                                        "onUpdate:modelValue": ($event) => scope.row.from = $event
                                      }, {
                                        prefix: withCtx(() => [
                                          scope.row.regexp ? (openBlock(), createElementBlock("span", _hoisted_10, "/")) : createCommentVNode("", true)
                                        ]),
                                        suffix: withCtx(() => [
                                          scope.row.regexp ? (openBlock(), createElementBlock("span", _hoisted_11, "/")) : createCommentVNode("", true)
                                        ]),
                                        _: 2
                                      }, 1032, ["modelValue", "onUpdate:modelValue"])
                                    ]),
                                    _: 1
                                  }),
                                  createVNode(_component_el_table_column, { label: "To" }, {
                                    default: withCtx((scope) => [
                                      createVNode(_component_el_input, {
                                        modelValue: scope.row.to,
                                        "onUpdate:modelValue": ($event) => scope.row.to = $event
                                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                    ]),
                                    _: 1
                                  }),
                                  createVNode(_component_el_table_column, {
                                    label: "RegExp",
                                    width: "80"
                                  }, {
                                    default: withCtx((scope) => [
                                      createVNode(_component_el_switch, {
                                        modelValue: scope.row.regexp,
                                        "onUpdate:modelValue": ($event) => scope.row.regexp = $event
                                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                                    ]),
                                    _: 1
                                  }),
                                  createVNode(_component_el_table_column, { width: "70" }, {
                                    default: withCtx((scope) => [
                                      createVNode(_sfc_main$2, {
                                        onConfirm: () => delTitleReplacement(scope.$index)
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(_component_el_button, {
                                            type: "danger",
                                            icon: unref(delete_default)
                                          }, null, 8, ["icon"])
                                        ]),
                                        _: 2
                                      }, 1032, ["onConfirm"])
                                    ]),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              }, 8, ["data"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_divider, null, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(unref(t2)("setting.history.title")), 1)
                    ]),
                    _: 1
                  }),
                  createBaseVNode("p", _hoisted_12, toDisplayString$1(unref(t2)("setting.history.downloadedNumberTip", {
                    num: Number.isNaN(downloadedNum.value) ? downloadedNum.value : unref(n)(downloadedNum.value)
                  })), 1),
                  createVNode(_component_el_button, {
                    type: "primary",
                    icon: unref(download_default),
                    disabled: !downloadedNum.value,
                    loading: exporting.value,
                    onClick: exportHistory
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(unref(t2)("setting.history.export")), 1)
                    ]),
                    _: 1
                  }, 8, ["icon", "disabled", "loading"]),
                  createVNode(_component_el_button, {
                    type: "primary",
                    icon: unref(upload_default),
                    loading: importing.value,
                    onClick: importHistory
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(unref(t2)("setting.history.import")), 1)
                    ]),
                    _: 1
                  }, 8, ["icon", "loading"]),
                  createVNode(_sfc_main$2, { onConfirm: clearHistory }, {
                    default: withCtx(() => [
                      createVNode(_component_el_button, {
                        type: "danger",
                        icon: unref(delete_default),
                        loading: clearing.value
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString$1(unref(t2)("setting.history.clear")), 1)
                        ]),
                        _: 1
                      }, 8, ["icon", "loading"])
                    ]),
                    _: 1
                  }),
                  createBaseVNode("p", _hoisted_13, toDisplayString$1(unref(t2)("setting.history.importTip")), 1)
                ])
              ]),
              _: 1
            }, 8, ["modelValue"]);
          };
        }
      });
      const SettingsDialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["__scopeId", "data-v-3b39b5cd"]]);
      const compileTemplate = (tpl) => template(tpl, { interpolate: /{{([\s\S]+?)}}/g });
      const getDownloadExt = () => {
        const ext = last(settings.compressionFilename.split("."));
        if (ext)
          return ext.toLowerCase();
        return "zip";
      };
      const getCompressionOptions = () => {
        return {
          streamFiles: settings.compressionStreamFiles,
          compression: settings.compressionLevel > 0 ? "DEFLATE" : "STORE",
          compressionOptions: { level: settings.compressionLevel }
        };
      };
      const getShowAllBtn = () => new Promise((resolve2, reject) => {
        const $btn = $("#show-all-images-button");
        if ($btn.length > 0) {
          resolve2($btn);
          return;
        }
        const container = document.getElementById("thumbnail-container");
        if (!container) {
          reject(new Error("Show all button not found"));
          return;
        }
        new MutationObserver((mutations, self2) => {
          mutations.forEach(({ addedNodes }) => {
            const btnContainer = addedNodes[0];
            if ((btnContainer == null ? void 0 : btnContainer.id) === "show-all-images-container") {
              self2.disconnect();
              resolve2($("#show-all-images-button"));
            }
          });
        }).observe(container, { childList: true });
      });
      const createMangaDownloadInfo = (gallery2, needReactive = false) => {
        const info = {
          gallery: gallery2,
          done: 0,
          compressing: false,
          compressingPercent: "0",
          error: false
        };
        if (needReactive) {
          markRaw(info.gallery);
          return reactive(info);
        }
        return info;
      };
      var noty = { exports: {} };
      /* 
        @package NOTY - Dependency-free notification library 
        @version version: 3.1.4 
        @contributors https://github.com/needim/noty/graphs/contributors 
        @documentation Examples and Documentation - http://needim.github.com/noty 
        @license Licensed under the MIT licenses: http://www.opensource.org/licenses/mit-license.php 
      */
      (function(module2, exports2) {
        (function webpackUniversalModuleDefinition(root2, factory) {
          module2.exports = factory();
        })(commonjsGlobal, function() {
          return (
            /******/
            function(modules) {
              var installedModules = {};
              function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) {
                  return installedModules[moduleId].exports;
                }
                var module22 = installedModules[moduleId] = {
                  /******/
                  i: moduleId,
                  /******/
                  l: false,
                  /******/
                  exports: {}
                  /******/
                };
                modules[moduleId].call(module22.exports, module22, module22.exports, __webpack_require__);
                module22.l = true;
                return module22.exports;
              }
              __webpack_require__.m = modules;
              __webpack_require__.c = installedModules;
              __webpack_require__.i = function(value) {
                return value;
              };
              __webpack_require__.d = function(exports22, name, getter) {
                if (!__webpack_require__.o(exports22, name)) {
                  Object.defineProperty(exports22, name, {
                    /******/
                    configurable: false,
                    /******/
                    enumerable: true,
                    /******/
                    get: getter
                    /******/
                  });
                }
              };
              __webpack_require__.n = function(module22) {
                var getter = module22 && module22.__esModule ? (
                  /******/
                  function getDefault() {
                    return module22["default"];
                  }
                ) : (
                  /******/
                  function getModuleExports() {
                    return module22;
                  }
                );
                __webpack_require__.d(getter, "a", getter);
                return getter;
              };
              __webpack_require__.o = function(object, property2) {
                return Object.prototype.hasOwnProperty.call(object, property2);
              };
              __webpack_require__.p = "";
              return __webpack_require__(__webpack_require__.s = 6);
            }([
              /* 0 */
              /***/
              function(module22, exports22, __webpack_require__) {
                Object.defineProperty(exports22, "__esModule", {
                  value: true
                });
                exports22.css = exports22.deepExtend = exports22.animationEndEvents = void 0;
                var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                  return typeof obj;
                } : function(obj) {
                  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                exports22.inArray = inArray;
                exports22.stopPropagation = stopPropagation;
                exports22.generateID = generateID;
                exports22.outerHeight = outerHeight;
                exports22.addListener = addListener;
                exports22.hasClass = hasClass2;
                exports22.addClass = addClass2;
                exports22.removeClass = removeClass2;
                exports22.remove = remove2;
                exports22.classList = classList;
                exports22.visibilityChangeFlow = visibilityChangeFlow;
                exports22.createAudioElements = createAudioElements;
                var _api = __webpack_require__(1);
                var API = _interopRequireWildcard(_api);
                function _interopRequireWildcard(obj) {
                  if (obj && obj.__esModule) {
                    return obj;
                  } else {
                    var newObj = {};
                    if (obj != null) {
                      for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key))
                          newObj[key] = obj[key];
                      }
                    }
                    newObj.default = obj;
                    return newObj;
                  }
                }
                exports22.animationEndEvents = "webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend";
                function inArray(needle, haystack, argStrict) {
                  var key = void 0;
                  var strict = !!argStrict;
                  if (strict) {
                    for (key in haystack) {
                      if (haystack.hasOwnProperty(key) && haystack[key] === needle) {
                        return true;
                      }
                    }
                  } else {
                    for (key in haystack) {
                      if (haystack.hasOwnProperty(key) && haystack[key] === needle) {
                        return true;
                      }
                    }
                  }
                  return false;
                }
                function stopPropagation(evt) {
                  evt = evt || window.event;
                  if (typeof evt.stopPropagation !== "undefined") {
                    evt.stopPropagation();
                  } else {
                    evt.cancelBubble = true;
                  }
                }
                exports22.deepExtend = function deepExtend2(out) {
                  out = out || {};
                  for (var i = 1; i < arguments.length; i++) {
                    var obj = arguments[i];
                    if (!obj)
                      continue;
                    for (var key in obj) {
                      if (obj.hasOwnProperty(key)) {
                        if (Array.isArray(obj[key])) {
                          out[key] = obj[key];
                        } else if (_typeof(obj[key]) === "object" && obj[key] !== null) {
                          out[key] = deepExtend2(out[key], obj[key]);
                        } else {
                          out[key] = obj[key];
                        }
                      }
                    }
                  }
                  return out;
                };
                function generateID() {
                  var prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
                  var id = "noty_" + prefix + "_";
                  id += "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
                    var r = Math.random() * 16 | 0;
                    var v2 = c2 === "x" ? r : r & 3 | 8;
                    return v2.toString(16);
                  });
                  return id;
                }
                function outerHeight(el) {
                  var height = el.offsetHeight;
                  var style = window.getComputedStyle(el);
                  height += parseInt(style.marginTop) + parseInt(style.marginBottom);
                  return height;
                }
                exports22.css = /* @__PURE__ */ function() {
                  var cssPrefixes = ["Webkit", "O", "Moz", "ms"];
                  var cssProps = {};
                  function camelCase2(string2) {
                    return string2.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(match2, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  function getVendorProp(name) {
                    var style = document.body.style;
                    if (name in style)
                      return name;
                    var i = cssPrefixes.length;
                    var capName = name.charAt(0).toUpperCase() + name.slice(1);
                    var vendorName = void 0;
                    while (i--) {
                      vendorName = cssPrefixes[i] + capName;
                      if (vendorName in style)
                        return vendorName;
                    }
                    return name;
                  }
                  function getStyleProp(name) {
                    name = camelCase2(name);
                    return cssProps[name] || (cssProps[name] = getVendorProp(name));
                  }
                  function applyCss(element, prop, value) {
                    prop = getStyleProp(prop);
                    element.style[prop] = value;
                  }
                  return function(element, properties) {
                    var args = arguments;
                    var prop = void 0;
                    var value = void 0;
                    if (args.length === 2) {
                      for (prop in properties) {
                        if (properties.hasOwnProperty(prop)) {
                          value = properties[prop];
                          if (value !== void 0 && properties.hasOwnProperty(prop)) {
                            applyCss(element, prop, value);
                          }
                        }
                      }
                    } else {
                      applyCss(element, args[1], args[2]);
                    }
                  };
                }();
                function addListener(el, events, cb) {
                  var useCapture = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  events = events.split(" ");
                  for (var i = 0; i < events.length; i++) {
                    if (document.addEventListener) {
                      el.addEventListener(events[i], cb, useCapture);
                    } else if (document.attachEvent) {
                      el.attachEvent("on" + events[i], cb);
                    }
                  }
                }
                function hasClass2(element, name) {
                  var list = typeof element === "string" ? element : classList(element);
                  return list.indexOf(" " + name + " ") >= 0;
                }
                function addClass2(element, name) {
                  var oldList = classList(element);
                  var newList = oldList + name;
                  if (hasClass2(oldList, name))
                    return;
                  element.className = newList.substring(1);
                }
                function removeClass2(element, name) {
                  var oldList = classList(element);
                  var newList = void 0;
                  if (!hasClass2(element, name))
                    return;
                  newList = oldList.replace(" " + name + " ", " ");
                  element.className = newList.substring(1, newList.length - 1);
                }
                function remove2(element) {
                  if (element.parentNode) {
                    element.parentNode.removeChild(element);
                  }
                }
                function classList(element) {
                  return (" " + (element && element.className || "") + " ").replace(/\s+/gi, " ");
                }
                function visibilityChangeFlow() {
                  var hidden = void 0;
                  var visibilityChange = void 0;
                  if (typeof document.hidden !== "undefined") {
                    hidden = "hidden";
                    visibilityChange = "visibilitychange";
                  } else if (typeof document.msHidden !== "undefined") {
                    hidden = "msHidden";
                    visibilityChange = "msvisibilitychange";
                  } else if (typeof document.webkitHidden !== "undefined") {
                    hidden = "webkitHidden";
                    visibilityChange = "webkitvisibilitychange";
                  }
                  function onVisibilityChange() {
                    API.PageHidden = document[hidden];
                    handleVisibilityChange();
                  }
                  function onBlur() {
                    API.PageHidden = true;
                    handleVisibilityChange();
                  }
                  function onFocus() {
                    API.PageHidden = false;
                    handleVisibilityChange();
                  }
                  function handleVisibilityChange() {
                    if (API.PageHidden)
                      stopAll();
                    else
                      resumeAll();
                  }
                  function stopAll() {
                    setTimeout(function() {
                      Object.keys(API.Store).forEach(function(id) {
                        if (API.Store.hasOwnProperty(id)) {
                          if (API.Store[id].options.visibilityControl) {
                            API.Store[id].stop();
                          }
                        }
                      });
                    }, 100);
                  }
                  function resumeAll() {
                    setTimeout(function() {
                      Object.keys(API.Store).forEach(function(id) {
                        if (API.Store.hasOwnProperty(id)) {
                          if (API.Store[id].options.visibilityControl) {
                            API.Store[id].resume();
                          }
                        }
                      });
                      API.queueRenderAll();
                    }, 100);
                  }
                  if (visibilityChange) {
                    addListener(document, visibilityChange, onVisibilityChange);
                  }
                  addListener(window, "blur", onBlur);
                  addListener(window, "focus", onFocus);
                }
                function createAudioElements(ref2) {
                  if (ref2.hasSound) {
                    var audioElement = document.createElement("audio");
                    ref2.options.sounds.sources.forEach(function(s2) {
                      var source = document.createElement("source");
                      source.src = s2;
                      source.type = "audio/" + getExtension(s2);
                      audioElement.appendChild(source);
                    });
                    if (ref2.barDom) {
                      ref2.barDom.appendChild(audioElement);
                    } else {
                      document.querySelector("body").appendChild(audioElement);
                    }
                    audioElement.volume = ref2.options.sounds.volume;
                    if (!ref2.soundPlayed) {
                      audioElement.play();
                      ref2.soundPlayed = true;
                    }
                    audioElement.onended = function() {
                      remove2(audioElement);
                    };
                  }
                }
                function getExtension(fileName) {
                  return fileName.match(/\.([^.]+)$/)[1];
                }
              },
              /* 1 */
              /***/
              function(module22, exports22, __webpack_require__) {
                Object.defineProperty(exports22, "__esModule", {
                  value: true
                });
                exports22.Defaults = exports22.Store = exports22.Queues = exports22.DefaultMaxVisible = exports22.docTitle = exports22.DocModalCount = exports22.PageHidden = void 0;
                exports22.getQueueCounts = getQueueCounts;
                exports22.addToQueue = addToQueue;
                exports22.removeFromQueue = removeFromQueue;
                exports22.queueRender = queueRender;
                exports22.queueRenderAll = queueRenderAll;
                exports22.ghostFix = ghostFix;
                exports22.build = build;
                exports22.hasButtons = hasButtons;
                exports22.handleModal = handleModal;
                exports22.handleModalClose = handleModalClose;
                exports22.queueClose = queueClose;
                exports22.dequeueClose = dequeueClose;
                exports22.fire = fire;
                exports22.openFlow = openFlow;
                exports22.closeFlow = closeFlow;
                var _utils = __webpack_require__(0);
                var Utils = _interopRequireWildcard(_utils);
                function _interopRequireWildcard(obj) {
                  if (obj && obj.__esModule) {
                    return obj;
                  } else {
                    var newObj = {};
                    if (obj != null) {
                      for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key))
                          newObj[key] = obj[key];
                      }
                    }
                    newObj.default = obj;
                    return newObj;
                  }
                }
                exports22.PageHidden = false;
                var DocModalCount = exports22.DocModalCount = 0;
                var DocTitleProps = {
                  originalTitle: null,
                  count: 0,
                  changed: false,
                  timer: -1
                };
                var docTitle = exports22.docTitle = {
                  increment: function increment() {
                    DocTitleProps.count++;
                    docTitle._update();
                  },
                  decrement: function decrement() {
                    DocTitleProps.count--;
                    if (DocTitleProps.count <= 0) {
                      docTitle._clear();
                      return;
                    }
                    docTitle._update();
                  },
                  _update: function _update() {
                    var title = document.title;
                    if (!DocTitleProps.changed) {
                      DocTitleProps.originalTitle = title;
                      document.title = "(" + DocTitleProps.count + ") " + title;
                      DocTitleProps.changed = true;
                    } else {
                      document.title = "(" + DocTitleProps.count + ") " + DocTitleProps.originalTitle;
                    }
                  },
                  _clear: function _clear() {
                    if (DocTitleProps.changed) {
                      DocTitleProps.count = 0;
                      document.title = DocTitleProps.originalTitle;
                      DocTitleProps.changed = false;
                    }
                  }
                };
                var DefaultMaxVisible = exports22.DefaultMaxVisible = 5;
                var Queues = exports22.Queues = {
                  global: {
                    maxVisible: DefaultMaxVisible,
                    queue: []
                  }
                };
                var Store = exports22.Store = {};
                exports22.Defaults = {
                  type: "alert",
                  layout: "topRight",
                  theme: "mint",
                  text: "",
                  timeout: false,
                  progressBar: true,
                  closeWith: ["click"],
                  animation: {
                    open: "noty_effects_open",
                    close: "noty_effects_close"
                  },
                  id: false,
                  force: false,
                  killer: false,
                  queue: "global",
                  container: false,
                  buttons: [],
                  callbacks: {
                    beforeShow: null,
                    onShow: null,
                    afterShow: null,
                    onClose: null,
                    afterClose: null,
                    onClick: null,
                    onHover: null,
                    onTemplate: null
                  },
                  sounds: {
                    sources: [],
                    volume: 1,
                    conditions: []
                  },
                  titleCount: {
                    conditions: []
                  },
                  modal: false,
                  visibilityControl: false
                  /**
                   * @param {string} queueName
                   * @return {object}
                   */
                };
                function getQueueCounts() {
                  var queueName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "global";
                  var count = 0;
                  var max = DefaultMaxVisible;
                  if (Queues.hasOwnProperty(queueName)) {
                    max = Queues[queueName].maxVisible;
                    Object.keys(Store).forEach(function(i) {
                      if (Store[i].options.queue === queueName && !Store[i].closed)
                        count++;
                    });
                  }
                  return {
                    current: count,
                    maxVisible: max
                  };
                }
                function addToQueue(ref2) {
                  if (!Queues.hasOwnProperty(ref2.options.queue)) {
                    Queues[ref2.options.queue] = { maxVisible: DefaultMaxVisible, queue: [] };
                  }
                  Queues[ref2.options.queue].queue.push(ref2);
                }
                function removeFromQueue(ref2) {
                  if (Queues.hasOwnProperty(ref2.options.queue)) {
                    var queue2 = [];
                    Object.keys(Queues[ref2.options.queue].queue).forEach(function(i) {
                      if (Queues[ref2.options.queue].queue[i].id !== ref2.id) {
                        queue2.push(Queues[ref2.options.queue].queue[i]);
                      }
                    });
                    Queues[ref2.options.queue].queue = queue2;
                  }
                }
                function queueRender() {
                  var queueName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "global";
                  if (Queues.hasOwnProperty(queueName)) {
                    var noty2 = Queues[queueName].queue.shift();
                    if (noty2)
                      noty2.show();
                  }
                }
                function queueRenderAll() {
                  Object.keys(Queues).forEach(function(queueName) {
                    queueRender(queueName);
                  });
                }
                function ghostFix(ref2) {
                  var ghostID = Utils.generateID("ghost");
                  var ghost = document.createElement("div");
                  ghost.setAttribute("id", ghostID);
                  Utils.css(ghost, {
                    height: Utils.outerHeight(ref2.barDom) + "px"
                  });
                  ref2.barDom.insertAdjacentHTML("afterend", ghost.outerHTML);
                  Utils.remove(ref2.barDom);
                  ghost = document.getElementById(ghostID);
                  Utils.addClass(ghost, "noty_fix_effects_height");
                  Utils.addListener(ghost, Utils.animationEndEvents, function() {
                    Utils.remove(ghost);
                  });
                }
                function build(ref2) {
                  findOrCreateContainer(ref2);
                  var markup = '<div class="noty_body">' + ref2.options.text + "</div>" + buildButtons(ref2) + '<div class="noty_progressbar"></div>';
                  ref2.barDom = document.createElement("div");
                  ref2.barDom.setAttribute("id", ref2.id);
                  Utils.addClass(ref2.barDom, "noty_bar noty_type__" + ref2.options.type + " noty_theme__" + ref2.options.theme);
                  ref2.barDom.innerHTML = markup;
                  fire(ref2, "onTemplate");
                }
                function hasButtons(ref2) {
                  return !!(ref2.options.buttons && Object.keys(ref2.options.buttons).length);
                }
                function buildButtons(ref2) {
                  if (hasButtons(ref2)) {
                    var buttons = document.createElement("div");
                    Utils.addClass(buttons, "noty_buttons");
                    Object.keys(ref2.options.buttons).forEach(function(key) {
                      buttons.appendChild(ref2.options.buttons[key].dom);
                    });
                    ref2.options.buttons.forEach(function(btn) {
                      buttons.appendChild(btn.dom);
                    });
                    return buttons.outerHTML;
                  }
                  return "";
                }
                function handleModal(ref2) {
                  if (ref2.options.modal) {
                    if (DocModalCount === 0) {
                      createModal();
                    }
                    exports22.DocModalCount = DocModalCount += 1;
                  }
                }
                function handleModalClose(ref2) {
                  if (ref2.options.modal && DocModalCount > 0) {
                    exports22.DocModalCount = DocModalCount -= 1;
                    if (DocModalCount <= 0) {
                      var modal = document.querySelector(".noty_modal");
                      if (modal) {
                        Utils.removeClass(modal, "noty_modal_open");
                        Utils.addClass(modal, "noty_modal_close");
                        Utils.addListener(modal, Utils.animationEndEvents, function() {
                          Utils.remove(modal);
                        });
                      }
                    }
                  }
                }
                function createModal() {
                  var body = document.querySelector("body");
                  var modal = document.createElement("div");
                  Utils.addClass(modal, "noty_modal");
                  body.insertBefore(modal, body.firstChild);
                  Utils.addClass(modal, "noty_modal_open");
                  Utils.addListener(modal, Utils.animationEndEvents, function() {
                    Utils.removeClass(modal, "noty_modal_open");
                  });
                }
                function findOrCreateContainer(ref2) {
                  if (ref2.options.container) {
                    ref2.layoutDom = document.querySelector(ref2.options.container);
                    return;
                  }
                  var layoutID = "noty_layout__" + ref2.options.layout;
                  ref2.layoutDom = document.querySelector("div#" + layoutID);
                  if (!ref2.layoutDom) {
                    ref2.layoutDom = document.createElement("div");
                    ref2.layoutDom.setAttribute("id", layoutID);
                    ref2.layoutDom.setAttribute("role", "alert");
                    ref2.layoutDom.setAttribute("aria-live", "polite");
                    Utils.addClass(ref2.layoutDom, "noty_layout");
                    document.querySelector("body").appendChild(ref2.layoutDom);
                  }
                }
                function queueClose(ref2) {
                  if (ref2.options.timeout) {
                    if (ref2.options.progressBar && ref2.progressDom) {
                      Utils.css(ref2.progressDom, {
                        transition: "width " + ref2.options.timeout + "ms linear",
                        width: "0%"
                      });
                    }
                    clearTimeout(ref2.closeTimer);
                    ref2.closeTimer = setTimeout(function() {
                      ref2.close();
                    }, ref2.options.timeout);
                  }
                }
                function dequeueClose(ref2) {
                  if (ref2.options.timeout && ref2.closeTimer) {
                    clearTimeout(ref2.closeTimer);
                    ref2.closeTimer = -1;
                    if (ref2.options.progressBar && ref2.progressDom) {
                      Utils.css(ref2.progressDom, {
                        transition: "width 0ms linear",
                        width: "100%"
                      });
                    }
                  }
                }
                function fire(ref2, eventName) {
                  if (ref2.listeners.hasOwnProperty(eventName)) {
                    ref2.listeners[eventName].forEach(function(cb) {
                      if (typeof cb === "function") {
                        cb.apply(ref2);
                      }
                    });
                  }
                }
                function openFlow(ref2) {
                  fire(ref2, "afterShow");
                  queueClose(ref2);
                  Utils.addListener(ref2.barDom, "mouseenter", function() {
                    dequeueClose(ref2);
                  });
                  Utils.addListener(ref2.barDom, "mouseleave", function() {
                    queueClose(ref2);
                  });
                }
                function closeFlow(ref2) {
                  delete Store[ref2.id];
                  ref2.closing = false;
                  fire(ref2, "afterClose");
                  Utils.remove(ref2.barDom);
                  if (ref2.layoutDom.querySelectorAll(".noty_bar").length === 0 && !ref2.options.container) {
                    Utils.remove(ref2.layoutDom);
                  }
                  if (Utils.inArray("docVisible", ref2.options.titleCount.conditions) || Utils.inArray("docHidden", ref2.options.titleCount.conditions)) {
                    docTitle.decrement();
                  }
                  queueRender(ref2.options.queue);
                }
              },
              /* 2 */
              /***/
              function(module22, exports22, __webpack_require__) {
                Object.defineProperty(exports22, "__esModule", {
                  value: true
                });
                exports22.NotyButton = void 0;
                var _utils = __webpack_require__(0);
                var Utils = _interopRequireWildcard(_utils);
                function _interopRequireWildcard(obj) {
                  if (obj && obj.__esModule) {
                    return obj;
                  } else {
                    var newObj = {};
                    if (obj != null) {
                      for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key))
                          newObj[key] = obj[key];
                      }
                    }
                    newObj.default = obj;
                    return newObj;
                  }
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                exports22.NotyButton = function NotyButton2(html2, classes, cb) {
                  var _this = this;
                  var attributes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                  _classCallCheck(this, NotyButton2);
                  this.dom = document.createElement("button");
                  this.dom.innerHTML = html2;
                  this.id = attributes.id = attributes.id || Utils.generateID("button");
                  this.cb = cb;
                  Object.keys(attributes).forEach(function(propertyName) {
                    _this.dom.setAttribute(propertyName, attributes[propertyName]);
                  });
                  Utils.addClass(this.dom, classes || "noty_btn");
                  return this;
                };
              },
              /* 3 */
              /***/
              function(module22, exports22, __webpack_require__) {
                Object.defineProperty(exports22, "__esModule", {
                  value: true
                });
                var _createClass = /* @__PURE__ */ function() {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor)
                        descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function(Constructor, protoProps, staticProps) {
                    if (protoProps)
                      defineProperties(Constructor.prototype, protoProps);
                    if (staticProps)
                      defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                exports22.Push = function() {
                  function Push2() {
                    var workerPath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "/service-worker.js";
                    _classCallCheck(this, Push2);
                    this.subData = {};
                    this.workerPath = workerPath;
                    this.listeners = {
                      onPermissionGranted: [],
                      onPermissionDenied: [],
                      onSubscriptionSuccess: [],
                      onSubscriptionCancel: [],
                      onWorkerError: [],
                      onWorkerSuccess: [],
                      onWorkerNotSupported: []
                    };
                    return this;
                  }
                  _createClass(Push2, [{
                    key: "on",
                    value: function on2(eventName) {
                      var cb = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
                      };
                      if (typeof cb === "function" && this.listeners.hasOwnProperty(eventName)) {
                        this.listeners[eventName].push(cb);
                      }
                      return this;
                    }
                  }, {
                    key: "fire",
                    value: function fire(eventName) {
                      var _this = this;
                      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                      if (this.listeners.hasOwnProperty(eventName)) {
                        this.listeners[eventName].forEach(function(cb) {
                          if (typeof cb === "function") {
                            cb.apply(_this, params);
                          }
                        });
                      }
                    }
                  }, {
                    key: "create",
                    value: function create() {
                      console.log("NOT IMPLEMENTED YET");
                    }
                    /**
                     * @return {boolean}
                     */
                  }, {
                    key: "isSupported",
                    value: function isSupported() {
                      var result = false;
                      try {
                        result = window.Notification || window.webkitNotifications || navigator.mozNotification || window.external && window.external.msIsSiteMode() !== void 0;
                      } catch (e) {
                      }
                      return result;
                    }
                    /**
                     * @return {string}
                     */
                  }, {
                    key: "getPermissionStatus",
                    value: function getPermissionStatus() {
                      var perm = "default";
                      if (window.Notification && window.Notification.permissionLevel) {
                        perm = window.Notification.permissionLevel;
                      } else if (window.webkitNotifications && window.webkitNotifications.checkPermission) {
                        switch (window.webkitNotifications.checkPermission()) {
                          case 1:
                            perm = "default";
                            break;
                          case 0:
                            perm = "granted";
                            break;
                          default:
                            perm = "denied";
                        }
                      } else if (window.Notification && window.Notification.permission) {
                        perm = window.Notification.permission;
                      } else if (navigator.mozNotification) {
                        perm = "granted";
                      } else if (window.external && window.external.msIsSiteMode() !== void 0) {
                        perm = window.external.msIsSiteMode() ? "granted" : "default";
                      }
                      return perm.toString().toLowerCase();
                    }
                    /**
                     * @return {string}
                     */
                  }, {
                    key: "getEndpoint",
                    value: function getEndpoint(subscription) {
                      var endpoint = subscription.endpoint;
                      var subscriptionId = subscription.subscriptionId;
                      if (subscriptionId && endpoint.indexOf(subscriptionId) === -1) {
                        endpoint += "/" + subscriptionId;
                      }
                      return endpoint;
                    }
                    /**
                     * @return {boolean}
                     */
                  }, {
                    key: "isSWRegistered",
                    value: function isSWRegistered() {
                      try {
                        return navigator.serviceWorker.controller.state === "activated";
                      } catch (e) {
                        return false;
                      }
                    }
                    /**
                     * @return {void}
                     */
                  }, {
                    key: "unregisterWorker",
                    value: function unregisterWorker() {
                      var self2 = this;
                      if ("serviceWorker" in navigator) {
                        navigator.serviceWorker.getRegistrations().then(function(registrations) {
                          var _iteratorNormalCompletion = true;
                          var _didIteratorError = false;
                          var _iteratorError = void 0;
                          try {
                            for (var _iterator = registrations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                              var registration = _step.value;
                              registration.unregister();
                              self2.fire("onSubscriptionCancel");
                            }
                          } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                          } finally {
                            try {
                              if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                              }
                            } finally {
                              if (_didIteratorError) {
                                throw _iteratorError;
                              }
                            }
                          }
                        });
                      }
                    }
                    /**
                     * @return {void}
                     */
                  }, {
                    key: "requestSubscription",
                    value: function requestSubscription() {
                      var _this2 = this;
                      var userVisibleOnly = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                      var self2 = this;
                      var current = this.getPermissionStatus();
                      var cb = function cb2(result) {
                        if (result === "granted") {
                          _this2.fire("onPermissionGranted");
                          if ("serviceWorker" in navigator) {
                            navigator.serviceWorker.register(_this2.workerPath).then(function() {
                              navigator.serviceWorker.ready.then(function(serviceWorkerRegistration) {
                                self2.fire("onWorkerSuccess");
                                serviceWorkerRegistration.pushManager.subscribe({
                                  userVisibleOnly
                                }).then(function(subscription) {
                                  var key = subscription.getKey("p256dh");
                                  var token = subscription.getKey("auth");
                                  self2.subData = {
                                    endpoint: self2.getEndpoint(subscription),
                                    p256dh: key ? window.btoa(String.fromCharCode.apply(null, new Uint8Array(key))) : null,
                                    auth: token ? window.btoa(String.fromCharCode.apply(null, new Uint8Array(token))) : null
                                  };
                                  self2.fire("onSubscriptionSuccess", [self2.subData]);
                                }).catch(function(err) {
                                  self2.fire("onWorkerError", [err]);
                                });
                              });
                            });
                          } else {
                            self2.fire("onWorkerNotSupported");
                          }
                        } else if (result === "denied") {
                          _this2.fire("onPermissionDenied");
                          _this2.unregisterWorker();
                        }
                      };
                      if (current === "default") {
                        if (window.Notification && window.Notification.requestPermission) {
                          window.Notification.requestPermission(cb);
                        } else if (window.webkitNotifications && window.webkitNotifications.checkPermission) {
                          window.webkitNotifications.requestPermission(cb);
                        }
                      } else {
                        cb(current);
                      }
                    }
                  }]);
                  return Push2;
                }();
              },
              /* 4 */
              /***/
              function(module22, exports22, __webpack_require__) {
                (function(process2, global2) {
                  var require2;
                  /*!
                  * @overview es6-promise - a tiny implementation of Promises/A+.
                  * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
                  * @license   Licensed under MIT license
                  *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
                  * @version   4.1.1
                  */
                  (function(global22, factory) {
                    module22.exports = factory();
                  })(this, function() {
                    function objectOrFunction(x2) {
                      var type = typeof x2;
                      return x2 !== null && (type === "object" || type === "function");
                    }
                    function isFunction2(x2) {
                      return typeof x2 === "function";
                    }
                    var _isArray = void 0;
                    if (Array.isArray) {
                      _isArray = Array.isArray;
                    } else {
                      _isArray = function(x2) {
                        return Object.prototype.toString.call(x2) === "[object Array]";
                      };
                    }
                    var isArray2 = _isArray;
                    var len = 0;
                    var vertxNext = void 0;
                    var customSchedulerFn = void 0;
                    var asap = function asap2(callback, arg) {
                      queue2[len] = callback;
                      queue2[len + 1] = arg;
                      len += 2;
                      if (len === 2) {
                        if (customSchedulerFn) {
                          customSchedulerFn(flush);
                        } else {
                          scheduleFlush();
                        }
                      }
                    };
                    function setScheduler(scheduleFn) {
                      customSchedulerFn = scheduleFn;
                    }
                    function setAsap(asapFn) {
                      asap = asapFn;
                    }
                    var browserWindow = typeof window !== "undefined" ? window : void 0;
                    var browserGlobal = browserWindow || {};
                    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
                    var isNode = typeof self === "undefined" && typeof process2 !== "undefined" && {}.toString.call(process2) === "[object process]";
                    var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
                    function useNextTick() {
                      return function() {
                        return process2.nextTick(flush);
                      };
                    }
                    function useVertxTimer() {
                      if (typeof vertxNext !== "undefined") {
                        return function() {
                          vertxNext(flush);
                        };
                      }
                      return useSetTimeout();
                    }
                    function useMutationObserver2() {
                      var iterations = 0;
                      var observer = new BrowserMutationObserver(flush);
                      var node = document.createTextNode("");
                      observer.observe(node, { characterData: true });
                      return function() {
                        node.data = iterations = ++iterations % 2;
                      };
                    }
                    function useMessageChannel() {
                      var channel = new MessageChannel();
                      channel.port1.onmessage = flush;
                      return function() {
                        return channel.port2.postMessage(0);
                      };
                    }
                    function useSetTimeout() {
                      var globalSetTimeout = setTimeout;
                      return function() {
                        return globalSetTimeout(flush, 1);
                      };
                    }
                    var queue2 = new Array(1e3);
                    function flush() {
                      for (var i = 0; i < len; i += 2) {
                        var callback = queue2[i];
                        var arg = queue2[i + 1];
                        callback(arg);
                        queue2[i] = void 0;
                        queue2[i + 1] = void 0;
                      }
                      len = 0;
                    }
                    function attemptVertx() {
                      try {
                        var r = require2;
                        var vertx = __webpack_require__(9);
                        vertxNext = vertx.runOnLoop || vertx.runOnContext;
                        return useVertxTimer();
                      } catch (e) {
                        return useSetTimeout();
                      }
                    }
                    var scheduleFlush = void 0;
                    if (isNode) {
                      scheduleFlush = useNextTick();
                    } else if (BrowserMutationObserver) {
                      scheduleFlush = useMutationObserver2();
                    } else if (isWorker) {
                      scheduleFlush = useMessageChannel();
                    } else if (browserWindow === void 0 && true) {
                      scheduleFlush = attemptVertx();
                    } else {
                      scheduleFlush = useSetTimeout();
                    }
                    function then(onFulfillment, onRejection) {
                      var _arguments = arguments;
                      var parent = this;
                      var child = new this.constructor(noop2);
                      if (child[PROMISE_ID] === void 0) {
                        makePromise(child);
                      }
                      var _state = parent._state;
                      if (_state) {
                        (function() {
                          var callback = _arguments[_state - 1];
                          asap(function() {
                            return invokeCallback(_state, child, callback, parent._result);
                          });
                        })();
                      } else {
                        subscribe(parent, child, onFulfillment, onRejection);
                      }
                      return child;
                    }
                    function resolve$1(object) {
                      var Constructor = this;
                      if (object && typeof object === "object" && object.constructor === Constructor) {
                        return object;
                      }
                      var promise = new Constructor(noop2);
                      resolve2(promise, object);
                      return promise;
                    }
                    var PROMISE_ID = Math.random().toString(36).substring(16);
                    function noop2() {
                    }
                    var PENDING = void 0;
                    var FULFILLED = 1;
                    var REJECTED = 2;
                    var GET_THEN_ERROR = new ErrorObject();
                    function selfFulfillment() {
                      return new TypeError("You cannot resolve a promise with itself");
                    }
                    function cannotReturnOwn() {
                      return new TypeError("A promises callback cannot return that same promise.");
                    }
                    function getThen(promise) {
                      try {
                        return promise.then;
                      } catch (error) {
                        GET_THEN_ERROR.error = error;
                        return GET_THEN_ERROR;
                      }
                    }
                    function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
                      try {
                        then$$1.call(value, fulfillmentHandler, rejectionHandler);
                      } catch (e) {
                        return e;
                      }
                    }
                    function handleForeignThenable(promise, thenable, then$$1) {
                      asap(function(promise2) {
                        var sealed = false;
                        var error = tryThen(then$$1, thenable, function(value) {
                          if (sealed) {
                            return;
                          }
                          sealed = true;
                          if (thenable !== value) {
                            resolve2(promise2, value);
                          } else {
                            fulfill(promise2, value);
                          }
                        }, function(reason) {
                          if (sealed) {
                            return;
                          }
                          sealed = true;
                          reject(promise2, reason);
                        }, "Settle: " + (promise2._label || " unknown promise"));
                        if (!sealed && error) {
                          sealed = true;
                          reject(promise2, error);
                        }
                      }, promise);
                    }
                    function handleOwnThenable(promise, thenable) {
                      if (thenable._state === FULFILLED) {
                        fulfill(promise, thenable._result);
                      } else if (thenable._state === REJECTED) {
                        reject(promise, thenable._result);
                      } else {
                        subscribe(thenable, void 0, function(value) {
                          return resolve2(promise, value);
                        }, function(reason) {
                          return reject(promise, reason);
                        });
                      }
                    }
                    function handleMaybeThenable(promise, maybeThenable, then$$1) {
                      if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
                        handleOwnThenable(promise, maybeThenable);
                      } else {
                        if (then$$1 === GET_THEN_ERROR) {
                          reject(promise, GET_THEN_ERROR.error);
                          GET_THEN_ERROR.error = null;
                        } else if (then$$1 === void 0) {
                          fulfill(promise, maybeThenable);
                        } else if (isFunction2(then$$1)) {
                          handleForeignThenable(promise, maybeThenable, then$$1);
                        } else {
                          fulfill(promise, maybeThenable);
                        }
                      }
                    }
                    function resolve2(promise, value) {
                      if (promise === value) {
                        reject(promise, selfFulfillment());
                      } else if (objectOrFunction(value)) {
                        handleMaybeThenable(promise, value, getThen(value));
                      } else {
                        fulfill(promise, value);
                      }
                    }
                    function publishRejection(promise) {
                      if (promise._onerror) {
                        promise._onerror(promise._result);
                      }
                      publish(promise);
                    }
                    function fulfill(promise, value) {
                      if (promise._state !== PENDING) {
                        return;
                      }
                      promise._result = value;
                      promise._state = FULFILLED;
                      if (promise._subscribers.length !== 0) {
                        asap(publish, promise);
                      }
                    }
                    function reject(promise, reason) {
                      if (promise._state !== PENDING) {
                        return;
                      }
                      promise._state = REJECTED;
                      promise._result = reason;
                      asap(publishRejection, promise);
                    }
                    function subscribe(parent, child, onFulfillment, onRejection) {
                      var _subscribers = parent._subscribers;
                      var length = _subscribers.length;
                      parent._onerror = null;
                      _subscribers[length] = child;
                      _subscribers[length + FULFILLED] = onFulfillment;
                      _subscribers[length + REJECTED] = onRejection;
                      if (length === 0 && parent._state) {
                        asap(publish, parent);
                      }
                    }
                    function publish(promise) {
                      var subscribers = promise._subscribers;
                      var settled = promise._state;
                      if (subscribers.length === 0) {
                        return;
                      }
                      var child = void 0, callback = void 0, detail = promise._result;
                      for (var i = 0; i < subscribers.length; i += 3) {
                        child = subscribers[i];
                        callback = subscribers[i + settled];
                        if (child) {
                          invokeCallback(settled, child, callback, detail);
                        } else {
                          callback(detail);
                        }
                      }
                      promise._subscribers.length = 0;
                    }
                    function ErrorObject() {
                      this.error = null;
                    }
                    var TRY_CATCH_ERROR = new ErrorObject();
                    function tryCatch(callback, detail) {
                      try {
                        return callback(detail);
                      } catch (e) {
                        TRY_CATCH_ERROR.error = e;
                        return TRY_CATCH_ERROR;
                      }
                    }
                    function invokeCallback(settled, promise, callback, detail) {
                      var hasCallback = isFunction2(callback), value = void 0, error = void 0, succeeded = void 0, failed = void 0;
                      if (hasCallback) {
                        value = tryCatch(callback, detail);
                        if (value === TRY_CATCH_ERROR) {
                          failed = true;
                          error = value.error;
                          value.error = null;
                        } else {
                          succeeded = true;
                        }
                        if (promise === value) {
                          reject(promise, cannotReturnOwn());
                          return;
                        }
                      } else {
                        value = detail;
                        succeeded = true;
                      }
                      if (promise._state !== PENDING)
                        ;
                      else if (hasCallback && succeeded) {
                        resolve2(promise, value);
                      } else if (failed) {
                        reject(promise, error);
                      } else if (settled === FULFILLED) {
                        fulfill(promise, value);
                      } else if (settled === REJECTED) {
                        reject(promise, value);
                      }
                    }
                    function initializePromise(promise, resolver) {
                      try {
                        resolver(function resolvePromise(value) {
                          resolve2(promise, value);
                        }, function rejectPromise(reason) {
                          reject(promise, reason);
                        });
                      } catch (e) {
                        reject(promise, e);
                      }
                    }
                    var id = 0;
                    function nextId() {
                      return id++;
                    }
                    function makePromise(promise) {
                      promise[PROMISE_ID] = id++;
                      promise._state = void 0;
                      promise._result = void 0;
                      promise._subscribers = [];
                    }
                    function Enumerator$1(Constructor, input) {
                      this._instanceConstructor = Constructor;
                      this.promise = new Constructor(noop2);
                      if (!this.promise[PROMISE_ID]) {
                        makePromise(this.promise);
                      }
                      if (isArray2(input)) {
                        this.length = input.length;
                        this._remaining = input.length;
                        this._result = new Array(this.length);
                        if (this.length === 0) {
                          fulfill(this.promise, this._result);
                        } else {
                          this.length = this.length || 0;
                          this._enumerate(input);
                          if (this._remaining === 0) {
                            fulfill(this.promise, this._result);
                          }
                        }
                      } else {
                        reject(this.promise, validationError());
                      }
                    }
                    function validationError() {
                      return new Error("Array Methods must be provided an Array");
                    }
                    Enumerator$1.prototype._enumerate = function(input) {
                      for (var i = 0; this._state === PENDING && i < input.length; i++) {
                        this._eachEntry(input[i], i);
                      }
                    };
                    Enumerator$1.prototype._eachEntry = function(entry, i) {
                      var c2 = this._instanceConstructor;
                      var resolve$$1 = c2.resolve;
                      if (resolve$$1 === resolve$1) {
                        var _then = getThen(entry);
                        if (_then === then && entry._state !== PENDING) {
                          this._settledAt(entry._state, i, entry._result);
                        } else if (typeof _then !== "function") {
                          this._remaining--;
                          this._result[i] = entry;
                        } else if (c2 === Promise$2) {
                          var promise = new c2(noop2);
                          handleMaybeThenable(promise, entry, _then);
                          this._willSettleAt(promise, i);
                        } else {
                          this._willSettleAt(new c2(function(resolve$$12) {
                            return resolve$$12(entry);
                          }), i);
                        }
                      } else {
                        this._willSettleAt(resolve$$1(entry), i);
                      }
                    };
                    Enumerator$1.prototype._settledAt = function(state, i, value) {
                      var promise = this.promise;
                      if (promise._state === PENDING) {
                        this._remaining--;
                        if (state === REJECTED) {
                          reject(promise, value);
                        } else {
                          this._result[i] = value;
                        }
                      }
                      if (this._remaining === 0) {
                        fulfill(promise, this._result);
                      }
                    };
                    Enumerator$1.prototype._willSettleAt = function(promise, i) {
                      var enumerator = this;
                      subscribe(promise, void 0, function(value) {
                        return enumerator._settledAt(FULFILLED, i, value);
                      }, function(reason) {
                        return enumerator._settledAt(REJECTED, i, reason);
                      });
                    };
                    function all$1(entries) {
                      return new Enumerator$1(this, entries).promise;
                    }
                    function race$1(entries) {
                      var Constructor = this;
                      if (!isArray2(entries)) {
                        return new Constructor(function(_2, reject2) {
                          return reject2(new TypeError("You must pass an array to race."));
                        });
                      } else {
                        return new Constructor(function(resolve22, reject2) {
                          var length = entries.length;
                          for (var i = 0; i < length; i++) {
                            Constructor.resolve(entries[i]).then(resolve22, reject2);
                          }
                        });
                      }
                    }
                    function reject$1(reason) {
                      var Constructor = this;
                      var promise = new Constructor(noop2);
                      reject(promise, reason);
                      return promise;
                    }
                    function needsResolver() {
                      throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                    }
                    function needsNew() {
                      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                    }
                    function Promise$2(resolver) {
                      this[PROMISE_ID] = nextId();
                      this._result = this._state = void 0;
                      this._subscribers = [];
                      if (noop2 !== resolver) {
                        typeof resolver !== "function" && needsResolver();
                        this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();
                      }
                    }
                    Promise$2.all = all$1;
                    Promise$2.race = race$1;
                    Promise$2.resolve = resolve$1;
                    Promise$2.reject = reject$1;
                    Promise$2._setScheduler = setScheduler;
                    Promise$2._setAsap = setAsap;
                    Promise$2._asap = asap;
                    Promise$2.prototype = {
                      constructor: Promise$2,
                      /**
                        The primary way of interacting with a promise is through its `then` method,
                        which registers callbacks to receive either a promise's eventual value or the
                        reason why the promise cannot be fulfilled.
                      
                        ```js
                        findUser().then(function(user){
                          // user is available
                        }, function(reason){
                          // user is unavailable, and you are given the reason why
                        });
                        ```
                      
                        Chaining
                        --------
                      
                        The return value of `then` is itself a promise.  This second, 'downstream'
                        promise is resolved with the return value of the first promise's fulfillment
                        or rejection handler, or rejected if the handler throws an exception.
                      
                        ```js
                        findUser().then(function (user) {
                          return user.name;
                        }, function (reason) {
                          return 'default name';
                        }).then(function (userName) {
                          // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
                          // will be `'default name'`
                        });
                      
                        findUser().then(function (user) {
                          throw new Error('Found user, but still unhappy');
                        }, function (reason) {
                          throw new Error('`findUser` rejected and we're unhappy');
                        }).then(function (value) {
                          // never reached
                        }, function (reason) {
                          // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
                          // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
                        });
                        ```
                        If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
                      
                        ```js
                        findUser().then(function (user) {
                          throw new PedagogicalException('Upstream error');
                        }).then(function (value) {
                          // never reached
                        }).then(function (value) {
                          // never reached
                        }, function (reason) {
                          // The `PedgagocialException` is propagated all the way down to here
                        });
                        ```
                      
                        Assimilation
                        ------------
                      
                        Sometimes the value you want to propagate to a downstream promise can only be
                        retrieved asynchronously. This can be achieved by returning a promise in the
                        fulfillment or rejection handler. The downstream promise will then be pending
                        until the returned promise is settled. This is called *assimilation*.
                      
                        ```js
                        findUser().then(function (user) {
                          return findCommentsByAuthor(user);
                        }).then(function (comments) {
                          // The user's comments are now available
                        });
                        ```
                      
                        If the assimliated promise rejects, then the downstream promise will also reject.
                      
                        ```js
                        findUser().then(function (user) {
                          return findCommentsByAuthor(user);
                        }).then(function (comments) {
                          // If `findCommentsByAuthor` fulfills, we'll have the value here
                        }, function (reason) {
                          // If `findCommentsByAuthor` rejects, we'll have the reason here
                        });
                        ```
                      
                        Simple Example
                        --------------
                      
                        Synchronous Example
                      
                        ```javascript
                        let result;
                      
                        try {
                          result = findResult();
                          // success
                        } catch(reason) {
                          // failure
                        }
                        ```
                      
                        Errback Example
                      
                        ```js
                        findResult(function(result, err){
                          if (err) {
                            // failure
                          } else {
                            // success
                          }
                        });
                        ```
                      
                        Promise Example;
                      
                        ```javascript
                        findResult().then(function(result){
                          // success
                        }, function(reason){
                          // failure
                        });
                        ```
                      
                        Advanced Example
                        --------------
                      
                        Synchronous Example
                      
                        ```javascript
                        let author, books;
                      
                        try {
                          author = findAuthor();
                          books  = findBooksByAuthor(author);
                          // success
                        } catch(reason) {
                          // failure
                        }
                        ```
                      
                        Errback Example
                      
                        ```js
                      
                        function foundBooks(books) {
                      
                        }
                      
                        function failure(reason) {
                      
                        }
                      
                        findAuthor(function(author, err){
                          if (err) {
                            failure(err);
                            // failure
                          } else {
                            try {
                              findBoooksByAuthor(author, function(books, err) {
                                if (err) {
                                  failure(err);
                                } else {
                                  try {
                                    foundBooks(books);
                                  } catch(reason) {
                                    failure(reason);
                                  }
                                }
                              });
                            } catch(error) {
                              failure(err);
                            }
                            // success
                          }
                        });
                        ```
                      
                        Promise Example;
                      
                        ```javascript
                        findAuthor().
                          then(findBooksByAuthor).
                          then(function(books){
                            // found books
                        }).catch(function(reason){
                          // something went wrong
                        });
                        ```
                      
                        @method then
                        @param {Function} onFulfilled
                        @param {Function} onRejected
                        Useful for tooling.
                        @return {Promise}
                      */
                      then,
                      /**
                        `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
                        as the catch block of a try/catch statement.
                      
                        ```js
                        function findAuthor(){
                          throw new Error('couldn't find that author');
                        }
                      
                        // synchronous
                        try {
                          findAuthor();
                        } catch(reason) {
                          // something went wrong
                        }
                      
                        // async with promises
                        findAuthor().catch(function(reason){
                          // something went wrong
                        });
                        ```
                      
                        @method catch
                        @param {Function} onRejection
                        Useful for tooling.
                        @return {Promise}
                      */
                      "catch": function _catch(onRejection) {
                        return this.then(null, onRejection);
                      }
                    };
                    function polyfill$1() {
                      var local = void 0;
                      if (typeof global2 !== "undefined") {
                        local = global2;
                      } else if (typeof self !== "undefined") {
                        local = self;
                      } else {
                        try {
                          local = Function("return this")();
                        } catch (e) {
                          throw new Error("polyfill failed because global object is unavailable in this environment");
                        }
                      }
                      var P2 = local.Promise;
                      if (P2) {
                        var promiseToString = null;
                        try {
                          promiseToString = Object.prototype.toString.call(P2.resolve());
                        } catch (e) {
                        }
                        if (promiseToString === "[object Promise]" && !P2.cast) {
                          return;
                        }
                      }
                      local.Promise = Promise$2;
                    }
                    Promise$2.polyfill = polyfill$1;
                    Promise$2.Promise = Promise$2;
                    return Promise$2;
                  });
                }).call(exports22, __webpack_require__(7), __webpack_require__(8));
              },
              /* 5 */
              /***/
              function(module22, exports22) {
              },
              /* 6 */
              /***/
              function(module22, exports22, __webpack_require__) {
                Object.defineProperty(exports22, "__esModule", {
                  value: true
                });
                var _createClass = /* @__PURE__ */ function() {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor)
                        descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function(Constructor, protoProps, staticProps) {
                    if (protoProps)
                      defineProperties(Constructor.prototype, protoProps);
                    if (staticProps)
                      defineProperties(Constructor, staticProps);
                    return Constructor;
                  };
                }();
                __webpack_require__(5);
                var _es6Promise = __webpack_require__(4);
                var _es6Promise2 = _interopRequireDefault(_es6Promise);
                var _utils = __webpack_require__(0);
                var Utils = _interopRequireWildcard(_utils);
                var _api = __webpack_require__(1);
                var API = _interopRequireWildcard(_api);
                var _button = __webpack_require__(2);
                var _push = __webpack_require__(3);
                function _interopRequireWildcard(obj) {
                  if (obj && obj.__esModule) {
                    return obj;
                  } else {
                    var newObj = {};
                    if (obj != null) {
                      for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key))
                          newObj[key] = obj[key];
                      }
                    }
                    newObj.default = obj;
                    return newObj;
                  }
                }
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : { default: obj };
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                var Noty2 = function() {
                  function Noty22() {
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    _classCallCheck(this, Noty22);
                    this.options = Utils.deepExtend({}, API.Defaults, options);
                    this.id = this.options.id || Utils.generateID("bar");
                    this.closeTimer = -1;
                    this.barDom = null;
                    this.layoutDom = null;
                    this.progressDom = null;
                    this.showing = false;
                    this.shown = false;
                    this.closed = false;
                    this.closing = false;
                    this.killable = this.options.timeout || this.options.closeWith.length > 0;
                    this.hasSound = this.options.sounds.sources.length > 0;
                    this.soundPlayed = false;
                    this.listeners = {
                      beforeShow: [],
                      onShow: [],
                      afterShow: [],
                      onClose: [],
                      afterClose: [],
                      onClick: [],
                      onHover: [],
                      onTemplate: []
                    };
                    this.promises = {
                      show: null,
                      close: null
                    };
                    this.on("beforeShow", this.options.callbacks.beforeShow);
                    this.on("onShow", this.options.callbacks.onShow);
                    this.on("afterShow", this.options.callbacks.afterShow);
                    this.on("onClose", this.options.callbacks.onClose);
                    this.on("afterClose", this.options.callbacks.afterClose);
                    this.on("onClick", this.options.callbacks.onClick);
                    this.on("onHover", this.options.callbacks.onHover);
                    this.on("onTemplate", this.options.callbacks.onTemplate);
                    return this;
                  }
                  _createClass(Noty22, [{
                    key: "on",
                    value: function on2(eventName) {
                      var cb = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
                      };
                      if (typeof cb === "function" && this.listeners.hasOwnProperty(eventName)) {
                        this.listeners[eventName].push(cb);
                      }
                      return this;
                    }
                    /**
                     * @return {Noty}
                     */
                  }, {
                    key: "show",
                    value: function show() {
                      var _this = this;
                      if (this.options.killer === true) {
                        Noty22.closeAll();
                      } else if (typeof this.options.killer === "string") {
                        Noty22.closeAll(this.options.killer);
                      }
                      var queueCounts = API.getQueueCounts(this.options.queue);
                      if (queueCounts.current >= queueCounts.maxVisible || API.PageHidden && this.options.visibilityControl) {
                        API.addToQueue(this);
                        if (API.PageHidden && this.hasSound && Utils.inArray("docHidden", this.options.sounds.conditions)) {
                          Utils.createAudioElements(this);
                        }
                        if (API.PageHidden && Utils.inArray("docHidden", this.options.titleCount.conditions)) {
                          API.docTitle.increment();
                        }
                        return this;
                      }
                      API.Store[this.id] = this;
                      API.fire(this, "beforeShow");
                      this.showing = true;
                      if (this.closing) {
                        this.showing = false;
                        return this;
                      }
                      API.build(this);
                      API.handleModal(this);
                      if (this.options.force) {
                        this.layoutDom.insertBefore(this.barDom, this.layoutDom.firstChild);
                      } else {
                        this.layoutDom.appendChild(this.barDom);
                      }
                      if (this.hasSound && !this.soundPlayed && Utils.inArray("docVisible", this.options.sounds.conditions)) {
                        Utils.createAudioElements(this);
                      }
                      if (Utils.inArray("docVisible", this.options.titleCount.conditions)) {
                        API.docTitle.increment();
                      }
                      this.shown = true;
                      this.closed = false;
                      if (API.hasButtons(this)) {
                        Object.keys(this.options.buttons).forEach(function(key) {
                          var btn = _this.barDom.querySelector("#" + _this.options.buttons[key].id);
                          Utils.addListener(btn, "click", function(e) {
                            Utils.stopPropagation(e);
                            _this.options.buttons[key].cb();
                          });
                        });
                      }
                      this.progressDom = this.barDom.querySelector(".noty_progressbar");
                      if (Utils.inArray("click", this.options.closeWith)) {
                        Utils.addClass(this.barDom, "noty_close_with_click");
                        Utils.addListener(this.barDom, "click", function(e) {
                          Utils.stopPropagation(e);
                          API.fire(_this, "onClick");
                          _this.close();
                        }, false);
                      }
                      Utils.addListener(this.barDom, "mouseenter", function() {
                        API.fire(_this, "onHover");
                      }, false);
                      if (this.options.timeout)
                        Utils.addClass(this.barDom, "noty_has_timeout");
                      if (this.options.progressBar) {
                        Utils.addClass(this.barDom, "noty_has_progressbar");
                      }
                      if (Utils.inArray("button", this.options.closeWith)) {
                        Utils.addClass(this.barDom, "noty_close_with_button");
                        var closeButton = document.createElement("div");
                        Utils.addClass(closeButton, "noty_close_button");
                        closeButton.innerHTML = "×";
                        this.barDom.appendChild(closeButton);
                        Utils.addListener(closeButton, "click", function(e) {
                          Utils.stopPropagation(e);
                          _this.close();
                        }, false);
                      }
                      API.fire(this, "onShow");
                      if (this.options.animation.open === null) {
                        this.promises.show = new _es6Promise2.default(function(resolve2) {
                          resolve2();
                        });
                      } else if (typeof this.options.animation.open === "function") {
                        this.promises.show = new _es6Promise2.default(this.options.animation.open.bind(this));
                      } else {
                        Utils.addClass(this.barDom, this.options.animation.open);
                        this.promises.show = new _es6Promise2.default(function(resolve2) {
                          Utils.addListener(_this.barDom, Utils.animationEndEvents, function() {
                            Utils.removeClass(_this.barDom, _this.options.animation.open);
                            resolve2();
                          });
                        });
                      }
                      this.promises.show.then(function() {
                        var _t2 = _this;
                        setTimeout(function() {
                          API.openFlow(_t2);
                        }, 100);
                      });
                      return this;
                    }
                    /**
                     * @return {Noty}
                     */
                  }, {
                    key: "stop",
                    value: function stop() {
                      API.dequeueClose(this);
                      return this;
                    }
                    /**
                     * @return {Noty}
                     */
                  }, {
                    key: "resume",
                    value: function resume() {
                      API.queueClose(this);
                      return this;
                    }
                    /**
                     * @param {int|boolean} ms
                     * @return {Noty}
                     */
                  }, {
                    key: "setTimeout",
                    value: function(_setTimeout) {
                      function setTimeout2(_x) {
                        return _setTimeout.apply(this, arguments);
                      }
                      setTimeout2.toString = function() {
                        return _setTimeout.toString();
                      };
                      return setTimeout2;
                    }(function(ms) {
                      this.stop();
                      this.options.timeout = ms;
                      if (this.barDom) {
                        if (this.options.timeout) {
                          Utils.addClass(this.barDom, "noty_has_timeout");
                        } else {
                          Utils.removeClass(this.barDom, "noty_has_timeout");
                        }
                        var _t2 = this;
                        setTimeout(function() {
                          _t2.resume();
                        }, 100);
                      }
                      return this;
                    })
                    /**
                     * @param {string} html
                     * @param {boolean} optionsOverride
                     * @return {Noty}
                     */
                  }, {
                    key: "setText",
                    value: function setText(html2) {
                      var optionsOverride = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                      if (this.barDom) {
                        this.barDom.querySelector(".noty_body").innerHTML = html2;
                      }
                      if (optionsOverride)
                        this.options.text = html2;
                      return this;
                    }
                    /**
                     * @param {string} type
                     * @param {boolean} optionsOverride
                     * @return {Noty}
                     */
                  }, {
                    key: "setType",
                    value: function setType(type) {
                      var _this2 = this;
                      var optionsOverride = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                      if (this.barDom) {
                        var classList = Utils.classList(this.barDom).split(" ");
                        classList.forEach(function(c2) {
                          if (c2.substring(0, 11) === "noty_type__") {
                            Utils.removeClass(_this2.barDom, c2);
                          }
                        });
                        Utils.addClass(this.barDom, "noty_type__" + type);
                      }
                      if (optionsOverride)
                        this.options.type = type;
                      return this;
                    }
                    /**
                     * @param {string} theme
                     * @param {boolean} optionsOverride
                     * @return {Noty}
                     */
                  }, {
                    key: "setTheme",
                    value: function setTheme(theme) {
                      var _this3 = this;
                      var optionsOverride = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                      if (this.barDom) {
                        var classList = Utils.classList(this.barDom).split(" ");
                        classList.forEach(function(c2) {
                          if (c2.substring(0, 12) === "noty_theme__") {
                            Utils.removeClass(_this3.barDom, c2);
                          }
                        });
                        Utils.addClass(this.barDom, "noty_theme__" + theme);
                      }
                      if (optionsOverride)
                        this.options.theme = theme;
                      return this;
                    }
                    /**
                     * @return {Noty}
                     */
                  }, {
                    key: "close",
                    value: function close() {
                      var _this4 = this;
                      if (this.closed)
                        return this;
                      if (!this.shown) {
                        API.removeFromQueue(this);
                        return this;
                      }
                      API.fire(this, "onClose");
                      this.closing = true;
                      if (this.options.animation.close === null) {
                        this.promises.close = new _es6Promise2.default(function(resolve2) {
                          resolve2();
                        });
                      } else if (typeof this.options.animation.close === "function") {
                        this.promises.close = new _es6Promise2.default(this.options.animation.close.bind(this));
                      } else {
                        Utils.addClass(this.barDom, this.options.animation.close);
                        this.promises.close = new _es6Promise2.default(function(resolve2) {
                          Utils.addListener(_this4.barDom, Utils.animationEndEvents, function() {
                            if (_this4.options.force) {
                              Utils.remove(_this4.barDom);
                            } else {
                              API.ghostFix(_this4);
                            }
                            resolve2();
                          });
                        });
                      }
                      this.promises.close.then(function() {
                        API.closeFlow(_this4);
                        API.handleModalClose(_this4);
                      });
                      this.closed = true;
                      return this;
                    }
                    // API functions
                    /**
                     * @param {boolean|string} queueName
                     * @return {Noty}
                     */
                  }], [{
                    key: "closeAll",
                    value: function closeAll2() {
                      var queueName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                      Object.keys(API.Store).forEach(function(id) {
                        if (queueName) {
                          if (API.Store[id].options.queue === queueName && API.Store[id].killable) {
                            API.Store[id].close();
                          }
                        } else if (API.Store[id].killable) {
                          API.Store[id].close();
                        }
                      });
                      return this;
                    }
                    /**
                     * @param {Object} obj
                     * @return {Noty}
                     */
                  }, {
                    key: "overrideDefaults",
                    value: function overrideDefaults(obj) {
                      API.Defaults = Utils.deepExtend({}, API.Defaults, obj);
                      return this;
                    }
                    /**
                     * @param {int} amount
                     * @param {string} queueName
                     * @return {Noty}
                     */
                  }, {
                    key: "setMaxVisible",
                    value: function setMaxVisible() {
                      var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : API.DefaultMaxVisible;
                      var queueName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "global";
                      if (!API.Queues.hasOwnProperty(queueName)) {
                        API.Queues[queueName] = { maxVisible: amount, queue: [] };
                      }
                      API.Queues[queueName].maxVisible = amount;
                      return this;
                    }
                    /**
                     * @param {string} innerHtml
                     * @param {String} classes
                     * @param {Function} cb
                     * @param {Object} attributes
                     * @return {NotyButton}
                     */
                  }, {
                    key: "button",
                    value: function button(innerHtml) {
                      var classes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                      var cb = arguments[2];
                      var attributes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                      return new _button.NotyButton(innerHtml, classes, cb, attributes);
                    }
                    /**
                     * @return {string}
                     */
                  }, {
                    key: "version",
                    value: function version2() {
                      return "3.1.4";
                    }
                    /**
                     * @param {String} workerPath
                     * @return {Push}
                     */
                  }, {
                    key: "Push",
                    value: function Push(workerPath) {
                      return new _push.Push(workerPath);
                    }
                  }]);
                  return Noty22;
                }();
                exports22.default = Noty2;
                Utils.visibilityChangeFlow();
                module22.exports = exports22["default"];
              },
              /* 7 */
              /***/
              function(module22, exports22) {
                var process2 = module22.exports = {};
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                  throw new Error("setTimeout has not been defined");
                }
                function defaultClearTimeout() {
                  throw new Error("clearTimeout has not been defined");
                }
                (function() {
                  try {
                    if (typeof setTimeout === "function") {
                      cachedSetTimeout = setTimeout;
                    } else {
                      cachedSetTimeout = defaultSetTimout;
                    }
                  } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                  }
                  try {
                    if (typeof clearTimeout === "function") {
                      cachedClearTimeout = clearTimeout;
                    } else {
                      cachedClearTimeout = defaultClearTimeout;
                    }
                  } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                  }
                })();
                function runTimeout(fun) {
                  if (cachedSetTimeout === setTimeout) {
                    return setTimeout(fun, 0);
                  }
                  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                  }
                  try {
                    return cachedSetTimeout(fun, 0);
                  } catch (e) {
                    try {
                      return cachedSetTimeout.call(null, fun, 0);
                    } catch (e2) {
                      return cachedSetTimeout.call(this, fun, 0);
                    }
                  }
                }
                function runClearTimeout(marker) {
                  if (cachedClearTimeout === clearTimeout) {
                    return clearTimeout(marker);
                  }
                  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                  }
                  try {
                    return cachedClearTimeout(marker);
                  } catch (e) {
                    try {
                      return cachedClearTimeout.call(null, marker);
                    } catch (e2) {
                      return cachedClearTimeout.call(this, marker);
                    }
                  }
                }
                var queue2 = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                  if (!draining || !currentQueue) {
                    return;
                  }
                  draining = false;
                  if (currentQueue.length) {
                    queue2 = currentQueue.concat(queue2);
                  } else {
                    queueIndex = -1;
                  }
                  if (queue2.length) {
                    drainQueue();
                  }
                }
                function drainQueue() {
                  if (draining) {
                    return;
                  }
                  var timeout = runTimeout(cleanUpNextTick);
                  draining = true;
                  var len = queue2.length;
                  while (len) {
                    currentQueue = queue2;
                    queue2 = [];
                    while (++queueIndex < len) {
                      if (currentQueue) {
                        currentQueue[queueIndex].run();
                      }
                    }
                    queueIndex = -1;
                    len = queue2.length;
                  }
                  currentQueue = null;
                  draining = false;
                  runClearTimeout(timeout);
                }
                process2.nextTick = function(fun) {
                  var args = new Array(arguments.length - 1);
                  if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                      args[i - 1] = arguments[i];
                    }
                  }
                  queue2.push(new Item(fun, args));
                  if (queue2.length === 1 && !draining) {
                    runTimeout(drainQueue);
                  }
                };
                function Item(fun, array) {
                  this.fun = fun;
                  this.array = array;
                }
                Item.prototype.run = function() {
                  this.fun.apply(null, this.array);
                };
                process2.title = "browser";
                process2.browser = true;
                process2.env = {};
                process2.argv = [];
                process2.version = "";
                process2.versions = {};
                function noop2() {
                }
                process2.on = noop2;
                process2.addListener = noop2;
                process2.once = noop2;
                process2.off = noop2;
                process2.removeListener = noop2;
                process2.removeAllListeners = noop2;
                process2.emit = noop2;
                process2.prependListener = noop2;
                process2.prependOnceListener = noop2;
                process2.listeners = function(name) {
                  return [];
                };
                process2.binding = function(name) {
                  throw new Error("process.binding is not supported");
                };
                process2.cwd = function() {
                  return "/";
                };
                process2.chdir = function(dir) {
                  throw new Error("process.chdir is not supported");
                };
                process2.umask = function() {
                  return 0;
                };
              },
              /* 8 */
              /***/
              function(module22, exports22) {
                var g;
                g = /* @__PURE__ */ function() {
                  return this;
                }();
                try {
                  g = g || Function("return this")() || (1, eval)("this");
                } catch (e) {
                  if (typeof window === "object")
                    g = window;
                }
                module22.exports = g;
              },
              /* 9 */
              /***/
              function(module22, exports22) {
              }
              /******/
            ])
          );
        });
      })(noty);
      var notyExports = noty.exports;
      const Noty = /* @__PURE__ */ getDefaultExportFromCjs(notyExports);
      const resource$1 = {
        "common": {
          "settings": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Settings" } },
          "auto": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Auto" } },
          "english": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "English" } },
          "japanese": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Japanese" } },
          "chinese": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Chinese" } },
          "pretty": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Pretty" } },
          "filter": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Filter" } },
          "none": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "None" } },
          "random": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Random" } },
          "balance": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Balance" } },
          "abbr": {
            "english": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "EN" } },
            "japanese": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "JP" } },
            "chinese": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "CN" } }
          }
        },
        "setting": {
          "title": { "t": 0, "b": { "t": 2, "i": [{ "t": 6, "k": { "t": 7, "v": "common.settings" } }] } },
          "advanceTitle": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Advance Settings" } },
          "helpButton": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Help" } },
          "asteriskTip": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "means refresh is required to take effect" } },
          "downloadThread": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Download thread" } },
          "openOnNewTab": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Open on new tab" } },
          "compressionFilename": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Compression filename" } },
          "maxNumber": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Max number" } },
          "separator": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Separator" } },
          "compressionLevel": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Compression level" } },
          "filenameLength": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Filename length" } },
          "autoCancelDownloadedManga": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Auto cancel downloaded manga" } },
          "autoRetryWhenErrorOccurs": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Auto retry when error occurs" } },
          "autoShowAll": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Auto show all" } },
          "showIgnoreButton": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": 'Show "Ignore" button' } },
          "judgeDownloadedMangaByTitle": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Judge downloaded manga by title" } },
          "customDownloadUrl": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Custom download URL" } },
          "compressionStreamFiles": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": 'Compression "streamFiles"' } },
          "seriesMode": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Series mode" } },
          "streamDownload": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Stream download" } },
          "preventConsoleClearing": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Prevent console clearing" } },
          "nHentaiDownloadHost": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "nHentai download host" } },
          "addMetaFile": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Add metadata file" } },
          "metaFileTitleLanguage": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Title language" } },
          "titleReplacement": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Title replacement" } },
          "history": {
            "title": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Download History" } },
            "downloadedNumberTip": { "t": 0, "b": { "t": 2, "i": [{ "t": 3, "v": "You have downloaded " }, { "t": 4, "k": "num" }, { "t": 3, "v": " manga on this site using nHentai Helper." }] } },
            "import": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Import" } },
            "export": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Export" } },
            "clear": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Clear" } },
            "importTip": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Tip: Import will not clear the existing history, but merges with it." } }
          }
        },
        "dialog": {
          "yes": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "YES" } },
          "no": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "NO" } },
          "action": {
            "getInfo": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "getting information" } },
            "download": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "downloading" } }
          },
          "downloadAgainConfirm": ({ named }) => `<i>${named("title")}</i> is already downloaded${named("hasQueue") ? " or in queue" : ""}.<br>Do you want to download again?`,
          "errorRetryConfirm": (ctx) => `Error occurred while ${getActionText(ctx)}, retry?`,
          "errorRetryTip": (ctx) => `Error occurred while ${getActionText(ctx)}, retrying...`,
          "downloadedTip": { "t": 0, "b": { "t": 2, "i": [{ "t": 3, "v": "<i>" }, { "t": 4, "k": "title" }, { "t": 3, "v": "</i> is already downloaded or in queue." }] } },
          "getMediaUrlTemplateFailed": { "t": 0, "b": { "t": 2, "i": [{ "t": 3, "v": 'Fail to get image download url. Please set "' }, { "t": 6, "k": { "t": 9, "v": "setting.customDownloadUrl" } }, { "t": 3, "v": '" manually, or open a github issue to report with current url.' }] } }
        },
        "button": {
          "download": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Download" } },
          "downloading": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Downloading" } },
          "compressing": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Compressing" } }
        },
        "confirmPopup": {
          "title": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "Are you sure?" } },
          "yes": { "t": 0, "b": { "static": "", "t": 2, "i": [] } },
          "no": { "t": 0, "b": { "static": "", "t": 2, "i": [] } }
        }
      };
      const resource = {
        "common": {
          "settings": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "设置" } },
          "auto": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "自动" } },
          "english": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "英文" } },
          "japanese": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "日文" } },
          "chinese": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "中文" } },
          "pretty": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "简略" } },
          "filter": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "过滤" } },
          "none": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "无" } },
          "random": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "随机" } },
          "balance": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "均衡" } },
          "abbr": {
            "english": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "英" } },
            "japanese": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "日" } },
            "chinese": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "中" } }
          }
        },
        "setting": {
          "title": { "t": 0, "b": { "t": 2, "i": [{ "t": 6, "k": { "t": 7, "v": "common.settings" } }] } },
          "advanceTitle": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "进阶设置" } },
          "helpButton": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "帮助" } },
          "asteriskTip": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "表示刷新页面才能生效" } },
          "downloadThread": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "下载线程数" } },
          "openOnNewTab": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "在新选项卡打开" } },
          "compressionFilename": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "压缩文件名" } },
          "maxNumber": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "最大数量" } },
          "separator": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "分隔符" } },
          "compressionLevel": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "压缩等级" } },
          "filenameLength": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "文件名长度" } },
          "autoCancelDownloadedManga": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "自动取消下载过的本子" } },
          "autoRetryWhenErrorOccurs": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "发生错误时自动重试" } },
          "autoShowAll": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "自动显示全部" } },
          "showIgnoreButton": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "显示“忽略”按钮" } },
          "judgeDownloadedMangaByTitle": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "用标题判断本子是否下载过" } },
          "customDownloadUrl": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "自定义下载地址" } },
          "compressionStreamFiles": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": '压缩 "streamFiles" 选项' } },
          "seriesMode": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "串行模式" } },
          "streamDownload": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "流式下载" } },
          "preventConsoleClearing": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "阻止控制台清空" } },
          "nHentaiDownloadHost": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "nHentai 下载节点" } },
          "addMetaFile": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "添加元数据文件" } },
          "metaFileTitleLanguage": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "标题语言" } },
          "titleReplacement": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "标题替换" } },
          "history": {
            "title": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "下载历史" } },
            "downloadedNumberTip": { "t": 0, "b": { "t": 2, "i": [{ "t": 3, "v": "你在这个站点上已经用 nHentai 助手下载了 " }, { "t": 4, "k": "num" }, { "t": 3, "v": " 个本子" }] } },
            "import": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "导入" } },
            "export": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "导出" } },
            "clear": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "清空" } },
            "importTip": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "提示：导入会将导入的历史记录与现有历史记录合并，不会清空现有历史记录" } }
          }
        },
        "dialog": {
          "yes": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "是的" } },
          "no": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "算了" } },
          "action": {
            "getInfo": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "获取信息" } },
            "download": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "下载" } }
          },
          "downloadAgainConfirm": ({ named }) => `《${named("title")}》已下载过${named("hasQueue") ? "或在队列中" : ""}，你希望再次下载吗？`,
          "errorRetryConfirm": (ctx) => `${getActionText(ctx)}发生错误，是否重试？`,
          "errorRetryTip": (ctx) => `${getActionText(ctx)}发生错误，重试中……`,
          "downloadedTip": { "t": 0, "b": { "t": 2, "i": [{ "t": 3, "v": "《" }, { "t": 4, "k": "title" }, { "t": 3, "v": "》已经下载过或在队列中" }] } },
          "getMediaUrlTemplateFailed": { "t": 0, "b": { "t": 2, "i": [{ "t": 3, "v": "获取图片下载地址失败，请手动设置“" }, { "t": 6, "k": { "t": 9, "v": "setting.customDownloadUrl" } }, { "t": 3, "v": "”，或前往 github issue 或脚本页面反馈并附带当前网址" }] } }
        },
        "button": {
          "download": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "下载" } },
          "downloading": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "下载中" } },
          "compressing": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "压缩中" } }
        },
        "confirmPopup": {
          "title": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "真的吗？" } },
          "yes": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "真的" } },
          "no": { "t": 0, "b": { "t": 2, "i": [{ "t": 3 }], "s": "算了" } }
        }
      };
      const i18n = createI18n({
        legacy: false,
        locale: settings.language,
        fallbackLocale: "en",
        messages: { en: resource$1, zh: resource }
      });
      const { t: t$1 } = i18n.global;
      const notyConfirmOption = {
        type: "error",
        layout: "bottomRight",
        theme: "nest",
        timeout: false,
        closeWith: []
      };
      const downloadAgainConfirm = async (title, hasQueue = false) => {
        if (hasQueue && settings.autoCancelDownloadedManga) {
          downloadedTip(title);
          return false;
        }
        return new Promise((resolve2) => {
          const n = new Noty({
            ...notyConfirmOption,
            text: t$1("dialog.downloadAgainConfirm", { title, hasQueue }),
            buttons: [
              Noty.button(t$1("dialog.yes"), "btn btn-noty-blue btn-noty", () => {
                n.close();
                resolve2(true);
              }),
              Noty.button(t$1("dialog.no"), "btn btn-noty-green btn-noty", () => {
                n.close();
                resolve2(false);
              })
            ]
          });
          n.show();
        });
      };
      const errorRetryConfirm = (action, noCb, yesCb) => {
        if (settings.autoRetryWhenErrorOccurs) {
          errorRetryTip(action);
          yesCb == null ? void 0 : yesCb();
          return;
        }
        const n = new Noty({
          ...notyConfirmOption,
          text: t$1("dialog.errorRetryConfirm", { action }),
          buttons: [
            Noty.button(t$1("dialog.no"), "btn btn-noty-blue btn-noty", () => {
              n.close();
              noCb == null ? void 0 : noCb();
            }),
            Noty.button(t$1("dialog.yes"), "btn btn-noty-green btn-noty", () => {
              n.close();
              yesCb == null ? void 0 : yesCb();
            })
          ]
        });
        n.show();
      };
      const downloadedTip = (title) => {
        new Noty({
          type: "info",
          layout: "bottomRight",
          theme: "nest",
          closeWith: [],
          timeout: 4e3,
          text: t$1("dialog.downloadedTip", { title })
        }).show();
      };
      const errorRetryTip = (action) => {
        new Noty({
          type: "warning",
          layout: "bottomRight",
          theme: "nest",
          closeWith: [],
          timeout: 3e3,
          text: t$1("dialog.errorRetryTip", { action })
        }).show();
      };
      const openAlert = (i18nKey) => {
        const n = new Noty({
          layout: "center",
          theme: "nest",
          modal: true,
          closeWith: [],
          text: t$1(i18nKey),
          buttons: [
            Noty.button("OK", "btn btn-noty-blue btn-noty", () => {
              n.close();
            })
          ]
        });
        n.show();
      };
      var StreamSaver = { exports: {} };
      /*! streamsaver. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
      (function(module2) {
        ((name, definition) => {
          module2.exports = definition();
        })("streamSaver", () => {
          const global2 = typeof window === "object" ? window : this;
          if (!global2.HTMLElement)
            console.warn("streamsaver is meant to run on browsers main thread");
          let mitmTransporter = null;
          let supportsTransferable = false;
          const test = (fn2) => {
            try {
              fn2();
            } catch (e) {
            }
          };
          const ponyfill = global2.WebStreamsPolyfill || {};
          const isSecureContext = global2.isSecureContext;
          let useBlobFallback = /constructor/i.test(global2.HTMLElement) || !!global2.safari || !!global2.WebKitPoint;
          const downloadStrategy = isSecureContext || "MozAppearance" in document.documentElement.style ? "iframe" : "navigate";
          const streamSaver = {
            createWriteStream,
            WritableStream: global2.WritableStream || ponyfill.WritableStream,
            supported: true,
            version: { full: "2.0.5", major: 2, minor: 0, dot: 5 },
            mitm: "https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0"
          };
          function makeIframe(src) {
            if (!src)
              throw new Error("meh");
            const iframe = document.createElement("iframe");
            iframe.hidden = true;
            iframe.src = src;
            iframe.loaded = false;
            iframe.name = "iframe";
            iframe.isIframe = true;
            iframe.postMessage = (...args) => iframe.contentWindow.postMessage(...args);
            iframe.addEventListener("load", () => {
              iframe.loaded = true;
            }, { once: true });
            document.body.appendChild(iframe);
            return iframe;
          }
          function makePopup(src) {
            const options = "width=200,height=100";
            const delegate = document.createDocumentFragment();
            const popup = {
              frame: global2.open(src, "popup", options),
              loaded: false,
              isIframe: false,
              isPopup: true,
              remove() {
                popup.frame.close();
              },
              addEventListener(...args) {
                delegate.addEventListener(...args);
              },
              dispatchEvent(...args) {
                delegate.dispatchEvent(...args);
              },
              removeEventListener(...args) {
                delegate.removeEventListener(...args);
              },
              postMessage(...args) {
                popup.frame.postMessage(...args);
              }
            };
            const onReady = (evt) => {
              if (evt.source === popup.frame) {
                popup.loaded = true;
                global2.removeEventListener("message", onReady);
                popup.dispatchEvent(new Event("load"));
              }
            };
            global2.addEventListener("message", onReady);
            return popup;
          }
          try {
            new Response(new ReadableStream());
            if (isSecureContext && !("serviceWorker" in navigator)) {
              useBlobFallback = true;
            }
          } catch (err) {
            useBlobFallback = true;
          }
          test(() => {
            const { readable } = new TransformStream();
            const mc = new MessageChannel();
            mc.port1.postMessage(readable, [readable]);
            mc.port1.close();
            mc.port2.close();
            supportsTransferable = true;
            Object.defineProperty(streamSaver, "TransformStream", {
              configurable: false,
              writable: false,
              value: TransformStream
            });
          });
          function loadTransporter() {
            if (!mitmTransporter) {
              mitmTransporter = isSecureContext ? makeIframe(streamSaver.mitm) : makePopup(streamSaver.mitm);
            }
          }
          function createWriteStream(filename, options, size2) {
            let opts = {
              size: null,
              pathname: null,
              writableStrategy: void 0,
              readableStrategy: void 0
            };
            let bytesWritten = 0;
            let downloadUrl = null;
            let channel = null;
            let ts = null;
            if (Number.isFinite(options)) {
              [size2, options] = [options, size2];
              console.warn("[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream");
              opts.size = size2;
              opts.writableStrategy = options;
            } else if (options && options.highWaterMark) {
              console.warn("[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream");
              opts.size = size2;
              opts.writableStrategy = options;
            } else {
              opts = options || {};
            }
            if (!useBlobFallback) {
              loadTransporter();
              channel = new MessageChannel();
              filename = encodeURIComponent(filename.replace(/\//g, ":")).replace(/['()]/g, escape).replace(/\*/g, "%2A");
              const response = {
                transferringReadable: supportsTransferable,
                pathname: opts.pathname || Math.random().toString().slice(-6) + "/" + filename,
                headers: {
                  "Content-Type": "application/octet-stream; charset=utf-8",
                  "Content-Disposition": "attachment; filename*=UTF-8''" + filename
                }
              };
              if (opts.size) {
                response.headers["Content-Length"] = opts.size;
              }
              const args = [response, "*", [channel.port2]];
              if (supportsTransferable) {
                const transformer = downloadStrategy === "iframe" ? void 0 : {
                  // This transformer & flush method is only used by insecure context.
                  transform(chunk, controller) {
                    if (!(chunk instanceof Uint8Array)) {
                      throw new TypeError("Can only write Uint8Arrays");
                    }
                    bytesWritten += chunk.length;
                    controller.enqueue(chunk);
                    if (downloadUrl) {
                      location.href = downloadUrl;
                      downloadUrl = null;
                    }
                  },
                  flush() {
                    if (downloadUrl) {
                      location.href = downloadUrl;
                    }
                  }
                };
                ts = new streamSaver.TransformStream(
                  transformer,
                  opts.writableStrategy,
                  opts.readableStrategy
                );
                const readableStream = ts.readable;
                channel.port1.postMessage({ readableStream }, [readableStream]);
              }
              channel.port1.onmessage = (evt) => {
                if (evt.data.download) {
                  if (downloadStrategy === "navigate") {
                    mitmTransporter.remove();
                    mitmTransporter = null;
                    if (bytesWritten) {
                      location.href = evt.data.download;
                    } else {
                      downloadUrl = evt.data.download;
                    }
                  } else {
                    if (mitmTransporter.isPopup) {
                      mitmTransporter.remove();
                      mitmTransporter = null;
                      if (downloadStrategy === "iframe") {
                        makeIframe(streamSaver.mitm);
                      }
                    }
                    makeIframe(evt.data.download);
                  }
                } else if (evt.data.abort) {
                  chunks = [];
                  channel.port1.postMessage("abort");
                  channel.port1.onmessage = null;
                  channel.port1.close();
                  channel.port2.close();
                  channel = null;
                }
              };
              if (mitmTransporter.loaded) {
                mitmTransporter.postMessage(...args);
              } else {
                mitmTransporter.addEventListener("load", () => {
                  mitmTransporter.postMessage(...args);
                }, { once: true });
              }
            }
            let chunks = [];
            return !useBlobFallback && ts && ts.writable || new streamSaver.WritableStream({
              write(chunk) {
                if (!(chunk instanceof Uint8Array)) {
                  throw new TypeError("Can only write Uint8Arrays");
                }
                if (useBlobFallback) {
                  chunks.push(chunk);
                  return;
                }
                channel.port1.postMessage(chunk);
                bytesWritten += chunk.length;
                if (downloadUrl) {
                  location.href = downloadUrl;
                  downloadUrl = null;
                }
              },
              close() {
                if (useBlobFallback) {
                  const blob2 = new Blob(chunks, { type: "application/octet-stream; charset=utf-8" });
                  const link = document.createElement("a");
                  link.href = URL.createObjectURL(blob2);
                  link.download = filename;
                  link.click();
                } else {
                  channel.port1.postMessage("end");
                }
              },
              abort() {
                chunks = [];
                channel.port1.postMessage("abort");
                channel.port1.onmessage = null;
                channel.port1.close();
                channel.port2.close();
                channel = null;
              }
            }, opts.writableStrategy);
          }
          return streamSaver;
        });
      })(StreamSaver);
      var StreamSaverExports = StreamSaver.exports;
      class MultiThread {
        constructor(tasks, taskFunc, params) {
          __publicField(this, "threads", []);
          __publicField(this, "taskIndex", 0);
          __publicField(this, "started", false);
          __publicField(this, "aborted", false);
          this.tasks = tasks;
          this.taskFunc = taskFunc;
          this.params = params;
        }
        startThread(threadId) {
          let abortFunc;
          const threadPromise = (async () => {
            while (true) {
              if (this.aborted)
                break;
              const i = this.taskIndex++;
              if (i >= this.tasks.length)
                break;
              const { abort, promise } = await this.taskFunc(this.tasks[i], threadId, this.params);
              abortFunc = abort;
              await promise;
            }
          })();
          return {
            abort: () => abortFunc == null ? void 0 : abortFunc(),
            promise: threadPromise
          };
        }
        start() {
          if (this.started)
            throw new Error("Multi-thread started.");
          this.started = true;
          for (let threadId = 0; threadId < settings.threadNum; threadId++) {
            this.threads.push(this.startThread(threadId));
          }
          return {
            abort: () => {
              this.aborted = true;
              this.threads.forEach(({ abort }) => abort());
            },
            promise: Promise.all(this.threads.map(({ promise }) => promise)).then()
          };
        }
      }
      class RequestAbortError extends Error {
        constructor(url) {
          super(`Request abort ${url}`);
        }
      }
      const isAbortError = (e) => e instanceof RequestAbortError;
      const request = (urlGetter, responseType, retry = 3) => {
        let abortFunc;
        const dataPromise = new Promise((resolve2, reject) => {
          try {
            const url = typeof urlGetter === "function" ? urlGetter() : urlGetter;
            const req = _GM_xmlhttpRequest({
              method: "GET",
              url,
              responseType,
              onerror: (e) => {
                if (retry === 0) {
                  logger.error("Network error", url, e);
                  reject(e);
                } else {
                  logger.warn("Network error, retry", url, e);
                  setTimeout(() => {
                    const { abort, dataPromise: dataPromise2 } = request(urlGetter, responseType, retry - 1);
                    abortFunc = abort;
                    resolve2(dataPromise2);
                  }, 1e3);
                }
              },
              onload: (r) => {
                const { status, response } = r;
                if (status === 200)
                  resolve2(response);
                else if (retry === 0)
                  reject(r);
                else {
                  logger.warn("Request error, retry", status, url, r);
                  setTimeout(() => {
                    const { abort, dataPromise: dataPromise2 } = request(urlGetter, responseType, retry - 1);
                    abortFunc = abort;
                    resolve2(dataPromise2);
                  }, 1e3);
                }
              }
            });
            abortFunc = () => {
              req.abort();
              logger.log("Request abort", url);
              reject(new RequestAbortError(url));
            };
          } catch (error) {
            reject(error);
          }
        });
        return {
          abort: () => abortFunc == null ? void 0 : abortFunc(),
          dataPromise
        };
      };
      const getText = (url) => request(url).dataPromise;
      const fetchJSON = (url) => fetch(url).then((r) => r.json());
      const checkHost = async (url) => {
        const { origin } = new URL(url);
        try {
          await fetch(origin, { method: "HEAD", mode: "no-cors" });
          return true;
        } catch {
          return false;
        }
      };
      class Counter {
        constructor(keys2) {
          __publicField(this, "countMap", {});
          __publicField(this, "countKeys");
          if (!keys2.length)
            throw new Error("Counter no key");
          this.countKeys = [...keys2];
          this.countKeys.forEach((key) => {
            this.countMap[key] = 0;
          });
        }
        add(key) {
          this.countMap[key]++;
        }
        del(key) {
          this.countMap[key]--;
        }
        getMin() {
          return minBy(this.countKeys, (key) => this.countMap[key]);
        }
      }
      const loadHTML = (html2) => {
        const parser2 = new DOMParser();
        return $(parser2.parseFromString(html2, "text/html").body);
      };
      var NHentaiImgExt = /* @__PURE__ */ ((NHentaiImgExt2) => {
        NHentaiImgExt2["j"] = "jpg";
        NHentaiImgExt2["p"] = "png";
        NHentaiImgExt2["g"] = "gif";
        return NHentaiImgExt2;
      })(NHentaiImgExt || {});
      const nHentaiImgExtReversed = invert(NHentaiImgExt);
      const getTypeFromExt = (ext) => nHentaiImgExtReversed[ext.toLowerCase()];
      const nHentaiDownloadHostCounter = new Counter(nHentaiDownloadHosts);
      const getNHentaiDownloadHost = () => {
        switch (settings.nHentaiDownloadHost) {
          case NHentaiDownloadHostSpecial.RANDOM:
            return sample(nHentaiDownloadHosts);
          case NHentaiDownloadHostSpecial.BALANCE:
            return nHentaiDownloadHostCounter.getMin();
          default:
            return settings.nHentaiDownloadHost;
        }
      };
      const getMediaDownloadUrl = (mid, filename) => `https://${getNHentaiDownloadHost()}/galleries/${mid}/${filename}`;
      const getMediaDownloadUrlOnMirrorSite = async (mid, filename) => (await getCompliedMediaUrlTemplate())({ mid, filename });
      const getGalleryFromApi = (gid2) => {
        const url = `https://nhentai.net/api/gallery/${gid2}`;
        return fetchJSON(url);
      };
      const getGalleryFromWebpage = async (gid) => {
        var _a2;
        let doc = document;
        if (!IS_PAGE_MANGA_DETAIL) {
          const html = await getText(`/g/${gid}`);
          const match = (_a2 = /gallery(\(\{[\s\S]+\}\));/.exec(html)) == null ? void 0 : _a2[1];
          if (match) {
            try {
              const gallery = eval(match);
              gallery.id = Number(gid);
            } catch {
              logger.warn("get gallery by eval failed");
            }
          }
          const parser = new DOMParser();
          doc = parser.parseFromString(html, "text/html");
        }
        const $doc = $(doc.body);
        const english = $doc.find("#info h1").text();
        const japanese = $doc.find("#info h2").text();
        const pages = [];
        let mediaId = "";
        $doc.find("#thumbnail-container img").each((i, img) => {
          const src = img.dataset.src ?? img.src;
          const match2 = /\/(\d+)\/(\d+)t?\.(\w+)/.exec(src);
          if (!match2)
            return;
          const [, mid, index, ext] = match2;
          if (!mediaId)
            mediaId = mid;
          const t2 = getTypeFromExt(ext);
          if (!t2)
            return;
          pages[Number(index) - 1] = { t: t2 };
        });
        if (!english && !japanese || !mediaId || !pages.length) {
          throw new Error("Get gallery info error.");
        }
        const getTags = (type, elContains) => {
          const $names = $(`#tags .tag-container:contains(${elContains}) .tag > .name`);
          const names2 = filter(Array.from($names).map((el) => el.innerText.trim()));
          return names2.map((name) => ({ type, name }));
        };
        const tags = [
          ...getTags("parody", "Parodies"),
          ...getTags("character", "Characters"),
          ...getTags("tag", "Tags"),
          ...getTags("artist", "Artists"),
          ...getTags("group", "Groups"),
          ...getTags("language", "Languages"),
          ...getTags("category", "Categories")
        ];
        const uploadDateStr = $("#tags .tag-container:contains(Uploaded) time").attr("datetime");
        const uploadDate = uploadDateStr ? new Date(uploadDateStr) : void 0;
        return {
          id: Number(gid),
          media_id: mediaId,
          title: {
            english: english || japanese,
            japanese: japanese || english,
            pretty: ""
          },
          images: {
            pages
          },
          tags,
          upload_date: uploadDate && String(uploadDate) !== "Invalid Date" ? Math.floor(uploadDate.getTime() / 1e3) : void 0
        };
      };
      const getCFNameArtists = (tags2) => {
        const artists = map(
          tags2.filter(({ name, type }) => type === "artist" && name),
          "name"
        );
        if (!artists.length)
          return "none";
        const maxNum = settings.filenameMaxArtistsNumber;
        if (maxNum && artists.length > maxNum)
          return "various";
        return artists.join(settings.filenameArtistsSeparator);
      };
      const getGallery = async (gid2) => {
        const gallery2 = IS_NHENTAI ? await getGalleryFromApi(gid2) : await getGalleryFromWebpage(gid2);
        logger.log("gallery", gallery2);
        return gallery2;
      };
      const getGalleryInfo = async (gid2) => {
        const {
          id,
          media_id,
          title,
          images: { pages: pages2 },
          num_pages,
          tags: tags2,
          upload_date
        } = await (async () => {
          var _a2;
          if (gid2)
            return getGallery(gid2);
          const gidFromUrl = (_a2 = /^\/g\/(\d+)/.exec(location.pathname)) == null ? void 0 : _a2[1];
          const localGallery = _unsafeWindow._gallery ?? _unsafeWindow.gallery;
          if (localGallery) {
            if (gidFromUrl)
              localGallery.id = Number(gidFromUrl);
            return localGallery;
          }
          if (gidFromUrl)
            return getGallery(gidFromUrl);
          throw new Error("Cannot get gallery info.");
        })();
        const { english: english2, japanese: japanese2, pretty } = title;
        const infoPages = (Array.isArray(pages2) ? pages2 : Object.values(pages2)).map(
          ({ t: t2, w: w2, h: h2 }, i) => ({ i: i + 1, t: NHentaiImgExt[t2], w: w2, h: h2 })
        );
        const info = {
          gid: id,
          mid: media_id,
          title,
          pages: infoPages,
          cfName: compileTemplate(settings.compressionFilename)({
            english: applyTitleReplacement(english2 || japanese2),
            japanese: applyTitleReplacement(japanese2 || english2),
            pretty: applyTitleReplacement(pretty || english2 || japanese2),
            id,
            pages: num_pages,
            artist: getCFNameArtists(tags2)
          }).replace(/[/\\:*?"<>|]/g, ""),
          tags: tags2,
          uploadDate: upload_date
        };
        logger.log("info", info);
        return info;
      };
      const fetchMediaUrlTemplate = async () => {
        var _a2, _b, _c;
        const onlineViewUrl = ((_b = (_a2 = document.querySelector(".gallery a")) == null ? void 0 : _a2.getAttribute("href")) == null ? void 0 : _b.concat("/1")) ?? ((_c = document.querySelector("a.gallerythumb")) == null ? void 0 : _c.getAttribute("href"));
        if (!onlineViewUrl) {
          throw new Error("get media url failed: cannot find a gallery");
        }
        logger.log(`fetching media url template by ${onlineViewUrl}`);
        const onlineViewHtml = await getText(onlineViewUrl);
        const $doc2 = loadHTML(onlineViewHtml);
        const imgSrc = $doc2.find("#image-container img").attr("src");
        if (!imgSrc) {
          throw new Error("get media url failed: cannot find an image src");
        }
        const template2 = imgSrc.replace(/\/\d+\//, "/{{mid}}/").replace(/\/\d+\.[^/]+$/, "/{{filename}}");
        _GM_setValue(MEDIA_URL_TEMPLATE_KEY, template2);
        return template2;
      };
      const getMediaUrlTemplate = async () => {
        const cachedTemplate = _GM_getValue(MEDIA_URL_TEMPLATE_KEY);
        if (cachedTemplate && await checkHost(cachedTemplate)) {
          logger.log(`use cached media url template: ${cachedTemplate}`);
          return cachedTemplate;
        }
        try {
          const template2 = await fetchMediaUrlTemplate();
          logger.log(`use media url template: ${template2}`);
          return template2;
        } catch (error) {
          openAlert("dialog.getMediaUrlTemplateFailed");
          logger.error(error);
          throw error;
        }
      };
      const getCompliedMediaUrlTemplate = once(async () => compileTemplate(await getMediaUrlTemplate()));
      const applyTitleReplacement = (title) => {
        if (!validTitleReplacement.value.length)
          return title;
        return validTitleReplacement.value.reduce((pre, { from, to, regexp }) => {
          try {
            return pre.replaceAll(regexp ? new RegExp(from, "g") : from, to);
          } catch {
            return pre;
          }
        }, title);
      };
      let textareaEl;
      const encodeHtml = (text) => {
        if (!textareaEl)
          textareaEl = document.createElement("textarea");
        textareaEl.innerText = text;
        const encodedText = textareaEl.innerHTML;
        textareaEl.innerHTML = "";
        return encodedText;
      };
      const langMap = {
        chinese: "zh",
        english: "en",
        japanese: "ja"
      };
      class ComicInfoXmlBuilder {
        constructor(info) {
          __publicField(this, "serializer", new XMLSerializer());
          __publicField(this, "doc", document.implementation.createDocument(null, "ComicInfo"));
          this.setRootNS();
          this.appendElement(
            "Title",
            settings.metaFileTitleLanguage in info.title ? info.title[settings.metaFileTitleLanguage] : info.title.english
          );
          this.appendElement(
            "Notes",
            `Created by nHentai Helper (Tsuk1ko/nhentai-helper) on ${(/* @__PURE__ */ new Date()).toISOString()}`
          );
          if (info.uploadDate) {
            const date = new Date(info.uploadDate * 1e3);
            this.appendElement("Year", date.getUTCFullYear());
            this.appendElement("Month", date.getUTCMonth() + 1);
            this.appendElement("Day", date.getUTCDate());
          }
          const getTags2 = (type) => info.tags.filter((t2) => t2.type === type);
          const artistTags = getTags2("artist");
          if (artistTags.length) {
            this.appendElement("Writer", map(artistTags, "name").join(", "));
          }
          const tags2 = getTags2("tag");
          if (tags2.length) {
            this.appendElement("Tags", map(tags2, "name").join(", "));
          }
          this.appendElement("Web", `${location.origin}/g/${info.gid}`);
          this.appendElement("PageCount", info.pages.length);
          const languageTag = info.tags.find(({ type, name }) => type === "language" && name in langMap);
          if (languageTag) {
            this.appendElement("LanguageISO", langMap[languageTag.name]);
          }
          this.appendElement("Format", /\[digital\]/i.test(info.title.english) ? "Digital" : "TBP");
          this.appendElement("Manga", "Yes");
          const characterTags = getTags2("character");
          if (characterTags.length) {
            this.appendElement("Characters", map(characterTags, "name").join(", "));
          }
          const pagesEl = this.createElement("Pages");
          const pageEls = info.pages.map(
            ({ i, w: w2, h: h2 }) => this.createElement("Page", void 0, { Image: i, ImageWidth: w2, ImageHeight: h2 })
          );
          pagesEl.append(...pageEls);
          this.root.append(pagesEl);
        }
        build() {
          const xml = this.serializer.serializeToString(this.doc);
          return `<?xml version="1.0" encoding="utf-8"?>
${xml}`;
        }
        get root() {
          return this.doc.documentElement;
        }
        setRootNS() {
          this.root.setAttribute("xmlns:xsd", "http://www.w3.org/2001/XMLSchema");
          this.root.setAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
        }
        createElement(name, value, attrs) {
          const el = this.doc.createElement(name);
          if (!isNil(value))
            el.innerHTML = encodeHtml(String(value));
          if (attrs) {
            forEach(attrs, (v2, k) => {
              if (!isNil(v2))
                el.setAttribute(k, String(v2));
            });
          }
          return el;
        }
        appendElement(name, value, attrs) {
          this.root.append(this.createElement(name, value, attrs));
        }
      }
      class EzeInfoJsonBuilder {
        constructor(info) {
          __publicField(this, "data");
          var _a2;
          const date = info.uploadDate ? new Date(info.uploadDate * 1e3) : void 0;
          this.data = {
            gallery_info: {
              title: info.title.english,
              title_title_original: info.title.japanese,
              link: `${location.origin}/g/${info.gid}`,
              category: (_a2 = info.tags.find(({ type }) => type === "category")) == null ? void 0 : _a2.name,
              tags: mapValues(groupBy(info.tags, "type"), (tags2) => map(tags2, "name")),
              ...this.getLanguageInfo(info),
              upload_date: date ? [
                date.getUTCFullYear(),
                date.getUTCMonth() + 1,
                date.getUTCDate(),
                date.getUTCHours(),
                date.getUTCMinutes(),
                date.getUTCSeconds()
              ] : void 0,
              source: {
                site: location.origin,
                gid: info.gid
              }
            }
          };
        }
        build() {
          return JSON.stringify(this.data);
        }
        getLanguageInfo(info) {
          let language;
          let translated = false;
          info.tags.filter(({ type }) => type === "language").forEach(({ name }) => {
            if (name === "translated") {
              translated = true;
              return;
            }
            language = name;
          });
          return { language, translated };
        }
      }
      const metaBuilderMap = {
        ComicInfoXml: { name: "ComicInfo.xml", Builder: ComicInfoXmlBuilder },
        EzeInfoJson: { name: "info.json", Builder: EzeInfoJsonBuilder }
      };
      const generateMetaFiles = (info) => {
        if (!settings.addMetaFile.length)
          return [];
        const files = [];
        for (const key of settings.addMetaFile) {
          if (key in metaBuilderMap) {
            const { name, Builder } = metaBuilderMap[key];
            files.push({
              name,
              data: new Builder(info).build()
            });
          }
        }
        return files;
      };
      var ErrorAction = /* @__PURE__ */ ((ErrorAction2) => {
        ErrorAction2["GET_INFO"] = "getInfo";
        ErrorAction2["DOWNLOAD"] = "download";
        return ErrorAction2;
      })(ErrorAction || {});
      const downloadGalleryByInfo = async (info, { progressDisplayController, rangeCheckers } = {}) => {
        info.done = 0;
        let { mid, pages: pages2, cfName } = info.gallery;
        if (rangeCheckers == null ? void 0 : rangeCheckers.length) {
          pages2 = pages2.filter(({ i }) => rangeCheckers.some((check) => check(i)));
        }
        let aborted = false;
        info.cancel = () => {
          aborted = true;
          progressDisplayController == null ? void 0 : progressDisplayController.reset();
        };
        progressDisplayController == null ? void 0 : progressDisplayController.bindInfo(info);
        progressDisplayController == null ? void 0 : progressDisplayController.updateProgress();
        const zip = new JSZip();
        const metaFiles = generateMetaFiles(info.gallery);
        if (metaFiles.length) {
          metaFiles.forEach(({ name, data }) => {
            zip.file(name, data);
          });
        }
        const downloadTask = async (page, threadID, { filenameLength, customDownloadUrl }) => {
          if (info.error)
            return { abort: () => {
            }, promise: Promise.resolve() };
          const usedCounterKeys = [];
          const urlGetter = customDownloadUrl ? compileTemplate(customDownloadUrl)({ mid, index: page.i, ext: page.t }) : IS_NHENTAI ? settings.nHentaiDownloadHost === NHentaiDownloadHostSpecial.BALANCE || settings.nHentaiDownloadHost === NHentaiDownloadHostSpecial.RANDOM ? () => {
            const url = getMediaDownloadUrl(mid, `${page.i}.${page.t}`);
            logger.log(`[${threadID}] ${url}`);
            if (settings.nHentaiDownloadHost === NHentaiDownloadHostSpecial.BALANCE) {
              const counterKey = new URL(url).host;
              usedCounterKeys.push(counterKey);
              nHentaiDownloadHostCounter.add(counterKey);
            }
            return url;
          } : getMediaDownloadUrl(mid, `${page.i}.${page.t}`) : await getMediaDownloadUrlOnMirrorSite(mid, `${page.i}.${page.t}`).catch(() => {
          });
          if (!urlGetter) {
            info.error = true;
            return { abort: () => {
            }, promise: Promise.resolve() };
          }
          if (typeof urlGetter !== "function") {
            logger.log(`[${threadID}] ${urlGetter}`);
          }
          const { abort: abort2, dataPromise } = request(urlGetter, "arraybuffer");
          return {
            abort: () => {
              logger.log(`[${threadID}] abort`);
              abort2();
            },
            promise: dataPromise.then(async (data) => {
              if (data) {
                zip.file(`${String(page.i).padStart(filenameLength || 0, "0")}.${page.t}`, data);
              }
              info.done++;
              progressDisplayController == null ? void 0 : progressDisplayController.updateProgress();
            }).catch((e) => {
              if (isAbortError(e))
                return;
              info.error = true;
              throw e;
            }).finally(() => {
              if (usedCounterKeys.length) {
                usedCounterKeys.forEach((key) => {
                  nHentaiDownloadHostCounter.del(key);
                });
              }
            })
          };
        };
        const multiThread = new MultiThread(pages2, downloadTask, {
          filenameLength: settings.filenameLength === "auto" ? Math.ceil(Math.log10(Math.max(...pages2.map(({ i }) => Number(i))))) : settings.filenameLength,
          customDownloadUrl: settings.customDownloadUrl
        });
        const { abort, promise } = multiThread.start();
        info.cancel = () => {
          aborted = true;
          abort();
          progressDisplayController == null ? void 0 : progressDisplayController.reset();
        };
        if (!aborted)
          await promise;
        if (aborted)
          return;
        return async () => {
          info.compressing = true;
          progressDisplayController == null ? void 0 : progressDisplayController.updateProgress();
          logger.log("start compressing", cfName);
          let lastZipFile = "";
          const onCompressionUpdate = ({ workerId, percent, currentFile }) => {
            if (lastZipFile !== currentFile && currentFile) {
              lastZipFile = currentFile;
              logger.log(`[${workerId}] compressing ${percent.toFixed(2)}%`, currentFile);
            }
            info.compressingPercent = percent.toFixed(2);
            progressDisplayController == null ? void 0 : progressDisplayController.updateProgress();
          };
          if (settings.streamDownload) {
            logger.log("stream mode on");
            const fileStream = StreamSaverExports.createWriteStream(cfName);
            const zipStream = await zip.generateStream(getCompressionOptions(), onCompressionUpdate);
            await zipStream.pipeTo(fileStream);
          } else {
            const data = await zip.generateAsync(getCompressionOptions(), onCompressionUpdate);
            FileSaver_minExports.saveAs(new File([data], cfName, { type: "application/zip" }));
          }
          logger.log("completed", cfName);
          progressDisplayController == null ? void 0 : progressDisplayController.complete();
          progressDisplayController == null ? void 0 : progressDisplayController.unbindInfo();
        };
      };
      const addDownloadGalleryTask = (gallery2, { progressDisplayController, markGalleryDownloaded } = {}) => {
        const info = createMangaDownloadInfo(gallery2, true);
        info.cancel = () => {
          progressDisplayController == null ? void 0 : progressDisplayController.reset();
        };
        dlQueue.push(async () => {
          const zipFunc = await downloadGalleryByInfo(info, { progressDisplayController }).catch((e) => {
            progressDisplayController == null ? void 0 : progressDisplayController.error();
            errorRetryConfirm(
              ErrorAction.DOWNLOAD,
              () => {
                dlQueue.skipFromError().catch(logger.error);
              },
              () => {
                info.error = false;
                dlQueue.restartFromError().catch(logger.error);
              }
            );
            throw e;
          });
          if (zipFunc) {
            zipQueue.push(async () => {
              try {
                await zipFunc();
                markAsDownloaded(gallery2.gid, gallery2.title);
                markGalleryDownloaded == null ? void 0 : markGalleryDownloaded();
              } catch (error) {
                if (!error)
                  logger.warn("user abort stream download");
                logger.error(error);
                progressDisplayController == null ? void 0 : progressDisplayController.error();
              }
            }, info);
            zipQueue.start().catch(logger.error);
          }
        }, info);
        dlQueue.start().catch(logger.error);
      };
      const { t } = i18n.global;
      class ProgressDisplayController {
        constructor(enableHeadTxt = false, docTitle) {
          __publicField(this, "downloadBtn");
          __publicField(this, "btnTxt");
          __publicField(this, "info");
          this.enableHeadTxt = enableHeadTxt;
          this.docTitle = docTitle;
          this.btnTxt = /* @__PURE__ */ jsx.createElement("span", { class: "download-zip-txt" }, this.defaultBtnText());
          this.downloadBtn = /* @__PURE__ */ jsx.createElement("button", { class: "btn btn-secondary nhentai-helper-btn download-zip-btn" }, /* @__PURE__ */ jsx.createElement("i", { class: "fa fa-download" }), " ", this.btnTxt);
        }
        get compressingHeadText() {
          return this.enableHeadTxt ? `${t("button.compressing")} ${getDownloadExt()} ` : "";
        }
        get downloadingHeadText() {
          return this.enableHeadTxt ? `${t("button.downloading")} ${getDownloadExt()} ` : "";
        }
        defaultBtnText(suffix) {
          if (!this.enableHeadTxt)
            return suffix ?? "";
          return `${t("button.download")} ${getDownloadExt()}${suffix ? ` ${suffix}` : ""}`;
        }
        bindInfo(info) {
          this.info = info;
        }
        unbindInfo() {
          this.info = void 0;
        }
        lockBtn(text) {
          this.downloadBtn.setAttribute("disabled", "disabled");
          if (text)
            this.btnTxt.innerText = text;
        }
        releaseBtn() {
          this.downloadBtn.removeAttribute("disabled");
        }
        complete() {
          this.setDocTitle("✓");
          this.btnTxt.innerText = this.defaultBtnText("✓");
          this.releaseBtn();
        }
        reset() {
          this.setDocTitle();
          this.btnTxt.innerText = this.defaultBtnText();
          this.releaseBtn();
        }
        error() {
          this.releaseBtn();
          this.btnTxt.innerText = "Error";
          this.setDocTitle("×");
        }
        updateProgress() {
          if (!this.info)
            return;
          const { done, compressing, compressingPercent } = this.info;
          if (compressing) {
            this.setDocTitle(`${compressingPercent}%`);
            this.btnTxt.innerText = `${this.compressingHeadText}${compressingPercent}%`;
          } else {
            const total = this.info.gallery.pages.length;
            this.setDocTitle(`${done}/${total}`);
            this.btnTxt.innerText = `${this.downloadingHeadText}${done}/${total}`;
          }
        }
        setDocTitle(prefix) {
          if (!this.docTitle)
            return;
          document.title = prefix ? `[${prefix}] ${this.docTitle}` : this.docTitle;
        }
      }
      class IgnoreController {
        constructor(text = true, status = false) {
          __publicField(this, "ignoreBtn");
          __publicField(this, "icon");
          __publicField(this, "text");
          this.status = status;
          this.icon = /* @__PURE__ */ jsx.createElement("i", { class: this.iconClass });
          if (text)
            this.text = /* @__PURE__ */ jsx.createElement("span", null, this.btnText);
          this.ignoreBtn = /* @__PURE__ */ jsx.createElement("button", { class: "btn btn-secondary nhentai-helper-btn ignore-btn" }, this.icon, " ", this.text);
        }
        setStatus(status) {
          this.status = status;
          this.updateBtn();
        }
        getStatus() {
          return this.status;
        }
        get iconClass() {
          return this.status ? "fa fa-eye-slash" : "fa fa-eye";
        }
        get btnText() {
          return this.status ? "Unignore this" : "Ignore this";
        }
        updateBtn() {
          this.icon.className = this.iconClass;
          if (this.text)
            this.text.innerText = this.btnText;
        }
      }
      const initDetailPage = async () => {
        const progressDisplayController = new ProgressDisplayController(true, document.title);
        const { downloadBtn } = progressDisplayController;
        const pagesInput = /* @__PURE__ */ jsx.createElement("input", { class: "pages-input", placeholder: "Download pages (e.g. 1-10,12,14,18-)" });
        $("#info > .buttons").append(downloadBtn).after(pagesInput);
        let ignoreController;
        if (settings.showIgnoreButton) {
          const gallery2 = await getGalleryInfo();
          const isDownloaded = await isDownloadedByGid(gallery2.gid);
          ignoreController = new IgnoreController(true, isDownloaded);
          const { ignoreBtn } = ignoreController;
          ignoreBtn.addEventListener("click", () => {
            const ignore = ignoreController.getStatus();
            if (ignore)
              unmarkAsDownloaded(gallery2.gid, gallery2.title);
            else
              markAsDownloaded(gallery2.gid, gallery2.title);
            ignoreController.setStatus(!ignore);
          });
          $("#info > .buttons").append(ignoreBtn);
        }
        downloadBtn.addEventListener("click", async () => {
          var _a2;
          const gallery2 = await getGalleryInfo();
          const rangeCheckers = pagesInput.value.split(",").filter((range2) => !Number.isNaN(parseInt(range2))).map((range2) => {
            const [start, end2] = range2.split("-").map((num) => parseInt(num));
            if (typeof end2 === "undefined")
              return (page) => page === start;
            else if (Number.isNaN(end2))
              return (page) => page >= start;
            else
              return (page) => start <= page && page <= end2;
          });
          progressDisplayController.lockBtn();
          try {
            const downloaded = await isDownloadedByGid(gallery2.gid) || await isDownloadedByTitle(gallery2.title);
            if (downloaded && !await downloadAgainConfirm(gallery2.title.japanese || gallery2.title.english)) {
              progressDisplayController.reset();
              markAsDownloaded(gallery2.gid, gallery2.title);
              ignoreController == null ? void 0 : ignoreController.setStatus(true);
              return;
            }
            await ((_a2 = await downloadGalleryByInfo(createMangaDownloadInfo(gallery2), {
              progressDisplayController,
              rangeCheckers
            })) == null ? void 0 : _a2());
            markAsDownloaded(gallery2.gid, gallery2.title);
            ignoreController == null ? void 0 : ignoreController.setStatus(true);
          } catch (error) {
            progressDisplayController.error();
            logger.error(error);
          }
        });
        applyAutoShowAll();
      };
      const applyAutoShowAll = () => {
        if (settings.autoShowAll) {
          getShowAllBtn().then(($btn) => $btn.trigger("click")).catch(logger.error);
        }
      };
      function tryOnScopeDispose(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function toValue(r) {
        return typeof r === "function" ? r() : unref(r);
      }
      const isClient = typeof window !== "undefined" && typeof document !== "undefined";
      typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
      const toString = Object.prototype.toString;
      const isObject = (val) => toString.call(val) === "[object Object]";
      const noop = () => {
      };
      function createFilterWrapper(filter2, fn2) {
        function wrapper(...args) {
          return new Promise((resolve2, reject) => {
            Promise.resolve(filter2(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve2).catch(reject);
          });
        }
        return wrapper;
      }
      const bypassFilter = (invoke2) => {
        return invoke2();
      };
      function pausableFilter(extendFilter = bypassFilter) {
        const isActive = ref(true);
        function pause() {
          isActive.value = false;
        }
        function resume() {
          isActive.value = true;
        }
        const eventFilter = (...args) => {
          if (isActive.value)
            extendFilter(...args);
        };
        return { isActive: readonly(isActive), pause, resume, eventFilter };
      }
      function getLifeCycleTarget(target) {
        return target || getCurrentInstance();
      }
      function watchWithFilter(source, cb, options = {}) {
        const {
          eventFilter = bypassFilter,
          ...watchOptions
        } = options;
        return watch(
          source,
          createFilterWrapper(
            eventFilter,
            cb
          ),
          watchOptions
        );
      }
      function watchPausable(source, cb, options = {}) {
        const {
          eventFilter: filter2,
          ...watchOptions
        } = options;
        const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
        const stop = watchWithFilter(
          source,
          cb,
          {
            ...watchOptions,
            eventFilter
          }
        );
        return { stop, pause, resume, isActive };
      }
      function tryOnMounted(fn2, sync = true, target) {
        const instance = getLifeCycleTarget();
        if (instance)
          onMounted(fn2, target);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function unrefElement(elRef) {
        var _a2;
        const plain = toValue(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      function useEventListener(...args) {
        let target;
        let events2;
        let listeners;
        let options;
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
          [events2, listeners, options] = args;
          target = defaultWindow;
        } else {
          [target, events2, listeners, options] = args;
        }
        if (!target)
          return noop;
        if (!Array.isArray(events2))
          events2 = [events2];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(
          () => [unrefElement(target), toValue(options)],
          ([el, options2]) => {
            cleanup();
            if (!el)
              return;
            const optionsClone = isObject(options2) ? { ...options2 } : options2;
            cleanups.push(
              ...events2.flatMap((event) => {
                return listeners.map((listener) => register(el, event, listener, optionsClone));
              })
            );
          },
          { immediate: true, flush: "post" }
        );
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      const handlers = /* @__PURE__ */ getHandlers();
      function getHandlers() {
        if (!(globalKey in _global))
          _global[globalKey] = _global[globalKey] || {};
        return _global[globalKey];
      }
      function getSSRHandler(key, fallback) {
        return handlers[key] || fallback;
      }
      function guessSerializerType(rawInit) {
        return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
      }
      const StorageSerializers = {
        boolean: {
          read: (v2) => v2 === "true",
          write: (v2) => String(v2)
        },
        object: {
          read: (v2) => JSON.parse(v2),
          write: (v2) => JSON.stringify(v2)
        },
        number: {
          read: (v2) => Number.parseFloat(v2),
          write: (v2) => String(v2)
        },
        any: {
          read: (v2) => v2,
          write: (v2) => String(v2)
        },
        string: {
          read: (v2) => v2,
          write: (v2) => String(v2)
        },
        map: {
          read: (v2) => new Map(JSON.parse(v2)),
          write: (v2) => JSON.stringify(Array.from(v2.entries()))
        },
        set: {
          read: (v2) => new Set(JSON.parse(v2)),
          write: (v2) => JSON.stringify(Array.from(v2))
        },
        date: {
          read: (v2) => new Date(v2),
          write: (v2) => v2.toISOString()
        }
      };
      const customStorageEventName = "vueuse-storage";
      function useStorage(key, defaults2, storage, options = {}) {
        var _a2;
        const {
          flush = "pre",
          deep = true,
          listenToStorageChanges = true,
          writeDefaults = true,
          mergeDefaults = false,
          shallow,
          window: window2 = defaultWindow,
          eventFilter,
          onError = (e) => {
            console.error(e);
          },
          initOnMounted
        } = options;
        const data = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
        if (!storage) {
          try {
            storage = getSSRHandler("getDefaultStorage", () => {
              var _a22;
              return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
            })();
          } catch (e) {
            onError(e);
          }
        }
        if (!storage)
          return data;
        const rawInit = toValue(defaults2);
        const type = guessSerializerType(rawInit);
        const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
        const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
          data,
          () => write(data.value),
          { flush, deep, eventFilter }
        );
        if (window2 && listenToStorageChanges) {
          tryOnMounted(() => {
            useEventListener(window2, "storage", update);
            useEventListener(window2, customStorageEventName, updateFromCustomEvent);
            if (initOnMounted)
              update();
          });
        }
        if (!initOnMounted)
          update();
        function dispatchWriteEvent(oldValue, newValue) {
          if (window2) {
            window2.dispatchEvent(new CustomEvent(customStorageEventName, {
              detail: {
                key,
                oldValue,
                newValue,
                storageArea: storage
              }
            }));
          }
        }
        function write(v2) {
          try {
            const oldValue = storage.getItem(key);
            if (v2 == null) {
              dispatchWriteEvent(oldValue, null);
              storage.removeItem(key);
            } else {
              const serialized = serializer.write(v2);
              if (oldValue !== serialized) {
                storage.setItem(key, serialized);
                dispatchWriteEvent(oldValue, serialized);
              }
            }
          } catch (e) {
            onError(e);
          }
        }
        function read(event) {
          const rawValue = event ? event.newValue : storage.getItem(key);
          if (rawValue == null) {
            if (writeDefaults && rawInit != null)
              storage.setItem(key, serializer.write(rawInit));
            return rawInit;
          } else if (!event && mergeDefaults) {
            const value = serializer.read(rawValue);
            if (typeof mergeDefaults === "function")
              return mergeDefaults(value, rawInit);
            else if (type === "object" && !Array.isArray(value))
              return { ...rawInit, ...value };
            return value;
          } else if (typeof rawValue !== "string") {
            return rawValue;
          } else {
            return serializer.read(rawValue);
          }
        }
        function update(event) {
          if (event && event.storageArea !== storage)
            return;
          if (event && event.key == null) {
            data.value = rawInit;
            return;
          }
          if (event && event.key !== key)
            return;
          pauseWatch();
          try {
            if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
              data.value = read(event);
          } catch (e) {
            onError(e);
          } finally {
            if (event)
              nextTick(resumeWatch);
            else
              resumeWatch();
          }
        }
        function updateFromCustomEvent(event) {
          update(event.detail);
        }
        return data;
      }
      function useSessionStorage(key, initialValue, options = {}) {
        const { window: window2 = defaultWindow } = options;
        return useStorage(key, initialValue, window2 == null ? void 0 : window2.sessionStorage, options);
      }
      const _hoisted_1 = { class: "language-filter" };
      const _sfc_main = /* @__PURE__ */ defineComponent({
        __name: "LanguageFilter",
        setup(__props, { expose: __expose }) {
          const { t: t2 } = i18n.global;
          const languageFilter = useSessionStorage("languageFilter", [], {
            listenToStorageChanges: false
          });
          const options = IS_NHENTAI_TO ? [
            ["japanese", "2"],
            ["english", "19"],
            ["chinese", "10197"]
          ] : [
            ["japanese", "6346"],
            ["english", "12227"],
            ["chinese", "29963"]
          ];
          watch(
            languageFilter,
            (val) => {
              filterLanguage(languageFilter.value);
            },
            { deep: true, immediate: true }
          );
          __expose({
            filterLanguage: ($node) => {
              filterLanguage(languageFilter.value, $node);
            }
          });
          return (_ctx, _cache) => {
            const _component_el_option = ElOption;
            const _component_el_select = ElSelect;
            return openBlock(), createElementBlock("li", _hoisted_1, [
              createVNode(_component_el_select, {
                modelValue: unref(languageFilter),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(languageFilter) ? languageFilter.value = $event : null),
                class: "filter-select",
                multiple: "",
                "collapse-tags": "",
                "collapse-tags-tooltip": "",
                placeholder: unref(t2)("common.filter")
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment$1, null, renderList(unref(options), ([key, val]) => {
                    return openBlock(), createBlock(_component_el_option, {
                      key,
                      label: unref(t2)(`common.abbr.${key}`),
                      value: val
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString$1(unref(t2)(`common.${key}`)), 1)
                      ]),
                      _: 2
                    }, 1032, ["label", "value"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "placeholder"])
            ]);
          };
        }
      });
      const LanguageFilter = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["__scopeId", "data-v-999a1213"]]);
      const filterLanguage = (tags2, $node) => {
        const getNode = $node ? (selector) => $node.find(selector) : (selector) => $(selector);
        getNode(".gallery").removeClass("hidden");
        if (tags2.length) {
          const notSelector = tags2.map((tag) => `:not([data-tags~=${tag}])`).join("");
          getNode(`.gallery${notSelector}`).addClass("hidden");
        }
      };
      const mountLanguageFilter = () => {
        var _a2;
        const menuLeft = document.querySelector("ul.menu.left");
        if (!menuLeft)
          return {};
        const vnode = h$1(LanguageFilter);
        render(vnode, menuLeft);
        return ((_a2 = vnode.component) == null ? void 0 : _a2.exposed) ?? {};
      };
      const initListPage = () => {
        $(".gallery").each(initGallery);
        const { filterLanguage: filterLanguage2 } = mountLanguageFilter();
        initShortcut();
        restoreDownloadQueue();
        const contentEl = $("#content")[0];
        if (contentEl) {
          new MutationObserver((mutations) => {
            mutations.forEach(({ addedNodes }) => {
              addedNodes.forEach((node) => {
                const $el = $(node);
                $el.find(".gallery").each(initGallery);
                filterLanguage2 == null ? void 0 : filterLanguage2($el);
              });
            });
          }).observe(contentEl, { childList: true });
        }
      };
      const initShortcut = () => {
        $(document).on("keydown", (event) => {
          switch (event.key) {
            case "ArrowLeft":
              $(".pagination .previous").trigger("click");
              break;
            case "ArrowRight":
              $(".pagination .next").trigger("click");
              break;
          }
        });
      };
      const restoreDownloadQueue = () => {
        const galleriesJson = sessionStorage.getItem("downloadQueue");
        if (!galleriesJson)
          return;
        try {
          const galleries = JSON.parse(galleriesJson);
          for (const gallery2 of galleries) {
            addDownloadGalleryTask(gallery2);
          }
        } catch (error) {
          logger.error(error);
        }
      };
      const initGallery = function() {
        var _a2;
        const $gallery = $(this);
        if ($gallery.attr("init"))
          return;
        $gallery.attr("init", "true");
        const $a = $gallery.find("a.cover");
        if (settings.openOnNewTab)
          $a.attr("target", "_blank");
        const gid2 = (_a2 = /\/g\/([0-9]+)/.exec($a.attr("href"))) == null ? void 0 : _a2[1];
        if (!gid2)
          return;
        const enTitle = $gallery.find(".caption").text().trim();
        const progressDisplayController = new ProgressDisplayController();
        const { downloadBtn } = progressDisplayController;
        $gallery.append(downloadBtn);
        let ignoreController;
        let galleryTitle;
        const markGalleryDownloaded = () => {
          $gallery.addClass("downloaded");
          ignoreController == null ? void 0 : ignoreController.setStatus(true);
        };
        const unmarkGalleryDownloaded = () => {
          $gallery.removeClass("downloaded");
          ignoreController == null ? void 0 : ignoreController.setStatus(false);
        };
        void Promise.all([isDownloadedByGid(gid2), isDownloadedByTitle({ english: enTitle })]).then(
          ([gidDownloaded, titleDownloaded]) => {
            const downloaded = gidDownloaded || titleDownloaded;
            if (downloaded)
              markGalleryDownloaded();
            if (settings.showIgnoreButton) {
              ignoreController = new IgnoreController(false, downloaded);
              const { ignoreBtn } = ignoreController;
              ignoreBtn.addEventListener("click", () => {
                const ignore = ignoreController.getStatus();
                if (ignore) {
                  unmarkGalleryDownloaded();
                  unmarkAsDownloaded(gid2, galleryTitle);
                } else {
                  markGalleryDownloaded();
                  markAsDownloaded(gid2, galleryTitle);
                }
              });
              $gallery.append(ignoreBtn);
            }
          }
        );
        let gallery2;
        let skipDownloadedCheck = false;
        const startDownload = async () => {
          if (!settings.autoCancelDownloadedManga) {
            progressDisplayController.lockBtn("Wait");
          }
          if (!skipDownloadedCheck && await isDownloadedByGid(gid2)) {
            const title = $gallery.find(".caption").text();
            if (!await downloadAgainConfirm(title, true)) {
              progressDisplayController.reset();
              markGalleryDownloaded();
              return;
            }
            skipDownloadedCheck = true;
          }
          if (settings.autoCancelDownloadedManga) {
            progressDisplayController.lockBtn("Wait");
          }
          if (!gallery2) {
            try {
              gallery2 = await getGalleryInfo(gid2);
              galleryTitle = gallery2.title;
            } catch (error) {
              logger.error(error);
              progressDisplayController.error();
              errorRetryConfirm(ErrorAction.GET_INFO, void 0, startDownload);
              return;
            }
          }
          if (!skipDownloadedCheck) {
            if (await isDownloadedByTitle(gallery2.title) && !await downloadAgainConfirm(gallery2.title.japanese || gallery2.title.english, true)) {
              progressDisplayController.reset();
              markAsDownloaded(gid2, gallery2.title);
              markGalleryDownloaded();
              return;
            }
            if (dlQueue.queue.some(
              ({
                info: {
                  gallery: { title }
                }
              }) => isSameTitle(title, gallery2.title)
            ) && !await downloadAgainConfirm(gallery2.title.japanese || gallery2.title.english, true)) {
              progressDisplayController.reset();
              return;
            }
          }
          addDownloadGalleryTask(gallery2, { progressDisplayController, markGalleryDownloaded });
        };
        downloadBtn.addEventListener("click", startDownload);
      };
      class StyleInjector {
        constructor(style) {
          __publicField(this, "styleNode");
          this.styleNode = /* @__PURE__ */ jsx.createElement("style", null, style);
        }
        inject() {
          document.head.append(this.styleNode);
        }
        remove() {
          this.styleNode.remove();
        }
      }
      const initOnlineViewPage = () => {
        if (!IS_NHENTAI)
          initViewMode();
      };
      const initViewMode = () => {
        const style = new StyleInjector(
          "#image-container img{width:auto;max-width:calc(100vw - 20px);max-height:100vh}"
        );
        const viewModeText = ["[off]", "[on]"];
        let viewMode = _GM_getValue("online_view_mode", 0);
        applyOnlineViewStyle(!!viewMode, style);
        const btnText = /* @__PURE__ */ jsx.createElement("span", null, viewModeText[viewMode]);
        const btn = /* @__PURE__ */ jsx.createElement("button", { id: "online-view-mode-btn", class: "btn btn-secondary" }, "100% view height ", btnText);
        btn.addEventListener("click", () => {
          viewMode = 1 - viewMode;
          _GM_setValue("online_view_mode", viewMode);
          btnText.innerText = viewModeText[viewMode];
          applyOnlineViewStyle(!!viewMode, style);
        });
        $("#page-container").prepend(btn);
      };
      const applyOnlineViewStyle = (enable, style) => {
        if (enable)
          style.inject();
        else
          style.remove();
      };
      const initPage = () => {
        if (IS_PAGE_MANGA_LIST) {
          initListPage();
          applyPjax();
        } else if (IS_PAGE_MANGA_DETAIL)
          initDetailPage().catch(logger.error);
        else if (IS_PAGE_ONLINE_VIEW)
          initOnlineViewPage();
      };
      const applyPjax = () => {
        $(document).pjax(".pagination a, .sort a", {
          container: "#content",
          fragment: "#content",
          timeout: 1e4
        });
        $(document).on("pjax:end", () => {
          $(".pagination a").each(function() {
            const $this = $(this);
            const href = $this.attr("href");
            const isPathname = href.startsWith("/");
            const url = isPathname ? new URL(href, location.origin) : new URL(href);
            url.searchParams.delete("_pjax");
            $this.attr("href", isPathname ? `${url.pathname}${url.search}` : url.href);
          });
          applyLazyLoad();
        });
      };
      const applyLazyLoad = () => {
        const { _n_app } = _unsafeWindow;
        if (_n_app) {
          _n_app.install_lazy_loader();
          _n_app.install_blacklisting();
        }
      };
      const createAppAndMount = (component, appInitFunc) => {
        const el = document.createElement("div");
        document.body.append(el);
        const app = createApp(component);
        appInitFunc == null ? void 0 : appInitFunc(app);
        return app.mount(el);
      };
      const initSettingsDialogApp = once(
        () => createAppAndMount(SettingsDialog, (app) => {
          app.use(i18n);
        })
      );
      const openSettingsDialog = () => {
        const dialog = initSettingsDialogApp();
        dialog.open();
      };
      createAppAndMount(_sfc_main$H);
      initPage();
      _GM_registerMenuCommand(i18n.global.t("common.settings"), openSettingsDialog);
    }
  });
  require_main_001();

})();